
AVRASM ver. 2.1.52  template.asm Sun Oct 18 18:22:45 2020

template.asm(14): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega1284p\device.asm'
../../avr8/devices/atmega1284p\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m1284Pdef.inc'
template.asm(53): Including file '../../avr8\drivers/usart_0.asm'
../../avr8\drivers/usart_0.asm(32): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(11): Including file '../../avr8\drivers/usart-rx-buffer.asm'
../../avr8\drivers/usart_common.asm(24): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(29): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(30): Including file '../../avr8\words/usart.asm'
template.asm(124): Including file '../../avr8\amforth.asm'
../../avr8\amforth.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth.asm(14): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(7): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/rww.inc(10): Including file '../../avr8\dict/appl_8k.inc'
../../avr8\dict/appl_8k.inc(1): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/newest.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/do-create.asm'
../../avr8\dict/compiler1.inc(5): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(9): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(10): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(17): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(33): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(38): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../common\words/create.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../common\words/reveal.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(53): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../common\words/recurse.asm'
../../avr8\dict/compiler1.inc(56): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(61): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(67): Including file '../../common\words/cfg-order.asm'
../../avr8\dict/compiler1.inc(68): Including file '../../common\words/cfg-recognizer.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(70): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(13): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../common\words/postpone.asm'
dict_appl.inc(16): Including file 'words/applturnkey.asm'
dict_appl.inc(21): Including file '../../common\words/dot-s.asm'
dict_appl.inc(26): Including file 'words/build-info.asm'
dict_appl.inc(31): Including file '../../common\words/place.asm'
dict_appl.inc(32): Including file '../../common\words/word.asm'
../../avr8\amforth.asm(23): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth.asm(24): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(35): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(36): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(42): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(45): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(46): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(49): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(56): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(63): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../common\words/q-negate.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(89): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(95): Including file '../../avr8\words/store-i_nrww.asm'
../../avr8\dict/nrww.inc(97): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(98): Including file '../../common\words/2literal.asm'
../../avr8\dict/nrww.inc(99): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(100): Including file '../../common\words/num-constants.asm'
../../avr8\dict/nrww.inc(103): Including file '../../avr8\dict/core_8k.inc'
../../avr8\dict/core_8k.inc(2): Including file '../../avr8\words/n_to_r.asm'
../../avr8\dict/core_8k.inc(3): Including file '../../avr8\words/n_r_from.asm'
../../avr8\dict/core_8k.inc(5): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/core_8k.inc(6): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/core_8k.inc(7): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/core_8k.inc(8): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/core_8k.inc(9): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/core_8k.inc(10): Including file '../../common\words/u-dot.asm'
../../avr8\dict/core_8k.inc(11): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/core_8k.inc(13): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/core_8k.inc(14): Including file '../../common\words/words.asm'
../../avr8\dict/core_8k.inc(17): Including file '../../common\words/pick.asm'
../../avr8\dict/core_8k.inc(18): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/core_8k.inc(19): Including file '../../common\words/squote.asm'
../../avr8\dict/core_8k.inc(21): Including file '../../avr8\words/fill.asm'
../../avr8\dict/core_8k.inc(23): Including file '../../avr8\words/environment.asm'
../../avr8\dict/core_8k.inc(24): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/core_8k.inc(25): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/core_8k.inc(26): Including file '../../common\words/env-slashhold.asm'
../../avr8\dict/core_8k.inc(27): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/core_8k.inc(28): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/core_8k.inc(29): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/core_8k.inc(30): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/core_8k.inc(31): Including file '../../common\words/env-usersize.asm'
../../avr8\dict/core_8k.inc(33): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/core_8k.inc(34): Including file '../../avr8\words/state.asm'
../../avr8\dict/core_8k.inc(35): Including file '../../common\words/base.asm'
../../avr8\dict/core_8k.inc(37): Including file '../../avr8\words/cells.asm'
../../avr8\dict/core_8k.inc(38): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/core_8k.inc(40): Including file '../../common\words/2dup.asm'
../../avr8\dict/core_8k.inc(41): Including file '../../common\words/2drop.asm'
../../avr8\dict/core_8k.inc(43): Including file '../../common\words/tuck.asm'
../../avr8\dict/core_8k.inc(45): Including file '../../common\words/to-in.asm'
../../avr8\dict/core_8k.inc(46): Including file '../../common\words/pad.asm'
../../avr8\dict/core_8k.inc(47): Including file '../../common\words/emit.asm'
../../avr8\dict/core_8k.inc(48): Including file '../../common\words/emitq.asm'
../../avr8\dict/core_8k.inc(49): Including file '../../common\words/key.asm'
../../avr8\dict/core_8k.inc(50): Including file '../../common\words/keyq.asm'
../../avr8\dict/core_8k.inc(52): Including file '../../avr8\words/dp.asm'
../../avr8\dict/core_8k.inc(53): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/core_8k.inc(54): Including file '../../avr8\words/here.asm'
../../avr8\dict/core_8k.inc(55): Including file '../../avr8\words/allot.asm'
../../avr8\dict/core_8k.inc(57): Including file '../../common\words/bin.asm'
../../avr8\dict/core_8k.inc(58): Including file '../../common\words/decimal.asm'
../../avr8\dict/core_8k.inc(59): Including file '../../common\words/hex.asm'
../../avr8\dict/core_8k.inc(60): Including file '../../common\words/bl.asm'
../../avr8\dict/core_8k.inc(62): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/core_8k.inc(64): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/core_8k.inc(65): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/core_8k.inc(66): Including file '../../avr8\words/negate.asm'
../../avr8\dict/core_8k.inc(67): Including file '../../common\words/slash.asm'
../../avr8\dict/core_8k.inc(68): Including file '../../common\words/mod.asm'
../../avr8\dict/core_8k.inc(69): Including file '../../common\words/abs.asm'
../../avr8\dict/core_8k.inc(70): Including file '../../common\words/min.asm'
../../avr8\dict/core_8k.inc(71): Including file '../../common\words/max.asm'
../../avr8\dict/core_8k.inc(72): Including file '../../common\words/within.asm'
../../avr8\dict/core_8k.inc(74): Including file '../../common\words/to-upper.asm'
../../avr8\dict/core_8k.inc(75): Including file '../../common\words/to-lower.asm'
../../avr8\dict/core_8k.inc(77): Including file '../../avr8\words/hld.asm'
../../avr8\dict/core_8k.inc(78): Including file '../../common\words/hold.asm'
../../avr8\dict/core_8k.inc(79): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/core_8k.inc(80): Including file '../../common\words/sharp.asm'
../../avr8\dict/core_8k.inc(81): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/core_8k.inc(82): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/core_8k.inc(83): Including file '../../common\words/sign.asm'
../../avr8\dict/core_8k.inc(84): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/core_8k.inc(85): Including file '../../common\words/dot-r.asm'
../../avr8\dict/core_8k.inc(86): Including file '../../common\words/d-dot.asm'
../../avr8\dict/core_8k.inc(87): Including file '../../common\words/dot.asm'
../../avr8\dict/core_8k.inc(88): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/core_8k.inc(89): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/core_8k.inc(90): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/core_8k.inc(91): Including file '../../common\words/digit-q.asm'
../../avr8\dict/core_8k.inc(93): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/core_8k.inc(94): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/core_8k.inc(95): Including file '../../avr8\words/itype.asm'
../../avr8\dict/core_8k.inc(96): Including file '../../avr8\words/icount.asm'
../../avr8\dict/core_8k.inc(97): Including file '../../common\words/cr.asm'
../../avr8\dict/core_8k.inc(98): Including file '../../common\words/space.asm'
../../avr8\dict/core_8k.inc(99): Including file '../../common\words/spaces.asm'
../../avr8\dict/core_8k.inc(100): Including file '../../common\words/type.asm'
../../avr8\dict/core_8k.inc(101): Including file '../../common\words/tick.asm'
../../avr8\dict/core_8k.inc(103): Including file '../../common\words/handler.asm'
../../avr8\dict/core_8k.inc(104): Including file '../../common\words/catch.asm'
../../avr8\dict/core_8k.inc(105): Including file '../../common\words/throw.asm'
../../avr8\dict/core_8k.inc(107): Including file '../../common\words/cskip.asm'
../../avr8\dict/core_8k.inc(108): Including file '../../common\words/cscan.asm'
../../avr8\dict/core_8k.inc(109): Including file '../../common\words/accept.asm'
../../avr8\dict/core_8k.inc(110): Including file '../../common\words/refill.asm'
../../avr8\dict/core_8k.inc(111): Including file '../../common\words/char.asm'
../../avr8\dict/core_8k.inc(112): Including file '../../common\words/number.asm'
../../avr8\dict/core_8k.inc(113): Including file '../../common\words/q-sign.asm'
../../avr8\dict/core_8k.inc(114): Including file '../../common\words/set-base.asm'
../../avr8\dict/core_8k.inc(115): Including file '../../common\words/to-number.asm'
../../avr8\dict/core_8k.inc(116): Including file '../../common\words/parse.asm'
../../avr8\dict/core_8k.inc(117): Including file '../../common\words/source.asm'
../../avr8\dict/core_8k.inc(118): Including file '../../common\words/slash-string.asm'
../../avr8\dict/core_8k.inc(119): Including file '../../common\words/parse-name.asm'
../../avr8\dict/core_8k.inc(120): Including file '../../common\words/find-xt.asm'
../../avr8\dict/core_8k.inc(122): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/core_8k.inc(123): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/core_8k.inc(124): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/core_8k.inc(125): Including file '../../common\words/prompt-input.asm'
../../avr8\dict/core_8k.inc(126): Including file '../../common\words/quit.asm'
../../avr8\dict/core_8k.inc(127): Including file '../../avr8\words/pause.asm'
../../avr8\dict/core_8k.inc(128): Including file '../../avr8\words/cold.asm'
../../avr8\dict/core_8k.inc(129): Including file '../../common\words/warm.asm'
../../avr8\dict/core_8k.inc(131): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/core_8k.inc(132): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/core_8k.inc(133): Including file '../../common\words/depth.asm'
../../avr8\dict/core_8k.inc(134): Including file '../../common\words/interpret.asm'
../../avr8\dict/core_8k.inc(135): Including file '../../avr8\words/forth-recognizer.asm'
../../avr8\dict/core_8k.inc(136): Including file '../../common\words/recognize.asm'
../../avr8\dict/core_8k.inc(137): Including file '../../common\words/rec-intnum.asm'
../../avr8\dict/core_8k.inc(138): Including file '../../common\words/rec-find.asm'
../../avr8\dict/core_8k.inc(139): Including file '../../common\words/rec-null.asm'
../../avr8\dict/core_8k.inc(141): Including file '../../common\words/q-stack.asm'
../../avr8\dict/core_8k.inc(142): Including file '../../common\words/ver.asm'
../../avr8\dict/core_8k.inc(144): Including file '../../common\words/noop.asm'
../../avr8\dict/core_8k.inc(145): Including file '../../avr8\words/unused.asm'
../../avr8\dict/core_8k.inc(147): Including file '../../common\words/to.asm'
../../avr8\dict/core_8k.inc(148): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/core_8k.inc(150): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/core_8k.inc(151): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/core_8k.inc(152): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/core_8k.inc(153): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/core_8k.inc(154): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/core_8k.inc(155): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/core_8k.inc(156): Including file '../../common\words/defer-store.asm'
../../avr8\dict/core_8k.inc(157): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/core_8k.inc(158): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/core_8k.inc(160): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/core_8k.inc(161): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/core_8k.inc(162): Including file '../../common\words/name2string.asm'
../../avr8\dict/core_8k.inc(163): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/core_8k.inc(164): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/core_8k.inc(166): Including file '../../common\words/star.asm'
../../avr8\dict/core_8k.inc(167): Including file '../../avr8\words/j.asm'
../../avr8\dict/core_8k.inc(169): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/core_8k.inc(170): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/core_8k.inc(171): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/core_8k.inc(172): Including file '../../common\words/2swap.asm'
../../avr8\dict/core_8k.inc(174): Including file '../../common\words/tib.asm'
../../avr8\dict/core_8k.inc(176): Including file '../../avr8\words/init-ram.asm'
../../avr8\dict/core_8k.inc(178): Including file '../../common\words/bounds.asm'
../../avr8\dict/core_8k.inc(179): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/core_8k.inc(180): Including file '../../avr8\words/to-body.asm'
../../avr8\dict/core_8k.inc(182): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/core_8k.inc(183): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/irqcnt.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-num.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(10): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(11): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(12): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(13): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(15): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(16): Including file '../../avr8\words/isr-end.asm'
../../avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
../../avr8\amforth.asm(36): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ;
                 ; The order of the entries (esp the include order) must not be
                 ; changed since it is very important that the settings are in the
                 ; right order
                 ;
                 ; note: .set is like a variable, .equ is like a constant
                 ;
                 ; first is include the preamble. It contains macro definitions, 
                 ; default settings and mcu specific stuff like register names. 
                 ; The files included with it depend on the -I order of the 
                 ; assembler.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set USER_P_OK    = 28
                 .set USER_P_ERR   = 30
                 .set USER_P_RDY   = 32
                 .set USER_P_INPUT = 34
                 
                 .set SYSUSERSIZE = 36
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot = r10
                   .def isrflag  = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  256
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 	elpm @0, Z+
                 	elpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_TIMER_COUNTER_3 = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_JTAG = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TWI = 0
                 .set WANT_USART1 = 0
                 .set WANT_SPI = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_CPU = 0
                 .equ intvecsize = 2 ; please verify; flash size: 131072 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d0ed      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d0eb      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d0e9      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d0e7      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 10
00000a d0e5      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 12
00000c d0e3      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 14
00000e d0e1      	 rcall isr ; Pin Change Interrupt Request 3
                 .org 16
000010 d0df      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 18
000012 d0dd      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 20
000014 d0db      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 22
000016 d0d9      	 rcall isr ; Timer/Counter2 Overflow
                 .org 24
000018 d0d7      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 26
00001a d0d5      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 28
00001c d0d3      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 30
00001e d0d1      	 rcall isr ; Timer/Counter1 Overflow
                 .org 32
000020 d0cf      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 34
000022 d0cd      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 36
000024 d0cb      	 rcall isr ; Timer/Counter0 Overflow
                 .org 38
000026 d0c9      	 rcall isr ; SPI Serial Transfer Complete
                 .org 40
000028 d0c7      	 rcall isr ; USART0, Rx Complete
                 .org 42
00002a d0c5      	 rcall isr ; USART0 Data register Empty
                 .org 44
00002c d0c3      	 rcall isr ; USART0, Tx Complete
                 .org 46
00002e d0c1      	 rcall isr ; Analog Comparator
                 .org 48
000030 d0bf      	 rcall isr ; ADC Conversion Complete
                 .org 50
000032 d0bd      	 rcall isr ; EEPROM Ready
                 .org 52
000034 d0bb      	 rcall isr ; 2-wire Serial Interface
                 .org 54
000036 d0b9      	 rcall isr ; Store Program Memory Read
                 .org 56
000038 d0b7      	 rcall isr ; USART1 RX complete
                 .org 58
00003a d0b5      	 rcall isr ; USART1 Data Register Empty
                 .org 60
00003c d0b3      	 rcall isr ; USART1 TX complete
                 .org 62
00003e d0b1      	 rcall isr ; Timer/Counter3 Capture Event
                 .org 64
000040 d0af      	 rcall isr ; Timer/Counter3 Compare Match A
                 .org 66
000042 d0ad      	 rcall isr ; Timer/Counter3 Compare Match B
                 .org 68
000044 d0ab      	 rcall isr ; Timer/Counter3 Overflow
                 .equ INTVECTORS = 35
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000045 4000      	.dw 16384
                 mcu_eepromsize:
000046 1000      	.dw 4096
                 mcu_maxdp:
000047 ffff      	.dw 65535 
                 mcu_numints:
000048 0023      	.dw 35
                 mcu_name:
000049 000b      	.dw 11
00004a 5441
00004b 656d
00004c 6167
00004d 3231
00004e 3438
00004f 0050      	.db "ATmega1284P",0
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 ; enabling Interrupts, disabling them affects
                 ; other settings as well. 
                 .set WANT_INTERRUPTS = 1
                 
                 ; count the number of interrupts individually.
                 ; requires a lot of RAM (one byte per interrupt)
                 ; disabled by default.
                 .set WANT_INTERRUPT_COUNTERS = 1
                 
                 ; receiving is asynchronously, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIB_SIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 ; The amforth code is split into two segments, one starting
                 ; at address 0 (the RWW area) and one starting in
                 ; the NRWW region. The latter part cannot be changed
                 ; at runtime so it contains most of the core system
                 ; that would never be changed. If unsure what it
                 ; means, leave it as it is. This address may be
                 ; adjusted to give room for other code fragments (e.g.
                 ; bootloaders). The amforth code will start here and may
                 ; occupy all space until flash-end.
                 
                 ; If you want leave out the first 512 bytes of the NRWW section
                 ; for e.g. a bootloader change the line to
                 ; .equ AMFORTH_RO_SEG = NRWW_START_ADDR+512/2
                 ; note the /2 since the flash is 16bit per address
                 ; default is the whole NRWW section
                 ; .equ AMFORTH_RO_SEG = NRWW_START_ADDR
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR
                 
                 ; amforth needs two essential parameters: CPU clock
                 ; and command terminal line.
                 ; cpu clock in hertz, 1MHz is factory default
                 .equ F_CPU = 8000000
                 
                 ; terminal settings
                 ; check http://amforth.sourceforge.net/TG/recipes/Usart.html
                 ; for further information
                 
                 ; serial line settings. The defaults are set in avr8/preamble.inc.
                 ; You should not change that file but use your own settings *here*
                 ; since it may get changed in future versions of amforth.
                 ;.set BAUD=38400
                 ;.set BAUD_MAXERROR=10
                 ;.set WANT_ISR_RX = 1 ; interrupt driven receive
                 ;.set WANT_ISR_TX = 0 ; send slowly but with less code space
                 
                 ; define which usart to use.
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .equ URXCaddr = URXC0addr
                   .equ UDREaddr = UDRE0addr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_INTERRUPTS == 0
                   .if WANT_ISR_RX == 1
                   .endif
                 .endif
                 
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-rx-buffer.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100            usart_rx_data: .byte usart_rx_size
000110            usart_rx_in:   .byte 1
000111            usart_rx_out:  .byte 1
                 .cseg
                 
                 VE_TO_RXBUF:
000050 ff07          .dw $ff07
000051 723e
000052 2d78
000053 7562
000054 0066          .db ">rx-buf",0
000055 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_RXBUF
                 XT_TO_RXBUF:
000056 0057          .dw PFA_rx_tobuf
                 PFA_rx_tobuf:
000057 2f08          mov temp0, tosl
000058 9110 0110     lds temp1, usart_rx_in
00005a e0e0          ldi zl, low(usart_rx_data)
00005b e0f1          ldi zh, high(usart_rx_data)
00005c 0fe1          add zl, temp1
00005d 1df3          adc zh, zeroh
00005e 8300          st Z, temp0
00005f 9513          inc temp1
000060 701f          andi temp1,usart_rx_mask
000061 9310 0110     sts usart_rx_in, temp1
000063 9189
000064 9199          loadtos
000065 940c f004     jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; setup with
                 ; ' isr-rx URXCaddr int!
                 VE_ISR_RX:
000067 ff06          .dw $ff06
000068 7369
000069 2d72
00006a 7872          .db "isr-rx"
00006b 0050          .dw VE_HEAD
                     .set VE_HEAD = VE_ISR_RX
                 XT_ISR_RX:
00006c f000          .dw DO_COLON
                 usart_rx_isr:
00006d f045        .dw XT_DOLITERAL
00006e 00c6        .dw usart_data
00006f f0a9        .dw XT_CFETCH
000070 f0c2        .dw XT_DUP
000071 f045        .dw XT_DOLITERAL
000072 0003        .dw 3
000073 f3f0        .dw XT_EQUAL
000074 f03e        .dw XT_DOCONDBRANCH
000075 0077        .dw usart_rx_isr1
000076 fa6b        .dw XT_COLD
                 usart_rx_isr1:
000077 0056        .dw XT_TO_RXBUF
000078 f025        .dw XT_EXIT
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RXBUFFER:
                 ;  .dw $ff0x
                 ;  .db "+usart-buffer"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RXBUFFER
                 XT_USART_INIT_RX_BUFFER:
000079 f000        .dw DO_COLON
                 PFA_USART_INIT_RX_BUFFER:          ; ( -- )
00007a f045
00007b 006c        .dw XT_DOLITERAL, XT_ISR_RX
00007c f045
00007d 0028        .dw XT_DOLITERAL, URXCaddr
00007e fdbc        .dw XT_INTSTORE
                 
00007f f045        .dw XT_DOLITERAL
000080 0100        .dw usart_rx_data
000081 f045        .dw XT_DOLITERAL
000082 0016        .dw usart_rx_size + 6
000083 f165        .dw XT_ZERO
000084 f4ca        .dw XT_FILL
000085 f025        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_BUFFER:
000086 ff06          .dw $ff06
000087 7872
000088 622d
000089 6675          .db "rx-buf"
00008a 0067          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_BUFFER
                 XT_RX_BUFFER:
00008b f000          .dw DO_COLON
                 PFA_RX_BUFFER:
00008c 00a6        .dw XT_RXQ_BUFFER
00008d f03e        .dw XT_DOCONDBRANCH
00008e 008c        .dw PFA_RX_BUFFER
00008f f045        .dw XT_DOLITERAL
000090 0111        .dw usart_rx_out
000091 f0a9        .dw XT_CFETCH
000092 f0c2        .dw XT_DUP
000093 f045        .dw XT_DOLITERAL
000094 0100        .dw usart_rx_data
000095 f1ae        .dw XT_PLUS
000096 f0a9        .dw XT_CFETCH
000097 f0d5        .dw XT_SWAP
000098 f240        .dw XT_1PLUS
000099 f045        .dw XT_DOLITERAL
00009a 000f        .dw usart_rx_mask
00009b f224        .dw XT_AND
00009c f045        .dw XT_DOLITERAL
00009d 0111        .dw usart_rx_out
00009e f09e        .dw XT_CSTORE
00009f f025        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue
                 VE_RXQ_BUFFER:
0000a0 ff07          .dw $ff07
0000a1 7872
0000a2 2d3f
0000a3 7562
0000a4 0066          .db "rx?-buf",0
0000a5 0086          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_BUFFER
                 XT_RXQ_BUFFER:
0000a6 f000          .dw DO_COLON
                 PFA_RXQ_BUFFER:
0000a7 fa63        .dw XT_PAUSE
0000a8 f045        .dw XT_DOLITERAL
0000a9 0111        .dw usart_rx_out
0000aa f0a9        .dw XT_CFETCH
0000ab f045        .dw XT_DOLITERAL
0000ac 0110        .dw usart_rx_in
0000ad f0a9        .dw XT_CFETCH
0000ae f122        .dw XT_NOTEQUAL
0000af f025        .dw XT_EXIT
                 ;  .include "drivers/timer-usart-isr.asm"
                   .set XT_RX  = XT_RX_BUFFER
                   .set XT_RXQ = XT_RXQ_BUFFER
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_BUFFER
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
0000b0 ff07          .dw $ff07
0000b1 7874
0000b2 702d
0000b3 6c6f
0000b4 006c          .db "tx-poll",0
0000b5 00a0          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
0000b6 f000          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
0000b7 00c4        .dw XT_TXQ_POLL
0000b8 f03e        .dw XT_DOCONDBRANCH
0000b9 00b7        .dw PFA_TX_POLL
                   ; send to usart
0000ba f045        .dw XT_DOLITERAL
0000bb 00c6        .dw USART_DATA
0000bc f09e        .dw XT_CSTORE
0000bd f025        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
0000be ff08          .dw $ff08
0000bf 7874
0000c0 2d3f
0000c1 6f70
0000c2 6c6c          .db "tx?-poll"
0000c3 00b0          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000c4 f000          .dw DO_COLON
                 PFA_TXQ_POLL:
0000c5 fa63        .dw XT_PAUSE
0000c6 f045        .dw XT_DOLITERAL
0000c7 00c0        .dw USART_A
0000c8 f0a9        .dw XT_CFETCH
0000c9 f045        .dw XT_DOLITERAL
0000ca 0020        .dw bm_USART_TXRD
0000cb f224        .dw XT_AND
0000cc f025        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000cd ff04        .dw $ff04
0000ce 6275
0000cf 7272        .db "ubrr"
0000d0 00be        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000d1 f080        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000d2 00a0        .dw EE_UBRRVAL
0000d3 fbca        .dw XT_EDEFERFETCH
0000d4 fbd4        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000d5 ff06        .dw $ff06
0000d6 752b
0000d7 6173
0000d8 7472        .db "+usart"
0000d9 00cd        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000da f000        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000db f045        .dw XT_DOLITERAL
0000dc 0098        .dw USART_B_VALUE
0000dd f045        .dw XT_DOLITERAL
0000de 00c1        .dw USART_B
0000df f09e        .dw XT_CSTORE
                 
0000e0 f045        .dw XT_DOLITERAL
0000e1 0006        .dw USART_C_VALUE
0000e2 f045        .dw XT_DOLITERAL
0000e3 00c2        .dw USART_C | bm_USARTC_en
0000e4 f09e        .dw XT_CSTORE
                 
0000e5 00d1        .dw XT_UBRR
0000e6 f0c2        .dw XT_DUP
0000e7 f30a        .dw XT_BYTESWAP
0000e8 f045        .dw XT_DOLITERAL
0000e9 00c5        .dw BAUDRATE_HIGH
0000ea f09e        .dw XT_CSTORE
0000eb f045        .dw XT_DOLITERAL
0000ec 00c4        .dw BAUDRATE_LOW
0000ed f09e        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
0000ee 0079        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
0000ef f025        .dw XT_EXIT
                 
                 
                 ; now define your own options, if the settings from
                 ; the files included above are not ok. Use the .set
                 ; instruction, not the .equ. e.g.:
                 ;
                 ; .set WANT_XY = 1
                 ;
                 ; there are many options available. There are two
                 ; places where they are defined initially: core/macros.asm 
                 ; and core/devices/<mcutype>/device.asm. Setting the value
                 ; to 1 enables the feature, setting to 0 disables it.
                 ; Most options are disabled by default. You should never
                 ; change the files mentioned above, setting the options here
                 ; is absolutly sufficient.
                 
                 ; the dictionary search treats lowercase and uppercase
                 ; letters the same. Set to 0 if you do not want it
                 .set WANT_IGNORECASE = 1
                 
                 
                 ; default settings as specified in core/macros.asm. Uncomment and
                 ; change them if necessary.
                 
                 ; Size of the Terminal Input Buffer. This is the command line buffer.
                 ; .set TIBSIZE  = $64    ; bytes; ANS94 needs at least 80 characters per line
                 
                 ; The total USER size is the sum of the system internal USER area plus
                 ; the size specified here.
                 ; .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments. 
                 ;.set rstackstart = RAMEND      ; start address of return stack, grows downward
                 ;.set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 
                 ; Total number of entries in the search order.
                 ; The standard requires 8 wordlists in the search oder, amforth uses
                 ; already one for itself. So you'll have 7 slots available.
                 ;.set NUMWORDLISTS = 8
                 
                 ; Total number of recognizers.
                 ; There are 2 recognizers already in the core system. That makes
                 ; 2 for you.
                 ;.set NUMRECOGNIZERS = 4
                 
                 
                 ; DRIVER SECTION
                 ; 
                 ; settings for 1wire interface, uncomment to use it
                 ;.equ OW_PORT=PORTB
                 ;.equ OW_BIT=4
                 ;.include "drivers/1wire.asm"
                 
                 ; Interrupts.
                 ; globally enable (or disable) the interrupt support. It is
                 ; enabled by default and some other settings (usart receive)
                 ; depend on it. disabling it makes the inner interpreter
                 ; slightly faster and frees some code space.
                 ; .set WANT_INTERRUPTS = 1
                 
                 ; reserve a RAM region to count each interrupt individually.
                 ; each interrupt of the given controller type gets a byte
                 ; that is incremented for each interrupt. Needs a lot of 
                 ; RAM but may be useful for debugging interrupts or get rid
                 ; of random effects. disabled by default.
                 ; .set WANT_INTERRUPT_COUNTERS = 0
                 
                 
                 ; include the whole source tree.
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 
                 .set corepc = pc
                 .org $0000
000000 940c fa6c   jmp_ PFA_COLD
                 
                 .org corepc
                 .include "drivers/generic-isr.asm"
                 
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .if WANT_INTERRUPT_COUNTERS==1
                 .dseg
000112           intcnt: .byte INTVECTORS
                 .endif
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
0000f0 920a          st -Y, r0
0000f1 b60f          in r0, SREG
0000f2 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
0000f3 900f          pop r0
0000f4 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
0000f5 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
                     ; check whether isrflag is zero. if not,
                     ; there is an still unhandled interrupt pending.
0000f6 20bb          tst isrflag
0000f7 f001          breq isr_clean
                     ; there is a collision. the previous interrupt is not yet
                     ; handled by the forth inner interpreter
                 isr_clean:
0000f8 2cb0          mov isrflag, r0
                 .if WANT_INTERRUPT_COUNTERS==1
0000f9 93ff          push zh
0000fa 93ef          push zl
0000fb e1e2          ldi zl, low(intcnt)
0000fc e0f1          ldi zh, high(intcnt)
0000fd 9406          lsr r0 ; we use byte addresses in the counter array, not words
0000fe 0de0          add zl, r0
0000ff 1df3          adc zh, zeroh
000100 8000          ld r0, Z
000101 9403          inc r0
000102 8200          st Z, r0
000103 91ef          pop zl
000104 91ff          pop zh
                 .endif
000105 9009          ld r0, Y+
000106 be0f          out SREG, r0
000107 9009          ld r0, Y+
000108 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                     ; no reti here, see words/isr-end.asm
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000109 ff02          .dw $ff02
00010a 2b6d          .db "m+"
00010b 00d5          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
00010c f000          .dw DO_COLON
                 PFA_MPLUS:
00010d fd8e          .dw XT_S2D
00010e f446          .dw XT_DPLUS
00010f f025          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
000110 ff03          .dw $ff03
000111 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
000112 002a          .db "ud*"
000113 0109          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
000114 f000          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
000115 f0c2
000116 f110
000117 f1f1
000118 f0ea              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000119 f0d5
00011a f107
00011b f1f1
00011c f0f2
00011d f1ae
00011e f025              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
00011f ff04          .dw $ff04
000120 6d75
000121 7861          .db "umax"
000122 0110          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
000123 f000          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
000124 f560
000125 f16d              .DW XT_2DUP,XT_ULESS
000126 f03e      	.dw XT_DOCONDBRANCH
000127 0129      	 DEST(UMAX1)
000128 f0d5              .DW XT_SWAP
000129 f0ea      UMAX1:  .DW XT_DROP
00012a f025      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
00012b ff04          .dw $ff04
00012c 6d75
00012d 6e69          .db "umin"
00012e 011f          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
00012f f000          .dw DO_COLON
                 PFA_UMIN:
                 .endif
000130 f560
000131 f178              .DW XT_2DUP,XT_UGREATER
000132 f03e      	.dw XT_DOCONDBRANCH
000133 0135      	DEST(UMIN1)
000134 f0d5              .DW XT_SWAP
000135 f0ea      UMIN1:  .DW XT_DROP
000136 f025      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; return +1 if immediate, -1 otherwise, flag from name>flags
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
000137 f000          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000138 f045          .dw XT_DOLITERAL
000139 8000          .dw $8000
00013a f224          .dw XT_AND
00013b f129          .dw XT_ZEROEQUAL
00013c f03e          .dw XT_DOCONDBRANCH
00013d 0140          DEST(IMMEDIATEQ1)
00013e f3f7           .dw XT_ONE
00013f f025           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
000140 f15c          .dw XT_TRUE
000141 f025          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
000142 ff0a          .dw $ff0a
000143 616e
000144 656d
000145 663e
000146 616c
000147 7367          .db "name>flags"
000148 012b          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
000149 f000          .dw DO_COLON
                 PFA_NAME2FLAGS:
00014a f3d8          .dw XT_FETCHI ; skip to link field
00014b f045          .dw XT_DOLITERAL
00014c ff00          .dw $ff00
00014d f224          .dw XT_AND
00014e f025          .dw XT_EXIT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
00014f ff03          .dw $ff03
000150 6d31
000151 0073          .db "1ms",0
000152 0142          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
000153 0154          .dw PFA_1MS
                 PFA_1MS:
000154 ede0
000155 e0f7
000156 9731
000157 f7f1          delay 1000
000158 940c f004     jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .include "dict/appl_8k.inc"
                 
                 
                 .include "words/newest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_NEWEST:
00015a ff06          .dw $ff06
00015b 656e
00015c 6577
00015d 7473          .db "newest"
00015e 014f          .dw VE_HEAD
                     .set VE_HEAD = VE_NEWEST
                 XT_NEWEST:
00015f f053          .dw PFA_DOVARIABLE
                 PFA_NEWEST:
000160 0135          .dw ram_newest
                 
                 .dseg
000135           ram_newest: .byte 4
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_LATEST:
000161 ff06          .dw $ff06
000162 616c
000163 6574
000164 7473          .db "latest"
000165 015a          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
000166 f053          .dw PFA_DOVARIABLE
                 PFA_LATEST:
000167 0139          .dw ram_latest
                 
                 .dseg
000139           ram_latest: .byte 2
                 .include "words/do-create.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE:
000168 ff08          .dw $ff08
000169 6328
00016a 6572
00016b 7461
00016c 2965          .db "(create)"
00016d 0161          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
00016e f000          .dw DO_COLON
                 PFA_DOCREATE:
                 .endif
00016f f9b9
000170 02d0          .DW XT_PARSENAME,XT_WLSCOPE  ; ( -- addr len wid)
000171 017b          .DW XT_DOCREATE_IN           ; ( addr len wid -- )
000172 f025          .DW XT_EXIT
                 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE_IN:
000173 ff0b          .dw $ff0b
000174 6328
000175 6572
000176 7461
000177 2d65
000178 6e69
../../common\words/do-create.asm(31): warning: .cseg .db misalignment - padding zero byte
000179 0029          .db "(create-in)"
00017a 0168          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE_IN
                 XT_DOCREATE_IN:
00017b f000          .dw DO_COLON
                 PFA_DOCREATE_IN:
                 .endif
00017c f0c2
00017d 015f
00017e f559
00017f f092          .DW XT_DUP,XT_NEWEST,XT_CELLPLUS,XT_STORE ; save the wid
000180 02b5
000181 015f
000182 f092          .DW XT_HEADER,XT_NEWEST,XT_STORE          ; save the nt
000183 f025          .DW XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
000184 0001          .dw $0001
000185 005c          .db $5c,0
000186 0173          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
000187 f000          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
000188 f9a0          .dw XT_SOURCE
000189 f101          .dw XT_NIP
00018a f579          .dw XT_TO_IN
00018b f092          .dw XT_STORE
00018c f025          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
00018d 0001          .dw $0001
00018e 0028          .db "(" ,0
00018f 0184          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
000190 f000          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
000191 f045          .dw XT_DOLITERAL
000192 0029          .dw ')'
000193 f98c          .dw XT_PARSE
000194 f569          .dw XT_2DROP
000195 f025          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
000196 ff07          .dw $ff07
000197 6f63
000198 706d
000199 6c69
00019a 0065          .db "compile",0
00019b 018d          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
00019c f000          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
00019d f107          .dw XT_R_FROM
00019e f0c2          .dw XT_DUP
00019f fbc1          .dw XT_ICELLPLUS
0001a0 f110          .dw XT_TO_R
0001a1 f3d8          .dw XT_FETCHI
0001a2 01a7          .dw XT_COMMA
0001a3 f025          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0001a4 ff01          .dw $ff01
0001a5 002c          .db ',',0 ; ,
0001a6 0196          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0001a7 f000          .dw DO_COLON
                 PFA_COMMA:
0001a8 f5a9          .dw XT_DP
0001a9 f37a          .dw XT_STOREI
0001aa f5a9          .dw XT_DP
0001ab f240          .dw XT_1PLUS
0001ac fbaf          .dw XT_DOTO
0001ad f5aa          .dw PFA_DP
0001ae f025          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
0001af 0003          .dw $0003
0001b0 275b
0001b1 005d          .db "[']",0
0001b2 01a4          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
0001b3 f000          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
0001b4 f805          .dw XT_TICK
0001b5 01bd          .dw XT_LITERAL
0001b6 f025          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
0001b7 0007          .dw $0007
0001b8 696c
0001b9 6574
0001ba 6172
0001bb 006c          .db "literal",0
0001bc 01af          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
0001bd f000          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
0001be 019c              .DW XT_COMPILE
0001bf f045              .DW XT_DOLITERAL
0001c0 01a7              .DW XT_COMMA
0001c1 f025              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
0001c2 0008        .dw $0008
0001c3 6c73
0001c4 7469
0001c5 7265
0001c6 6c61        .db "sliteral"
0001c7 01b7        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
0001c8 f000          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
0001c9 019c          .dw XT_COMPILE
0001ca f768          .dw XT_DOSLITERAL    ; ( -- addr n)
0001cb f776          .dw XT_SCOMMA
0001cc f025          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
0001cd f000          .dw DO_COLON
                 PFA_GMARK:
0001ce f5a9          .dw XT_DP
0001cf 019c          .dw XT_COMPILE
0001d0 ffff          .dw -1           ; ffff does not erase flash
0001d1 f025          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
0001d2 f000          .dw DO_COLON
                 PFA_GRESOLVE:
0001d3 fb6d          .dw XT_QSTACK
0001d4 f5a9          .dw XT_DP
0001d5 f0d5          .dw XT_SWAP
0001d6 f37a          .dw XT_STOREI
0001d7 f025          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
0001d8 f000          .dw DO_COLON
                 PFA_LMARK:
0001d9 f5a9          .dw XT_DP
0001da f025          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
0001db f000          .dw DO_COLON
                 PFA_LRESOLVE:
0001dc fb6d          .dw XT_QSTACK
0001dd 01a7          .dw XT_COMMA
0001de f025          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
0001df 0005          .dw $0005
0001e0 6861
0001e1 6165
0001e2 0064          .db "ahead",0
0001e3 01c2          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
0001e4 f000          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
0001e5 019c          .dw XT_COMPILE
0001e6 f034          .dw XT_DOBRANCH
0001e7 01cd          .dw XT_GMARK
0001e8 f025          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
0001e9 0002          .dw $0002
0001ea 6669          .db "if"
0001eb 01df          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
0001ec f000          .dw DO_COLON
                 PFA_IF:
                 .endif
0001ed 019c          .dw XT_COMPILE
0001ee f03e          .dw XT_DOCONDBRANCH
0001ef 01cd          .dw XT_GMARK
0001f0 f025          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
0001f1 0004          .dw $0004
0001f2 6c65
0001f3 6573          .db "else"
0001f4 01e9          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
0001f5 f000          .dw DO_COLON
                 PFA_ELSE:
                 .endif
0001f6 019c          .dw XT_COMPILE
0001f7 f034          .dw XT_DOBRANCH
0001f8 01cd          .dw XT_GMARK
0001f9 f0d5          .dw XT_SWAP
0001fa 01d2          .dw XT_GRESOLVE
0001fb f025          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
0001fc 0004          .dw $0004
0001fd 6874
0001fe 6e65          .db "then"
0001ff 01f1          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
000200 f000          .dw DO_COLON
                 PFA_THEN:
                 .endif
000201 01d2          .dw XT_GRESOLVE
000202 f025          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
000203 0005          .dw $0005
000204 6562
000205 6967
000206 006e          .db "begin",0
000207 01fc          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
000208 f000          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
000209 01d8          .dw XT_LMARK
00020a f025          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
00020b 0005          .dw $0005
00020c 6877
00020d 6c69
00020e 0065          .db "while",0
00020f 0203          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
000210 f000          .dw DO_COLON
                 PFA_WHILE:
                 .endif
000211 01ec          .dw XT_IF
000212 f0d5          .dw XT_SWAP
000213 f025          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
000214 0006          .dw $0006
000215 6572
000216 6570
000217 7461          .db "repeat"
000218 020b          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
000219 f000          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
00021a 022d          .dw XT_AGAIN
00021b 0200          .dw XT_THEN
00021c f025          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
00021d 0005          .dw $0005
00021e 6e75
00021f 6974
000220 006c          .db "until",0
000221 0214          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
000222 f000          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
000223 f045          .dw XT_DOLITERAL
000224 f03e          .dw XT_DOCONDBRANCH
000225 01a7          .dw XT_COMMA
                 
000226 01db          .dw XT_LRESOLVE
000227 f025          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
000228 0005          .dw $0005
000229 6761
00022a 6961
00022b 006e          .db "again",0
00022c 021d          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
00022d f000          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
00022e 019c          .dw XT_COMPILE
00022f f034          .dw XT_DOBRANCH
000230 01db          .dw XT_LRESOLVE
000231 f025          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
000232 0002          .dw $0002
000233 6f64          .db "do"
000234 0228          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000235 f000          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
000236 019c          .dw XT_COMPILE
000237 f2ac          .dw XT_DODO
000238 01d8          .dw XT_LMARK
000239 f165          .dw XT_ZERO
00023a 0290          .dw XT_TO_L
00023b f025          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
00023c 0004          .dw $0004
00023d 6f6c
00023e 706f          .db "loop"
00023f 0232          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
000240 f000          .dw DO_COLON
                 PFA_LOOP:
                 .endif
000241 019c          .dw XT_COMPILE
000242 f2da          .dw XT_DOLOOP
000243 0277          .dw XT_ENDLOOP
000244 f025          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
000245 0005          .dw $0005
000246 6c2b
000247 6f6f
000248 0070          .db "+loop",0
000249 023c          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
00024a f000          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
00024b 019c          .dw XT_COMPILE
00024c f2cb          .dw XT_DOPLUSLOOP
00024d 0277          .dw XT_ENDLOOP
00024e f025          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
00024f 0005         .dw $0005
000250 656c
000251 7661
000252 0065         .db "leave",0
000253 0245         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
000254 f000          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
000255 019c
000256 f2e5          .DW XT_COMPILE,XT_UNLOOP
000257 01e4
000258 0290
000259 f025          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
00025a 0003          .dw $0003
00025b 643f
00025c 006f          .db "?do",0
00025d 024f          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
00025e f000          .dw DO_COLON
                 PFA_QDO:
                 .endif
00025f 019c          .dw XT_COMPILE
000260 0266          .dw XT_QDOCHECK
000261 01ec          .dw XT_IF
000262 0235          .dw XT_DO
000263 f0d5          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
000264 0290          .dw XT_TO_L    ; then follows at the end.
000265 f025          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
000266 f000          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
000267 f560          .dw XT_2DUP
000268 f3f0          .dw XT_EQUAL
000269 f0c2          .dw XT_DUP
00026a f110          .dw XT_TO_R
00026b f03e          .dw XT_DOCONDBRANCH
00026c 026e          DEST(PFA_QDOCHECK1)
00026d f569          .dw XT_2DROP
                 PFA_QDOCHECK1:
00026e f107          .dw XT_R_FROM
00026f f20e          .dw XT_INVERT
000270 f025          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
000271 ff07          .dw $ff07
000272 6e65
000273 6c64
000274 6f6f
000275 0070          .db "endloop",0
000276 025a          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
000277 f000          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
000278 01db              .DW XT_LRESOLVE
000279 0284
00027a f0ca
00027b f03e      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
00027c 0280               DEST(LOOP2)
00027d 0200              .DW XT_THEN
00027e f034      	.dw XT_DOBRANCH
00027f 0279               DEST(LOOP1)
000280 f025      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
000281 ff02          .dw $ff02
000282 3e6c          .db "l>"
000283 0271          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
000284 f000          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
000285 02a3          .dw XT_LP
000286 f08a          .dw XT_FETCH
000287 f08a          .dw XT_FETCH
000288 f045          .dw XT_DOLITERAL
000289 fffe          .dw -2
00028a 02a3          .dw XT_LP
00028b f276          .dw XT_PLUSSTORE
00028c f025          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
00028d ff02          .dw $ff02
00028e 6c3e          .db ">l"
00028f 0281          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
000290 f000          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
000291 f3fc              .dw XT_TWO
000292 02a3      	.dw XT_LP
000293 f276      	.dw XT_PLUSSTORE
000294 02a3      	.dw XT_LP
000295 f08a      	.dw XT_FETCH
000296 f092      	.dw XT_STORE
000297 f025      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
000298 ff03          .dw $ff03
000299 706c
00029a 0030          .db "lp0",0
00029b 028d          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
00029c f080          .dw PFA_DOVALUE1
                 PFA_LP0:
00029d 0052          .dw CFG_LP0
00029e fbca          .dw XT_EDEFERFETCH
00029f fbd4          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
0002a0 ff02          .dw $ff02
0002a1 706c          .db "lp"
0002a2 0298          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
0002a3 f053          .dw PFA_DOVARIABLE
                 PFA_LP:
0002a4 013b          .dw ram_lp
                 
                 .dseg
00013b           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CREATE:
0002a5 ff06          .dw $ff06
0002a6 7263
0002a7 6165
0002a8 6574          .db "create"
0002a9 02a0          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
0002aa f000          .dw DO_COLON
                 PFA_CREATE:
                 .endif
0002ab 016e          .dw XT_DOCREATE
0002ac 02d9          .dw XT_REVEAL
0002ad 019c          .dw XT_COMPILE
0002ae f060          .dw PFA_DOCONSTANT
0002af f025          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
0002b0 ff06          .dw $ff06
0002b1 6568
0002b2 6461
0002b3 7265          .db "header"
0002b4 02a5          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
0002b5 f000          .dw DO_COLON
                 PFA_HEADER:
0002b6 f5a9          .dw XT_DP           ; the new Name Field
0002b7 f110          .dw XT_TO_R
0002b8 f110          .dw XT_TO_R		; ( R: NFA WID )
0002b9 f0c2          .dw XT_DUP    
0002ba f137          .dw XT_GREATERZERO 
0002bb f03e          .dw XT_DOCONDBRANCH
0002bc 02c7          .dw PFA_HEADER1
0002bd f0c2          .dw XT_DUP
0002be f045          .dw XT_DOLITERAL
0002bf ff00          .dw $ff00           ; all flags are off (e.g. immediate)
0002c0 f22d          .dw XT_OR
0002c1 f77a          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
0002c2 f107          .dw XT_R_FROM
0002c3 f366          .dw XT_FETCHE
0002c4 01a7          .dw XT_COMMA
0002c5 f107          .dw XT_R_FROM
0002c6 f025          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
0002c7 f045          .dw XT_DOLITERAL
0002c8 fff0          .dw -16
0002c9 f83c          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
0002ca ff07          .dw $ff07
0002cb 6c77
0002cc 6373
0002cd 706f
0002ce 0065          .db "wlscope",0
0002cf 02b0          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
0002d0 fc29          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
0002d1 004e          .dw CFG_WLSCOPE
0002d2 fbca          .dw XT_EDEFERFETCH
0002d3 fbd4          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REVEAL:
0002d4 ff06          .dw $ff06
0002d5 6572
0002d6 6576
0002d7 6c61          .db "reveal"
0002d8 02ca          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
0002d9 f000          .dw DO_COLON
                 PFA_REVEAL:
                 .endif
0002da 015f
0002db f559
0002dc f08a          .DW XT_NEWEST,XT_CELLPLUS,XT_FETCH ; only if wordlist is in use
0002dd f0ca
0002de f03e          .DW XT_QDUP,XT_DOCONDBRANCH
0002df 02e4          DEST(REVEAL1)
0002e0 015f
0002e1 f08a
0002e2 f0d5
0002e3 f342          .DW XT_NEWEST,XT_FETCH,XT_SWAP,XT_STOREE
                 ;    .DW XT_ZERO,XT_NEWEST,XT_CELLPLUS,XT_STORE ; clean wordlist entry
                 REVEAL1:
0002e4 f025          .DW XT_EXIT
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
0002e5 0005          .dw $0005
0002e6 6f64
0002e7 7365
0002e8 003e          .db "does>",0
0002e9 02d4          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
0002ea f000          .dw DO_COLON
                 PFA_DOES:
0002eb 019c          .dw XT_COMPILE
0002ec 02fd          .dw XT_DODOES
0002ed 019c          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
0002ee 940e          .dw $940e       ; the address of this compiled
0002ef 019c          .dw XT_COMPILE  ; code will replace the XT of the 
0002f0 02f2          .dw DO_DODOES   ; word that CREATE created
0002f1 f025          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
0002f2 939a
0002f3 938a          savetos
0002f4 01cb          movw tosl, wl
0002f5 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
0002f6 917f          pop wh
0002f7 916f          pop wl
                 
0002f8 93bf          push XH
0002f9 93af          push XL
0002fa 01db          movw XL, wl
0002fb 940c f004     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
0002fd f000          .dw DO_COLON
                 PFA_DODOES:
0002fe f107          .dw XT_R_FROM
0002ff 015f          .dw XT_NEWEST
000300 f559          .dw XT_CELLPLUS
000301 f08a          .dw XT_FETCH
000302 f366          .dw XT_FETCHE
000303 fc94          .dw XT_NFA2CFA
000304 f37a          .dw XT_STOREI
000305 f025          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
000306 ff01          .dw $ff01
000307 003a          .db ":",0
000308 02e5          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000309 f000          .dw DO_COLON
                 PFA_COLON:
                 .endif
00030a 016e          .dw XT_DOCREATE
00030b 0314          .dw XT_COLONNONAME
00030c f0ea          .dw XT_DROP
00030d f025          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
00030e ff07          .dw $ff07
00030f 6e3a
000310 6e6f
000311 6d61
000312 0065          .db ":noname",0
000313 0306          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000314 f000          .dw DO_COLON
                 PFA_COLONNONAME:
000315 f5a9          .dw XT_DP
000316 f0c2          .dw XT_DUP
000317 0166          .dw XT_LATEST
000318 f092          .dw XT_STORE
                 
000319 019c          .dw XT_COMPILE
00031a f000          .dw DO_COLON
                 
00031b 0329          .dw XT_RBRACKET
00031c f025          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
00031d 0001          .dw $0001
00031e 003b          .db $3b,0
00031f 030e          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
000320 f000          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
000321 019c          .dw XT_COMPILE
000322 f025          .dw XT_EXIT
000323 0331          .dw XT_LBRACKET
000324 02d9          .dw XT_REVEAL
000325 f025          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
000326 ff01          .dw $ff01
000327 005d          .db "]",0
000328 031d          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000329 f000          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
00032a f3f7          .dw XT_ONE
00032b f546          .dw XT_STATE
00032c f092          .dw XT_STORE
00032d f025          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
00032e 0001          .dw $0001
00032f 005b          .db "[",0
000330 0326          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
000331 f000          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
000332 f165          .dw XT_ZERO
000333 f546          .dw XT_STATE
000334 f092          .dw XT_STORE
000335 f025          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
000336 ff08          .dw $ff08
000337 6176
000338 6972
000339 6261
00033a 656c          .db "variable"
00033b 032e          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
00033c f000          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
00033d f5ba          .dw XT_HERE
00033e 0348          .dw XT_CONSTANT
00033f f3fc          .dw XT_TWO
000340 f5c3          .dw XT_ALLOT
000341 f025          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
000342 ff08          .dw $ff08
000343 6f63
000344 736e
000345 6174
000346 746e          .db "constant"
000347 0336          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000348 f000          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
000349 016e          .dw XT_DOCREATE
00034a 02d9          .dw XT_REVEAL
00034b 019c          .dw XT_COMPILE
00034c f053          .dw PFA_DOVARIABLE
00034d 01a7          .dw XT_COMMA
00034e f025          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
00034f ff04          .dw $ff04
000350 7375
000351 7265          .db "user"
000352 0342          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
000353 f000          .dw DO_COLON
                 PFA_USER:
000354 016e          .dw XT_DOCREATE
000355 02d9          .dw XT_REVEAL
                 
000356 019c          .dw XT_COMPILE
000357 f066          .dw PFA_DOUSER
000358 01a7          .dw XT_COMMA
000359 f025          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECURSE:
00035a 0007          .dw $0007
00035b 6572
00035c 7563
00035d 7372
00035e 0065          .db "recurse",0
00035f 034f          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
000360 f000          .dw DO_COLON
                 PFA_RECURSE:
                 .endif
000361 0166          .dw XT_LATEST
000362 f08a          .dw XT_FETCH
000363 01a7          .dw XT_COMMA
000364 f025          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
000365 ff09          .dw $ff09
000366 6d69
000367 656d
000368 6964
000369 7461
00036a 0065          .db "immediate",0
00036b 035a          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
00036c f000          .dw DO_COLON
                 PFA_IMMEDIATE:
00036d 040e          .dw XT_GET_CURRENT
00036e f366          .dw XT_FETCHE
00036f f0c2          .dw XT_DUP
000370 f3d8          .dw XT_FETCHI
000371 f045          .dw XT_DOLITERAL
000372 7fff          .dw $7fff
000373 f224          .dw XT_AND
000374 f0d5          .dw XT_SWAP
000375 f37a          .dw XT_STOREI
000376 f025          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
000377 0006          .dw $0006
000378 635b
000379 6168
00037a 5d72          .db "[char]"
00037b 0365          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
00037c f000          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
00037d 019c          .dw XT_COMPILE
00037e f045          .dw XT_DOLITERAL
00037f f8ea          .dw XT_CHAR
000380 01a7          .dw XT_COMMA
000381 f025          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
000382 0006          .dw $0006
000383 6261
000384 726f
000385 2274          .db "abort",'"'
000386 0377          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
000387 f000          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
000388 f4bc          .dw XT_SQUOTE
000389 019c          .dw XT_COMPILE
00038a 0399          .dw XT_QABORT
00038b f025          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
00038c ff05          .dw $ff05
00038d 6261
00038e 726f
00038f 0074          .db "abort",0
000390 0382          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
000391 f000          .dw DO_COLON
                 PFA_ABORT:
                 .endif
000392 f15c          .dw XT_TRUE
000393 f83c          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
000394 ff06          .dw $ff06
000395 613f
000396 6f62
000397 7472          .db "?abort"
000398 038c          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
000399 f000          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
00039a f0f2
00039b f03e              .DW XT_ROT,XT_DOCONDBRANCH
00039c 039f              DEST(QABO1)
00039d f79b
00039e 0391              .DW XT_ITYPE,XT_ABORT
00039f f569
0003a0 f025      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
0003a1 ff09          .dw $ff09
0003a2 6567
0003a3 2d74
0003a4 7473
0003a5 6361
0003a6 006b          .db "get-stack",0
0003a7 0394          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
0003a8 f000          .dw DO_COLON
                 .endif
0003a9 f0c2          .dw XT_DUP
0003aa f559          .dw XT_CELLPLUS
0003ab f0d5          .dw XT_SWAP
0003ac f366          .dw XT_FETCHE
0003ad f0c2          .dw XT_DUP
0003ae f110          .dw XT_TO_R
0003af f165          .dw XT_ZERO
0003b0 f0d5          .dw XT_SWAP    ; go from bigger to smaller addresses
0003b1 0266          .dw XT_QDOCHECK
0003b2 f03e          .dw XT_DOCONDBRANCH
0003b3 03bf          DEST(PFA_N_FETCH_E2)
0003b4 f2ac          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
0003b5 f2bd          .dw XT_I
0003b6 f246          .dw XT_1MINUS
0003b7 f553          .dw XT_CELLS ; ( -- ee-addr i*2 )
0003b8 f0e0          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
0003b9 f1ae          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
0003ba f366          .dw XT_FETCHE ;( -- ee-addr item_i )
0003bb f0d5          .dw XT_SWAP   ;( -- item_i ee-addr )
0003bc f15c          .dw XT_TRUE  ; shortcut for -1
0003bd f2cb          .dw XT_DOPLUSLOOP
0003be 03b5          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
0003bf f569          .dw XT_2DROP
0003c0 f107          .dw XT_R_FROM
0003c1 f025          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
0003c2 ff09          .dw $ff09
0003c3 6573
0003c4 2d74
0003c5 7473
0003c6 6361
0003c7 006b          .db "set-stack",0
0003c8 03a1          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
0003c9 f000          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
0003ca f0e0          .dw XT_OVER
0003cb f130          .dw XT_ZEROLESS
0003cc f03e          .dw XT_DOCONDBRANCH
0003cd 03d1          DEST(PFA_SET_STACK0)
0003ce f045          .dw XT_DOLITERAL
0003cf fffc          .dw -4
0003d0 f83c          .dw XT_THROW
                 PFA_SET_STACK0:
0003d1 f560          .dw XT_2DUP
0003d2 f342          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
0003d3 f0d5          .dw XT_SWAP    
0003d4 f165          .dw XT_ZERO
0003d5 0266          .dw XT_QDOCHECK
0003d6 f03e          .dw XT_DOCONDBRANCH
0003d7 03de          DEST(PFA_SET_STACK2)
0003d8 f2ac          .dw XT_DODO
                 PFA_SET_STACK1:
0003d9 f559          .dw XT_CELLPLUS ; ( -- i_x e-addr )
0003da f571          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
0003db f342          .dw XT_STOREE
0003dc f2da          .dw XT_DOLOOP
0003dd 03d9          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
0003de f0ea          .dw XT_DROP
0003df f025          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
0003e0 ff09          .dw $ff09
0003e1 616d
0003e2 2d70
0003e3 7473
0003e4 6361
0003e5 006b          .db "map-stack",0
0003e6 03c2          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
0003e7 f000          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
0003e8 f0c2          .dw XT_DUP
0003e9 f559          .dw XT_CELLPLUS
0003ea f0d5          .dw XT_SWAP
0003eb f366          .dw XT_FETCHE
0003ec f553          .dw XT_CELLS
0003ed fd85          .dw XT_BOUNDS
0003ee 0266          .dw XT_QDOCHECK
0003ef f03e          .dw XT_DOCONDBRANCH
0003f0 0403          DEST(PFA_MAPSTACK3)
0003f1 f2ac          .dw XT_DODO
                 PFA_MAPSTACK1:
0003f2 f2bd            .dw XT_I
0003f3 f366            .dw XT_FETCHE   ; -- i*x XT id
0003f4 f0d5            .dw XT_SWAP
0003f5 f110            .dw XT_TO_R
0003f6 f117            .dw XT_R_FETCH
0003f7 f02f            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
0003f8 f0ca            .dw XT_QDUP
0003f9 f03e            .dw XT_DOCONDBRANCH
0003fa 03ff            DEST(PFA_MAPSTACK2)
0003fb f107               .dw XT_R_FROM
0003fc f0ea               .dw XT_DROP
0003fd f2e5               .dw XT_UNLOOP
0003fe f025               .dw XT_EXIT
                 PFA_MAPSTACK2:
0003ff f107            .dw XT_R_FROM
000400 f3fc            .dw XT_TWO
000401 f2cb            .dw XT_DOPLUSLOOP
000402 03f2            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
000403 f0ea          .dw XT_DROP
000404 f165          .dw XT_ZERO
000405 f025          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ; ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000406 ff0b          .dw $ff0b
000407 6567
000408 2d74
000409 7563
00040a 7272
00040b 6e65
00040c 0074          .db "get-current",0
00040d 03e0          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
00040e f000          .dw DO_COLON
                 PFA_GET_CURRENT:
00040f f045          .dw XT_DOLITERAL
000410 0058          .dw CFG_CURRENT
000411 f366          .dw XT_FETCHE
000412 f025          .dw XT_EXIT
                 .include "words/cfg-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CFG_ORDER:
000413 ff09          .dw $ff09
000414 6663
000415 2d67
000416 726f
000417 6564
000418 0072          .db "cfg-order",0
000419 0406          .dw VE_HEAD
                     .set VE_HEAD = VE_CFG_ORDER
                 XT_CFG_ORDER:
00041a f053          .dw PFA_DOVARIABLE
                 PFA_CFG_ORDER:
                 .endif
00041b 005c          .dw CFG_ORDERLISTLEN
                 .include "words/cfg-recognizer.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CFG_RECOGNIZER:
00041c ff08          .dw $ff08
00041d 6663
00041e 2d67
00041f 6572
000420 7363          .db "cfg-recs"
000421 0413          .dw VE_HEAD
                     .set VE_HEAD = VE_CFG_RECOGNIZER
                 XT_CFG_RECOGNIZER:
000422 f053          .dw PFA_DOVARIABLE
                 PFA_CFG_RECOGNIZER:
                 .endif
000423 006e          .dw CFG_RECOGNIZERLISTLEN
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000424 ff07          .dw $ff07
000425 6f63
000426 706d
000427 7261
000428 0065          .db "compare",0
000429 041c          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
00042a 042b          .dw PFA_COMPARE
                 PFA_COMPARE:
00042b 93bf          push xh
00042c 93af          push xl
00042d 018c          movw temp0, tosl
00042e 9189
00042f 9199          loadtos
000430 01dc          movw xl, tosl
000431 9189
000432 9199          loadtos
000433 019c          movw temp2, tosl
000434 9189
000435 9199          loadtos
000436 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000437 90ed          ld temp4, X+
000438 90f1          ld temp5, Z+
000439 14ef          cp temp4, temp5
00043a f451          brne PFA_COMPARE_NOTEQUAL
00043b 950a          dec temp0
00043c f019          breq PFA_COMPARE_ENDREACHED2
00043d 952a          dec temp2
00043e f7c1          brne PFA_COMPARE_LOOP
00043f c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000440 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000441 2b02          or temp0, temp2
000442 f411          brne PFA_COMPARE_CHECKLASTCHAR
000443 2788          clr tosl
000444 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000445 ef8f          ser tosl
000446 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000447 2f98          mov tosh, tosl
000448 91af          pop xl
000449 91bf          pop xh
00044a 940c f004     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
00044c ff07         .dw $ff07
00044d 666e
00044e 3e61
00044f 666c
000450 0061         .db "nfa>lfa",0
000451 0424         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000452 f000          .dw DO_COLON
                 PFA_NFA2LFA:
000453 fc88          .dw XT_NAME2STRING
000454 f240          .dw XT_1PLUS
000455 f215          .dw XT_2SLASH
000456 f1ae          .dw XT_PLUS
000457 f025          .dw XT_EXIT
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; This file contains definitions which are either
                 ; optional or application specific. They are placed
                 ; in the RWW flash section.
                 
                 ; The file dict/compiler2.inc contains a number of
                 ; non-essential words with compiler functionality.
                 ; It is recoomended but not strictly necessairy
                 ; to include it. It is already included by default
                 ; on atmegas with 8k boot loader sections, but it is
                 ; safe to include this file twice.
                 
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
000458 ff0b          .dw $ff0b
000459 6573
00045a 2d74
00045b 7563
00045c 7272
00045d 6e65
00045e 0074          .db "set-current",0
00045f 044c          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
000460 f000          .dw DO_COLON
                 PFA_SET_CURRENT:
000461 f045          .dw XT_DOLITERAL
000462 0058          .dw CFG_CURRENT
000463 f342          .dw XT_STOREE
000464 f025          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
000465 ff08          .dw $ff08
000466 6f77
000467 6472
000468 696c
000469 7473          .db "wordlist"
00046a 0458          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
00046b f000          .dw DO_COLON
                 PFA_WORDLIST:
00046c f5b2          .dw XT_EHERE
00046d f165          .dw XT_ZERO
00046e f0e0          .dw XT_OVER
00046f f342          .dw XT_STOREE
000470 f0c2          .dw XT_DUP
000471 f559          .dw XT_CELLPLUS
000472 fbaf          .dw XT_DOTO
000473 f5b3          .dw PFA_EHERE
000474 f025          .dw XT_EXIT
                 
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTHWORDLIST:
000475 ff0e          .dw $ff0e
000476 6f66
000477 7472
000478 2d68
000479 6f77
00047a 6472
00047b 696c
00047c 7473          .db "forth-wordlist"
00047d 0465          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHWORDLIST
                 XT_FORTHWORDLIST:
00047e f053          .dw PFA_DOVARIABLE
                 PFA_FORTHWORDLIST:
00047f 005a          .dw CFG_FORTHWORDLIST
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000480 ff04          .dw $ff04
000481 6f63
000482 6564          .db "code"
000483 0475          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
000484 f000          .dw DO_COLON
                 PFA_CODE:
000485 016e          .dw XT_DOCREATE
000486 02d9          .dw XT_REVEAL
000487 f5a9          .dw XT_DP
000488 fbc1          .dw XT_ICELLPLUS
000489 01a7          .dw XT_COMMA
00048a f025          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
00048b ff08          .dw $ff08
00048c 6e65
00048d 2d64
00048e 6f63
00048f 6564          .db "end-code"
000490 0480          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000491 f000          .dw DO_COLON
                 PFA_ENDCODE:
000492 019c          .dw XT_COMPILE
000493 940c          .dw $940c
000494 019c          .dw XT_COMPILE
000495 f004          .dw DO_NEXT
000496 f025          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
000497 ff08          .dw $ff08
000498 6d28
000499 7261
00049a 656b
00049b 2972          .db "(marker)"
00049c 048b          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
00049d f080          .dw PFA_DOVALUE1
                 PFA_MARKER:
00049e 007a          .dw EE_MARKER
00049f fbca          .dw XT_EDEFERFETCH
0004a0 fbd4          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
0004a1 0008          .dw $0008
0004a2 6f70
0004a3 7473
0004a4 6f70
0004a5 656e          .db "postpone"
0004a6 0497          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
0004a7 f000          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
0004a8 f9b9          .dw XT_PARSENAME
0004a9 fad9          .dw XT_FORTHRECOGNIZER
0004aa fae4          .dw XT_RECOGNIZE
0004ab f0c2          .dw XT_DUP
0004ac f110          .dw XT_TO_R
0004ad fbc1          .dw XT_ICELLPLUS
0004ae fbc1          .dw XT_ICELLPLUS
0004af f3d8          .dw XT_FETCHI
0004b0 f02f          .dw XT_EXECUTE
0004b1 f107          .dw XT_R_FROM
0004b2 fbc1          .dw XT_ICELLPLUS
0004b3 f3d8          .dw XT_FETCHI
0004b4 01a7          .dw XT_COMMA
0004b5 f025          .dw XT_EXIT
                 .endif
                 
                 ; turnkey is always needed and application specific
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
0004b6 ff0b          .dw $ff0b
0004b7 7061
0004b8 6c70
0004b9 7574
0004ba 6e72
0004bb 656b
0004bc 0079          .db "applturnkey",0
0004bd 04a1          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
0004be f000          .dw DO_COLON
                 PFA_APPLTURNKEY:
0004bf 00da          .dw XT_USART
                 
                 .if WANT_INTERRUPTS == 1
0004c0 fdac          .dw XT_INTON
                 .endif
0004c1 fb7a          .dw XT_DOT_VER
0004c2 f025          .dw XT_EXIT
                 
                 ; the command .s has many flavors. the one in the
                 ; core directory prints the TOS on the *left* hand side.
                 ; lib/tools/dot-s.frt has a .s for the opposite.
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTS:
0004c3 ff02          .dw $ff02
0004c4 732e          .db ".s"
0004c5 04b6          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
0004c6 f000          .dw DO_COLON
                 PFA_DOTS:
                 .endif
0004c7 faae          .dw XT_DEPTH
0004c8 f479          .dw XT_UDOT
0004c9 f7dd          .dw XT_SPACE
0004ca faae          .dw XT_DEPTH
0004cb f165          .dw XT_ZERO
0004cc 0266          .dw XT_QDOCHECK
0004cd f03e          .dw XT_DOCONDBRANCH
0004ce 04d5          DEST(PFA_DOTS2)
0004cf f2ac          .dw XT_DODO
                 PFA_DOTS1:
0004d0 f2bd          .dw XT_I
0004d1 f4aa          .dw XT_PICK
0004d2 f479          .dw XT_UDOT
0004d3 f2da          .dw XT_DOLOOP
0004d4 04d0          DEST(PFA_DOTS1)
                 PFA_DOTS2:
0004d5 f025          .dw XT_EXIT
                 
                 ; print the date and time the amforth hex files are created
                 ; comment the next line if not needed. Depends on a make/ant
                 ; rule to create the actual include file from a template.
                 .include "words/build-info.asm"
                 
                 ; R( -- )
                 ; Build Info as flash string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BUILDINFO:
0004d6 ff0a          .dw $ff0a
0004d7 7562
0004d8 6c69
0004d9 2d64
0004da 6e69
0004db 6f66          .db "build-info"
0004dc 04c3          .dw VE_HEAD
                     .set VE_HEAD = VE_BUILDINFO
                 XT_BUILDINFO:
0004dd f000          .dw DO_COLON
                 PFA_BUILDINFO:
0004de f768          .dw XT_DOSLITERAL
0004df 0015          .dw 21
0004e0 634f
0004e1 2074
0004e2 3831
0004e3 202c
0004e4 3032
0004e5 3032
0004e6 3120
0004e7 3a38
0004e8 3232
0004e9 343a
words/build-info.asm(24): warning: .cseg .db misalignment - padding zero byte
0004ea 0035          .db "Oct 18, 2020 18:22:45"
                 .endif
0004eb f025          .dw XT_EXIT
                 
                 ; now add words which are either not included by default but
                 ; part of amforth (e.g. words for counted strings) or add
                 ; your own ones (from the words directory in this one)
                 .include "words/place.asm"
                 
                 ; String
                 ; copy string as counted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLACE:
0004ec ff05          .dw $ff05
0004ed 6c70
0004ee 6361
0004ef 0065          .db "place",0
0004f0 04d6          .dw VE_HEAD
                     .set VE_HEAD = VE_PLACE
                 XT_PLACE:
0004f1 f000          .dw DO_COLON
                 PFA_PLACE:
                 .endif
0004f2 f560          .dw XT_2DUP        ; ( -- addr1 len1 addr2 len1 addr2)
0004f3 f09e          .dw XT_CSTORE      ; ( -- addr1 len1 addr2)
0004f4 f240          .dw XT_1PLUS       ; ( -- addr1 len1 addr2')
0004f5 f0d5          .dw XT_SWAP        ; ( -- addr1 addr2' len1)
0004f6 fd13          .dw XT_CMOVE       ; ( --- )
0004f7 f025          .dw XT_EXIT
                 .include "words/word.asm"
                 
                 ; Tools
                 ; skip leading delimiter character and parse SOURCE until the next delimiter. copy the word to HERE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WORD:
0004f8 ff04          .dw $ff04
0004f9 6f77
0004fa 6472          .db "word"
0004fb 04ec          .dw VE_HEAD
                     .set VE_HEAD = VE_WORD
                 XT_WORD:
0004fc f000          .dw DO_COLON
                 PFA_WORD:
                 .endif
0004fd f9bd          .dw XT_SKIPSCANCHAR ; factor for both parse/word
                     ; move to HERE
0004fe f5ba          .dw XT_HERE
0004ff 04f1          .dw XT_PLACE
                     ; leave result
000500 f5ba          .dw XT_HERE
000501 f025          .dw XT_EXIT
                 
                 .set DPSTART = pc
                 .if(pc>AMFORTH_RO_SEG)
                 .endif
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
00f000 93bf          push XH
00f001 93af          push XL          ; PUSH IP
00f002 01db          movw XL, wl
00f003 9611          adiw xl, 1
                 DO_NEXT:
                 .if WANT_INTERRUPTS == 1
00f004 14b2          cp isrflag, zerol
00f005 f499          brne DO_INTERRUPT
                 .endif
00f006 01fd          movw zl, XL        ; READ IP
00f007 2755
00f008 0fee
00f009 1fff
00f00a 1f55
00f00b bf5b
00f00c 9167
00f00d 9177          readflashcell wl, wh
00f00e 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00f00f 01fb          movw zl, wl
00f010 2755
00f011 0fee
00f012 1fff
00f013 1f55
00f014 bf5b
00f015 9107
00f016 9117          readflashcell temp0,temp1
00f017 01f8          movw zl, temp0
00f018 9409          ijmp
                 
                 .if WANT_INTERRUPTS == 1
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
00f019 939a
00f01a 938a          savetos
00f01b 2d8b          mov tosl, isrflag
00f01c 24bb          clr isrflag
00f01d 2799          clr tosh
00f01e ed68          ldi wl, LOW(XT_ISREXEC)
00f01f ef7d          ldi wh, HIGH(XT_ISREXEC)
00f020 cfee          rjmp DO_EXECUTE
                 .endif
                 .include "dict/nrww.inc"
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
00f021 ff04          .dw $ff04
00f022 7865
00f023 7469          .db "exit"
00f024 04f8          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00f025 f026          .dw PFA_EXIT
                 PFA_EXIT:
00f026 91af          pop XL
00f027 91bf          pop XH
00f028 cfdb          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
00f029 ff07          .dw $ff07
00f02a 7865
00f02b 6365
00f02c 7475
00f02d 0065          .db "execute",0
00f02e f021          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
00f02f f030          .dw PFA_EXECUTE
                 PFA_EXECUTE:
00f030 01bc          movw wl, tosl
00f031 9189
00f032 9199          loadtos
00f033 cfdb          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
00f034 f035          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00f035 01fd          movw zl, XL
00f036 2755
00f037 0fee
00f038 1fff
00f039 1f55
00f03a bf5b
00f03b 91a7
00f03c 91b7          readflashcell XL,XH
00f03d cfc6          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
00f03e f03f          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
00f03f 2b98          or tosh, tosl
00f040 9189
00f041 9199          loadtos
00f042 f391          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
00f043 9611          adiw XL, 1
00f044 cfbf          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
00f045 f046          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
00f046 939a
00f047 938a          savetos
00f048 01fd          movw zl, xl
00f049 2755
00f04a 0fee
00f04b 1fff
00f04c 1f55
00f04d bf5b
00f04e 9187
00f04f 9197          readflashcell tosl,tosh
00f050 9611          adiw xl, 1
00f051 cfb2          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
00f052 f053          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
00f053 939a
00f054 938a          savetos
00f055 01fb          movw zl, wl
00f056 9631          adiw zl,1
00f057 2755
00f058 0fee
00f059 1fff
00f05a 1f55
00f05b bf5b
00f05c 9187
00f05d 9197          readflashcell tosl,tosh
00f05e cfa5          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00f05f f060          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00f060 939a
00f061 938a          savetos
00f062 01cb          movw tosl, wl
00f063 9601          adiw tosl, 1
00f064 cf9f          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
00f065 f066          .dw PFA_DOUSER
                 PFA_DOUSER:
00f066 939a
00f067 938a          savetos
00f068 01fb          movw zl, wl
00f069 9631          adiw zl, 1
00f06a 2755
00f06b 0fee
00f06c 1fff
00f06d 1f55
00f06e bf5b
00f06f 9187
00f070 9197          readflashcell tosl,tosh
00f071 0d84          add tosl, upl
00f072 1d95          adc tosh, uph
00f073 cf90          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
00f074 ff07          .dw $ff07
00f075 7628
00f076 6c61
00f077 6575
00f078 0029          .db "(value)", 0
00f079 f029          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
00f07a f000          .dw DO_COLON
                 PFA_DOVALUE:
00f07b 016e          .dw XT_DOCREATE
00f07c 02d9          .dw XT_REVEAL
00f07d 019c          .dw XT_COMPILE
00f07e f080          .dw PFA_DOVALUE1
00f07f f025          .dw XT_EXIT
                 PFA_DOVALUE1:
00f080 940e 02f2     call_ DO_DODOES
00f082 f0c2          .dw XT_DUP
00f083 fbc1          .dw XT_ICELLPLUS
00f084 f3d8          .dw XT_FETCHI
00f085 f02f          .dw XT_EXECUTE
00f086 f025          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
00f087 ff01          .dw $ff01
00f088 0040          .db "@",0
00f089 f074          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
00f08a f08b          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
00f08b 01fc          movw zl, tosl
                     ; low byte is read before the high byte
00f08c 9181          ld tosl, z+
00f08d 9191          ld tosh, z+
00f08e cf75          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
00f08f ff01          .dw $ff01
00f090 0021          .db "!",0
00f091 f087          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00f092 f093          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00f093 01fc          movw zl, tosl
00f094 9189
00f095 9199          loadtos
                     ; the high byte is written before the low byte
00f096 8391          std Z+1, tosh
00f097 8380          std Z+0, tosl
00f098 9189
00f099 9199          loadtos
00f09a cf69          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
00f09b ff02          .dw $ff02
00f09c 2163          .db "c!"
00f09d f08f          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
00f09e f09f          .dw PFA_CSTORE
                 PFA_CSTORE:
00f09f 01fc          movw zl, tosl
00f0a0 9189
00f0a1 9199          loadtos
00f0a2 8380          st Z, tosl
00f0a3 9189
00f0a4 9199          loadtos
00f0a5 cf5e          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
00f0a6 ff02          .dw $ff02
00f0a7 4063          .db "c@"
00f0a8 f09b          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
00f0a9 f0aa          .dw PFA_CFETCH
                 PFA_CFETCH:
00f0aa 01fc          movw zl, tosl
00f0ab 2799          clr tosh
00f0ac 8180          ld tosl, Z
00f0ad cf56          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
00f0ae ff02          .dw $ff02
00f0af 7540          .db "@u"
00f0b0 f0a6          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00f0b1 f000          .dw DO_COLON
                 PFA_FETCHU:
00f0b2 f313          .dw XT_UP_FETCH
00f0b3 f1ae          .dw XT_PLUS
00f0b4 f08a          .dw XT_FETCH
00f0b5 f025          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
00f0b6 ff02          .dw $ff02
00f0b7 7521          .db "!u"
00f0b8 f0ae          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
00f0b9 f000          .dw DO_COLON
                 PFA_STOREU:
00f0ba f313          .dw XT_UP_FETCH
00f0bb f1ae          .dw XT_PLUS
00f0bc f092          .dw XT_STORE
00f0bd f025          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
00f0be ff03          .dw $ff03
00f0bf 7564
00f0c0 0070          .db "dup",0
00f0c1 f0b6          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
00f0c2 f0c3          .dw PFA_DUP
                 PFA_DUP:
00f0c3 939a
00f0c4 938a          savetos
00f0c5 cf3e          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
00f0c6 ff04          .dw $ff04
00f0c7 643f
00f0c8 7075          .db "?dup"
00f0c9 f0be          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
00f0ca f0cb          .dw PFA_QDUP
                 PFA_QDUP:
00f0cb 2f08          mov temp0, tosl
00f0cc 2b09          or temp0, tosh
00f0cd f011          breq PFA_QDUP1
00f0ce 939a
00f0cf 938a          savetos
                 PFA_QDUP1:
00f0d0 cf33          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
00f0d1 ff04          .dw $ff04
00f0d2 7773
00f0d3 7061          .db "swap"
00f0d4 f0c6          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
00f0d5 f0d6          .dw PFA_SWAP
                 PFA_SWAP:
00f0d6 018c          movw temp0, tosl
00f0d7 9189
00f0d8 9199          loadtos
00f0d9 931a          st -Y, temp1
00f0da 930a          st -Y, temp0
00f0db cf28          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
00f0dc ff04          .dw $ff04
00f0dd 766f
00f0de 7265          .db "over"
00f0df f0d1          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
00f0e0 f0e1          .dw PFA_OVER
                 PFA_OVER:
00f0e1 939a
00f0e2 938a          savetos
00f0e3 818a          ldd tosl, Y+2
00f0e4 819b          ldd tosh, Y+3
                 
00f0e5 cf1e          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
00f0e6 ff04          .dw $ff04
00f0e7 7264
00f0e8 706f          .db "drop"
00f0e9 f0dc          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
00f0ea f0eb          .dw PFA_DROP
                 PFA_DROP:
00f0eb 9189
00f0ec 9199          loadtos
00f0ed cf16          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
00f0ee ff03          .dw $ff03
00f0ef 6f72
00f0f0 0074          .db "rot",0
00f0f1 f0e6          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
00f0f2 f0f3          .dw PFA_ROT
                 PFA_ROT:
00f0f3 018c          movw temp0, tosl
00f0f4 9129          ld temp2, Y+
00f0f5 9139          ld temp3, Y+ 
00f0f6 9189
00f0f7 9199          loadtos
                         
00f0f8 933a          st -Y, temp3
00f0f9 932a          st -Y, temp2
00f0fa 931a          st -Y, temp1
00f0fb 930a          st -Y, temp0
                 
00f0fc cf07          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
00f0fd ff03          .dw $ff03
00f0fe 696e
00f0ff 0070          .db "nip",0
00f100 f0ee          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
00f101 f102          .dw PFA_NIP
                 PFA_NIP:
00f102 9622          adiw yl, 2
00f103 cf00          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
00f104 ff02          .dw $ff02
00f105 3e72          .db "r>"
00f106 f0fd          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
00f107 f108          .dw PFA_R_FROM
                 PFA_R_FROM:
00f108 939a
00f109 938a          savetos
00f10a 918f          pop tosl
00f10b 919f          pop tosh
00f10c cef7          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
00f10d ff02          .dw $ff02
00f10e 723e          .db ">r"
00f10f f104          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
00f110 f111          .dw PFA_TO_R
                 PFA_TO_R:
00f111 939f          push tosh
00f112 938f          push tosl
00f113 cfd7          jmp_ PFA_DROP
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
00f114 ff02          .dw $ff02
00f115 4072          .db "r@"
00f116 f10d          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
00f117 f118          .dw PFA_R_FETCH
                 PFA_R_FETCH:
00f118 939a
00f119 938a          savetos
00f11a 918f          pop tosl
00f11b 919f          pop tosh
00f11c 939f          push tosh
00f11d 938f          push tosl
00f11e cee5          jmp_ DO_NEXT
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
00f11f ff02          .dw $ff02
00f120 3e3c          .db "<>"
00f121 f114          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
00f122 f000          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
00f123 f3f0
00f124 f129
00f125 f025          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
00f126 ff02          .dw $ff02
00f127 3d30          .db "0="
00f128 f11f          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
00f129 f12a          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
00f12a 2b98          or tosh, tosl
00f12b f5e1          brne PFA_ZERO1
00f12c c032          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
00f12d ff02          .dw $ff02
00f12e 3c30          .db "0<"
00f12f f126          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
00f130 f131          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
00f131 fd97          sbrc tosh,7
00f132 c02c          rjmp PFA_TRUE1
00f133 c034          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
00f134 ff02          .dw $ff02
00f135 3e30          .db "0>"
00f136 f12d          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
00f137 f138          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
00f138 1582          cp tosl, zerol
00f139 0593          cpc tosh, zeroh
00f13a f16c          brlt PFA_ZERO1
00f13b f161          brbs 1, PFA_ZERO1
00f13c c022          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
00f13d ff03          .dw $ff03
00f13e 3064
00f13f 003e          .db "d0>",0
00f140 f134          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00f141 f142          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
00f142 1593          cp tosh, zeroh
00f143 f03c          brlt PFA_DGREATERZERO_FALSE ; if MSBit is set, d:arg is negative, we are done (false).
00f144 0582          cpc tosl, zerol
00f145 9189
00f146 9199          loadtos
00f147 0582          cpc tosl, zerol
00f148 0593          cpc tosh, zeroh
00f149 f0f1          brbs 1, PFA_ZERO1           ; if all 4 Bytes of d:arg are zero, we are done (false).
00f14a c014          rjmp PFA_TRUE1              ; if we get this far, d:arg was positive! (true)
                 PFA_DGREATERZERO_FALSE:
00f14b 01c1          movw tosl, zerol            ; ZERO
00f14c cfb5          rjmp PFA_NIP                ; NIP
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
00f14d ff03          .dw $ff03
00f14e 3064
00f14f 003c          .db "d0<",0
00f150 f13d          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
00f151 f152          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
00f152 9622          adiw Y,2
00f153 fd97          sbrc tosh,7
00f154 940c f15f     jmp PFA_TRUE1
00f156 940c f168     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
00f158 ff04          .dw $ff04
00f159 7274
00f15a 6575          .db "true"
00f15b f14d          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
00f15c f15d          .dw PFA_TRUE
                 PFA_TRUE:
00f15d 939a
00f15e 938a          savetos
                 PFA_TRUE1:
00f15f ef8f          ser tosl
00f160 ef9f          ser tosh
00f161 cea2          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
00f162 ff01          .dw $ff01
00f163 0030          .db "0",0
00f164 f158          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
00f165 f166          .dw PFA_ZERO
                 PFA_ZERO:
00f166 939a
00f167 938a          savetos
                 PFA_ZERO1:
00f168 01c1          movw tosl, zerol
00f169 ce9a          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
00f16a ff02          .dw $ff02
00f16b 3c75          .db "u<"
00f16c f162          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
00f16d f16e          .dw PFA_ULESS
                 PFA_ULESS:
00f16e 9129          ld temp2, Y+
00f16f 9139          ld temp3, Y+
00f170 1782          cp tosl, temp2
00f171 0793          cpc tosh, temp3
00f172 f3a8          brlo PFA_ZERO1
00f173 f3a1          brbs 1, PFA_ZERO1
00f174 cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
00f175 ff02          .dw $ff02
00f176 3e75          .db "u>"
00f177 f16a          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
00f178 f000          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
00f179 f0d5          .DW XT_SWAP
00f17a f16d          .dw XT_ULESS
00f17b f025          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
00f17c ff01          .dw $ff01
00f17d 003c          .db "<",0
00f17e f175          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
00f17f f180          .dw PFA_LESS
                 PFA_LESS:
00f180 9129          ld temp2, Y+
00f181 9139          ld temp3, Y+
00f182 1728          cp temp2, tosl
00f183 0739          cpc temp3, tosh
                 PFA_LESSDONE:
00f184 f71c          brge PFA_ZERO1
00f185 cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
00f186 ff01          .dw $ff01
00f187 003e          .db ">",0
00f188 f17c          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
00f189 f18a          .dw PFA_GREATER
                 PFA_GREATER:
00f18a 9129          ld temp2, Y+
00f18b 9139          ld temp3, Y+
00f18c 1728          cp temp2, tosl
00f18d 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
00f18e f2cc          brlt PFA_ZERO1
00f18f f2c1          brbs 1, PFA_ZERO1
00f190 cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
00f191 ff04          .dw $ff04
00f192 6f6c
00f193 3267          .db "log2"
00f194 f186          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
00f195 f196          .dw PFA_LOG2
                 PFA_LOG2:
00f196 01fc          movw zl, tosl
00f197 2799          clr tosh
00f198 e180          ldi tosl, 16
                 PFA_LOG2_1:
00f199 958a          dec tosl
00f19a f022          brmi PFA_LOG2_2 ; wrong data
00f19b 0fee          lsl  zl
00f19c 1fff          rol  zh
00f19d f7d8          brcc PFA_LOG2_1
00f19e ce65          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
00f19f 959a          dec tosh
00f1a0 ce63          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
00f1a1 ff01          .dw $ff01
00f1a2 002d          .db "-",0
00f1a3 f191          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
00f1a4 f1a5          .dw PFA_MINUS
                 PFA_MINUS:
00f1a5 9109          ld temp0, Y+
00f1a6 9119          ld temp1, Y+
00f1a7 1b08          sub temp0, tosl
00f1a8 0b19          sbc temp1, tosh
00f1a9 01c8          movw tosl, temp0
00f1aa ce59          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
00f1ab ff01          .dw $ff01
00f1ac 002b          .db "+",0
00f1ad f1a1          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
00f1ae f1af          .dw PFA_PLUS
                 PFA_PLUS:
00f1af 9109          ld temp0, Y+
00f1b0 9119          ld temp1, Y+
00f1b1 0f80          add tosl, temp0
00f1b2 1f91          adc tosh, temp1
00f1b3 ce50          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
00f1b4 ff02          .dw $ff02
00f1b5 2a6d          .db "m*"
00f1b6 f1ab          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
00f1b7 f1b8          .dw PFA_MSTAR
                 PFA_MSTAR:
00f1b8 018c          movw temp0, tosl
00f1b9 9189
00f1ba 9199          loadtos
00f1bb 019c          movw temp2, tosl
                     ; high cell ah*bh
00f1bc 0231          muls temp3, temp1
00f1bd 0170          movw temp4, r0
                     ; low cell  al*bl
00f1be 9f20          mul  temp2, temp0
00f1bf 01c0          movw tosl, r0
                     ; signed ah*bl
00f1c0 0330          mulsu temp3, temp0
00f1c1 08f3          sbc   temp5, zeroh
00f1c2 0d90          add   tosh,  r0
00f1c3 1ce1          adc   temp4, r1
00f1c4 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
00f1c5 0312          mulsu temp1, temp2
00f1c6 08f3          sbc   temp5, zeroh
00f1c7 0d90          add   tosh,  r0
00f1c8 1ce1          adc   temp4, r1
00f1c9 1cf3          adc   temp5, zeroh
                 
00f1ca 939a
00f1cb 938a          savetos
00f1cc 01c7          movw tosl, temp4
00f1cd ce36          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
00f1ce ff06          .dw $ff06
00f1cf 6d75
00f1d0 6d2f
00f1d1 646f          .db "um/mod"
00f1d2 f1b4          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
00f1d3 f1d4          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
00f1d4 017c          movw temp4, tosl
                 
00f1d5 9129          ld temp2, Y+
00f1d6 9139          ld temp3, Y+
                   
00f1d7 9109          ld temp0, Y+
00f1d8 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
00f1d9 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
00f1da 2755          clr temp7
00f1db 0f00          lsl temp0
00f1dc 1f11          rol temp1
00f1dd 1f22          rol temp2
00f1de 1f33          rol temp3
00f1df 1f55          rol temp7
                 
                   ; try subtracting divisor
00f1e0 152e          cp temp2, temp4
00f1e1 053f          cpc temp3, temp5
00f1e2 0552          cpc temp7,zerol
                 
00f1e3 f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
00f1e4 9503          inc temp0
00f1e5 192e          sub temp2, temp4
00f1e6 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
00f1e7 954a          dec  temp6
00f1e8 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
00f1e9 933a          st -Y,temp3
00f1ea 932a          st -Y,temp2
                 
                     ; put quotient on stack
00f1eb 01c8          movw tosl, temp0
00f1ec ce17          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
00f1ed ff03          .dw $ff03
00f1ee 6d75
00f1ef 002a          .db "um*",0
00f1f0 f1ce          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
00f1f1 f1f2          .dw PFA_UMSTAR
                 PFA_UMSTAR:
00f1f2 018c          movw temp0, tosl
00f1f3 9189
00f1f4 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
00f1f5 9f80          mul tosl,temp0
00f1f6 01f0          movw zl, r0
00f1f7 2722          clr temp2
00f1f8 2733          clr temp3
                     ; middle bytes
00f1f9 9f90          mul tosh, temp0
00f1fa 0df0          add zh, r0
00f1fb 1d21          adc temp2, r1
00f1fc 1d33          adc temp3, zeroh
                         
00f1fd 9f81          mul tosl, temp1
00f1fe 0df0          add zh, r0
00f1ff 1d21          adc temp2, r1
00f200 1d33          adc temp3, zeroh
                     
00f201 9f91          mul tosh, temp1
00f202 0d20          add temp2, r0
00f203 1d31          adc temp3, r1
00f204 01cf          movw tosl, zl
00f205 939a
00f206 938a          savetos
00f207 01c9          movw tosl, temp2
00f208 cdfb          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
00f209 ff06          .dw $ff06
00f20a 6e69
00f20b 6576
00f20c 7472          .db "invert"
00f20d f1ed          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
00f20e f20f          .dw PFA_INVERT
                 PFA_INVERT:
00f20f 9580          com tosl
00f210 9590          com tosh
00f211 cdf2          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
00f212 ff02          .dw $ff02
00f213 2f32          .db "2/"
00f214 f209          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
00f215 f216          .dw PFA_2SLASH
                 PFA_2SLASH:
00f216 9595          asr tosh
00f217 9587          ror tosl
00f218 cdeb          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
00f219 ff02          .dw $ff02
00f21a 2a32          .db "2*"
00f21b f212          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
00f21c f21d          .dw PFA_2STAR
                 PFA_2STAR:
00f21d 0f88          lsl tosl
00f21e 1f99          rol tosh
00f21f cde4          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
00f220 ff03          .dw $ff03
00f221 6e61
00f222 0064          .db "and",0
00f223 f219          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
00f224 f225          .dw PFA_AND
                 PFA_AND:
00f225 9109          ld temp0, Y+
00f226 9119          ld temp1, Y+
00f227 2380          and tosl, temp0
00f228 2391          and tosh, temp1
00f229 cdda          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
00f22a ff02          .dw $ff02
00f22b 726f          .db "or"
00f22c f220          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
00f22d f22e          .dw PFA_OR
                 PFA_OR:
00f22e 9109          ld temp0, Y+
00f22f 9119          ld temp1, Y+
00f230 2b80          or tosl, temp0
00f231 2b91          or tosh, temp1
00f232 cdd1          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
00f233 ff03          .dw $ff03
00f234 6f78
00f235 0072          .db "xor",0
00f236 f22a          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
00f237 f238          .dw PFA_XOR
                 PFA_XOR:
00f238 9109          ld temp0, Y+
00f239 9119          ld temp1, Y+
00f23a 2780          eor tosl, temp0
00f23b 2791          eor tosh, temp1
00f23c cdc7          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
00f23d ff02          .dw $ff02
00f23e 2b31          .db "1+"
00f23f f233          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
00f240 f241          .dw PFA_1PLUS
                 PFA_1PLUS:
00f241 9601          adiw tosl,1
00f242 cdc1          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
00f243 ff02          .dw $ff02 
00f244 2d31          .db "1-"
00f245 f23d          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
00f246 f247          .dw PFA_1MINUS
                 PFA_1MINUS:
00f247 9701          sbiw tosl, 1
00f248 cdbb          jmp_ DO_NEXT
                 .include "words/q-negate.asm"
                 
                 ;   0< IF NEGATE THEN ;        ...a common factor
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QNEGATE:
00f249 ff07          .dw $ff07
00f24a 6e3f
00f24b 6765
00f24c 7461
../../common\words/q-negate.asm(11): warning: .cseg .db misalignment - padding zero byte
00f24d 0065          .db "?negate"
00f24e f243          .dw VE_HEAD
                     .set VE_HEAD = VE_QNEGATE
                 XT_QNEGATE:
00f24f f000          .dw DO_COLON
                 PFA_QNEGATE:
                 
                 .endif
00f250 f130
00f251 f03e              .DW XT_ZEROLESS,XT_DOCONDBRANCH
00f252 f254              DEST(QNEG1)
00f253 f63a              .DW XT_NEGATE
00f254 f025      QNEG1:  .DW XT_EXIT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
00f255 ff06          .dw $ff06
00f256 736c
00f257 6968
00f258 7466          .db "lshift"
00f259 f249          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
00f25a f25b          .dw PFA_LSHIFT
                 PFA_LSHIFT:
00f25b 01fc          movw zl, tosl
00f25c 9189
00f25d 9199          loadtos
                 PFA_LSHIFT1:
00f25e 9731          sbiw zl, 1
00f25f f01a          brmi PFA_LSHIFT2
00f260 0f88          lsl tosl
00f261 1f99          rol tosh
00f262 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
00f263 cda0          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
00f264 ff06          .dw $ff06
00f265 7372
00f266 6968
00f267 7466          .db "rshift"
00f268 f255          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
00f269 f26a          .dw PFA_RSHIFT
                 PFA_RSHIFT:
00f26a 01fc          movw zl, tosl
00f26b 9189
00f26c 9199          loadtos
                 PFA_RSHIFT1:
00f26d 9731          sbiw zl, 1
00f26e f01a          brmi PFA_RSHIFT2
00f26f 9596          lsr tosh
00f270 9587          ror tosl
00f271 cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
00f272 cd91          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
00f273 ff02          .dw $ff02
00f274 212b          .db "+!"
00f275 f264          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
00f276 f277          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
00f277 01fc          movw zl, tosl
00f278 9189
00f279 9199          loadtos
00f27a 8120          ldd temp2, Z+0
00f27b 8131          ldd temp3, Z+1
00f27c 0f82          add tosl, temp2
00f27d 1f93          adc tosh, temp3
00f27e 8380          std Z+0, tosl
00f27f 8391          std Z+1, tosh
00f280 9189
00f281 9199          loadtos
00f282 cd81          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
00f283 ff03          .dw $ff03
00f284 7072
00f285 0040          .db "rp@",0
00f286 f273          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
00f287 f288          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
00f288 939a
00f289 938a          savetos
00f28a b78d          in tosl, SPL
00f28b b79e          in tosh, SPH
00f28c cd77          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
00f28d ff03          .dw $ff03
00f28e 7072
00f28f 0021          .db "rp!",0
00f290 f283          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
00f291 f292          .dw PFA_RP_STORE
                 PFA_RP_STORE:
00f292 b72f          in temp2, SREG
00f293 94f8          cli
00f294 bf8d          out SPL, tosl
00f295 bf9e          out SPH, tosh
00f296 bf2f          out SREG, temp2
00f297 9189
00f298 9199          loadtos
00f299 cd6a          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
00f29a ff03          .dw $ff03
00f29b 7073
00f29c 0040          .db "sp@",0
00f29d f28d          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
00f29e f29f          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
00f29f 939a
00f2a0 938a          savetos
00f2a1 01ce          movw tosl, yl
00f2a2 cd61          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
00f2a3 ff03          .dw $ff03
00f2a4 7073
00f2a5 0021          .db "sp!",0
00f2a6 f29a          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
00f2a7 f2a8          .dw PFA_SP_STORE
                 PFA_SP_STORE:
00f2a8 01ec          movw yl, tosl
00f2a9 9189
00f2aa 9199          loadtos
00f2ab cd58          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
00f2ac f2ad          .dw PFA_DODO
                 PFA_DODO:
00f2ad 9129          ld temp2, Y+
00f2ae 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
00f2af e8e0          ldi zl, $80
00f2b0 0f3e          add temp3, zl
00f2b1 1b82          sub  tosl, temp2
00f2b2 0b93          sbc  tosh, temp3
                 
00f2b3 933f          push temp3
00f2b4 932f          push temp2    ; limit  ( --> limit + $8000)
00f2b5 939f          push tosh
00f2b6 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
00f2b7 9189
00f2b8 9199          loadtos
00f2b9 cd4a          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
00f2ba ff01          .dw $FF01
00f2bb 0069          .db "i",0
00f2bc f2a3          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
00f2bd f2be          .dw PFA_I
                 PFA_I:
00f2be 939a
00f2bf 938a          savetos
00f2c0 918f          pop tosl
00f2c1 919f          pop tosh  ; index
00f2c2 91ef          pop zl
00f2c3 91ff          pop zh    ; limit
00f2c4 93ff          push zh
00f2c5 93ef          push zl
00f2c6 939f          push tosh
00f2c7 938f          push tosl
00f2c8 0f8e          add tosl, zl
00f2c9 1f9f          adc tosh, zh
00f2ca cd39          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
00f2cb f2cc          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
00f2cc 91ef          pop zl
00f2cd 91ff          pop zh
00f2ce 0fe8          add zl, tosl
00f2cf 1ff9          adc zh, tosh
00f2d0 9189
00f2d1 9199          loadtos
00f2d2 f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
00f2d3 93ff          push zh
00f2d4 93ef          push zl
00f2d5 cd5f          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
00f2d6 910f          pop  temp0
00f2d7 911f          pop  temp1  ; remove limit
00f2d8 9611          adiw xl, 1  ; skip branch-back address
00f2d9 cd2a          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
00f2da f2db          .dw PFA_DOLOOP
                 PFA_DOLOOP:
00f2db 91ef          pop zl
00f2dc 91ff          pop zh
00f2dd 9631          adiw zl,1
00f2de f3bb          brvs PFA_DOPLUSLOOP_LEAVE
00f2df cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
00f2e0 ff06          .dw $ff06
00f2e1 6e75
00f2e2 6f6c
00f2e3 706f          .db "unloop"
00f2e4 f2ba          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
00f2e5 f2e6          .dw PFA_UNLOOP
                 PFA_UNLOOP:
00f2e6 911f          pop temp1
00f2e7 910f          pop temp0
00f2e8 911f          pop temp1
00f2e9 910f          pop temp0
00f2ea cd19          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
00f2eb ff06          .dw $ff06
00f2ec 6d63
00f2ed 766f
00f2ee 3e65          .db "cmove>"
00f2ef f2e0          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
00f2f0 f2f1          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
00f2f1 93bf          push xh
00f2f2 93af          push xl
00f2f3 91e9          ld zl, Y+
00f2f4 91f9          ld zh, Y+ ; addr-to
00f2f5 91a9          ld xl, Y+
00f2f6 91b9          ld xh, Y+ ; addr-from
00f2f7 2f09          mov temp0, tosh
00f2f8 2b08          or temp0, tosl
00f2f9 f041          brbs 1, PFA_CMOVE_G1
00f2fa 0fe8          add zl, tosl
00f2fb 1ff9          adc zh, tosh
00f2fc 0fa8          add xl, tosl
00f2fd 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
00f2fe 911e          ld temp1, -X
00f2ff 9312          st -Z, temp1
00f300 9701          sbiw tosl, 1
00f301 f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
00f302 91af          pop xl
00f303 91bf          pop xh
00f304 9189
00f305 9199          loadtos
00f306 ccfd          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
00f307 ff02          .dw $ff02
00f308 3c3e          .db "><"
00f309 f2eb          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
00f30a f30b          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
00f30b 2f09          mov temp0, tosh
00f30c 2f98          mov tosh, tosl
00f30d 2f80          mov tosl, temp0
00f30e ccf5          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
00f30f ff03          .dw $ff03
00f310 7075
00f311 0040          .db "up@",0
00f312 f307          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
00f313 f314          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
00f314 939a
00f315 938a          savetos
00f316 01c2          movw tosl, upl
00f317 ccec          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
00f318 ff03          .dw $ff03
00f319 7075
00f31a 0021          .db "up!",0
00f31b f30f          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
00f31c f31d          .dw PFA_UP_STORE
                 PFA_UP_STORE:
00f31d 012c          movw upl, tosl
00f31e 9189
00f31f 9199          loadtos
00f320 cce3          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
00f321 ff03          .dw $ff03
00f322 3e32
00f323 0072          .db "2>r",0
00f324 f318          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
00f325 f326          .dw PFA_2TO_R
                 PFA_2TO_R:
00f326 01fc          movw zl, tosl
00f327 9189
00f328 9199          loadtos
00f329 939f          push tosh
00f32a 938f          push tosl
00f32b 93ff          push zh
00f32c 93ef          push zl
00f32d 9189
00f32e 9199          loadtos
00f32f ccd4          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
00f330 ff03          .dw $ff03
00f331 7232
00f332 003e          .db "2r>",0
00f333 f321          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
00f334 f335          .dw PFA_2R_FROM
                 PFA_2R_FROM:
00f335 939a
00f336 938a          savetos
00f337 91ef          pop zl
00f338 91ff          pop zh
00f339 918f          pop tosl
00f33a 919f          pop tosh
00f33b 939a
00f33c 938a          savetos
00f33d 01cf          movw tosl, zl
00f33e ccc5          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
00f33f ff02          .dw $ff02
00f340 6521          .db "!e"
00f341 f330          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
00f342 f343          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
00f343 01fc          movw zl, tosl
00f344 9189
00f345 9199          loadtos
00f346 b72f          in_ temp2, SREG
00f347 94f8          cli
00f348 d028          rcall PFA_FETCHE2
00f349 b500          in_  temp0, EEDR
00f34a 1708          cp temp0,tosl
00f34b f009          breq PFA_STOREE3
00f34c d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
00f34d 9631          adiw zl,1
00f34e d022          rcall PFA_FETCHE2
00f34f b500          in_  temp0, EEDR
00f350 1709          cp temp0,tosh
00f351 f011          breq PFA_STOREE4
00f352 2f89          mov tosl, tosh
00f353 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
00f354 bf2f          out_ SREG, temp2
00f355 9189
00f356 9199          loadtos
00f357 ccac          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
00f358 99f9          sbic EECR, EEPE
00f359 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
00f35a b707          in_ temp0, SPMCSR
00f35b fd00          sbrc temp0,SPMEN
00f35c cffd          rjmp PFA_STOREE2
                 
00f35d bdf2          out_ EEARH,zh
00f35e bde1          out_ EEARL,zl
00f35f bd80          out_ EEDR, tosl
00f360 9afa          sbi EECR,EEMPE
00f361 9af9          sbi EECR,EEPE
                 
00f362 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
00f363 ff02          .dw $ff02
00f364 6540          .db "@e"
00f365 f33f          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
00f366 f367          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
00f367 b72f          in_ temp2, SREG
00f368 94f8          cli
00f369 01fc          movw zl, tosl
00f36a d006          rcall PFA_FETCHE2
00f36b b580          in_ tosl, EEDR
                 
00f36c 9631          adiw zl,1
                 
00f36d d003          rcall PFA_FETCHE2
00f36e b590          in_  tosh, EEDR
00f36f bf2f          out_ SREG, temp2
00f370 cc93          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
00f371 99f9          sbic EECR, EEPE
00f372 cffe          rjmp PFA_FETCHE2
                 
00f373 bdf2          out_ EEARH,zh
00f374 bde1          out_ EEARL,zl
                 
00f375 9af8          sbi EECR,EERE
00f376 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
00f377 ff02          .dw $ff02
00f378 6921          .db "!i"
00f379 f363          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
00f37a fc29          .dw PFA_DODEFER1
                 PFA_STOREI:
00f37b 0078          .dw EE_STOREI
00f37c fbca          .dw XT_EDEFERFETCH
00f37d fbd4          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                 .else
                   .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
00f37e ff09          .dw $ff09
00f37f 2128
00f380 2d69
00f381 726e
00f382 7777
00f383 0029          .db "(!i-nrww)",0
00f384 f377          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
00f385 f386          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
00f386 b71f        in temp1,SREG
00f387 931f        push temp1
00f388 94f8        cli
                 
00f389 019c        movw temp2, tosl ; save the (word) address
00f38a 9189
00f38b 9199        loadtos          ; get the new value for the flash cell
00f38c 93af        push xl
00f38d 93bf        push xh
00f38e 93cf        push yl
00f38f 93df        push yh
00f390 d009        rcall DO_STOREI_atmega
00f391 91df        pop yh
00f392 91cf        pop yl
00f393 91bf        pop xh
00f394 91af        pop xl
                   ; finally clear the stack
00f395 9189
00f396 9199        loadtos
00f397 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
00f398 bf1f        out SREG,temp1
                 
00f399 cc6a        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
00f39a d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
00f39b 94e0        com temp4
00f39c 94f0        com temp5
00f39d 218e        and tosl, temp4
00f39e 219f        and tosh, temp5
00f39f 2b98        or tosh, tosl
00f3a0 f019        breq DO_STOREI_writepage 
00f3a1 01f9          movw zl, temp2
00f3a2 e002          ldi temp0,(1<<PGERS)
00f3a3 d023          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
00f3a4 01f9        movw zl, temp2
00f3a5 e004        ldi temp0,(1<<PGWRT)
00f3a6 d020        rcall dospm
                 
                   ; reenable RWW section
00f3a7 01f9        movw zl, temp2
00f3a8 e100        ldi temp0,(1<<RWWSRE)
00f3a9 d01d        rcall dospm
00f3aa 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
00f3ab 01f9        movw zl, temp2
                   ; get the beginning of page
00f3ac 78e0        andi zl,low(pagemask)
00f3ad 7fff        andi zh,high(pagemask)
00f3ae 01ef        movw y, z
                   ; loop counter (in words)
00f3af e8a0        ldi xl,low(pagesize)
00f3b0 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
00f3b1 01fe        movw z, y
00f3b2 2755
00f3b3 0fee
00f3b4 1fff
00f3b5 1f55
00f3b6 bf5b
00f3b7 9147
00f3b8 9157        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
00f3b9 01fe        movw z, y
00f3ba 17e2        cp zl, temp2
00f3bb 07f3        cpc zh, temp3
00f3bc f011        breq pageload_newdata
00f3bd 010a          movw r0, temp6
00f3be c002          rjmp pageload_cont
                 pageload_newdata:
00f3bf 017a          movw temp4, temp6
00f3c0 010c          movw r0, tosl
                 pageload_cont:
00f3c1 2700        clr temp0
00f3c2 d004        rcall dospm
00f3c3 9621        adiw y, 1
00f3c4 9711        sbiw x, 1
00f3c5 f759        brne pageload_loop
                 
                 pageload_done:
00f3c6 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
00f3c7 99f9        sbic EECR, EEPE
00f3c8 cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
00f3c9 b717        in_  temp1, SPMCSR
00f3ca fd10        sbrc temp1, SPMEN
00f3cb cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
00f3cc 2755
00f3cd 0fee
00f3ce 1fff
00f3cf 1f55
00f3d0 bf5b        writeflashcell
                   ; execute spm
00f3d1 6001        ori temp0, (1<<SPMEN)
00f3d2 bf07        out_ SPMCSR,temp0
00f3d3 95e8        spm
00f3d4 9508        ret
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
00f3d5 ff02          .dw $ff02
00f3d6 6940          .db "@i"
00f3d7 f37e          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
00f3d8 f3d9          .dw PFA_FETCHI
                 PFA_FETCHI:
00f3d9 01fc          movw zl, tosl
00f3da 2755
00f3db 0fee
00f3dc 1fff
00f3dd 1f55
00f3de bf5b
00f3df 9187
00f3e0 9197          readflashcell tosl,tosh
00f3e1 cc22          jmp_ DO_NEXT
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2LITERAL:
00f3e2 0008          .dw $0008
00f3e3 6c32
00f3e4 7469
00f3e5 7265
00f3e6 6c61          .db "2literal"
00f3e7 f3d5          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
00f3e8 f000          .dw DO_COLON
                 PFA_2LITERAL:
                 .endif
00f3e9 f0d5          .dw XT_SWAP
00f3ea 01bd          .dw XT_LITERAL
00f3eb 01bd          .dw XT_LITERAL
00f3ec f025          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
00f3ed ff01          .dw $ff01
00f3ee 003d          .db "=",0
00f3ef f3e2          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
00f3f0 f000          .dw DO_COLON
                 PFA_EQUAL:
00f3f1 f1a4          .dw XT_MINUS
00f3f2 f129          .dw XT_ZEROEQUAL
00f3f3 f025          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
00f3f4 ff01          .dw $ff01
00f3f5 0031          .db "1",0
00f3f6 f3ed          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
00f3f7 f053          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
00f3f8 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
00f3f9 ff01          .dw $ff01
00f3fa 0032          .db "2",0
00f3fb f3f4          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
00f3fc f053          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
00f3fd 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
00f3fe ff02          .dw $ff02
00f3ff 312d          .db "-1"
00f400 f3f9          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
00f401 f053          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
00f402 ffff              .DW -1
                 
                 .if AMFORTH_NRWW_SIZE>8000
                   .include "dict/core_8k.inc"
                 
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
00f403 ff03          .dw $ff03
00f404 3e6e
00f405 0072          .db "n>r",0
00f406 f3fe          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
00f407 f408          .dw PFA_N_TO_R
                 PFA_N_TO_R:
00f408 01fc          movw zl, tosl
00f409 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
00f40a 9189
00f40b 9199          loadtos
00f40c 939f          push tosh
00f40d 938f          push tosl
00f40e 950a          dec temp0
00f40f f7d1          brne PFA_N_TO_R1
00f410 93ef          push zl
00f411 93ff          push zh
00f412 9189
00f413 9199          loadtos
00f414 cbef          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
00f415 ff03          .dw $ff03
00f416 726e
00f417 003e          .db "nr>",0
00f418 f403          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
00f419 f41a          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
00f41a 939a
00f41b 938a          savetos
00f41c 91ff          pop zh
00f41d 91ef          pop zl
00f41e 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
00f41f 918f          pop tosl
00f420 919f          pop tosh
00f421 939a
00f422 938a          savetos
00f423 950a          dec temp0
00f424 f7d1          brne PFA_N_R_FROM1
00f425 01cf          movw tosl, zl
00f426 cbdd          jmp_ DO_NEXT
                 
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
00f427 ff03          .dw $ff03
00f428 3264
00f429 002a          .db "d2*",0
00f42a f415          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
00f42b f42c          .dw PFA_D2STAR
                 PFA_D2STAR:
00f42c 9109          ld temp0, Y+
00f42d 9119          ld temp1, Y+
00f42e 0f00          lsl temp0
00f42f 1f11          rol temp1
00f430 1f88          rol tosl
00f431 1f99          rol tosh
00f432 931a          st -Y, temp1
00f433 930a          st -Y, temp0
00f434 cbcf          jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
00f435 ff03          .dw $ff03
00f436 3264
00f437 002f          .db "d2/",0
00f438 f427          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
00f439 f43a          .dw PFA_D2SLASH
                 PFA_D2SLASH:
00f43a 9109          ld temp0, Y+
00f43b 9119          ld temp1, Y+
00f43c 9595          asr tosh
00f43d 9587          ror tosl
00f43e 9517          ror temp1
00f43f 9507          ror temp0
00f440 931a          st -Y, temp1
00f441 930a          st -Y, temp0
00f442 cbc1          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
00f443 ff02          .dw $ff02
00f444 2b64          .db "d+"
00f445 f435          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
00f446 f447          .dw PFA_DPLUS
                 PFA_DPLUS:
00f447 9129          ld temp2, Y+
00f448 9139          ld temp3, Y+
                 
00f449 90e9          ld temp4, Y+
00f44a 90f9          ld temp5, Y+
00f44b 9149          ld temp6, Y+
00f44c 9159          ld temp7, Y+
                 
00f44d 0f24          add temp2, temp6
00f44e 1f35          adc temp3, temp7
00f44f 1d8e          adc tosl, temp4
00f450 1d9f          adc tosh, temp5
                     
00f451 933a          st -Y, temp3
00f452 932a          st -Y, temp2
00f453 cbb0          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
00f454 ff02          .dw $ff02
00f455 2d64          .db "d-"
00f456 f443          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
00f457 f458          .dw PFA_DMINUS
                 PFA_DMINUS:
00f458 9129          ld temp2, Y+
00f459 9139          ld temp3, Y+
                 
00f45a 90e9          ld temp4, Y+
00f45b 90f9          ld temp5, Y+
00f45c 9149          ld temp6, Y+
00f45d 9159          ld temp7, Y+
                 
00f45e 1b42          sub temp6, temp2
00f45f 0b53          sbc temp7, temp3
00f460 0ae8          sbc temp4, tosl
00f461 0af9          sbc temp5, tosh
                 
00f462 935a          st -Y, temp7
00f463 934a          st -Y, temp6
00f464 01c7          movw tosl, temp4
00f465 cb9e          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
00f466 ff07          .dw $ff07
00f467 6964
00f468 766e
00f469 7265
00f46a 0074          .db "dinvert",0
00f46b f454          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
00f46c f46d          .dw PFA_DINVERT
                 PFA_DINVERT:
00f46d 9109          ld temp0, Y+
00f46e 9119          ld temp1, Y+
00f46f 9580          com tosl
00f470 9590          com tosh
00f471 9500          com temp0
00f472 9510          com temp1
00f473 931a          st -Y, temp1
00f474 930a          st -Y, temp0
00f475 cb8e          jmp_ DO_NEXT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
00f476 ff02          .dw $ff02
00f477 2e75          .db "u."
00f478 f466          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
00f479 f000          .dw DO_COLON
                 PFA_UDOT:
                 .endif
00f47a f165          .dw XT_ZERO
00f47b f725          .dw XT_UDDOT
00f47c f025          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
00f47d ff03          .dw $ff03
00f47e 2e75
00f47f 0072          .db "u.r",0
00f480 f476          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
00f481 f000          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
00f482 f165          .dw XT_ZERO
00f483 f0d5          .dw XT_SWAP
00f484 f72e          .dw XT_UDDOTR
00f485 f025          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
00f486 ff0d          .dw $ff0d
00f487 6873
00f488 776f
00f489 772d
00f48a 726f
00f48b 6c64
00f48c 7369
00f48d 0074          .db "show-wordlist",0
00f48e f47d          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
00f48f f000          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
00f490 f045          .dw XT_DOLITERAL
00f491 f495          .dw XT_SHOWWORD
00f492 f0d5          .dw XT_SWAP
00f493 fc6d          .dw XT_TRAVERSEWORDLIST
00f494 f025          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
00f495 f000          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
00f496 fc88          .dw XT_NAME2STRING
00f497 f79b          .dw XT_ITYPE
00f498 f7dd          .dw XT_SPACE         ; ( -- addr n)
00f499 f15c          .dw XT_TRUE
00f49a f025          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_WORDS:
00f49b ff05          .dw $ff05
00f49c 6f77
00f49d 6472
00f49e 0073          .db "words",0
00f49f f486          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
00f4a0 f000          .dw DO_COLON
                 PFA_WORDS:
                 .endif
00f4a1 f045          .dw XT_DOLITERAL
00f4a2 005e          .dw CFG_ORDERLISTLEN+2
00f4a3 f366          .dw XT_FETCHE
00f4a4 f48f          .dw XT_SHOWWORDLIST
00f4a5 f025          .dw XT_EXIT
                 
                 
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
00f4a6 ff04          .dw $ff04
00f4a7 6970
00f4a8 6b63          .db "pick"
00f4a9 f49b          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
00f4aa f000          .dw DO_COLON
                 PFA_PICK:
                 .endif
00f4ab f240          .dw XT_1PLUS
00f4ac f553          .dw XT_CELLS
00f4ad f29e          .dw XT_SP_FETCH
00f4ae f1ae          .dw XT_PLUS
00f4af f08a          .dw XT_FETCH
00f4b0 f025          .dw XT_EXIT
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
00f4b1 0002          .dw $0002
00f4b2 222e          .db ".",$22
00f4b3 f4a6          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
00f4b4 f000          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
00f4b5 f4bc          .dw XT_SQUOTE
00f4b6 019c          .dw XT_COMPILE
00f4b7 f79b          .dw XT_ITYPE
00f4b8 f025          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
00f4b9 0002        .dw $0002
00f4ba 2273        .db "s",$22
00f4bb f4b1        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
00f4bc f000          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
00f4bd f045          .dw XT_DOLITERAL
00f4be 0022          .dw 34   ; 0x22 
00f4bf f98c          .dw XT_PARSE       ; ( -- addr n)
00f4c0 f546          .dw XT_STATE
00f4c1 f08a          .dw XT_FETCH
00f4c2 f03e          .dw XT_DOCONDBRANCH
00f4c3 f4c5          DEST(PFA_SQUOTE1)
00f4c4 01c8            .dw XT_SLITERAL
                 PFA_SQUOTE1:
00f4c5 f025          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
00f4c6 ff04          .dw $ff04
00f4c7 6966
00f4c8 6c6c          .db "fill"
00f4c9 f4b9          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
00f4ca f000          .dw DO_COLON
                 PFA_FILL:
00f4cb f0f2          .dw XT_ROT
00f4cc f0f2          .dw XT_ROT
00f4cd f0ca
00f4ce f03e          .dw XT_QDUP,XT_DOCONDBRANCH
00f4cf f4d7          DEST(PFA_FILL2)
00f4d0 fd85          .dw XT_BOUNDS
00f4d1 f2ac          .dw XT_DODO
                 PFA_FILL1:
00f4d2 f0c2          .dw XT_DUP
00f4d3 f2bd          .dw XT_I
00f4d4 f09e          .dw XT_CSTORE  ; ( -- c c-addr)
00f4d5 f2da          .dw XT_DOLOOP
00f4d6 f4d2          .dw PFA_FILL1
                 PFA_FILL2:
00f4d7 f0ea          .dw XT_DROP
00f4d8 f025          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
00f4d9 ff0b          .dw $ff0b
00f4da 6e65
00f4db 6976
00f4dc 6f72
00f4dd 6d6e
00f4de 6e65
00f4df 0074          .db "environment",0
00f4e0 f4c6          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
00f4e1 f053          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
00f4e2 0056          .dw CFG_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
00f4e3 ff09          .dw $ff09
00f4e4 6f77
00f4e5 6472
00f4e6 696c
00f4e7 7473
00f4e8 0073          .db "wordlists",0
00f4e9 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
00f4ea f000          .dw DO_COLON
                 PFA_ENVWORDLISTS:
00f4eb f045          .dw XT_DOLITERAL
00f4ec 0008          .dw NUMWORDLISTS
00f4ed f025          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
00f4ee ff04          .dw $ff04
00f4ef 702f
00f4f0 6461          .db "/pad"
00f4f1 f4e3          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
00f4f2 f000          .dw DO_COLON
                 PFA_ENVSLASHPAD:
00f4f3 f29e          .dw XT_SP_FETCH
00f4f4 f57f          .dw XT_PAD
00f4f5 f1a4          .dw XT_MINUS
00f4f6 f025          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENVSLASHHOLD:
00f4f7 ff05          .dw $ff05
00f4f8 682f
00f4f9 6c6f
00f4fa 0064          .db "/hold",0
00f4fb f4ee          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
00f4fc f000          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
                 .endif
00f4fd f57f          .dw XT_PAD
00f4fe f5ba          .dw XT_HERE
00f4ff f1a4          .dw XT_MINUS
00f500 f025          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
00f501 ff0a          .dw $ff0a
00f502 6f66
00f503 7472
00f504 2d68
00f505 616e
00f506 656d          .db "forth-name"
00f507 f4f7          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
00f508 f000          .dw DO_COLON
                 PFA_EN_FORTHNAME:
00f509 f768          .dw XT_DOSLITERAL
00f50a 0007          .dw 7
                 .endif
00f50b 6d61
00f50c 6f66
00f50d 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
00f50e 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
00f50f f025          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
00f510 ff07          .dw $ff07
00f511 6576
00f512 7372
00f513 6f69
00f514 006e          .db "version",0
00f515 f501          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
00f516 f000          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
00f517 f045          .dw XT_DOLITERAL
00f518 0045          .dw 69
00f519 f025          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
00f51a ff03          .dw $ff03
00f51b 7063
00f51c 0075          .db "cpu",0
00f51d f510          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
00f51e f000          .dw DO_COLON
                 PFA_EN_CPU:
                 .endif
00f51f f045          .dw XT_DOLITERAL
00f520 0049          .dw mcu_name
00f521 f7c7          .dw XT_ICOUNT
00f522 f025          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
00f523 ff08          .dw $ff08
00f524 636d
00f525 2d75
00f526 6e69
00f527 6f66          .db "mcu-info"
00f528 f51a          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
00f529 f000          .dw DO_COLON
                 PFA_EN_MCUINFO:
00f52a f045          .dw XT_DOLITERAL
00f52b 0045          .dw mcu_info
00f52c f025          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_ENVUSERSIZE:
00f52d ff05          .dw $ff05
00f52e 752f
00f52f 6573
00f530 0072          .db "/user",0
00f531 f523          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
00f532 f000          .dw DO_COLON
                 PFA_ENVUSERSIZE:
                 .endif
00f533 f045          .dw XT_DOLITERAL
00f534 002e          .dw SYSUSERSIZE + APPUSERSIZE
00f535 f025          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
00f536 ff05          .dw $ff05
00f537 5f66
00f538 7063
00f539 0075          .db "f_cpu",0
00f53a f4d9          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
00f53b f000          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
00f53c f045          .dw XT_DOLITERAL
00f53d 1200          .dw (F_CPU % 65536)
00f53e f045          .dw XT_DOLITERAL
00f53f 007a          .dw (F_CPU / 65536)
00f540 f025          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
00f541 ff05          .dw $ff05
00f542 7473
00f543 7461
00f544 0065          .db "state",0
00f545 f536          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
00f546 f053          .dw PFA_DOVARIABLE
                 PFA_STATE:
00f547 013d          .dw ram_state
                 
                 .dseg
00013d           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
00f548 ff04          .dw $ff04
00f549 6162
00f54a 6573          .db "base"
00f54b f541          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
00f54c f066          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
00f54d 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
00f54e ff05          .dw $ff05
00f54f 6563
00f550 6c6c
00f551 0073          .db "cells",0
00f552 f548          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
00f553 f21d          .dw PFA_2STAR
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
00f554 ff05          .dw $ff05
00f555 6563
00f556 6c6c
00f557 002b          .db "cell+",0
00f558 f54e          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
00f559 f55a          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
00f55a 9602          adiw tosl, CELLSIZE
00f55b caa8          jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
00f55c ff04          .dw $ff04
00f55d 6432
00f55e 7075          .db "2dup"
00f55f f554          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
00f560 f000          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
00f561 f0e0          .dw XT_OVER
00f562 f0e0          .dw XT_OVER
00f563 f025          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
00f564 ff05          .dw $ff05
00f565 6432
00f566 6f72
00f567 0070          .db "2drop",0
00f568 f55c          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
00f569 f000          .dw DO_COLON
                 PFA_2DROP:
                 .endif
00f56a f0ea          .dw XT_DROP
00f56b f0ea          .dw XT_DROP
00f56c f025          .dw XT_EXIT
                 
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
00f56d ff04          .dw $ff04
00f56e 7574
00f56f 6b63          .db "tuck"
00f570 f564          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
00f571 f000          .dw DO_COLON
                 PFA_TUCK:
                 .endif
00f572 f0d5          .dw XT_SWAP
00f573 f0e0          .dw XT_OVER
00f574 f025          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
00f575 ff03          .dw $ff03
00f576 693e
00f577 006e          .db ">in",0
00f578 f56d          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
00f579 f066          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
00f57a 0018          .dw USER_TO_IN
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PAD:
00f57b ff03          .dw $ff03
00f57c 6170
00f57d 0064          .db "pad",0
00f57e f575          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
00f57f f000          .dw DO_COLON
                 PFA_PAD:
                 .endif
00f580 f5ba          .dw XT_HERE
00f581 f045          .dw XT_DOLITERAL
00f582 0028          .dw 40
00f583 f1ae          .dw XT_PLUS
00f584 f025          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMIT:
00f585 ff04          .dw $ff04
00f586 6d65
00f587 7469          .db "emit"
00f588 f57b          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
00f589 fc29          .dw PFA_DODEFER1
                 PFA_EMIT:
                 .endif
00f58a 000e          .dw USER_EMIT
00f58b fbf2          .dw XT_UDEFERFETCH
00f58c fbfe          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMITQ:
00f58d ff05          .dw $ff05
00f58e 6d65
00f58f 7469
00f590 003f          .db "emit?",0
00f591 f585          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
00f592 fc29          .dw PFA_DODEFER1
                 PFA_EMITQ:
                 .endif
00f593 0010          .dw USER_EMITQ
00f594 fbf2          .dw XT_UDEFERFETCH
00f595 fbfe          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEY:
00f596 ff03          .dw $ff03
00f597 656b
00f598 0079          .db "key",0
00f599 f58d          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
00f59a fc29          .dw PFA_DODEFER1
                 PFA_KEY:
                 .endif
00f59b 0012          .dw USER_KEY
00f59c fbf2          .dw XT_UDEFERFETCH
00f59d fbfe          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEYQ:
00f59e ff04          .dw $ff04
00f59f 656b
00f5a0 3f79          .db "key?"
00f5a1 f596          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
00f5a2 fc29          .dw PFA_DODEFER1
                 PFA_KEYQ:
                 .endif
00f5a3 0014          .dw USER_KEYQ
00f5a4 fbf2          .dw XT_UDEFERFETCH
00f5a5 fbfe          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
00f5a6 ff02          .dw $ff02
00f5a7 7064          .db "dp"
00f5a8 f59e          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
00f5a9 f080          .dw PFA_DOVALUE1
                 PFA_DP:
00f5aa 0048          .dw CFG_DP
00f5ab fbca          .dw XT_EDEFERFETCH
00f5ac fbd4          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
00f5ad ff05          .dw $ff05
00f5ae 6865
00f5af 7265
00f5b0 0065          .db "ehere",0
00f5b1 f5a6          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
00f5b2 f080          .dw PFA_DOVALUE1
                 PFA_EHERE:
00f5b3 004c          .dw EE_EHERE
00f5b4 fbca          .dw XT_EDEFERFETCH
00f5b5 fbd4          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
00f5b6 ff04          .dw $ff04
00f5b7 6568
00f5b8 6572          .db "here"
00f5b9 f5ad          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
00f5ba f080          .dw PFA_DOVALUE1
                 PFA_HERE:
00f5bb 004a          .dw EE_HERE
00f5bc fbca          .dw XT_EDEFERFETCH
00f5bd fbd4          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
00f5be ff05          .dw $ff05
00f5bf 6c61
00f5c0 6f6c
00f5c1 0074          .db "allot",0
00f5c2 f5b6          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
00f5c3 f000          .dw DO_COLON
                 PFA_ALLOT:
00f5c4 f5ba          .dw XT_HERE
00f5c5 f1ae          .dw XT_PLUS
00f5c6 fbaf          .dw XT_DOTO
00f5c7 f5bb          .dw PFA_HERE
00f5c8 f025          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
00f5c9 ff03          .dw $ff03
00f5ca 6962
00f5cb 006e          .db "bin",0
00f5cc f5be          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
00f5cd f000          .dw DO_COLON
                 PFA_BIN:
                 .endif
00f5ce f3fc          .dw XT_TWO
00f5cf f54c          .dw XT_BASE
00f5d0 f092          .dw XT_STORE
00f5d1 f025          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
00f5d2 ff07          .dw $ff07
00f5d3 6564
00f5d4 6963
00f5d5 616d
00f5d6 006c          .db "decimal",0
00f5d7 f5c9          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
00f5d8 f000          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
00f5d9 f045          .dw XT_DOLITERAL
00f5da 000a          .dw 10
00f5db f54c          .dw XT_BASE
00f5dc f092          .dw XT_STORE
00f5dd f025          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
00f5de ff03          .dw $ff03
00f5df 6568
00f5e0 0078          .db "hex",0
00f5e1 f5d2          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
00f5e2 f000          .dw DO_COLON
                 PFA_HEX:
                 .endif
00f5e3 f045          .dw XT_DOLITERAL
00f5e4 0010          .dw 16
00f5e5 f54c          .dw XT_BASE
00f5e6 f092          .dw XT_STORE
00f5e7 f025          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
00f5e8 ff02          .dw $ff02
00f5e9 6c62          .db "bl"
00f5ea f5de          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
00f5eb f053          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
00f5ec 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
00f5ed ff07          .dw $ff07
00f5ee 7574
00f5ef 6e72
00f5f0 656b
00f5f1 0079          .db "turnkey",0
00f5f2 f5e8          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
00f5f3 fc29          .dw PFA_DODEFER1
                 PFA_TURNKEY:
00f5f4 0054          .dw CFG_TURNKEY
00f5f5 fbca          .dw XT_EDEFERFETCH
00f5f6 fbd4          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
00f5f7 ff04          .dw $ff04
00f5f8 6d2f
00f5f9 646f          .db "/mod"
00f5fa f5ed          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
00f5fb f5fc          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
00f5fc 019c          movw temp2, tosl
                     
00f5fd 9109          ld temp0, Y+
00f5fe 9119          ld temp1, Y+
                 
00f5ff 2f41          mov	temp6,temp1	;move dividend High to sign register
00f600 2743          eor	temp6,temp3	;xor divisor High with sign register
00f601 ff17          sbrs	temp1,7	;if MSB in dividend set
00f602 c004          rjmp	PFA_SLASHMOD_1
00f603 9510          com	temp1		;    change sign of dividend
00f604 9500          com	temp0		
00f605 5f0f          subi	temp0,low(-1)
00f606 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
00f607 ff37          sbrs	temp3,7	;if MSB in divisor set
00f608 c004          rjmp	PFA_SLASHMOD_2
00f609 9530          com	temp3		;    change sign of divisor
00f60a 9520          com	temp2		
00f60b 5f2f          subi	temp2,low(-1)
00f60c 4f3f          sbci	temp3,high(-1)
00f60d 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
00f60e 18ff          sub	temp5,temp5;clear remainder High byte and carry
00f60f e151          ldi	temp7,17	;init loop counter
                 
00f610 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
00f611 1f11          rol	temp1
00f612 955a          dec	temp7		;decrement counter
00f613 f439          brne	PFA_SLASHMOD_5		;if done
00f614 ff47          sbrs	temp6,7		;    if MSB in sign register set
00f615 c004          rjmp	PFA_SLASHMOD_4
00f616 9510          com	temp1	;        change sign of result
00f617 9500          com	temp0
00f618 5f0f          subi	temp0,low(-1)
00f619 4f1f          sbci	temp1,high(-1)
00f61a c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
00f61b 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
00f61c 1cff          rol	temp5
00f61d 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
00f61e 0af3          sbc	temp5,temp3	;
00f61f f420          brcc	PFA_SLASHMOD_6		;if result negative
00f620 0ee2          add	temp4,temp2	;    restore remainder
00f621 1ef3          adc	temp5,temp3
00f622 9488          clc			;    clear carry to be shifted into result
00f623 cfec          rjmp	PFA_SLASHMOD_3		;else
00f624 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
00f625 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
00f626 92fa          st -Y,temp5
00f627 92ea          st -Y,temp4
                 
                     ; put quotient on stack
00f628 01c8          movw tosl, temp0
00f629 c9da          jmp_ DO_NEXT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
00f62a ff05          .dw $ff05
00f62b 2f75
00f62c 6f6d
00f62d 0064          .db "u/mod",0
00f62e f5f7          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
00f62f f000          .dw DO_COLON
                 PFA_USLASHMOD:
00f630 f110          .dw XT_TO_R
00f631 f165          .dw XT_ZERO
00f632 f107          .dw XT_R_FROM
00f633 f1d3          .dw XT_UMSLASHMOD
00f634 f025          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
00f635 ff06          .dw $ff06
00f636 656e
00f637 6167
00f638 6574          .db "negate"
00f639 f62a          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
00f63a f000          .dw DO_COLON
                 PFA_NEGATE:
00f63b f20e          .dw XT_INVERT
00f63c f240          .dw XT_1PLUS
00f63d f025          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
00f63e ff01          .dw $ff01
00f63f 002f          .db "/",0
00f640 f635          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
00f641 f000          .dw DO_COLON
                 PFA_SLASH:
                 .endif
00f642 f5fb          .dw XT_SLASHMOD
00f643 f101          .dw XT_NIP
00f644 f025          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
00f645 ff03          .dw $ff03
00f646 6f6d
00f647 0064          .db "mod",0
00f648 f63e          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
00f649 f000          .dw DO_COLON
                 PFA_MOD:
                 .endif
00f64a f5fb          .dw XT_SLASHMOD
00f64b f0ea          .dw XT_DROP
00f64c f025          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ;   DUP ?NEGATE ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABS:
00f64d ff03          .dw $ff03
00f64e 6261
00f64f 0073          .db "abs",0
00f650 f645          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
00f651 f000          .dw DO_COLON
                 PFA_ABS:
                 
                 .endif
                 
00f652 f0c2
00f653 f24f
00f654 f025          .DW XT_DUP,XT_QNEGATE,XT_EXIT
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
00f655 ff03          .dw $ff03
00f656 696d
00f657 006e          .db "min",0
00f658 f64d          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
00f659 f000          .dw DO_COLON
                 PFA_MIN:
                 .endif
00f65a f560          .dw XT_2DUP
00f65b f189          .dw XT_GREATER
00f65c f03e          .dw XT_DOCONDBRANCH
00f65d f65f          DEST(PFA_MIN1)
00f65e f0d5          .dw XT_SWAP
                 PFA_MIN1:
00f65f f0ea          .dw XT_DROP
00f660 f025          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
00f661 ff03          .dw $ff03
00f662 616d
00f663 0078          .db "max",0
00f664 f655          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
00f665 f000          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
00f666 f560          .dw XT_2DUP
00f667 f17f          .dw XT_LESS
00f668 f03e          .dw XT_DOCONDBRANCH
00f669 f66b          DEST(PFA_MAX1)
00f66a f0d5          .dw XT_SWAP
                 PFA_MAX1:
00f66b f0ea          .dw XT_DROP
00f66c f025          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
00f66d ff06          .dw $ff06
00f66e 6977
00f66f 6874
00f670 6e69          .db "within"
00f671 f661          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
00f672 f000          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
00f673 f0e0          .dw XT_OVER
00f674 f1a4          .dw XT_MINUS
00f675 f110          .dw XT_TO_R
00f676 f1a4          .dw XT_MINUS
00f677 f107          .dw XT_R_FROM
00f678 f16d          .dw XT_ULESS
00f679 f025          .dw XT_EXIT
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
00f67a ff07          .dw $ff07 
00f67b 6f74
00f67c 7075
00f67d 6570
00f67e 0072          .db "toupper",0
00f67f f66d          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
00f680 f000          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
00f681 f0c2          .dw XT_DUP 
00f682 f045          .dw XT_DOLITERAL 
00f683 0061          .dw 'a' 
00f684 f045          .dw XT_DOLITERAL 
00f685 007b          .dw 'z'+1
00f686 f672          .dw XT_WITHIN 
00f687 f03e          .dw XT_DOCONDBRANCH
00f688 f68c          DEST(PFA_TOUPPER0)
00f689 f045          .dw XT_DOLITERAL
00f68a 00df          .dw 223 ; inverse of 0x20: 0xdf
00f68b f224          .dw XT_AND 
                 PFA_TOUPPER0:
00f68c f025          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
00f68d ff07          .dw $ff07
00f68e 6f74
00f68f 6f6c
00f690 6577
00f691 0072          .db "tolower",0
00f692 f67a          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
00f693 f000          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
00f694 f0c2          .dw XT_DUP
00f695 f045          .dw XT_DOLITERAL
00f696 0041          .dw 'A'
00f697 f045          .dw XT_DOLITERAL
00f698 005b          .dw 'Z'+1
00f699 f672          .dw XT_WITHIN
00f69a f03e          .dw XT_DOCONDBRANCH
00f69b f69f          DEST(PFA_TOLOWER0)
00f69c f045          .dw XT_DOLITERAL
00f69d 0020          .dw 32
00f69e f22d          .dw XT_OR 
                 PFA_TOLOWER0:
00f69f f025          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
00f6a0 ff03          .dw $ff03
00f6a1 6c68
00f6a2 0064          .db "hld",0
00f6a3 f68d          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
00f6a4 f053          .dw PFA_DOVARIABLE
                 PFA_HLD:
00f6a5 013f          .dw ram_hld
                 
                 .dseg
00013f           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
00f6a6 ff04          .dw $ff04
00f6a7 6f68
00f6a8 646c          .db "hold"
00f6a9 f6a0          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
00f6aa f000          .dw DO_COLON
                 PFA_HOLD:
                 .endif
00f6ab f6a4          .dw XT_HLD
00f6ac f0c2          .dw XT_DUP
00f6ad f08a          .dw XT_FETCH
00f6ae f246          .dw XT_1MINUS
00f6af f0c2          .dw XT_DUP
00f6b0 f110          .dw XT_TO_R
00f6b1 f0d5          .dw XT_SWAP
00f6b2 f092          .dw XT_STORE
00f6b3 f107          .dw XT_R_FROM
00f6b4 f09e          .dw XT_CSTORE
00f6b5 f025          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
00f6b6 ff02          .dw $ff02
00f6b7 233c          .db "<#"
00f6b8 f6a6          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
00f6b9 f000          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
00f6ba f57f          .dw XT_PAD
00f6bb f6a4          .dw XT_HLD
00f6bc f092          .dw XT_STORE
00f6bd f025          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
00f6be ff01          .dw $ff01
00f6bf 0023          .db "#",0
00f6c0 f6b6          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
00f6c1 f000          .dw DO_COLON
                 PFA_SHARP:
                 .endif
00f6c2 f54c          .dw XT_BASE
00f6c3 f08a          .dw XT_FETCH
00f6c4 f73e          .dw XT_UDSLASHMOD
00f6c5 f0f2          .dw XT_ROT
00f6c6 f045          .dw XT_DOLITERAL
00f6c7 0009          .dw 9
00f6c8 f0e0          .dw XT_OVER
00f6c9 f17f          .dw XT_LESS
00f6ca f03e          .dw XT_DOCONDBRANCH
00f6cb f6cf          DEST(PFA_SHARP1)
00f6cc f045          .dw XT_DOLITERAL
00f6cd 0007          .dw 7
00f6ce f1ae          .dw XT_PLUS
                 PFA_SHARP1:
00f6cf f045          .dw XT_DOLITERAL
00f6d0 0030          .dw 48 ; ASCII 0
00f6d1 f1ae          .dw XT_PLUS
00f6d2 f6aa          .dw XT_HOLD
00f6d3 f025          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
00f6d4 ff02          .dw $ff02
00f6d5 7323          .db "#s"
00f6d6 f6be          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
00f6d7 f000          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
00f6d8 f6c1          .dw XT_SHARP
00f6d9 f560          .dw XT_2DUP
00f6da f22d          .dw XT_OR
00f6db f129          .dw XT_ZEROEQUAL
00f6dc f03e          .dw XT_DOCONDBRANCH
00f6dd f6d8          DEST(NUMS1) ; PFA_SHARP_S
00f6de f025          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
00f6df ff02          .dw $ff02
00f6e0 3e23          .db "#>"
00f6e1 f6d4          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
00f6e2 f000          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
00f6e3 f569          .dw XT_2DROP
00f6e4 f6a4          .dw XT_HLD
00f6e5 f08a          .dw XT_FETCH
00f6e6 f57f          .dw XT_PAD
00f6e7 f0e0          .dw XT_OVER
00f6e8 f1a4          .dw XT_MINUS
00f6e9 f025          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
00f6ea ff04          .dw $ff04
00f6eb 6973
00f6ec 6e67          .db "sign"
00f6ed f6df          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
00f6ee f000          .dw DO_COLON
                 PFA_SIGN:
                 .endif
00f6ef f130          .dw XT_ZEROLESS
00f6f0 f03e          .dw XT_DOCONDBRANCH
00f6f1 f6f5          DEST(PFA_SIGN1)
00f6f2 f045          .dw XT_DOLITERAL
00f6f3 002d          .dw 45 ; ascii -
00f6f4 f6aa          .dw XT_HOLD
                 PFA_SIGN1:
00f6f5 f025          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
00f6f6 ff03          .dw $ff03
00f6f7 2e64
00f6f8 0072          .db "d.r",0
00f6f9 f6ea          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
00f6fa f000          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
00f6fb f110          .dw XT_TO_R
00f6fc f571          .dw XT_TUCK
00f6fd fcfb          .dw XT_DABS
00f6fe f6b9          .dw XT_L_SHARP
00f6ff f6d7          .dw XT_SHARP_S
00f700 f0f2          .dw XT_ROT
00f701 f6ee          .dw XT_SIGN
00f702 f6e2          .dw XT_SHARP_G
00f703 f107          .dw XT_R_FROM
00f704 f0e0          .dw XT_OVER
00f705 f1a4          .dw XT_MINUS
00f706 f7e6          .dw XT_SPACES
00f707 f7f6          .dw XT_TYPE
00f708 f025          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
00f709 ff02          .dw $ff02
00f70a 722e          .db ".r"
00f70b f6f6          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
00f70c f000          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
00f70d f110          .dw XT_TO_R
00f70e fd8e          .dw XT_S2D
00f70f f107          .dw XT_R_FROM
00f710 f6fa          .dw XT_DDOTR
00f711 f025          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
00f712 ff02          .dw $ff02
00f713 2e64          .db "d."
00f714 f709          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
00f715 f000          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
00f716 f165          .dw XT_ZERO
00f717 f6fa          .dw XT_DDOTR
00f718 f7dd          .dw XT_SPACE
00f719 f025          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
00f71a ff01          .dw $ff01
00f71b 002e          .db ".",0
00f71c f712          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
00f71d f000          .dw DO_COLON
                 PFA_DOT:
                 .endif
00f71e fd8e          .dw XT_S2D
00f71f f715          .dw XT_DDOT
00f720 f025          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
00f721 ff03          .dw $ff03
00f722 6475
00f723 002e          .db "ud.",0
00f724 f71a          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
00f725 f000          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
00f726 f165          .dw XT_ZERO
00f727 f72e          .dw XT_UDDOTR
00f728 f7dd          .dw XT_SPACE
00f729 f025          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
00f72a ff04          .dw $ff04
00f72b 6475
00f72c 722e          .db "ud.r"
00f72d f721          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
00f72e f000          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
00f72f f110          .dw XT_TO_R
00f730 f6b9          .dw XT_L_SHARP
00f731 f6d7          .dw XT_SHARP_S
00f732 f6e2          .dw XT_SHARP_G
00f733 f107          .dw XT_R_FROM
00f734 f0e0          .dw XT_OVER
00f735 f1a4          .dw XT_MINUS
00f736 f7e6          .dw XT_SPACES
00f737 f7f6          .dw XT_TYPE
00f738 f025          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
00f739 ff06          .dw $ff06
00f73a 6475
00f73b 6d2f
00f73c 646f          .db "ud/mod"
00f73d f72a          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
00f73e f000          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
00f73f f110          .dw XT_TO_R
00f740 f165          .dw XT_ZERO
00f741 f117          .dw XT_R_FETCH
00f742 f1d3          .dw XT_UMSLASHMOD
00f743 f107          .dw XT_R_FROM
00f744 f0d5          .dw XT_SWAP
00f745 f110          .dw XT_TO_R
00f746 f1d3          .dw XT_UMSLASHMOD
00f747 f107          .dw XT_R_FROM
00f748 f025          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
00f749 ff06          .dw $ff06 
00f74a 6964
00f74b 6967
00f74c 3f74          .db "digit?"
00f74d f739          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
00f74e f000          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
00f74f f680          .dw XT_TOUPPER
00f750 f0c2
00f751 f045
00f752 0039
00f753 f189
00f754 f045
00f755 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
00f756 f224
00f757 f1ae
00f758 f0c2
00f759 f045
00f75a 0140
00f75b f189          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
00f75c f045
00f75d 0107
00f75e f224
00f75f f1a4
00f760 f045
00f761 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
00f762 f1a4
00f763 f0c2
00f764 f54c
00f765 f08a
00f766 f16d          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
00f767 f025          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
00f768 f000        .dw DO_COLON
                 PFA_DOSLITERAL:
00f769 f117        .dw XT_R_FETCH   ; ( -- addr )
00f76a f7c7        .dw XT_ICOUNT
00f76b f107        .dw XT_R_FROM
00f76c f0e0        .dw XT_OVER     ; ( -- addr' n addr n)
00f76d f240        .dw XT_1PLUS
00f76e f215        .dw XT_2SLASH   ; ( -- addr' n addr k )
00f76f f1ae        .dw XT_PLUS     ; ( -- addr' n addr'' )
00f770 f240        .dw XT_1PLUS
00f771 f110        .dw XT_TO_R     ; ( -- )
00f772 f025        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
00f773 ff02        .dw $ff02
00f774 2c73        .db "s",$2c
00f775 f749        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
00f776 f000          .dw DO_COLON
                 PFA_SCOMMA:
00f777 f0c2          .dw XT_DUP
00f778 f77a          .dw XT_DOSCOMMA
00f779 f025          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
00f77a f000          .dw DO_COLON
                 PFA_DOSCOMMA:
00f77b 01a7          .dw XT_COMMA
00f77c f0c2          .dw XT_DUP   ; ( --addr len len)
00f77d f215          .dw XT_2SLASH ; ( -- addr len len/2
00f77e f571          .dw XT_TUCK   ; ( -- addr len/2 len len/2
00f77f f21c          .dw XT_2STAR  ; ( -- addr len/2 len len'
00f780 f1a4          .dw XT_MINUS  ; ( -- addr len/2 rem
00f781 f110          .dw XT_TO_R
00f782 f165          .dw XT_ZERO
00f783 0266          .dw XT_QDOCHECK
00f784 f03e          .dw XT_DOCONDBRANCH
00f785 f78d          .dw PFA_SCOMMA2
00f786 f2ac          .dw XT_DODO
                 PFA_SCOMMA1:
00f787 f0c2          .dw XT_DUP         ; ( -- addr addr )
00f788 f08a          .dw XT_FETCH       ; ( -- addr c1c2 )
00f789 01a7          .dw XT_COMMA       ; ( -- addr )
00f78a f559          .dw XT_CELLPLUS    ; ( -- addr+cell )
00f78b f2da          .dw XT_DOLOOP
00f78c f787          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
00f78d f107          .dw XT_R_FROM
00f78e f137          .dw XT_GREATERZERO
00f78f f03e          .dw XT_DOCONDBRANCH
00f790 f794          .dw PFA_SCOMMA3
00f791 f0c2            .dw XT_DUP     ; well, tricky
00f792 f0a9            .dw XT_CFETCH
00f793 01a7            .dw XT_COMMA
                 PFA_SCOMMA3:
00f794 f0ea          .dw XT_DROP        ; ( -- )
00f795 f025          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
00f796 ff05          .dw $ff05
00f797 7469
00f798 7079
00f799 0065          .db "itype",0
00f79a f773          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
00f79b f000          .dw DO_COLON
                 PFA_ITYPE:
00f79c f0c2          .dw XT_DUP    ; ( --addr len len)
00f79d f215          .dw XT_2SLASH ; ( -- addr len len/2
00f79e f571          .dw XT_TUCK   ; ( -- addr len/2 len len/2
00f79f f21c          .dw XT_2STAR  ; ( -- addr len/2 len len'
00f7a0 f1a4          .dw XT_MINUS  ; ( -- addr len/2 rem
00f7a1 f110          .dw XT_TO_R
00f7a2 f165          .dw XT_ZERO
00f7a3 0266          .dw XT_QDOCHECK
00f7a4 f03e          .dw XT_DOCONDBRANCH
00f7a5 f7af          .dw PFA_ITYPE2
00f7a6 f2ac          .dw XT_DODO
                 PFA_ITYPE1:
00f7a7 f0c2          .dw XT_DUP         ; ( -- addr addr )
00f7a8 f3d8          .dw XT_FETCHI      ; ( -- addr c1c2 )
00f7a9 f0c2          .dw XT_DUP
00f7aa f7bc          .dw XT_LOWEMIT
00f7ab f7b8          .dw XT_HIEMIT
00f7ac f240          .dw XT_1PLUS    ; ( -- addr+cell )
00f7ad f2da          .dw XT_DOLOOP
00f7ae f7a7          .dw PFA_ITYPE1
                 PFA_ITYPE2:
00f7af f107          .dw XT_R_FROM
00f7b0 f137          .dw XT_GREATERZERO
00f7b1 f03e          .dw XT_DOCONDBRANCH
00f7b2 f7b6          .dw PFA_ITYPE3
00f7b3 f0c2            .dw XT_DUP     ; make sure the drop below has always something to do
00f7b4 f3d8            .dw XT_FETCHI
00f7b5 f7bc            .dw XT_LOWEMIT
                 PFA_ITYPE3:
00f7b6 f0ea          .dw XT_DROP
00f7b7 f025          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
00f7b8 f000          .dw DO_COLON
                 PFA_HIEMIT:
00f7b9 f30a          .dw XT_BYTESWAP
00f7ba f7bc          .dw XT_LOWEMIT
00f7bb f025          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
00f7bc f000          .dw DO_COLON
                 PFA_LOWEMIT:
00f7bd f045          .dw XT_DOLITERAL
00f7be 00ff          .dw $00ff
00f7bf f224          .dw XT_AND
00f7c0 f589          .dw XT_EMIT
00f7c1 f025          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
00f7c2 ff06          .dw $ff06
00f7c3 6369
00f7c4 756f
00f7c5 746e          .db "icount"
00f7c6 f796          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
00f7c7 f000          .dw DO_COLON
                 PFA_ICOUNT:
00f7c8 f0c2          .dw XT_DUP
00f7c9 f240          .dw XT_1PLUS
00f7ca f0d5          .dw XT_SWAP
00f7cb f3d8          .dw XT_FETCHI
00f7cc f025          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
00f7cd ff02          .dw 0xff02
00f7ce 7263          .db "cr"
00f7cf f7c2          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
00f7d0 f000          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
00f7d1 f045          .dw XT_DOLITERAL
00f7d2 000d          .dw 13
00f7d3 f589          .dw XT_EMIT
00f7d4 f045          .dw XT_DOLITERAL
00f7d5 000a          .dw 10
00f7d6 f589          .dw XT_EMIT
00f7d7 f025          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
00f7d8 ff05          .dw $ff05
00f7d9 7073
00f7da 6361
00f7db 0065          .db "space",0
00f7dc f7cd          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
00f7dd f000          .dw DO_COLON
                 PFA_SPACE:
                 .endif
00f7de f5eb          .dw XT_BL
00f7df f589          .dw XT_EMIT
00f7e0 f025          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
00f7e1 ff06          .dw $ff06
00f7e2 7073
00f7e3 6361
00f7e4 7365          .db "spaces"
00f7e5 f7d8          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
00f7e6 f000          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
00f7e7 f165
00f7e8 f665      	.DW XT_ZERO, XT_MAX
00f7e9 f0c2
00f7ea f03e      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
00f7eb f7f0              DEST(SPCS2)
00f7ec f7dd
00f7ed f246
00f7ee f034              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
00f7ef f7e9              DEST(SPCS1)
00f7f0 f0ea
00f7f1 f025      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
00f7f2 ff04          .dw $ff04
00f7f3 7974
00f7f4 6570          .db "type"
00f7f5 f7e1          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
00f7f6 f000          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
00f7f7 fd85          .dw XT_BOUNDS
00f7f8 0266          .dw XT_QDOCHECK
00f7f9 f03e          .dw XT_DOCONDBRANCH
00f7fa f801          DEST(PFA_TYPE2)
00f7fb f2ac          .dw XT_DODO
                 PFA_TYPE1:
00f7fc f2bd          .dw XT_I
00f7fd f0a9          .dw XT_CFETCH
00f7fe f589          .dw XT_EMIT
00f7ff f2da          .dw XT_DOLOOP
00f800 f7fc          DEST(PFA_TYPE1)
                 PFA_TYPE2:
00f801 f025          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
00f802 ff01          .dw $ff01
00f803 0027          .db "'",0
00f804 f7f2          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
00f805 f000          .dw DO_COLON
                 PFA_TICK:
                 .endif
00f806 f9b9          .dw XT_PARSENAME
00f807 fad9          .dw XT_FORTHRECOGNIZER
00f808 fae4          .dw XT_RECOGNIZE
                     ; a word is tickable unless RECTYPE-TOKEN is RECTYPE-NULL or 
                     ; the interpret action is a NOOP
00f809 f0c2          .dw XT_DUP
00f80a fb60          .dw XT_RECTYPE_NULL
00f80b f3f0          .dw XT_EQUAL
00f80c f0d5          .dw XT_SWAP
00f80d f3d8          .dw XT_FETCHI
00f80e f045          .dw XT_DOLITERAL
00f80f fb95          .dw XT_NOOP
00f810 f3f0          .dw XT_EQUAL
00f811 f22d          .dw XT_OR
00f812 f03e          .dw XT_DOCONDBRANCH
00f813 f817          DEST(PFA_TICK1)
00f814 f045            .dw XT_DOLITERAL
00f815 fff3            .dw -13
00f816 f83c            .dw XT_THROW
                 PFA_TICK1:
00f817 f0ea          .dw XT_DROP
00f818 f025          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
00f819 ff07          .dw $ff07
00f81a 6168
00f81b 646e
00f81c 656c
00f81d 0072          .db "handler",0
00f81e f802          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
00f81f f066          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
00f820 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
00f821 ff05          .dw $ff05
00f822 6163
00f823 6374
00f824 0068          .db "catch",0
00f825 f819          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
00f826 f000          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
00f827 f29e          .dw XT_SP_FETCH
00f828 f110          .dw XT_TO_R
                     ; handler @ >r
00f829 f81f          .dw XT_HANDLER
00f82a f08a          .dw XT_FETCH
00f82b f110          .dw XT_TO_R
                     ; rp@ handler !
00f82c f287          .dw XT_RP_FETCH
00f82d f81f          .dw XT_HANDLER
00f82e f092          .dw XT_STORE
00f82f f02f          .dw XT_EXECUTE
                     ; r> handler !
00f830 f107          .dw XT_R_FROM
00f831 f81f          .dw XT_HANDLER
00f832 f092          .dw XT_STORE
00f833 f107          .dw XT_R_FROM
00f834 f0ea          .dw XT_DROP
00f835 f165          .dw XT_ZERO
00f836 f025          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
00f837 ff05          .dw $ff05
00f838 6874
00f839 6f72
00f83a 0077          .db "throw",0
00f83b f821          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
00f83c f000          .dw DO_COLON
                 PFA_THROW:
                 .endif
00f83d f0ca          .dw XT_QDUP
00f83e f03e          .dw XT_DOCONDBRANCH
00f83f f84c          DEST(PFA_THROW1)
00f840 f81f            .dw XT_HANDLER
00f841 f08a            .dw XT_FETCH
00f842 f291            .dw XT_RP_STORE
00f843 f107            .dw XT_R_FROM
00f844 f81f            .dw XT_HANDLER
00f845 f092            .dw XT_STORE
00f846 f107            .dw XT_R_FROM
00f847 f0d5            .dw XT_SWAP
00f848 f110            .dw XT_TO_R
00f849 f2a7            .dw XT_SP_STORE
00f84a f0ea            .dw XT_DROP
00f84b f107            .dw XT_R_FROM    
                 PFA_THROW1:
00f84c f025          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
00f84d ff05          .dw $ff05
00f84e 7363
00f84f 696b
00f850 0070          .db "cskip",0
00f851 f837          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
00f852 f000          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
00f853 f110          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
00f854 f0c2          .dw XT_DUP            ; ( -- addr' n' n' )
00f855 f03e          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00f856 f861          DEST(PFA_CSKIP2)
00f857 f0e0          .dw XT_OVER           ; ( -- addr' n' addr' )
00f858 f0a9          .dw XT_CFETCH         ; ( -- addr' n' c' )
00f859 f117          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
00f85a f3f0          .dw XT_EQUAL          ; ( -- addr' n' f )
00f85b f03e          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00f85c f861          DEST(PFA_CSKIP2)
00f85d f3f7          .dw XT_ONE
00f85e f9aa          .dw XT_SLASHSTRING
00f85f f034          .dw XT_DOBRANCH
00f860 f854          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
00f861 f107          .dw XT_R_FROM
00f862 f0ea          .dw XT_DROP           ; ( -- addr2 n2)
00f863 f025          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
00f864 ff05          .dw $ff05
00f865 7363
00f866 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
00f867 006e          .db "cscan"
00f868 f84d          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
00f869 f000          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
00f86a f110          .dw XT_TO_R
00f86b f0e0          .dw XT_OVER
                 PFA_CSCAN1:
00f86c f0c2          .dw XT_DUP
00f86d f0a9          .dw XT_CFETCH
00f86e f117          .dw XT_R_FETCH
00f86f f3f0          .dw XT_EQUAL
00f870 f129          .dw XT_ZEROEQUAL
00f871 f03e          .dw XT_DOCONDBRANCH
00f872 f87e          DEST(PFA_CSCAN2)
00f873 f0d5            .dw XT_SWAP
00f874 f246            .dw XT_1MINUS
00f875 f0d5            .dw XT_SWAP
00f876 f0e0            .dw XT_OVER
00f877 f130            .dw XT_ZEROLESS ; not negative
00f878 f129            .dw XT_ZEROEQUAL
00f879 f03e            .dw XT_DOCONDBRANCH
00f87a f87e            DEST(PFA_CSCAN2)
00f87b f240              .dw XT_1PLUS
00f87c f034              .dw XT_DOBRANCH
00f87d f86c              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
00f87e f101          .dw XT_NIP
00f87f f0e0          .dw XT_OVER
00f880 f1a4          .dw XT_MINUS
00f881 f107          .dw XT_R_FROM
00f882 f0ea          .dw XT_DROP
00f883 f025          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
00f884 ff06          .dw $ff06
00f885 6361
00f886 6563
00f887 7470          .db "accept"
00f888 f864          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
00f889 f000          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
00f88a f0e0
00f88b f1ae
00f88c f0e0              .DW XT_OVER,XT_PLUS,XT_OVER
00f88d f59a
00f88e f0c2
00f88f f8d2
00f890 f129
00f891 f03e      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
00f892 f8c5              DEST(ACC5)
00f893 f0c2
00f894 f045
00f895 0008
00f896 f3f0
00f897 f03e              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
00f898 f8ab              DEST(ACC3)
00f899 f0ea
00f89a f0f2
00f89b f560
00f89c f189
00f89d f110
00f89e f0f2
00f89f f0f2
00f8a0 f107
00f8a1 f03e              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
00f8a2 f8a9      	DEST(ACC6)
00f8a3 f8ca
00f8a4 f246
00f8a5 f110
00f8a6 f0e0
00f8a7 f107
00f8a8 0123      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
00f8a9 f034      ACC6:   .DW XT_DOBRANCH
00f8aa f8c3              DEST(ACC4)
                     
                 
                 ACC3:    ; check for remaining control characters, replace them with blank
00f8ab f0c2      	.dw XT_DUP            ; ( -- addr k k )
00f8ac f5eb              .dw XT_BL
00f8ad f17f              .dw XT_LESS
00f8ae f03e              .dw XT_DOCONDBRANCH
00f8af f8b2              DEST(PFA_ACCEPT6)
00f8b0 f0ea              .dw XT_DROP
00f8b1 f5eb              .dw XT_BL
                 PFA_ACCEPT6:
00f8b2 f110
00f8b3 f560
00f8b4 f189
00f8b5 f107
00f8b6 f0d5
00f8b7 f03e      	.DW XT_TO_R,XT_2DUP,XT_GREATER,XT_R_FROM,XT_SWAP,XT_DOCONDBRANCH
00f8b8 f8c2              DEST(ACC7)
00f8b9 f0c2
00f8ba f589
00f8bb f0e0
00f8bc f09e
00f8bd f240
00f8be f0e0
00f8bf 012f                  .DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
00f8c0 f034      	    .DW XT_DOBRANCH
00f8c1 f8c3      	    DEST(ACC4)
00f8c2 f0ea      ACC7:   .DW XT_DROP
00f8c3 f034      ACC4:   .DW XT_DOBRANCH
00f8c4 f88d              DEST(ACC1)
00f8c5 f0ea
00f8c6 f101
00f8c7 f0d5
00f8c8 f1a4
00f8c9 f025      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
00f8ca f000          .dw DO_COLON
                 .endif
00f8cb f045          .dw XT_DOLITERAL
00f8cc 0008          .dw 8
00f8cd f0c2          .dw XT_DUP
00f8ce f589          .dw XT_EMIT
00f8cf f7dd          .dw XT_SPACE
00f8d0 f589          .dw XT_EMIT
00f8d1 f025          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
00f8d2 f000          .dw DO_COLON
                 .endif
00f8d3 f0c2          .dw XT_DUP
00f8d4 f045          .dw XT_DOLITERAL
00f8d5 000d          .dw 13
00f8d6 f3f0          .dw XT_EQUAL
00f8d7 f0d5          .dw XT_SWAP
00f8d8 f045          .dw XT_DOLITERAL
00f8d9 000a          .dw 10
00f8da f3f0          .dw XT_EQUAL
00f8db f22d          .dw XT_OR
00f8dc f025          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILL:
00f8dd ff06          .dw $ff06
00f8de 6572
00f8df 6966
00f8e0 6c6c          .db "refill"
00f8e1 f884          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
00f8e2 fc29          .dw PFA_DODEFER1
                 PFA_REFILL:
                 .endif
00f8e3 001a          .dw USER_REFILL
00f8e4 fbf2          .dw XT_UDEFERFETCH
00f8e5 fbfe          .dw XT_UDEFERSTORE
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
00f8e6 ff04          .dw $ff04
00f8e7 6863
00f8e8 7261          .db "char"
00f8e9 f8dd          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
00f8ea f000          .dw DO_COLON
                 PFA_CHAR:
                 .endif
00f8eb f9b9          .dw XT_PARSENAME
00f8ec f129
00f8ed f03e          .dw XT_ZEROEQUAL,XT_DOCONDBRANCH 
00f8ee f8f2          DEST(CHAR_1)
00f8ef f045
00f8f0 fff0
00f8f1 f83c             .dw XT_DOLITERAL, -16, XT_THROW
                 CHAR_1:
                 
00f8f2 f0a9          .dw XT_CFETCH
00f8f3 f025          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
00f8f4 ff06          .dw $ff06
00f8f5 756e
00f8f6 626d
00f8f7 7265          .db "number"
00f8f8 f8e6          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
00f8f9 f000          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
00f8fa f54c          .dw XT_BASE
00f8fb f08a          .dw XT_FETCH
00f8fc f110          .dw XT_TO_R
00f8fd f93d          .dw XT_QSIGN
00f8fe f110          .dw XT_TO_R
00f8ff f950          .dw XT_SET_BASE
00f900 f93d          .dw XT_QSIGN
00f901 f107          .dw XT_R_FROM
00f902 f22d          .dw XT_OR
00f903 f110          .dw XT_TO_R
                     ; check whether something is left
00f904 f0c2          .dw XT_DUP
00f905 f129          .dw XT_ZEROEQUAL
00f906 f03e          .dw XT_DOCONDBRANCH
00f907 f910          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
00f908 f569            .dw XT_2DROP
00f909 f107            .dw XT_R_FROM
00f90a f0ea            .dw XT_DROP
00f90b f107            .dw XT_R_FROM
00f90c f54c            .dw XT_BASE
00f90d f092            .dw XT_STORE
00f90e f165            .dw XT_ZERO
00f90f f025            .dw XT_EXIT
                 PFA_NUMBER0:
00f910 f325          .dw XT_2TO_R
00f911 f165          .dw XT_ZERO       ; starting value
00f912 f165          .dw XT_ZERO
00f913 f334          .dw XT_2R_FROM
00f914 f96e          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
00f915 f0ca          .dw XT_QDUP
00f916 f03e          .dw XT_DOCONDBRANCH
00f917 f932          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
00f918 f3f7          .dw XT_ONE
00f919 f3f0          .dw XT_EQUAL
00f91a f03e          .dw XT_DOCONDBRANCH
00f91b f929          DEST(PFA_NUMBER2)
                 	; excatly one character is left
00f91c f0a9      	.dw XT_CFETCH
00f91d f045      	.dw XT_DOLITERAL
00f91e 002e      	.dw 46 ; .
00f91f f3f0      	.dw XT_EQUAL
00f920 f03e      	.dw XT_DOCONDBRANCH
00f921 f92a      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
00f922 f107      	.dw XT_R_FROM
00f923 f03e              .dw XT_DOCONDBRANCH
00f924 f926      	DEST(PFA_NUMBER3)
00f925 fd08              .dw XT_DNEGATE
                 PFA_NUMBER3:
00f926 f3fc      	.dw XT_TWO
00f927 f034      	.dw XT_DOBRANCH
00f928 f938      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
00f929 f0ea      	.dw XT_DROP
                 PFA_NUMBER6:
00f92a f569      	.dw XT_2DROP
00f92b f107      	.dw XT_R_FROM
00f92c f0ea      	.dw XT_DROP
00f92d f107              .dw XT_R_FROM
00f92e f54c              .dw XT_BASE
00f92f f092              .dw XT_STORE
00f930 f165      	.dw XT_ZERO
00f931 f025      	.dw XT_EXIT
                 PFA_NUMBER1:
00f932 f569          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
00f933 f107          .dw XT_R_FROM
00f934 f03e          .dw XT_DOCONDBRANCH
00f935 f937          DEST(PFA_NUMBER4)
00f936 f63a          .dw XT_NEGATE
                 PFA_NUMBER4:
00f937 f3f7          .dw XT_ONE
                 PFA_NUMBER5:
00f938 f107          .dw XT_R_FROM
00f939 f54c          .dw XT_BASE
00f93a f092          .dw XT_STORE
00f93b f15c          .dw XT_TRUE
00f93c f025          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
00f93d f000          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
00f93e f0e0          .dw XT_OVER    ; ( -- addr len addr )
00f93f f0a9          .dw XT_CFETCH
00f940 f045          .dw XT_DOLITERAL
00f941 002d          .dw '-'
00f942 f3f0          .dw XT_EQUAL  ; ( -- addr len flag )
00f943 f0c2          .dw XT_DUP
00f944 f110          .dw XT_TO_R
00f945 f03e          .dw XT_DOCONDBRANCH
00f946 f949          DEST(PFA_NUMBERSIGN_DONE)
00f947 f3f7          .dw XT_ONE    ; skip sign character
00f948 f9aa          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
00f949 f107          .dw XT_R_FROM
00f94a f025          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
00f94b f060          .dw PFA_DOCONSTANT
                 .endif
00f94c 000a
00f94d 0010
00f94e 0002
00f94f 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
00f950 f000          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
00f951 f0e0          .dw XT_OVER
00f952 f0a9          .dw XT_CFETCH
00f953 f045          .dw XT_DOLITERAL
00f954 0023          .dw 35
00f955 f1a4          .dw XT_MINUS
00f956 f0c2          .dw XT_DUP
00f957 f165          .dw XT_ZERO
00f958 f045          .dw XT_DOLITERAL
00f959 0004          .dw 4
00f95a f672          .dw XT_WITHIN
00f95b f03e          .dw XT_DOCONDBRANCH
00f95c f966          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
00f95d f94b      	.dw XT_BASES
00f95e f1ae      	.dw XT_PLUS
00f95f f3d8      	.dw XT_FETCHI
00f960 f54c      	.dw XT_BASE
00f961 f092      	.dw XT_STORE
00f962 f3f7      	.dw XT_ONE
00f963 f9aa      	.dw XT_SLASHSTRING
00f964 f034      	.dw XT_DOBRANCH
00f965 f967      	DEST(SET_BASE2)
                 SET_BASE1:
00f966 f0ea      	.dw XT_DROP
                 SET_BASE2:
00f967 f025          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
00f968 ff07          .dw $ff07
00f969 6e3e
00f96a 6d75
00f96b 6562
00f96c 0072          .db ">number",0
00f96d f8f4          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
00f96e f000          .dw DO_COLON
                 
                 .endif
                 
00f96f f0c2
00f970 f03e      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
00f971 f986              DEST(TONUM3)
00f972 f0e0
00f973 f0a9
00f974 f74e              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
00f975 f129
00f976 f03e              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
00f977 f97a              DEST(TONUM2)
00f978 f0ea
00f979 f025              .DW XT_DROP,XT_EXIT
00f97a f110
00f97b fd2c
00f97c f54c
00f97d f08a
00f97e 0114      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
00f97f f107
00f980 010c
00f981 fd2c              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
00f982 f3f7
00f983 f9aa
00f984 f034              .DW XT_ONE,XT_SLASHSTRING,XT_DOBRANCH
00f985 f96f              DEST(TONUM1)
00f986 f025      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
00f987 ff05          .dw $ff05
00f988 6170
00f989 7372
00f98a 0065          .db "parse",0
00f98b f968          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
00f98c f000          .dw DO_COLON
                 PFA_PARSE:
                 .endif
00f98d f110          .dw XT_TO_R     ; ( -- )
00f98e f9a0          .dw XT_SOURCE   ; ( -- addr len)
00f98f f579          .dw XT_TO_IN     ; ( -- addr len >in)
00f990 f08a          .dw XT_FETCH
00f991 f9aa          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
00f992 f107          .dw XT_R_FROM      ; ( -- addr' len' c)
00f993 f869          .dw XT_CSCAN       ; ( -- addr' len'')
00f994 f0c2          .dw XT_DUP         ; ( -- addr' len'' len'')
00f995 f240          .dw XT_1PLUS
00f996 f579          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
00f997 f276          .dw XT_PLUSSTORE   ; ( -- addr' len')
00f998 f3f7          .dw XT_ONE
00f999 f9aa          .dw XT_SLASHSTRING
00f99a f025          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCE:
00f99b ff06          .dw $FF06
00f99c 6f73
00f99d 7275
00f99e 6563          .db "source"
00f99f f987          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
00f9a0 fc29          .dw PFA_DODEFER1
                 PFA_SOURCE:
                 .endif
00f9a1 0016          .dw USER_SOURCE
00f9a2 fbf2          .dw XT_UDEFERFETCH
00f9a3 fbfe          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
00f9a4 ff07          .dw $ff07
00f9a5 732f
00f9a6 7274
00f9a7 6e69
00f9a8 0067          .db "/string",0
00f9a9 f99b          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
00f9aa f000          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
00f9ab f0f2          .dw XT_ROT
00f9ac f0e0          .dw XT_OVER
00f9ad f1ae          .dw XT_PLUS
00f9ae f0f2          .dw XT_ROT
00f9af f0f2          .dw XT_ROT
00f9b0 f1a4          .dw XT_MINUS
00f9b1 f025          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
00f9b2 ff0a          .dw $FF0A 
00f9b3 6170
00f9b4 7372
00f9b5 2d65
00f9b6 616e
00f9b7 656d          .db "parse-name"
00f9b8 f9a4          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
00f9b9 f000          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
00f9ba f5eb          .dw XT_BL
00f9bb f9bd          .dw XT_SKIPSCANCHAR
00f9bc f025          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
00f9bd f000          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
00f9be f110          .dw XT_TO_R
00f9bf f9a0          .dw XT_SOURCE 
00f9c0 f579          .dw XT_TO_IN 
00f9c1 f08a          .dw XT_FETCH 
00f9c2 f9aa          .dw XT_SLASHSTRING 
                 
00f9c3 f117          .dw XT_R_FETCH
00f9c4 f852          .dw XT_CSKIP
00f9c5 f107          .dw XT_R_FROM
00f9c6 f869          .dw XT_CSCAN
                 
                     ; adjust >IN
00f9c7 f560          .dw XT_2DUP
00f9c8 f1ae          .dw XT_PLUS
00f9c9 f9a0          .dw XT_SOURCE 
00f9ca f0ea          .dw XT_DROP
00f9cb f1a4          .dw XT_MINUS
00f9cc f579          .dw XT_TO_IN
00f9cd f092          .dw XT_STORE
00f9ce f025          .dw XT_EXIT
                 .include "words/find-xt.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the xt from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDXT:
00f9cf ff07          .dw $ff07
00f9d0 6966
00f9d1 646e
00f9d2 782d
00f9d3 0074          .db "find-xt",0
00f9d4 f9b2          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDXT
                 XT_FINDXT:
00f9d5 f000          .dw DO_COLON
                 PFA_FINDXT:
                 .endif
00f9d6 f045          .dw XT_DOLITERAL
00f9d7 f9e1          .dw XT_FINDXTA
00f9d8 f045          .dw XT_DOLITERAL
00f9d9 005c          .dw CFG_ORDERLISTLEN
00f9da 03e7          .dw XT_MAPSTACK
00f9db f129          .dw XT_ZEROEQUAL
00f9dc f03e          .dw XT_DOCONDBRANCH
00f9dd f9e0          DEST(PFA_FINDXT1)
00f9de f569            .dw XT_2DROP
00f9df f165            .dw XT_ZERO
                 PFA_FINDXT1:
00f9e0 f025          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDXTA:
00f9e1 f000          .dw DO_COLON
                 PFA_FINDXTA:
                 .endif
00f9e2 f110          .dw XT_TO_R
00f9e3 f560          .dw XT_2DUP
00f9e4 f107          .dw XT_R_FROM
00f9e5 fc3b          .dw XT_SEARCH_WORDLIST
00f9e6 f0c2          .dw XT_DUP
00f9e7 f03e          .dw XT_DOCONDBRANCH
00f9e8 f9ee          DEST(PFA_FINDXTA1)
00f9e9 f110            .dw XT_TO_R
00f9ea f101            .dw XT_NIP
00f9eb f101            .dw XT_NIP
00f9ec f107            .dw XT_R_FROM
00f9ed f15c            .dw XT_TRUE
                 PFA_FINDXTA1:
00f9ee f025          .dw XT_EXIT
                 
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_DEFAULT_PROMPTOK:
00f9ef f000          .dw DO_COLON
                 PFA_DEFAULT_PROMPTOK:
00f9f0 f768          .dw XT_DOSLITERAL
00f9f1 0003          .dw 3
00f9f2 6f20
00f9f3 006b          .db " ok",0
                 .endif
00f9f4 f79b          .dw XT_ITYPE
00f9f5 f025          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTOK:
00f9f6 ff03          .dw $FF03
00f9f7 6f2e
../../common\words/prompt-ok.asm(43): warning: .cseg .db misalignment - padding zero byte
00f9f8 006b          .db ".ok"
00f9f9 f9cf          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
00f9fa fc29          .dw PFA_DODEFER1
                 PFA_PROMPTOK:
                 .endif
00f9fb 001c          .dw USER_P_OK
00f9fc fbf2          .dw XT_UDEFERFETCH
00f9fd fbfe          .dw XT_UDEFERSTORE
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_DEFAULT_PROMPTREADY:
00f9fe f000          .dw DO_COLON
                 PFA_DEFAULT_PROMPTREADY:
00f9ff f768          .dw XT_DOSLITERAL
00fa00 0002          .dw 2
00fa01 203e          .db "> "
                 .endif
00fa02 f7d0          .dw XT_CR
00fa03 f79b          .dw XT_ITYPE
00fa04 f025          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTREADY:
00fa05 ff06          .dw $FF06
00fa06 722e
00fa07 6165
00fa08 7964          .db ".ready"
00fa09 f9f6          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTREADY
                 XT_PROMPTREADY:
00fa0a fc29          .dw PFA_DODEFER1
                 PFA_PROMPTREADY:
                 .endif
00fa0b 0020          .dw USER_P_RDY
00fa0c fbf2          .dw XT_UDEFERFETCH
00fa0d fbfe          .dw XT_UDEFERSTORE
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_DEFAULT_PROMPTERROR:
00fa0e f000          .dw DO_COLON
                 PFA_DEFAULT_PROMPTERROR:
00fa0f f768      	.dw XT_DOSLITERAL
00fa10 0004          .dw 4
00fa11 3f20
00fa12 203f          .db " ?? "
                 .endif
00fa13 f79b          .dw XT_ITYPE
00fa14 f54c          .dw XT_BASE
00fa15 f08a          .dw XT_FETCH
00fa16 f110          .dw XT_TO_R
00fa17 f5d8          .dw XT_DECIMAL
00fa18 f71d          .dw XT_DOT
00fa19 f579          .dw XT_TO_IN
00fa1a f08a          .dw XT_FETCH
00fa1b f71d          .dw XT_DOT
00fa1c f107          .dw XT_R_FROM
00fa1d f54c          .dw XT_BASE
00fa1e f092          .dw XT_STORE
00fa1f f025          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTERROR:
00fa20 ff06          .dw $FF06
00fa21 652e
00fa22 7272
00fa23 726f          .db ".error"
00fa24 fa05          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
00fa25 fc29          .dw PFA_DODEFER1
                 PFA_PROMPTERROR:
                 .endif
00fa26 001e          .dw USER_P_ERR
00fa27 fbf2          .dw XT_UDEFERFETCH
00fa28 fbfe          .dw XT_UDEFERSTORE
                 .include "words/prompt-input.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_DEFAULT_PROMPTINPUT:
00fa29 f000          .dw DO_COLON
                 PFA_DEFAULT_PROMPTINPUT:
                 .endif
00fa2a f7d0          .dw XT_CR
00fa2b f025          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTINPUT:
00fa2c ff06          .dw $FF06
00fa2d 692e
00fa2e 706e
00fa2f 7475          .db ".input"
00fa30 fa20          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTINPUT
                 XT_PROMPTINPUT:
00fa31 fc29          .dw PFA_DODEFER1
                 PFA_PROMPTINPUT:
                 .endif
00fa32 0022          .dw USER_P_INPUT
00fa33 fbf2          .dw XT_UDEFERFETCH
00fa34 fbfe          .dw XT_UDEFERSTORE
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
00fa35 ff04          .dw $ff04
00fa36 7571
00fa37 7469          .db "quit"
00fa38 fa2c          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
00fa39 f000          .dw DO_COLON
                 .endif
                 PFA_QUIT:
00fa3a 029c
00fa3b 02a3
00fa3c f092          .dw XT_LP0,XT_LP,XT_STORE
00fa3d fa9b          .dw XT_SP0
00fa3e f2a7          .dw XT_SP_STORE
00fa3f faa3          .dw XT_RP0
00fa40 f291          .dw XT_RP_STORE
00fa41 0331          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
00fa42 f546          .dw XT_STATE
00fa43 f08a          .dw XT_FETCH
00fa44 f129          .dw XT_ZEROEQUAL
00fa45 f03e          .dw XT_DOCONDBRANCH
00fa46 fa48          DEST(PFA_QUIT4)
00fa47 fa0a          .dw XT_PROMPTREADY
                 PFA_QUIT4:
00fa48 f8e2          .dw XT_REFILL
00fa49 fa31          .dw XT_PROMPTINPUT
00fa4a f03e          .dw XT_DOCONDBRANCH
00fa4b fa5b          DEST(PFA_QUIT3)
00fa4c f045          .dw XT_DOLITERAL
00fa4d fabc          .dw XT_INTERPRET
00fa4e f826          .dw XT_CATCH
00fa4f f0ca          .dw XT_QDUP
00fa50 f03e          .dw XT_DOCONDBRANCH
00fa51 fa5b          DEST(PFA_QUIT3)
00fa52 f0c2      	.dw XT_DUP
00fa53 f045      	.dw XT_DOLITERAL
00fa54 fffe      	.dw -2
00fa55 f17f      	.dw XT_LESS
00fa56 f03e      	.dw XT_DOCONDBRANCH
00fa57 fa59      	DEST(PFA_QUIT5)
00fa58 fa25      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
00fa59 f034      	.dw XT_DOBRANCH
00fa5a fa3a      	DEST(PFA_QUIT)
                 PFA_QUIT3:
00fa5b f9fa          .dw XT_PROMPTOK
00fa5c f034          .dw XT_DOBRANCH
00fa5d fa42          DEST(PFA_QUIT2)
                 ;    .dw XT_EXIT ; never reached
                 
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
00fa5e ff05          .dw $ff05
00fa5f 6170
00fa60 7375
00fa61 0065          .db "pause",0
00fa62 fa35          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
00fa63 fc29          .dw PFA_DODEFER1
                 PFA_PAUSE:
00fa64 0141          .dw ram_pause
00fa65 fbde          .dw XT_RDEFERFETCH
00fa66 fbe8          .dw XT_RDEFERSTORE
                 
                 .dseg
000141           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
00fa67 ff04          .dw $ff04
00fa68 6f63
00fa69 646c          .db "cold"
00fa6a fa5e          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
00fa6b fa6c          .dw PFA_COLD
                 PFA_COLD:
00fa6c b6a4          in_ mcu_boot, MCUSR
00fa6d 2422          clr zerol
00fa6e 2433          clr zeroh
00fa6f 24bb          clr isrflag
00fa70 be24          out_ MCUSR, zerol
                     ; clear RAM
00fa71 e0e0          ldi zl, low(ramstart)
00fa72 e0f1          ldi zh, high(ramstart)
                 clearloop:
00fa73 9221          st Z+, zerol
00fa74 30e0          cpi zl, low(sram_size+ramstart)
00fa75 f7e9          brne clearloop
00fa76 34f1          cpi zh, high(sram_size+ramstart)
00fa77 f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000143           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
00fa78 e4e3          ldi zl, low(ram_user1)
00fa79 e0f1          ldi zh, high(ram_user1)
00fa7a 012f          movw upl, zl
                     ; init return stack pointer
00fa7b ef0f          ldi temp0,low(rstackstart)
00fa7c bf0d          out_ SPL,temp0
00fa7d 8304          std Z+4, temp0
00fa7e e410          ldi temp1,high(rstackstart)
00fa7f bf1e          out_ SPH,temp1
00fa80 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
00fa81 eacf          ldi yl,low(stackstart)
00fa82 83c6          std Z+6, yl
00fa83 e4d0          ldi yh,high(stackstart)
00fa84 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
00fa85 e8ae          ldi XL, low(PFA_WARM)
00fa86 efba          ldi XH, high(PFA_WARM)
                     ; its a far jump...
00fa87 940c f004     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WARM:
00fa89 ff04          .dw $ff04
00fa8a 6177
00fa8b 6d72          .db "warm"
00fa8c fa67          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
00fa8d f000          .dw DO_COLON
                 PFA_WARM:
                 .endif
00fa8e fd77          .dw XT_INIT_RAM
00fa8f f045          .dw XT_DOLITERAL
00fa90 fb95          .dw XT_NOOP
00fa91 f045          .dw XT_DOLITERAL
00fa92 fa63          .dw XT_PAUSE
00fa93 fc09          .dw XT_DEFERSTORE
00fa94 0331          .dw XT_LBRACKET
00fa95 f5f3          .dw XT_TURNKEY
00fa96 fa39          .dw XT_QUIT     ; never returns
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
00fa97 ff03          .dw $ff03
00fa98 7073
00fa99 0030          .db "sp0",0
00fa9a fa89          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
00fa9b f080          .dw PFA_DOVALUE1
                 PFA_SP0:
00fa9c 0006          .dw USER_SP0
00fa9d fbf2          .dw XT_UDEFERFETCH
00fa9e fbfe          .dw XT_UDEFERSTORE
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
00fa9f ff03          .dw $ff03
00faa0 7072
00faa1 0030          .db "rp0",0
00faa2 fa97          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
00faa3 f000          .dw DO_COLON
                 PFA_RP0:
00faa4 faa7          .dw XT_DORP0
00faa5 f08a          .dw XT_FETCH
00faa6 f025          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
00faa7 f066          .dw PFA_DOUSER
                 PFA_DORP0:
00faa8 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
00faa9 ff05          .dw $ff05
00faaa 6564
00faab 7470
00faac 0068          .db "depth",0
00faad fa9f          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
00faae f000          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
00faaf fa9b          .dw XT_SP0
00fab0 f29e          .dw XT_SP_FETCH
00fab1 f1a4          .dw XT_MINUS
00fab2 f215          .dw XT_2SLASH
00fab3 f246          .dw XT_1MINUS
00fab4 f025          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
00fab5 ff09          .dw $ff09
00fab6 6e69
00fab7 6574
00fab8 7072
00fab9 6572
00faba 0074          .db "interpret",0
00fabb faa9          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
00fabc f000          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
00fabd f9b9          .dw XT_PARSENAME ; ( -- addr len )
00fabe f0c2          .dw XT_DUP   ; ( -- addr len flag)
00fabf f03e          .dw XT_DOCONDBRANCH
00fac0 facd          DEST(PFA_INTERPRET2)
00fac1 fad9            .dw XT_FORTHRECOGNIZER
00fac2 fae4            .dw XT_RECOGNIZE
00fac3 f546            .dw XT_STATE
00fac4 f08a            .dw XT_FETCH
00fac5 f03e            .dw XT_DOCONDBRANCH
00fac6 fac8          DEST(PFA_INTERPRET1)
00fac7 fbc1            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
00fac8 f3d8            .dw XT_FETCHI
00fac9 f02f            .dw XT_EXECUTE
00faca fb6d            .dw XT_QSTACK
00facb f034          .dw XT_DOBRANCH
00facc fabd          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
00facd f569          .dw XT_2DROP
00face f025          .dw XT_EXIT
                 .include "words/forth-recognizer.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_FORTHRECOGNIZER:
00facf ff10          .dw $ff10
00fad0 6f66
00fad1 7472
00fad2 2d68
00fad3 6572
00fad4 6f63
00fad5 6e67
00fad6 7a69
00fad7 7265          .db "forth-recognizer"
00fad8 fab5          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHRECOGNIZER
                 XT_FORTHRECOGNIZER:
00fad9 f080          .dw PFA_DOVALUE1
                 PFA_FORTHRECOGNIZER:
00fada 0050          .dw CFG_FORTHRECOGNIZER
00fadb fbca          .dw XT_EDEFERFETCH
00fadc fbd4          .dw XT_EDEFERSTORE
                 .include "words/recognize.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECOGNIZE:
00fadd ff09          .dw $ff09
00fade 6572
00fadf 6f63
00fae0 6e67
00fae1 7a69
00fae2 0065          .db "recognize",0
00fae3 facf          .dw VE_HEAD
                     .set VE_HEAD = VE_RECOGNIZE
                 XT_RECOGNIZE:
00fae4 f000          .dw DO_COLON
                 PFA_RECOGNIZE:
                 .endif
00fae5 f045          .dw XT_DOLITERAL
00fae6 faef          .dw XT_RECOGNIZE_A
00fae7 f0d5          .dw XT_SWAP
00fae8 03e7          .dw XT_MAPSTACK
00fae9 f129          .dw XT_ZEROEQUAL
00faea f03e          .dw XT_DOCONDBRANCH
00faeb faee          DEST(PFA_RECOGNIZE1)
00faec f569            .dw XT_2DROP
00faed fb60            .dw XT_RECTYPE_NULL
                 PFA_RECOGNIZE1:
00faee f025          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ; ( addr len XT -- addr len [ rectype-* -1 | 0 ] )
                 XT_RECOGNIZE_A:
00faef f000         .dw DO_COLON
                 PFA_RECOGNIZE_A:
                 .endif
00faf0 f0f2         .dw XT_ROT  ; -- len xt addr
00faf1 f0f2         .dw XT_ROT  ; -- xt addr len
00faf2 f560         .dw XT_2DUP 
00faf3 f325         .dw XT_2TO_R
00faf4 f0f2         .dw XT_ROT  ; -- addr len xt
00faf5 f02f         .dw XT_EXECUTE ; -- i*x rectype-* | rectype-null
00faf6 f334         .dw XT_2R_FROM
00faf7 f0f2         .dw XT_ROT
00faf8 f0c2         .dw XT_DUP
00faf9 fb60         .dw XT_RECTYPE_NULL
00fafa f3f0         .dw XT_EQUAL
00fafb f03e         .dw XT_DOCONDBRANCH
00fafc fb00         DEST(PFA_RECOGNIZE_A1)
00fafd f0ea           .dw XT_DROP
00fafe f165           .dw XT_ZERO
00faff f025           .dw XT_EXIT
                 PFA_RECOGNIZE_A1:
00fb00 f101         .dw XT_NIP 
00fb01 f101         .dw XT_NIP
00fb02 f15c         .dw XT_TRUE
00fb03 f025         .dw XT_EXIT
                 
                 ; : recognize ( addr len stack-id -- i*x rectype-* | rectype-null )
                 ;   [: ( addr len -- addr len 0 | i*x rectype-* -1 )
                 ;      rot rot 2dup 2>r rot execute 2r> rot 
                 ;      dup rectype-null = ( -- addr len rectype-* f )
                 ;      if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    map-stack ( -- i*x addr len rectype-* f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop rectype-null
                 ;    then ;
                 ;
                 .include "words/rec-intnum.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_NUM:
00fb04 ff0b          .dw $ff0b
00fb05 6572
00fb06 7463
00fb07 7079
00fb08 2d65
00fb09 756e
00fb0a 006d          .db "rectype-num",0
00fb0b fadd          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_NUM
                 XT_RECTYPE_NUM:
00fb0c f060          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_NUM:
                 .endif
00fb0d fb95          .dw XT_NOOP    ; interpret
00fb0e 01bd          .dw XT_LITERAL ; compile
00fb0f 01bd          .dw XT_LITERAL ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_DNUM:
00fb10 ff0c          .dw $ff0c
00fb11 6572
00fb12 7463
00fb13 7079
00fb14 2d65
00fb15 6e64
00fb16 6d75          .db "rectype-dnum"
00fb17 fb04          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_DNUM
                 XT_RECTYPE_DNUM:
00fb18 f060          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_DNUM:
                 .endif
00fb19 fb95          .dw XT_NOOP     ; interpret
00fb1a f3e8          .dw XT_2LITERAL ; compile
00fb1b f3e8          .dw XT_2LITERAL ; postpone
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
00fb1c ff07          .dw $ff07
00fb1d 6572
00fb1e 2d63
00fb1f 756e
00fb20 006d          .db "rec-num",0
00fb21 fb10          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
00fb22 f000          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
00fb23 f8f9          .dw XT_NUMBER
00fb24 f03e          .dw XT_DOCONDBRANCH
00fb25 fb2e          DEST(PFA_REC_NONUMBER)
00fb26 f3f7          .dw XT_ONE
00fb27 f3f0          .dw XT_EQUAL
00fb28 f03e          .dw XT_DOCONDBRANCH
00fb29 fb2c          DEST(PFA_REC_INTNUM2)
00fb2a fb0c            .dw XT_RECTYPE_NUM
00fb2b f025            .dw XT_EXIT
                 PFA_REC_INTNUM2:
00fb2c fb18            .dw XT_RECTYPE_DNUM
00fb2d f025            .dw XT_EXIT
                 PFA_REC_NONUMBER:
00fb2e fb60          .dw XT_RECTYPE_NULL
00fb2f f025          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_FIND:
00fb30 ff08          .dw $ff08
00fb31 6572
00fb32 2d63
00fb33 6966
00fb34 646e          .db "rec-find"
00fb35 fb1c          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
00fb36 f000          .dw DO_COLON
                 PFA_REC_FIND:
                 .endif
00fb37 f9d5          .DW XT_FINDXT
00fb38 f0c2          .dw XT_DUP
00fb39 f129          .dw XT_ZEROEQUAL
00fb3a f03e          .dw XT_DOCONDBRANCH
00fb3b fb3f          DEST(PFA_REC_WORD_FOUND)
00fb3c f0ea              .dw XT_DROP
00fb3d fb60      	.dw XT_RECTYPE_NULL
00fb3e f025      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
00fb3f fb48          .dw XT_RECTYPE_XT
                 
00fb40 f025          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_XT:
00fb41 ff0a          .dw $ff0a
00fb42 6572
00fb43 7463
00fb44 7079
00fb45 2d65
00fb46 7478          .db "rectype-xt"
00fb47 fb30          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_XT
                 XT_RECTYPE_XT:
00fb48 f060          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_XT:
                 .endif
00fb49 fb4c          .dw XT_R_WORD_INTERPRET
00fb4a fb50          .dw XT_R_WORD_COMPILE
00fb4b f3e8          .dw XT_2LITERAL
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
00fb4c f000          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
00fb4d f0ea          .dw XT_DROP ; the flags are in the way
00fb4e f02f          .dw XT_EXECUTE
00fb4f f025          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
00fb50 f000          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
00fb51 f130          .dw XT_ZEROLESS
00fb52 f03e          .dw XT_DOCONDBRANCH
00fb53 fb56          DEST(PFA_R_WORD_COMPILE1)
00fb54 01a7      	.dw XT_COMMA
00fb55 f025              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
00fb56 f02f              .dw XT_EXECUTE
00fb57 f025          .dw XT_EXIT
                 .include "words/rec-null.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_NULL:
00fb58 ff0c          .dw $ff0c
00fb59 6572
00fb5a 7463
00fb5b 7079
00fb5c 2d65
00fb5d 756e
00fb5e 6c6c          .db "rectype-null"
00fb5f fb41          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_NULL
                 XT_RECTYPE_NULL:
00fb60 f060          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_NULL:
                 .endif
00fb61 fb64          .dw XT_FAIL  ; interpret
00fb62 fb64          .dw XT_FAIL  ; compile
00fb63 fb64          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
00fb64 f000          .dw DO_COLON
                 PFA_FAIL:
                 .endif
00fb65 f045          .dw XT_DOLITERAL
00fb66 fff3          .dw -13
00fb67 f83c          .dw XT_THROW
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
00fb68 ff06          .dw $ff06
00fb69 733f
00fb6a 6174
00fb6b 6b63          .db "?stack"
00fb6c fb58          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
00fb6d f000          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
00fb6e faae          .dw XT_DEPTH
00fb6f f130          .dw XT_ZEROLESS
00fb70 f03e          .dw XT_DOCONDBRANCH
00fb71 fb75          DEST(PFA_QSTACK1)
00fb72 f045            .dw XT_DOLITERAL
00fb73 fffc            .dw -4
00fb74 f83c            .dw XT_THROW
                 PFA_QSTACK1:
00fb75 f025          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
00fb76 ff03          .dw $ff03
00fb77 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
00fb78 0072          .db "ver"
00fb79 fb68          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
00fb7a f000          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
00fb7b f508          .dw XT_ENV_FORTHNAME
00fb7c f79b          .dw XT_ITYPE
00fb7d f7dd          .dw XT_SPACE
00fb7e f54c          .dw XT_BASE
00fb7f f08a          .dw XT_FETCH
                 
00fb80 f516          .dw XT_ENV_FORTHVERSION
00fb81 f5d8          .dw XT_DECIMAL
00fb82 fd8e          .dw XT_S2D
00fb83 f6b9          .dw XT_L_SHARP
00fb84 f6c1          .dw XT_SHARP
00fb85 f045          .dw XT_DOLITERAL
00fb86 002e          .dw '.'
00fb87 f6aa          .dw XT_HOLD
00fb88 f6d7          .dw XT_SHARP_S
00fb89 f6e2          .dw XT_SHARP_G
00fb8a f7f6          .dw XT_TYPE
00fb8b f54c          .dw XT_BASE
00fb8c f092          .dw XT_STORE
00fb8d f7dd          .dw XT_SPACE
00fb8e f51e          .dw XT_ENV_CPU
00fb8f f79b          .dw XT_ITYPE
                 
00fb90 f025          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOOP:
00fb91 ff04          .dw $ff04
00fb92 6f6e
00fb93 706f          .db "noop"
00fb94 fb76          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
00fb95 f000          .dw DO_COLON
                 PFA_NOOP:
                 .endif
00fb96 f025         .DW XT_EXIT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
00fb97 ff06          .dw $ff06
00fb98 6e75
00fb99 7375
00fb9a 6465          .db "unused"
00fb9b fb91          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
00fb9c f000          .dw DO_COLON
                 PFA_UNUSED:
00fb9d f29e          .dw XT_SP_FETCH
00fb9e f5ba          .dw XT_HERE
00fb9f f1a4          .dw XT_MINUS
00fba0 f025          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
00fba1 0002          .dw $0002
00fba2 6f74          .db "to"
00fba3 fb97          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
00fba4 f000          .dw DO_COLON
                 PFA_TO:
                 .endif
00fba5 f805          .dw XT_TICK
00fba6 fd97          .dw XT_TO_BODY
00fba7 f546          .dw XT_STATE
00fba8 f08a          .dw XT_FETCH
00fba9 f03e          .dw XT_DOCONDBRANCH
00fbaa fbb5          DEST(PFA_TO1)
00fbab 019c          .dw XT_COMPILE
00fbac fbaf          .dw XT_DOTO
00fbad 01a7          .dw XT_COMMA
00fbae f025          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
00fbaf f000          .dw DO_COLON
                 PFA_DOTO:
                 .endif
00fbb0 f107          .dw XT_R_FROM
00fbb1 f0c2          .dw XT_DUP
00fbb2 fbc1          .dw XT_ICELLPLUS
00fbb3 f110          .dw XT_TO_R
00fbb4 f3d8          .dw XT_FETCHI
                 PFA_TO1:
00fbb5 f0c2          .dw XT_DUP
00fbb6 fbc1          .dw XT_ICELLPLUS
00fbb7 fbc1          .dw XT_ICELLPLUS
00fbb8 f3d8          .dw XT_FETCHI
00fbb9 f02f          .dw XT_EXECUTE
00fbba f025          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
00fbbb ff07          .dw $FF07
00fbbc 2d69
00fbbd 6563
00fbbe 6c6c
00fbbf 002b          .db "i-cell+",0
00fbc0 fba1          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
00fbc1 f000          .dw DO_COLON
                 PFA_ICELLPLUS:
00fbc2 f240          .dw XT_1PLUS
00fbc3 f025          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
00fbc4 ff07          .dw $ff07
00fbc5 6445
00fbc6 6665
00fbc7 7265
00fbc8 0040          .db "Edefer@",0
00fbc9 fbbb          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
00fbca f000          .dw DO_COLON
                 PFA_EDEFERFETCH:
00fbcb f3d8          .dw XT_FETCHI
00fbcc f366          .dw XT_FETCHE
00fbcd f025          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
00fbce ff07          .dw $ff07
00fbcf 6445
00fbd0 6665
00fbd1 7265
00fbd2 0021          .db "Edefer!",0
00fbd3 fbc4          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
00fbd4 f000          .dw DO_COLON
                 PFA_EDEFERSTORE:
00fbd5 f3d8          .dw XT_FETCHI
00fbd6 f342          .dw XT_STOREE
00fbd7 f025          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
00fbd8 ff07          .dw $ff07
00fbd9 6452
00fbda 6665
00fbdb 7265
00fbdc 0040          .db "Rdefer@",0
00fbdd fbce          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
00fbde f000          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
00fbdf f3d8          .dw XT_FETCHI
00fbe0 f08a          .dw XT_FETCH
00fbe1 f025          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
00fbe2 ff07          .dw $ff07
00fbe3 6452
00fbe4 6665
00fbe5 7265
00fbe6 0021          .db "Rdefer!",0
00fbe7 fbd8          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
00fbe8 f000          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
00fbe9 f3d8          .dw XT_FETCHI
00fbea f092          .dw XT_STORE
00fbeb f025          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
00fbec ff07          .dw $ff07
00fbed 6455
00fbee 6665
00fbef 7265
00fbf0 0040          .db "Udefer@",0
00fbf1 fbe2          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
00fbf2 f000          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
00fbf3 f3d8          .dw XT_FETCHI
00fbf4 f313          .dw XT_UP_FETCH
00fbf5 f1ae          .dw XT_PLUS
00fbf6 f08a          .dw XT_FETCH
00fbf7 f025          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
00fbf8 ff07          .dw $ff07
00fbf9 6455
00fbfa 6665
00fbfb 7265
00fbfc 0021          .db "Udefer!",0
00fbfd fbec          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
00fbfe f000          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
00fbff f3d8          .dw XT_FETCHI
00fc00 f313          .dw XT_UP_FETCH
00fc01 f1ae          .dw XT_PLUS
00fc02 f092          .dw XT_STORE
00fc03 f025          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
00fc04 ff06          .dw $ff06
00fc05 6564
00fc06 6566
00fc07 2172          .db "defer!"
00fc08 fbf8          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
00fc09 f000          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
00fc0a fd97          .dw XT_TO_BODY
00fc0b f0c2          .dw XT_DUP
00fc0c fbc1          .dw XT_ICELLPLUS
00fc0d fbc1          .dw XT_ICELLPLUS
00fc0e f3d8          .dw XT_FETCHI
00fc0f f02f          .dw XT_EXECUTE
00fc10 f025          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
00fc11 ff06          .dw $ff06
00fc12 6564
00fc13 6566
00fc14 4072          .db "defer@"
00fc15 fc04          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
00fc16 f000          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
00fc17 fd97          .dw XT_TO_BODY 
00fc18 f0c2          .dw XT_DUP
00fc19 fbc1          .dw XT_ICELLPLUS
00fc1a f3d8          .dw XT_FETCHI
00fc1b f02f          .dw XT_EXECUTE
00fc1c f025          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
00fc1d ff07          .dw $ff07
00fc1e 6428
00fc1f 6665
00fc20 7265
00fc21 0029          .db "(defer)", 0
00fc22 fc11          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
00fc23 f000          .dw DO_COLON
                 PFA_DODEFER:
00fc24 016e          .dw XT_DOCREATE
00fc25 02d9          .dw XT_REVEAL
00fc26 019c          .dw XT_COMPILE
00fc27 fc29          .dw PFA_DODEFER1
00fc28 f025          .dw XT_EXIT
                 PFA_DODEFER1:
00fc29 940e 02f2     call_ DO_DODOES
00fc2b f0c2          .dw XT_DUP
00fc2c fbc1          .dw XT_ICELLPLUS
00fc2d f3d8          .dw XT_FETCHI
00fc2e f02f          .dw XT_EXECUTE 
00fc2f f02f          .dw XT_EXECUTE
00fc30 f025          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
00fc31 ff0f          .dw $ff0f
00fc32 6573
00fc33 7261
00fc34 6863
00fc35 772d
00fc36 726f
00fc37 6c64
00fc38 7369
00fc39 0074          .db "search-wordlist",0
00fc3a fc1d          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
00fc3b f000          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
00fc3c f110          .dw XT_TO_R
00fc3d f165          .dw XT_ZERO
00fc3e f045          .dw XT_DOLITERAL
00fc3f fc50          .dw XT_ISWORD
00fc40 f107          .dw XT_R_FROM
00fc41 fc6d          .dw XT_TRAVERSEWORDLIST
00fc42 f0c2          .dw XT_DUP
00fc43 f129          .dw XT_ZEROEQUAL
00fc44 f03e          .dw XT_DOCONDBRANCH
00fc45 fc4a          DEST(PFA_SEARCH_WORDLIST1)
00fc46 f569             .dw XT_2DROP
00fc47 f0ea             .dw XT_DROP
00fc48 f165             .dw XT_ZERO
00fc49 f025             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
00fc4a f0c2            .dw XT_DUP
00fc4b fc94            .dw XT_NFA2CFA
                       ; .. and get the header flag
00fc4c f0d5            .dw XT_SWAP
00fc4d 0149            .dw XT_NAME2FLAGS
00fc4e 0137            .dw XT_IMMEDIATEQ
00fc4f f025          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
00fc50 f000          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
00fc51 f110          .dw XT_TO_R
00fc52 f0ea          .dw XT_DROP
00fc53 f560          .dw XT_2DUP
00fc54 f117          .dw XT_R_FETCH  ; -- addr len addr len nt
00fc55 fc88          .dw XT_NAME2STRING
00fc56 fc9e          .dw XT_ICOMPARE      ; (-- addr len f )
00fc57 f03e          .dw XT_DOCONDBRANCH
00fc58 fc5e          DEST(PFA_ISWORD3)
                       ; not now
00fc59 f107            .dw XT_R_FROM
00fc5a f0ea            .dw XT_DROP
00fc5b f165            .dw XT_ZERO
00fc5c f15c            .dw XT_TRUE         ; maybe next word
00fc5d f025            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
00fc5e f569            .dw XT_2DROP
00fc5f f107            .dw XT_R_FROM
00fc60 f165            .dw XT_ZERO       ; finish traverse-wordlist
00fc61 f025            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
00fc62 ff11          .dw $ff11
00fc63 7274
00fc64 7661
00fc65 7265
00fc66 6573
00fc67 772d
00fc68 726f
00fc69 6c64
00fc6a 7369
00fc6b 0074          .db "traverse-wordlist",0
00fc6c fc31          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
00fc6d f000          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
00fc6e f366          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
00fc6f f0c2          .dw XT_DUP           ; ( -- xt nt nt )
00fc70 f03e          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
00fc71 fc7e          DEST(PFA_TRAVERSEWORDLIST2)
00fc72 f560          .dw XT_2DUP
00fc73 f325          .dw XT_2TO_R
00fc74 f0d5          .dw XT_SWAP
00fc75 f02f          .dw XT_EXECUTE
00fc76 f334          .dw XT_2R_FROM
00fc77 f0f2          .dw XT_ROT
00fc78 f03e          .dw XT_DOCONDBRANCH
00fc79 fc7e          DEST(PFA_TRAVERSEWORDLIST2)
00fc7a 0452          .dw XT_NFA2LFA
00fc7b f3d8          .dw XT_FETCHI
00fc7c f034          .dw XT_DOBRANCH      ; ( -- addr )
00fc7d fc6f          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
00fc7e f569          .dw XT_2DROP
00fc7f f025          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' )
                 ;        begin @ dup
                 ;        while
                 ;          2dup 2>r
                 ;          swap execute ( i*x nt -- i*x' f )
                 ;          2r> rot
                 ;        while
                 ;          nfa>lfa @i
                 ;        repeat then 2drop ;
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
00fc80 ff0b          .dw $ff0b
00fc81 616e
00fc82 656d
00fc83 733e
00fc84 7274
00fc85 6e69
00fc86 0067          .db "name>string",0
00fc87 fc62          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
00fc88 f000          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
00fc89 f7c7          .dw XT_ICOUNT   ; ( -- addr n )
00fc8a f045          .dw XT_DOLITERAL
00fc8b 00ff          .dw 255
00fc8c f224          .dw XT_AND      ; mask immediate bit
00fc8d f025          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
00fc8e ff07          .dw $ff07
00fc8f 666e
00fc90 3e61
00fc91 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
00fc92 0061          .db "nfa>cfa"
00fc93 fc80          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
00fc94 f000          .dw DO_COLON
                 PFA_NFA2CFA:
00fc95 0452          .dw XT_NFA2LFA ; skip to link field
00fc96 f240          .dw XT_1PLUS   ; next is the execution token
00fc97 f025          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
00fc98 ff08          .dw $ff08
00fc99 6369
00fc9a 6d6f
00fc9b 6170
00fc9c 6572          .db "icompare"
00fc9d fc8e          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
00fc9e f000          .dw DO_COLON
                 PFA_ICOMPARE:
00fc9f f110          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
00fca0 f0e0          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
00fca1 f107          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
00fca2 f122          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
00fca3 f03e          .dw XT_DOCONDBRANCH
00fca4 fca9          .dw PFA_ICOMPARE_SAMELEN
00fca5 f569            .dw XT_2DROP
00fca6 f0ea            .dw XT_DROP
00fca7 f15c            .dw XT_TRUE
00fca8 f025            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
00fca9 f0d5          .dw XT_SWAP ; ( -- r-addr f-addr len )
00fcaa f165          .dw XT_ZERO
00fcab 0266          .dw XT_QDOCHECK
00fcac f03e          .dw XT_DOCONDBRANCH
00fcad fcce          .dw PFA_ICOMPARE_DONE
00fcae f2ac          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
00fcaf f0e0          .dw XT_OVER
00fcb0 f08a          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
00fcb1 fcd1          .dw XT_ICOMPARE_LC
                 .endif
00fcb2 f0e0          .dw XT_OVER
00fcb3 f3d8          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
00fcb4 fcd1          .dw XT_ICOMPARE_LC
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
00fcb5 f0c2          .dw XT_DUP
                     ;.dw XT_BYTESWAP
00fcb6 f045          .dw XT_DOLITERAL
00fcb7 0100          .dw $100
00fcb8 f16d          .dw XT_ULESS
00fcb9 f03e          .dw XT_DOCONDBRANCH
00fcba fcbf          .dw PFA_ICOMPARE_LASTCELL
00fcbb f0d5          .dw XT_SWAP
00fcbc f045          .dw XT_DOLITERAL
00fcbd 00ff          .dw $00FF
00fcbe f224          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
00fcbf f122          .dw XT_NOTEQUAL
00fcc0 f03e          .dw XT_DOCONDBRANCH
00fcc1 fcc6          .dw PFA_ICOMPARE_NEXTLOOP
00fcc2 f569          .dw XT_2DROP
00fcc3 f15c          .dw XT_TRUE
00fcc4 f2e5          .dw XT_UNLOOP
00fcc5 f025          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
00fcc6 f240          .dw XT_1PLUS
00fcc7 f0d5          .dw XT_SWAP
00fcc8 f559          .dw XT_CELLPLUS
00fcc9 f0d5          .dw XT_SWAP
00fcca f045          .dw XT_DOLITERAL
00fccb 0002          .dw 2
00fccc f2cb          .dw XT_DOPLUSLOOP
00fccd fcaf          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
00fcce f569          .dw XT_2DROP
00fccf f165          .dw XT_ZERO
00fcd0 f025          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 ; ( cc1 cc2 -- f) 
                 ; Tools
                 ; compares two packed characters 
                 ;VE_ICOMPARELC:
                 ;    .dw $ff08
                 ;    .db "icompare-lower"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ICOMPARELC
                 XT_ICOMPARE_LC:
00fcd1 f000          .dw DO_COLON
                 PFA_ICOMPARE_LC:
00fcd2 f0c2          .dw XT_DUP
00fcd3 f045          .dw XT_DOLITERAL
00fcd4 00ff          .dw $00ff
00fcd5 f224          .dw XT_AND
00fcd6 f693          .dw XT_TOLOWER
00fcd7 f0d5          .dw XT_SWAP
00fcd8 f30a          .dw XT_BYTESWAP
00fcd9 f045          .dw XT_DOLITERAL
00fcda 00ff          .dw $00ff
00fcdb f224          .dw XT_AND
00fcdc f693          .dw XT_TOLOWER
00fcdd f30a          .dw XT_BYTESWAP
00fcde f22d          .dw XT_OR
00fcdf f025          .dw XT_EXIT
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
00fce0 ff01          .dw $ff01
00fce1 002a          .db "*",0
00fce2 fc98          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
00fce3 f000          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
00fce4 f1b7          .dw XT_MSTAR
00fce5 f0ea          .dw XT_DROP
00fce6 f025          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
00fce7 ff01          .dw $FF01
00fce8 006a          .db "j",0
00fce9 fce0          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
00fcea f000          .dw DO_COLON
                 PFA_J:
00fceb f287          .dw XT_RP_FETCH
00fcec f045          .dw XT_DOLITERAL
00fced 0007          .dw 7
00fcee f1ae          .dw XT_PLUS
00fcef f08a          .dw XT_FETCH
00fcf0 f287          .dw XT_RP_FETCH
00fcf1 f045          .dw XT_DOLITERAL
00fcf2 0009          .dw 9
00fcf3 f1ae          .dw XT_PLUS
00fcf4 f08a          .dw XT_FETCH
00fcf5 f1ae          .dw XT_PLUS
00fcf6 f025          .dw XT_EXIT
                 
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
00fcf7 ff04          .dw $ff04
00fcf8 6164
00fcf9 7362          .db "dabs"
00fcfa fce7          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
00fcfb f000          .dw DO_COLON
                 PFA_DABS:
00fcfc f0c2          .dw XT_DUP
00fcfd f130          .dw XT_ZEROLESS
00fcfe f03e          .dw XT_DOCONDBRANCH
00fcff fd01          .dw PFA_DABS1
00fd00 fd08          .dw XT_DNEGATE
                 PFA_DABS1:
00fd01 f025          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
00fd02 ff07          .dw $ff07
00fd03 6e64
00fd04 6765
00fd05 7461
00fd06 0065          .db "dnegate",0
00fd07 fcf7          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
00fd08 f000          .dw DO_COLON
                 PFA_DNEGATE:
00fd09 f46c          .dw XT_DINVERT
00fd0a f3f7          .dw XT_ONE
00fd0b f165          .dw XT_ZERO
00fd0c f446          .dw XT_DPLUS
00fd0d f025          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
00fd0e ff05          .dw $ff05
00fd0f 6d63
00fd10 766f
00fd11 0065          .db "cmove",0
00fd12 fd02          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
00fd13 fd14          .dw PFA_CMOVE
                 PFA_CMOVE:
00fd14 93bf          push xh
00fd15 93af          push xl
00fd16 91e9          ld zl, Y+
00fd17 91f9          ld zh, Y+ ; addr-to
00fd18 91a9          ld xl, Y+
00fd19 91b9          ld xh, Y+ ; addr-from
00fd1a 2f09          mov temp0, tosh
00fd1b 2b08          or temp0, tosl
00fd1c f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
00fd1d 911d          ld temp1, X+
00fd1e 9311          st Z+, temp1
00fd1f 9701          sbiw tosl, 1
00fd20 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
00fd21 91af          pop xl
00fd22 91bf          pop xh
00fd23 9189
00fd24 9199          loadtos
00fd25 940c f004     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
00fd27 ff05          .dw $ff05
00fd28 7332
00fd29 6177
00fd2a 0070          .db "2swap",0
00fd2b fd0e          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
00fd2c f000          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
00fd2d f0f2          .dw XT_ROT
00fd2e f110          .dw XT_TO_R
00fd2f f0f2          .dw XT_ROT
00fd30 f107          .dw XT_R_FROM
00fd31 f025          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System
                 ; refills the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILLTIB:
00fd32 ff0a          .dw $ff0a
00fd33 6572
00fd34 6966
00fd35 6c6c
00fd36 742d
00fd37 6269          .db "refill-tib"
00fd38 fd27          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
00fd39 f000          .dw DO_COLON
                 PFA_REFILLTIB:
                 .endif
00fd3a fd55          .dw XT_TIB
00fd3b f045          .dw XT_DOLITERAL
00fd3c 005a          .dw TIB_SIZE
00fd3d f889          .dw XT_ACCEPT
00fd3e fd5b          .dw XT_NUMBERTIB
00fd3f f092          .dw XT_STORE
00fd40 f165          .dw XT_ZERO
00fd41 f579          .dw XT_TO_IN
00fd42 f092          .dw XT_STORE
00fd43 f15c          .dw XT_TRUE ; -1
00fd44 f025          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCETIB:
00fd45 ff0a          .dw $FF0A
00fd46 6f73
00fd47 7275
00fd48 6563
00fd49 742d
00fd4a 6269          .db "source-tib"
00fd4b fd32          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
00fd4c f000          .dw DO_COLON
                 PFA_SOURCETIB:
                 .endif
00fd4d fd55          .dw XT_TIB
00fd4e fd5b          .dw XT_NUMBERTIB
00fd4f f08a          .dw XT_FETCH
00fd50 f025          .dw XT_EXIT
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; terminal input buffer address
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TIB:
00fd51 ff03          .dw $ff03
00fd52 6974
00fd53 0062          .db "tib",0
00fd54 fd45          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
00fd55 f053          .dw PFA_DOVARIABLE
                 PFA_TIB:
00fd56 0171          .dw ram_tib
                 .dseg
000171           ram_tib: .byte TIB_SIZE
                 .cseg
                 .endif
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBERTIB:
00fd57 ff04          .dw $ff04
00fd58 7423
00fd59 6269          .db "#tib"
00fd5a fd51          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
00fd5b f053          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
00fd5c 01cb          .dw ram_sharptib
                 .dseg
0001cb           ram_sharptib: .byte 2
                 .cseg
                 .endif
                 
                 .include "words/init-ram.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
00fd5d ff06        .dw $ff06
00fd5e 6565
00fd5f 723e
00fd60 6d61        .db "ee>ram"
00fd61 fd57        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
00fd62 f000        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
00fd63 f165          .dw XT_ZERO
00fd64 f2ac          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
00fd65 f0e0          .dw XT_OVER
00fd66 f366          .dw XT_FETCHE
00fd67 f0e0          .dw XT_OVER
00fd68 f092          .dw XT_STORE
00fd69 f559          .dw XT_CELLPLUS
00fd6a f0d5          .dw XT_SWAP
00fd6b f559          .dw XT_CELLPLUS
00fd6c f0d5          .dw XT_SWAP
00fd6d f2da          .dw XT_DOLOOP
00fd6e fd65          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
00fd6f f569          .dw XT_2DROP
00fd70 f025          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INIT_RAM:
00fd71 ff08        .dw $ff08
00fd72 6e69
00fd73 7469
00fd74 722d
00fd75 6d61        .db "init-ram"
00fd76 fd5d        .dw VE_HEAD
                   .set VE_HEAD = VE_INIT_RAM
                 XT_INIT_RAM:
00fd77 f000        .dw DO_COLON
                 PFA_INI_RAM:          ; ( -- )
00fd78 f045          .dw XT_DOLITERAL
00fd79 007c          .dw EE_INITUSER
00fd7a f313          .dw XT_UP_FETCH
00fd7b f045          .dw XT_DOLITERAL
00fd7c 0024          .dw SYSUSERSIZE
00fd7d f215          .dw XT_2SLASH
00fd7e fd62          .dw XT_EE2RAM
00fd7f f025          .dw XT_EXIT
                 
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
00fd80 ff06          .dw $ff06
00fd81 6f62
00fd82 6e75
00fd83 7364          .db "bounds"
00fd84 fd71          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
00fd85 f000          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
00fd86 f0e0          .dw XT_OVER
00fd87 f1ae          .dw XT_PLUS
00fd88 f0d5          .dw XT_SWAP
00fd89 f025          .dw XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
00fd8a ff03          .dw $ff03
00fd8b 3e73
00fd8c 0064          .db "s>d",0
00fd8d fd80          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
00fd8e f000          .dw DO_COLON
                 PFA_S2D:
                 .endif
00fd8f f0c2          .dw XT_DUP
00fd90 f130          .dw XT_ZEROLESS
00fd91 f025          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
00fd92 ff05          .dw $ff05
00fd93 623e
00fd94 646f
00fd95 0079          .db ">body",0
00fd96 fd8a          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
00fd97 f241          .dw PFA_1PLUS
                 
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .endif
                 .include "dict/interrupt.inc"
                 
                 .if WANT_INTERRUPTS == 1
                 
                 .if WANT_INTERRUPT_COUNTERS == 1
                   .include "words/irqcnt.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_IRQCNTADDR:
00fd98 ff06          .dw $ff06
00fd99 7269
00fd9a 5b71
00fd9b 235d          .db "irq[]#"
00fd9c fd92          .dw VE_HEAD
                     .set VE_HEAD = VE_IRQCNTADDR
                 XT_IRQCNTADDR:
00fd9d f000          .dw DO_COLON
                 PFA_IRQCNTADDR:
00fd9e f045          .dw XT_DOLITERAL
00fd9f 0112          .dw intcnt
00fda0 f1ae          .dw XT_PLUS
00fda1 f025          .dw XT_EXIT
                   .include "words/int-num.asm"
                 
                 ; Interrupt
                 ; number of interrupt vectors (0 based)
                 VE_NUMINT:
00fda2 ff04          .dw $ff04
00fda3 6923
00fda4 746e          .db "#int"
00fda5 fd98          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMINT
                 XT_NUMINT:
00fda6 f053          .dw PFA_DOVARIABLE
                 PFA_NUMINT:
00fda7 0023          .dw INTVECTORS
                 .endif
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
00fda8 ff04          .dw $ff04
00fda9 692b
00fdaa 746e          .db "+int"
00fdab fda2          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
00fdac fdad          .dw PFA_INTON
                 PFA_INTON:
00fdad 9478          sei
00fdae 940c f004     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
00fdb0 ff04          .dw $ff04
00fdb1 692d
00fdb2 746e          .db "-int"
00fdb3 fda8          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
00fdb4 fdb5          .dw PFA_INTOFF
                 PFA_INTOFF:
00fdb5 94f8          cli
00fdb6 940c f004     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
00fdb8 ff04          .dw $ff04
00fdb9 6e69
00fdba 2174          .db "int!"
00fdbb fdb0          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
00fdbc f000          .dw DO_COLON
                 PFA_INTSTORE:
00fdbd f045          .dw XT_DOLITERAL
00fdbe 0000          .dw intvec
00fdbf f1ae          .dw XT_PLUS
00fdc0 f342          .dw XT_STOREE
00fdc1 f025          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
00fdc2 ff04          .dw $ff04
00fdc3 6e69
00fdc4 4074          .db "int@"
00fdc5 fdb8          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
00fdc6 f000          .dw DO_COLON
                 PFA_INTFETCH:
00fdc7 f045          .dw XT_DOLITERAL
00fdc8 0000          .dw intvec
00fdc9 f1ae          .dw XT_PLUS
00fdca f366          .dw XT_FETCHE
00fdcb f025          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
00fdcc ff08          .dw $ff08
00fdcd 6e69
00fdce 2d74
00fdcf 7274
00fdd0 7061          .db "int-trap"
00fdd1 fdc2          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
00fdd2 fdd3          .dw PFA_INTTRAP
                 PFA_INTTRAP:
00fdd3 2eb8          mov isrflag, tosl
00fdd4 9189
00fdd5 9199          loadtos
00fdd6 940c f004     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
00fdd8 f000          .dw DO_COLON
                 PFA_ISREXEC:
00fdd9 fdc6          .dw XT_INTFETCH
00fdda f02f          .dw XT_EXECUTE
00fddb fddd          .dw XT_ISREND
00fddc f025          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
00fddd fdde          .dw PFA_ISREND
                 PFA_ISREND:
00fdde d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
00fddf 940c f004     jmp_ DO_NEXT
                 PFA_ISREND1:
00fde1 9518          reti
                 .endif
                 .elif AMFORTH_NRWW_SIZE>4000
                 .elif AMFORTH_NRWW_SIZE>2000
                 .else
                 .endif
                 .include "dict_appl_core.inc"
                 
                 ; in the NRWW flash section. There is a default file
                 ; called dict/nrww.inc which contains all essential
                 ; words which is included automatically. There is usually
                 ; not much space left.
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000046 ff ff     
                 ; some configs
000048 02 05     CFG_DP:      .dw DPSTART         ; Dictionary Pointer
00004a cd 01     EE_HERE:     .dw HERESTART       ; Memory Allocation
00004c a2 00     EE_EHERE:    .dw EHERESTART      ; EEProm Memory Allocation
00004e 0e 04     CFG_WLSCOPE: .dw XT_GET_CURRENT  ; default wordlist scope
000050 6e 00     CFG_FORTHRECOGNIZER: .dw CFG_RECOGNIZERLISTLEN ; Recognizer word set
                 ; LEAVE stack is between data stack and return stack.
000052 b0 40     CFG_LP0:     .dw stackstart+1
000054 be 04     CFG_TURNKEY: .dw XT_APPLTURNKEY    ; TURNKEY
000056 2d f5     CFG_ENVIRONMENT:.dw VE_ENVHEAD     ; environmental queries
000058 5a 00     CFG_CURRENT: .dw CFG_FORTHWORDLIST ; forth-wordlist
00005a cc fd     CFG_FORTHWORDLIST:.dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
00005c 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
00005e 5a 00         .dw CFG_FORTHWORDLIST      ; get/set-order
000060               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
00006e 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
000070 36 fb         .dw XT_REC_FIND
000072 22 fb         .dw XT_REC_NUM
000074               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_STOREI:
000078 85 f3         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
00007a 7a 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
00007c 00 00         .dw 0  ; USER_STATE
00007e 00 00         .dw 0  ; USER_FOLLOWER
000080 ff 40         .dw rstackstart  ; USER_RP
000082 af 40         .dw stackstart   ; USER_SP0
000084 af 40         .dw stackstart   ; USER_SP
                     
000086 00 00         .dw 0  ; USER_HANDLER
000088 0a 00         .dw 10 ; USER_BASE
                     
00008a b6 00         .dw XT_TX  ; USER_EMIT
00008c c4 00         .dw XT_TXQ ; USER_EMITQ
00008e 8b 00         .dw XT_RX  ; USER_KEY
000090 a6 00         .dw XT_RXQ ; USER_KEYQ
000092 4c fd         .dw XT_SOURCETIB ; USER_SOURCE
000094 00 00         .dw 0            ; USER_G_IN
000096 39 fd         .dw XT_REFILLTIB ; USER_REFILL  
000098 ef f9         .dw XT_DEFAULT_PROMPTOK
00009a 0e fa         .dw XT_DEFAULT_PROMPTERROR
00009c fe f9         .dw XT_DEFAULT_PROMPTREADY
00009e 29 fa         .dw XT_DEFAULT_PROMPTINPUT
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
0000a0 0c 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega1284P" register use summary:
r0 :  25 r1 :   5 r2 :  10 r3 :  12 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   7 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  78 r17:  57 r18:  52 r19:  37 r20:  13 r21:  38 r22:  11 r23:   3 
r24: 187 r25: 132 r26:  28 r27:  17 r28:   7 r29:   4 r30:  78 r31:  40 
x  :   4 y  : 201 z  :  41 
Registers used: 29 out of 35 (82.9%)

"ATmega1284P" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  22 add   :  17 adiw  :  17 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   2 brcs  :   1 break :   0 breq  :   7 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  13 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   0 cbr   :   0 
clc   :   1 clh   :   0 cli   :   5 cln   :   0 clr   :  22 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  14 cp    :  11 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :  10 elpm  :  16 eor   :   3 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :  14 inc   :   3 
jmp   :  13 ld    : 134 ldd   :   4 ldi   :  27 lds   :   1 lpm   :   0 
lsl   :  14 lsr   :   2 mov   :  15 movw  :  66 mul   :   5 muls  :   1 
mulsu :   2 neg   :   0 nop   :   0 or    :   9 ori   :   1 out   :  25 
pop   :  45 push  :  39 rcall :  47 ret   :   6 reti  :   1 rjmp  :  98 
rol   :  32 ror   :   5 sbc   :   9 sbci  :   3 sbi   :   3 sbic  :   3 
sbis  :   0 sbiw  :   7 sbr   :   0 sbrc  :   4 sbrs  :   3 sec   :   1 
seh   :   0 sei   :   1 sen   :   0 ser   :   3 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   2 st    :  74 std   :   8 
sts   :   1 sub   :   6 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 

Instructions used: 71 out of 114 (62.3%)

"ATmega1284P" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x01fbc4   1922  14792  16714  131072  12.8%
[.dseg] 0x000100 0x0001cd      0    205    205   16384   1.3%
[.eseg] 0x000000 0x0000a2      0    162    162    4096   4.0%

Assembly complete, 0 errors, 9 warnings
