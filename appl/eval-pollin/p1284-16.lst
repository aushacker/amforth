
AVRASM ver. 2.1.52  p1284-16.asm Sun Oct 18 18:22:44 2020

p1284-16.asm(5): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega1284p\device.asm'
../../avr8/devices/atmega1284p\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m1284Pdef.inc'
p1284-16.asm(14): Including file '../../avr8\drivers/usart_0.asm'
../../avr8\drivers/usart_0.asm(32): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(11): Including file '../../avr8\drivers/usart-rx-buffer.asm'
../../avr8\drivers/usart_common.asm(24): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(29): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(30): Including file '../../avr8\words/usart.asm'
p1284-16.asm(19): Including file '../../avr8\drivers/1wire.asm'
p1284-16.asm(21): Including file '../../avr8\amforth.asm'
../../avr8\amforth.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth.asm(14): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(7): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/rww.inc(10): Including file '../../avr8\dict/appl_8k.inc'
../../avr8\dict/appl_8k.inc(1): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/newest.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/do-create.asm'
../../avr8\dict/compiler1.inc(5): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(9): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(10): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(17): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(33): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(38): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../common\words/create.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../common\words/reveal.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(53): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../common\words/recurse.asm'
../../avr8\dict/compiler1.inc(56): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(61): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(67): Including file '../../common\words/cfg-order.asm'
../../avr8\dict/compiler1.inc(68): Including file '../../common\words/cfg-recognizer.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(70): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(3): Including file '../../common\words/dot-s.asm'
dict_appl.inc(4): Including file '../../avr8\words/spirw.asm'
dict_appl.inc(5): Including file '../../avr8\words/n-spi.asm'
dict_appl.inc(6): Including file 'words/applturnkey.asm'
dict_appl.inc(7): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../common\words/postpone.asm'
dict_appl.inc(8): Including file '../../avr8\words/2r_fetch.asm'
../../avr8\amforth.asm(23): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth.asm(24): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(35): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(36): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(42): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(45): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(46): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(49): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(56): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(63): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../common\words/q-negate.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(89): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(95): Including file '../../avr8\words/store-i_nrww.asm'
../../avr8\dict/nrww.inc(97): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(98): Including file '../../common\words/2literal.asm'
../../avr8\dict/nrww.inc(99): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(100): Including file '../../common\words/num-constants.asm'
../../avr8\dict/nrww.inc(103): Including file '../../avr8\dict/core_8k.inc'
../../avr8\dict/core_8k.inc(2): Including file '../../avr8\words/n_to_r.asm'
../../avr8\dict/core_8k.inc(3): Including file '../../avr8\words/n_r_from.asm'
../../avr8\dict/core_8k.inc(5): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/core_8k.inc(6): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/core_8k.inc(7): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/core_8k.inc(8): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/core_8k.inc(9): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/core_8k.inc(10): Including file '../../common\words/u-dot.asm'
../../avr8\dict/core_8k.inc(11): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/core_8k.inc(13): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/core_8k.inc(14): Including file '../../common\words/words.asm'
../../avr8\dict/core_8k.inc(17): Including file '../../common\words/pick.asm'
../../avr8\dict/core_8k.inc(18): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/core_8k.inc(19): Including file '../../common\words/squote.asm'
../../avr8\dict/core_8k.inc(21): Including file '../../avr8\words/fill.asm'
../../avr8\dict/core_8k.inc(23): Including file '../../avr8\words/environment.asm'
../../avr8\dict/core_8k.inc(24): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/core_8k.inc(25): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/core_8k.inc(26): Including file '../../common\words/env-slashhold.asm'
../../avr8\dict/core_8k.inc(27): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/core_8k.inc(28): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/core_8k.inc(29): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/core_8k.inc(30): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/core_8k.inc(31): Including file '../../common\words/env-usersize.asm'
../../avr8\dict/core_8k.inc(33): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/core_8k.inc(34): Including file '../../avr8\words/state.asm'
../../avr8\dict/core_8k.inc(35): Including file '../../common\words/base.asm'
../../avr8\dict/core_8k.inc(37): Including file '../../avr8\words/cells.asm'
../../avr8\dict/core_8k.inc(38): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/core_8k.inc(40): Including file '../../common\words/2dup.asm'
../../avr8\dict/core_8k.inc(41): Including file '../../common\words/2drop.asm'
../../avr8\dict/core_8k.inc(43): Including file '../../common\words/tuck.asm'
../../avr8\dict/core_8k.inc(45): Including file '../../common\words/to-in.asm'
../../avr8\dict/core_8k.inc(46): Including file '../../common\words/pad.asm'
../../avr8\dict/core_8k.inc(47): Including file '../../common\words/emit.asm'
../../avr8\dict/core_8k.inc(48): Including file '../../common\words/emitq.asm'
../../avr8\dict/core_8k.inc(49): Including file '../../common\words/key.asm'
../../avr8\dict/core_8k.inc(50): Including file '../../common\words/keyq.asm'
../../avr8\dict/core_8k.inc(52): Including file '../../avr8\words/dp.asm'
../../avr8\dict/core_8k.inc(53): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/core_8k.inc(54): Including file '../../avr8\words/here.asm'
../../avr8\dict/core_8k.inc(55): Including file '../../avr8\words/allot.asm'
../../avr8\dict/core_8k.inc(57): Including file '../../common\words/bin.asm'
../../avr8\dict/core_8k.inc(58): Including file '../../common\words/decimal.asm'
../../avr8\dict/core_8k.inc(59): Including file '../../common\words/hex.asm'
../../avr8\dict/core_8k.inc(60): Including file '../../common\words/bl.asm'
../../avr8\dict/core_8k.inc(62): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/core_8k.inc(64): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/core_8k.inc(65): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/core_8k.inc(66): Including file '../../avr8\words/negate.asm'
../../avr8\dict/core_8k.inc(67): Including file '../../common\words/slash.asm'
../../avr8\dict/core_8k.inc(68): Including file '../../common\words/mod.asm'
../../avr8\dict/core_8k.inc(69): Including file '../../common\words/abs.asm'
../../avr8\dict/core_8k.inc(70): Including file '../../common\words/min.asm'
../../avr8\dict/core_8k.inc(71): Including file '../../common\words/max.asm'
../../avr8\dict/core_8k.inc(72): Including file '../../common\words/within.asm'
../../avr8\dict/core_8k.inc(74): Including file '../../common\words/to-upper.asm'
../../avr8\dict/core_8k.inc(75): Including file '../../common\words/to-lower.asm'
../../avr8\dict/core_8k.inc(77): Including file '../../avr8\words/hld.asm'
../../avr8\dict/core_8k.inc(78): Including file '../../common\words/hold.asm'
../../avr8\dict/core_8k.inc(79): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/core_8k.inc(80): Including file '../../common\words/sharp.asm'
../../avr8\dict/core_8k.inc(81): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/core_8k.inc(82): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/core_8k.inc(83): Including file '../../common\words/sign.asm'
../../avr8\dict/core_8k.inc(84): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/core_8k.inc(85): Including file '../../common\words/dot-r.asm'
../../avr8\dict/core_8k.inc(86): Including file '../../common\words/d-dot.asm'
../../avr8\dict/core_8k.inc(87): Including file '../../common\words/dot.asm'
../../avr8\dict/core_8k.inc(88): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/core_8k.inc(89): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/core_8k.inc(90): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/core_8k.inc(91): Including file '../../common\words/digit-q.asm'
../../avr8\dict/core_8k.inc(93): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/core_8k.inc(94): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/core_8k.inc(95): Including file '../../avr8\words/itype.asm'
../../avr8\dict/core_8k.inc(96): Including file '../../avr8\words/icount.asm'
../../avr8\dict/core_8k.inc(97): Including file '../../common\words/cr.asm'
../../avr8\dict/core_8k.inc(98): Including file '../../common\words/space.asm'
../../avr8\dict/core_8k.inc(99): Including file '../../common\words/spaces.asm'
../../avr8\dict/core_8k.inc(100): Including file '../../common\words/type.asm'
../../avr8\dict/core_8k.inc(101): Including file '../../common\words/tick.asm'
../../avr8\dict/core_8k.inc(103): Including file '../../common\words/handler.asm'
../../avr8\dict/core_8k.inc(104): Including file '../../common\words/catch.asm'
../../avr8\dict/core_8k.inc(105): Including file '../../common\words/throw.asm'
../../avr8\dict/core_8k.inc(107): Including file '../../common\words/cskip.asm'
../../avr8\dict/core_8k.inc(108): Including file '../../common\words/cscan.asm'
../../avr8\dict/core_8k.inc(109): Including file '../../common\words/accept.asm'
../../avr8\dict/core_8k.inc(110): Including file '../../common\words/refill.asm'
../../avr8\dict/core_8k.inc(111): Including file '../../common\words/char.asm'
../../avr8\dict/core_8k.inc(112): Including file '../../common\words/number.asm'
../../avr8\dict/core_8k.inc(113): Including file '../../common\words/q-sign.asm'
../../avr8\dict/core_8k.inc(114): Including file '../../common\words/set-base.asm'
../../avr8\dict/core_8k.inc(115): Including file '../../common\words/to-number.asm'
../../avr8\dict/core_8k.inc(116): Including file '../../common\words/parse.asm'
../../avr8\dict/core_8k.inc(117): Including file '../../common\words/source.asm'
../../avr8\dict/core_8k.inc(118): Including file '../../common\words/slash-string.asm'
../../avr8\dict/core_8k.inc(119): Including file '../../common\words/parse-name.asm'
../../avr8\dict/core_8k.inc(120): Including file '../../common\words/find-xt.asm'
../../avr8\dict/core_8k.inc(122): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/core_8k.inc(123): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/core_8k.inc(124): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/core_8k.inc(125): Including file '../../common\words/prompt-input.asm'
../../avr8\dict/core_8k.inc(126): Including file '../../common\words/quit.asm'
../../avr8\dict/core_8k.inc(127): Including file '../../avr8\words/pause.asm'
../../avr8\dict/core_8k.inc(128): Including file '../../avr8\words/cold.asm'
../../avr8\dict/core_8k.inc(129): Including file '../../common\words/warm.asm'
../../avr8\dict/core_8k.inc(131): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/core_8k.inc(132): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/core_8k.inc(133): Including file '../../common\words/depth.asm'
../../avr8\dict/core_8k.inc(134): Including file '../../common\words/interpret.asm'
../../avr8\dict/core_8k.inc(135): Including file '../../avr8\words/forth-recognizer.asm'
../../avr8\dict/core_8k.inc(136): Including file '../../common\words/recognize.asm'
../../avr8\dict/core_8k.inc(137): Including file '../../common\words/rec-intnum.asm'
../../avr8\dict/core_8k.inc(138): Including file '../../common\words/rec-find.asm'
../../avr8\dict/core_8k.inc(139): Including file '../../common\words/rec-null.asm'
../../avr8\dict/core_8k.inc(141): Including file '../../common\words/q-stack.asm'
../../avr8\dict/core_8k.inc(142): Including file '../../common\words/ver.asm'
../../avr8\dict/core_8k.inc(144): Including file '../../common\words/noop.asm'
../../avr8\dict/core_8k.inc(145): Including file '../../avr8\words/unused.asm'
../../avr8\dict/core_8k.inc(147): Including file '../../common\words/to.asm'
../../avr8\dict/core_8k.inc(148): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/core_8k.inc(150): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/core_8k.inc(151): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/core_8k.inc(152): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/core_8k.inc(153): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/core_8k.inc(154): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/core_8k.inc(155): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/core_8k.inc(156): Including file '../../common\words/defer-store.asm'
../../avr8\dict/core_8k.inc(157): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/core_8k.inc(158): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/core_8k.inc(160): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/core_8k.inc(161): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/core_8k.inc(162): Including file '../../common\words/name2string.asm'
../../avr8\dict/core_8k.inc(163): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/core_8k.inc(164): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/core_8k.inc(166): Including file '../../common\words/star.asm'
../../avr8\dict/core_8k.inc(167): Including file '../../avr8\words/j.asm'
../../avr8\dict/core_8k.inc(169): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/core_8k.inc(170): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/core_8k.inc(171): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/core_8k.inc(172): Including file '../../common\words/2swap.asm'
../../avr8\dict/core_8k.inc(174): Including file '../../common\words/tib.asm'
../../avr8\dict/core_8k.inc(176): Including file '../../avr8\words/init-ram.asm'
../../avr8\dict/core_8k.inc(178): Including file '../../common\words/bounds.asm'
../../avr8\dict/core_8k.inc(179): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/core_8k.inc(180): Including file '../../avr8\words/to-body.asm'
../../avr8\dict/core_8k.inc(182): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/core_8k.inc(183): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/irqcnt.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-num.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(10): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(11): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(12): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(13): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(15): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(16): Including file '../../avr8\words/isr-end.asm'
../../avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
../../avr8\amforth.asm(36): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; file see ../template/template.asm. You may want to
                 ; copy that file to this one and edit it afterwards.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set USER_P_OK    = 28
                 .set USER_P_ERR   = 30
                 .set USER_P_RDY   = 32
                 .set USER_P_INPUT = 34
                 
                 .set SYSUSERSIZE = 36
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot = r10
                   .def isrflag  = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  256
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 	elpm @0, Z+
                 	elpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_TIMER_COUNTER_3 = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_JTAG = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TWI = 0
                 .set WANT_USART1 = 0
                 .set WANT_SPI = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_CPU = 0
                 .equ intvecsize = 2 ; please verify; flash size: 131072 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d139      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d137      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d135      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d133      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 10
00000a d131      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 12
00000c d12f      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 14
00000e d12d      	 rcall isr ; Pin Change Interrupt Request 3
                 .org 16
000010 d12b      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 18
000012 d129      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 20
000014 d127      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 22
000016 d125      	 rcall isr ; Timer/Counter2 Overflow
                 .org 24
000018 d123      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 26
00001a d121      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 28
00001c d11f      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 30
00001e d11d      	 rcall isr ; Timer/Counter1 Overflow
                 .org 32
000020 d11b      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 34
000022 d119      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 36
000024 d117      	 rcall isr ; Timer/Counter0 Overflow
                 .org 38
000026 d115      	 rcall isr ; SPI Serial Transfer Complete
                 .org 40
000028 d113      	 rcall isr ; USART0, Rx Complete
                 .org 42
00002a d111      	 rcall isr ; USART0 Data register Empty
                 .org 44
00002c d10f      	 rcall isr ; USART0, Tx Complete
                 .org 46
00002e d10d      	 rcall isr ; Analog Comparator
                 .org 48
000030 d10b      	 rcall isr ; ADC Conversion Complete
                 .org 50
000032 d109      	 rcall isr ; EEPROM Ready
                 .org 52
000034 d107      	 rcall isr ; 2-wire Serial Interface
                 .org 54
000036 d105      	 rcall isr ; Store Program Memory Read
                 .org 56
000038 d103      	 rcall isr ; USART1 RX complete
                 .org 58
00003a d101      	 rcall isr ; USART1 Data Register Empty
                 .org 60
00003c d0ff      	 rcall isr ; USART1 TX complete
                 .org 62
00003e d0fd      	 rcall isr ; Timer/Counter3 Capture Event
                 .org 64
000040 d0fb      	 rcall isr ; Timer/Counter3 Compare Match A
                 .org 66
000042 d0f9      	 rcall isr ; Timer/Counter3 Compare Match B
                 .org 68
000044 d0f7      	 rcall isr ; Timer/Counter3 Overflow
                 .equ INTVECTORS = 35
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000045 4000      	.dw 16384
                 mcu_eepromsize:
000046 1000      	.dw 4096
                 mcu_maxdp:
000047 ffff      	.dw 65535 
                 mcu_numints:
000048 0023      	.dw 35
                 mcu_name:
000049 000b      	.dw 11
00004a 5441
00004b 656d
00004c 6167
00004d 3231
00004e 3438
00004f 0050      	.db "ATmega1284P",0
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 ; enabling Interrupts, disabling them affects
                 ; other settings as well. 
                 .set WANT_INTERRUPTS = 1
                 
                 ; count the number of interrupts individually.
                 ; requires a lot of RAM (one byte per interrupt)
                 ; disabled by default.
                 .set WANT_INTERRUPT_COUNTERS = 1
                 
                 ; receiving is asynchronously, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIB_SIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR+1
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 16000000
                 .set BAUD_MAXERROR = 30
                 .equ TIMER_INT = OVF2addr
                 
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .equ URXCaddr = URXC0addr
                   .equ UDREaddr = UDRE0addr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_INTERRUPTS == 0
                   .if WANT_ISR_RX == 1
                   .endif
                 .endif
                 
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-rx-buffer.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100            usart_rx_data: .byte usart_rx_size
000110            usart_rx_in:   .byte 1
000111            usart_rx_out:  .byte 1
                 .cseg
                 
                 VE_TO_RXBUF:
000050 ff07          .dw $ff07
000051 723e
000052 2d78
000053 7562
000054 0066          .db ">rx-buf",0
000055 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_RXBUF
                 XT_TO_RXBUF:
000056 0057          .dw PFA_rx_tobuf
                 PFA_rx_tobuf:
000057 2f08          mov temp0, tosl
000058 9110 0110     lds temp1, usart_rx_in
00005a e0e0          ldi zl, low(usart_rx_data)
00005b e0f1          ldi zh, high(usart_rx_data)
00005c 0fe1          add zl, temp1
00005d 1df3          adc zh, zeroh
00005e 8300          st Z, temp0
00005f 9513          inc temp1
000060 701f          andi temp1,usart_rx_mask
000061 9310 0110     sts usart_rx_in, temp1
000063 9189
000064 9199          loadtos
000065 940c f005     jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; setup with
                 ; ' isr-rx URXCaddr int!
                 VE_ISR_RX:
000067 ff06          .dw $ff06
000068 7369
000069 2d72
00006a 7872          .db "isr-rx"
00006b 0050          .dw VE_HEAD
                     .set VE_HEAD = VE_ISR_RX
                 XT_ISR_RX:
00006c f001          .dw DO_COLON
                 usart_rx_isr:
00006d f046        .dw XT_DOLITERAL
00006e 00c6        .dw usart_data
00006f f0aa        .dw XT_CFETCH
000070 f0c3        .dw XT_DUP
000071 f046        .dw XT_DOLITERAL
000072 0003        .dw 3
000073 f3f1        .dw XT_EQUAL
000074 f03f        .dw XT_DOCONDBRANCH
000075 0077        .dw usart_rx_isr1
000076 fa6c        .dw XT_COLD
                 usart_rx_isr1:
000077 0056        .dw XT_TO_RXBUF
000078 f026        .dw XT_EXIT
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RXBUFFER:
                 ;  .dw $ff0x
                 ;  .db "+usart-buffer"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RXBUFFER
                 XT_USART_INIT_RX_BUFFER:
000079 f001        .dw DO_COLON
                 PFA_USART_INIT_RX_BUFFER:          ; ( -- )
00007a f046
00007b 006c        .dw XT_DOLITERAL, XT_ISR_RX
00007c f046
00007d 0028        .dw XT_DOLITERAL, URXCaddr
00007e fdac        .dw XT_INTSTORE
                 
00007f f046        .dw XT_DOLITERAL
000080 0100        .dw usart_rx_data
000081 f046        .dw XT_DOLITERAL
000082 0016        .dw usart_rx_size + 6
000083 f166        .dw XT_ZERO
000084 f4cb        .dw XT_FILL
000085 f026        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_BUFFER:
000086 ff06          .dw $ff06
000087 7872
000088 622d
000089 6675          .db "rx-buf"
00008a 0067          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_BUFFER
                 XT_RX_BUFFER:
00008b f001          .dw DO_COLON
                 PFA_RX_BUFFER:
00008c 00a6        .dw XT_RXQ_BUFFER
00008d f03f        .dw XT_DOCONDBRANCH
00008e 008c        .dw PFA_RX_BUFFER
00008f f046        .dw XT_DOLITERAL
000090 0111        .dw usart_rx_out
000091 f0aa        .dw XT_CFETCH
000092 f0c3        .dw XT_DUP
000093 f046        .dw XT_DOLITERAL
000094 0100        .dw usart_rx_data
000095 f1af        .dw XT_PLUS
000096 f0aa        .dw XT_CFETCH
000097 f0d6        .dw XT_SWAP
000098 f241        .dw XT_1PLUS
000099 f046        .dw XT_DOLITERAL
00009a 000f        .dw usart_rx_mask
00009b f225        .dw XT_AND
00009c f046        .dw XT_DOLITERAL
00009d 0111        .dw usart_rx_out
00009e f09f        .dw XT_CSTORE
00009f f026        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue
                 VE_RXQ_BUFFER:
0000a0 ff07          .dw $ff07
0000a1 7872
0000a2 2d3f
0000a3 7562
0000a4 0066          .db "rx?-buf",0
0000a5 0086          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_BUFFER
                 XT_RXQ_BUFFER:
0000a6 f001          .dw DO_COLON
                 PFA_RXQ_BUFFER:
0000a7 fa64        .dw XT_PAUSE
0000a8 f046        .dw XT_DOLITERAL
0000a9 0111        .dw usart_rx_out
0000aa f0aa        .dw XT_CFETCH
0000ab f046        .dw XT_DOLITERAL
0000ac 0110        .dw usart_rx_in
0000ad f0aa        .dw XT_CFETCH
0000ae f123        .dw XT_NOTEQUAL
0000af f026        .dw XT_EXIT
                 ;  .include "drivers/timer-usart-isr.asm"
                   .set XT_RX  = XT_RX_BUFFER
                   .set XT_RXQ = XT_RXQ_BUFFER
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_BUFFER
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
0000b0 ff07          .dw $ff07
0000b1 7874
0000b2 702d
0000b3 6c6f
0000b4 006c          .db "tx-poll",0
0000b5 00a0          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
0000b6 f001          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
0000b7 00c4        .dw XT_TXQ_POLL
0000b8 f03f        .dw XT_DOCONDBRANCH
0000b9 00b7        .dw PFA_TX_POLL
                   ; send to usart
0000ba f046        .dw XT_DOLITERAL
0000bb 00c6        .dw USART_DATA
0000bc f09f        .dw XT_CSTORE
0000bd f026        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
0000be ff08          .dw $ff08
0000bf 7874
0000c0 2d3f
0000c1 6f70
0000c2 6c6c          .db "tx?-poll"
0000c3 00b0          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000c4 f001          .dw DO_COLON
                 PFA_TXQ_POLL:
0000c5 fa64        .dw XT_PAUSE
0000c6 f046        .dw XT_DOLITERAL
0000c7 00c0        .dw USART_A
0000c8 f0aa        .dw XT_CFETCH
0000c9 f046        .dw XT_DOLITERAL
0000ca 0020        .dw bm_USART_TXRD
0000cb f225        .dw XT_AND
0000cc f026        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000cd ff04        .dw $ff04
0000ce 6275
0000cf 7272        .db "ubrr"
0000d0 00be        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000d1 f081        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000d2 00a0        .dw EE_UBRRVAL
0000d3 fbcb        .dw XT_EDEFERFETCH
0000d4 fbd5        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000d5 ff06        .dw $ff06
0000d6 752b
0000d7 6173
0000d8 7472        .db "+usart"
0000d9 00cd        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000da f001        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000db f046        .dw XT_DOLITERAL
0000dc 0098        .dw USART_B_VALUE
0000dd f046        .dw XT_DOLITERAL
0000de 00c1        .dw USART_B
0000df f09f        .dw XT_CSTORE
                 
0000e0 f046        .dw XT_DOLITERAL
0000e1 0006        .dw USART_C_VALUE
0000e2 f046        .dw XT_DOLITERAL
0000e3 00c2        .dw USART_C | bm_USARTC_en
0000e4 f09f        .dw XT_CSTORE
                 
0000e5 00d1        .dw XT_UBRR
0000e6 f0c3        .dw XT_DUP
0000e7 f30b        .dw XT_BYTESWAP
0000e8 f046        .dw XT_DOLITERAL
0000e9 00c5        .dw BAUDRATE_HIGH
0000ea f09f        .dw XT_CSTORE
0000eb f046        .dw XT_DOLITERAL
0000ec 00c4        .dw BAUDRATE_LOW
0000ed f09f        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
0000ee 0079        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
0000ef f026        .dw XT_EXIT
                 
                 ; settings for 1wire interface
                 .equ OW_PORT=PORTB
                 .EQU OW_BIT=4
                 .include "drivers/1wire.asm"
                 
                 ;   B. J. Rodriguez (MSP 430)
                 ;   Matthias Trute (AVR Atmega)
                 ; COPYRIGHT
                 ;   (c) 2012 Bradford J. Rodriguez for the 430 code and API
                 
                 ;  adapted 430 assembly code to AVR
                 ;  wishlist: 
                 ;     use a configurable pin at runtime, compatible with bitnames.frt
                 ;     no external pull up, no external power supply for devices
                 ;     ???
                 ;
                 ;.EQU OW_BIT=4
                 ;.equ OW_PORT=PORTE
                 .set OW_DDR=(OW_PORT-1)
                 .set OW_PIN=(OW_DDR-1)
                 
                 ;****f* 1W.RESET
                 ; NAME
                 ;   1W.RESET
                 ; SYNOPSIS
                 ;   1W.RESET ( -- f )  Initialize 1-wire devices; return true if present
                 ; DESCRIPTION
                 ;   This configures the port pin used by the 1-wire interface, and then
                 ;   sends an "initialize" sequence to the 1-wire devices.  If any device
                 ;   is present, it will be detected.
                 ;
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" (drive output low) for >480 usec.
                 ;   b) Output "1" (let output float).
                 ;   c) After 15 to 60 usec, device will drive pin low for 60 to 240 usec.
                 ;      So, wait 75 usec and sample input.
                 ;   d) Leave output high (floating) for at least 480 usec.
                 ;******
                 ; ( -- f )
                 ; Hardware
                 ; Initialize 1-wire devices; return true if present
                 VE_OW_RESET:
0000f0 ff08          .dw $ff08
0000f1 7731
0000f2 722e
0000f3 7365
0000f4 7465          .db "1w.reset"
0000f5 00d5          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_RESET
                 XT_OW_RESET:
0000f6 00f7          .dw PFA_OW_RESET
                 PFA_OW_RESET:
0000f7 939a
0000f8 938a          savetos
                     ; setup to output
0000f9 9a24          sbi OW_DDR, OW_BIT
                     ; Pull output low
0000fa 982c          cbi OW_PORT, OW_BIT
                     ; Delay >480 usec        
0000fb e8e0
0000fc e0f7
0000fd 9731
0000fe f7f1          DELAY   480
                     ; Critical timing period, disable interrupts.
0000ff b71f          in temp1, SREG
000100 94f8          cli
                     ; Pull output high
000101 9a2c          sbi OW_PORT, OW_BIT
                     ; make pin input, sends "1"
000102 9824          cbi OW_DDR, OW_BIT 
000103 e0e0
000104 e0f1
000105 9731
000106 f7f1          DELAY   64 ; delayB
                     ; Sample input pin, set TOS if input is zero
000107 b183          in tosl, OW_PIN
000108 ff84          sbrs tosl, OW_BIT
000109 ef9f          ser  tosh
                     ; End critical timing period, enable interrupts
00010a bf1f          out SREG, temp1
                     ; release bus
00010b 9824          cbi OW_DDR, OW_BIT
00010c 982c          cbi OW_PORT, OW_BIT
                 
                     ; Delay rest of 480 usec 
00010d e8e0
00010e e0f6
00010f 9731
000110 f7f1          DELAY   416
                     ; we now have the result flag in TOS        
000111 2f89          mov tosl, tosh
000112 940c f005     jmp_ DO_NEXT
                     
                 ;****f* 1W.SLOT
                 ; NAME
                 ;   1W.SLOT
                 ; SYNOPSIS
                 ;   1W.SLOT ( c -- c' ) Write and read one bit to/from 1-wire.
                 ; DESCRIPTION
                 ;   The "touch byte" function is described in Dallas App Note 74.
                 ;   It outputs a byte to the 1-wire pin, LSB first, and reads back
                 ;   the state of the 1-wire pin after a suitable delay.
                 ;   To read a byte, output $FF and read the reply data.
                 ;   To write a byte, output that byte and discard the reply.
                 ;
                 ;   This function performs one bit of the "touch" operation --
                 ;   one read/write "slot" in Dallas jargon.  Perform this eight
                 ;   times in a row to get the "touch byte" function.
                 ;
                 ; PARAMETERS
                 ;   The input parameter is xxxxxxxxbbbbbbbo where
                 ;   'xxxxxxxx' are don't cares,
                 ;   'bbbbbbb' are bits to be shifted down, and
                 ;   'o' is the bit to be output in the slot.  This must be 1
                 ;   to create a read slot.
                 ;
                 ;   The returned value is xxxxxxxxibbbbbbb where
                 ;   'xxxxxxxx' are not known (the input shifted down 1 position),
                 ;   'i' is the bit read during the slot.  This has no meaning
                 ;   if it was a write slot.
                 ;   'bbbbbbb' are the 7 input bits, shifted down one position.
                 ;
                 ;   This peculiar parameter usage allows OWTOUCH to be written as
                 ;     OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT 
                 ;
                 ; NOTES 
                 ;   Interrupts are disabled during each bit.
                 
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" for start period.  (> 1 us, < 15 us, typ. 6 us*)
                 ;   b) Output data bit (0 or 1), open drain 
                 ;   c) After MS from start of cycle, sample input (15 to 60 us, typ. 25 us*)
                 ;   d) After write-0 period from start of cycle, output "1" (>60 us)
                 ;   e) After recovery period, loop or return. (> 1 us)
                 ;   For writes, DS18B20 samples input 15 to 60 usec from start of cycle.
                 ;   * "Typical" values are per App Note 132 for a 300m cable length.
                 
                 ;   ---------        -------------------------------
                 ;            \      /                        /
                 ;             ------------------------------- 
                 ;            a      b          c             d     e
                 ;            |  6us |   19us   |    35us     | 2us |
                 ;******
                 ; ( c -- c' )
                 ; Hardware
                 ; Write and read one bit to/from 1-wire.
                 VE_OW_SLOT:
000114 ff07          .dw $ff07
000115 7731
000116 732e
000117 6f6c
000118 0074          .db "1w.slot",0
000119 00f0          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_SLOT
                 XT_OW_SLOT:
00011a 011b          .dw PFA_OW_SLOT
                 PFA_OW_SLOT:
                     ; pull low
00011b 982c          cbi OW_PORT, OW_BIT
00011c 9a24          sbi OW_DDR, OW_BIT
                     ; disable interrupts
00011d b71f          in temp1, SREG
00011e 94f8          cli
00011f e1e8
000120 e0f0
000121 9731
000122 f7f1          DELAY   6 ; DELAY A
                     ; check bit
000123 9488          clc
000124 9587          ror tosl
000125 f410          brcc PFA_OW_SLOT0 ; a 0 keeps the bus low
                       ; release bus, a 1 is written
000126 9a2c            sbi OW_PORT, OW_BIT
000127 9824            cbi OW_DDR, OW_BIT
                 PFA_OW_SLOT0:
                     ; sample the input (no action required if zero)
000128 e2e4
000129 e0f0
00012a 9731
00012b f7f1          DELAY 9   ; wait DELAY E to sample
00012c b103          in temp0, OW_PIN
00012d fd04          sbrc temp0, OW_BIT
00012e 6880          ori tosl, $80
                 
00012f ecec
000130 e0f0
000131 9731
000132 f7f1          DELAY   51 ; DELAY B
000133 9a2c          sbi OW_PORT, OW_BIT ; release bus
000134 9824          cbi OW_DDR, OW_BIT
000135 e0e8
000136 e0f0
000137 9731
000138 f7f1          delay 2
                     ; re-enable interrupts
000139 bf1f          out SREG, temp1
00013a 940c f005     jmp_ DO_NEXT
                 
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 
                 .set corepc = pc
                 .org $0000
000000 940c fa6d   jmp_ PFA_COLD
                 
                 .org corepc
                 .include "drivers/generic-isr.asm"
                 
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .if WANT_INTERRUPT_COUNTERS==1
                 .dseg
000112           intcnt: .byte INTVECTORS
                 .endif
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
00013c 920a          st -Y, r0
00013d b60f          in r0, SREG
00013e 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
00013f 900f          pop r0
000140 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
000141 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
                     ; check whether isrflag is zero. if not,
                     ; there is an still unhandled interrupt pending.
000142 20bb          tst isrflag
000143 f001          breq isr_clean
                     ; there is a collision. the previous interrupt is not yet
                     ; handled by the forth inner interpreter
                 isr_clean:
000144 2cb0          mov isrflag, r0
                 .if WANT_INTERRUPT_COUNTERS==1
000145 93ff          push zh
000146 93ef          push zl
000147 e1e2          ldi zl, low(intcnt)
000148 e0f1          ldi zh, high(intcnt)
000149 9406          lsr r0 ; we use byte addresses in the counter array, not words
00014a 0de0          add zl, r0
00014b 1df3          adc zh, zeroh
00014c 8000          ld r0, Z
00014d 9403          inc r0
00014e 8200          st Z, r0
00014f 91ef          pop zl
000150 91ff          pop zh
                 .endif
000151 9009          ld r0, Y+
000152 be0f          out SREG, r0
000153 9009          ld r0, Y+
000154 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                     ; no reti here, see words/isr-end.asm
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000155 ff02          .dw $ff02
000156 2b6d          .db "m+"
000157 0114          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
000158 f001          .dw DO_COLON
                 PFA_MPLUS:
000159 fd7e          .dw XT_S2D
00015a f447          .dw XT_DPLUS
00015b f026          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
00015c ff03          .dw $ff03
00015d 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
00015e 002a          .db "ud*"
00015f 0155          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
000160 f001          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
000161 f0c3
000162 f111
000163 f1f2
000164 f0eb              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000165 f0d6
000166 f108
000167 f1f2
000168 f0f3
000169 f1af
00016a f026              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
00016b ff04          .dw $ff04
00016c 6d75
00016d 7861          .db "umax"
00016e 015c          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
00016f f001          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
000170 f561
000171 f16e              .DW XT_2DUP,XT_ULESS
000172 f03f      	.dw XT_DOCONDBRANCH
000173 0175      	 DEST(UMAX1)
000174 f0d6              .DW XT_SWAP
000175 f0eb      UMAX1:  .DW XT_DROP
000176 f026      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
000177 ff04          .dw $ff04
000178 6d75
000179 6e69          .db "umin"
00017a 016b          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
00017b f001          .dw DO_COLON
                 PFA_UMIN:
                 .endif
00017c f561
00017d f179              .DW XT_2DUP,XT_UGREATER
00017e f03f      	.dw XT_DOCONDBRANCH
00017f 0181      	DEST(UMIN1)
000180 f0d6              .DW XT_SWAP
000181 f0eb      UMIN1:  .DW XT_DROP
000182 f026      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; return +1 if immediate, -1 otherwise, flag from name>flags
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
000183 f001          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000184 f046          .dw XT_DOLITERAL
000185 8000          .dw $8000
000186 f225          .dw XT_AND
000187 f12a          .dw XT_ZEROEQUAL
000188 f03f          .dw XT_DOCONDBRANCH
000189 018c          DEST(IMMEDIATEQ1)
00018a f3f8           .dw XT_ONE
00018b f026           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
00018c f15d          .dw XT_TRUE
00018d f026          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
00018e ff0a          .dw $ff0a
00018f 616e
000190 656d
000191 663e
000192 616c
000193 7367          .db "name>flags"
000194 0177          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
000195 f001          .dw DO_COLON
                 PFA_NAME2FLAGS:
000196 f3d9          .dw XT_FETCHI ; skip to link field
000197 f046          .dw XT_DOLITERAL
000198 ff00          .dw $ff00
000199 f225          .dw XT_AND
00019a f026          .dw XT_EXIT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
00019b ff03          .dw $ff03
00019c 6d31
00019d 0073          .db "1ms",0
00019e 018e          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
00019f 01a0          .dw PFA_1MS
                 PFA_1MS:
0001a0 eae0
0001a1 e0ff
0001a2 9731
0001a3 f7f1          delay 1000
0001a4 940c f005     jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .include "dict/appl_8k.inc"
                 
                 
                 .include "words/newest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_NEWEST:
0001a6 ff06          .dw $ff06
0001a7 656e
0001a8 6577
0001a9 7473          .db "newest"
0001aa 019b          .dw VE_HEAD
                     .set VE_HEAD = VE_NEWEST
                 XT_NEWEST:
0001ab f054          .dw PFA_DOVARIABLE
                 PFA_NEWEST:
0001ac 0135          .dw ram_newest
                 
                 .dseg
000135           ram_newest: .byte 4
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_LATEST:
0001ad ff06          .dw $ff06
0001ae 616c
0001af 6574
0001b0 7473          .db "latest"
0001b1 01a6          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
0001b2 f054          .dw PFA_DOVARIABLE
                 PFA_LATEST:
0001b3 0139          .dw ram_latest
                 
                 .dseg
000139           ram_latest: .byte 2
                 .include "words/do-create.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE:
0001b4 ff08          .dw $ff08
0001b5 6328
0001b6 6572
0001b7 7461
0001b8 2965          .db "(create)"
0001b9 01ad          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
0001ba f001          .dw DO_COLON
                 PFA_DOCREATE:
                 .endif
0001bb f9ba
0001bc 031c          .DW XT_PARSENAME,XT_WLSCOPE  ; ( -- addr len wid)
0001bd 01c7          .DW XT_DOCREATE_IN           ; ( addr len wid -- )
0001be f026          .DW XT_EXIT
                 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE_IN:
0001bf ff0b          .dw $ff0b
0001c0 6328
0001c1 6572
0001c2 7461
0001c3 2d65
0001c4 6e69
../../common\words/do-create.asm(31): warning: .cseg .db misalignment - padding zero byte
0001c5 0029          .db "(create-in)"
0001c6 01b4          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE_IN
                 XT_DOCREATE_IN:
0001c7 f001          .dw DO_COLON
                 PFA_DOCREATE_IN:
                 .endif
0001c8 f0c3
0001c9 01ab
0001ca f55a
0001cb f093          .DW XT_DUP,XT_NEWEST,XT_CELLPLUS,XT_STORE ; save the wid
0001cc 0301
0001cd 01ab
0001ce f093          .DW XT_HEADER,XT_NEWEST,XT_STORE          ; save the nt
0001cf f026          .DW XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
0001d0 0001          .dw $0001
0001d1 005c          .db $5c,0
0001d2 01bf          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
0001d3 f001          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
0001d4 f9a1          .dw XT_SOURCE
0001d5 f102          .dw XT_NIP
0001d6 f57a          .dw XT_TO_IN
0001d7 f093          .dw XT_STORE
0001d8 f026          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
0001d9 0001          .dw $0001
0001da 0028          .db "(" ,0
0001db 01d0          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
0001dc f001          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
0001dd f046          .dw XT_DOLITERAL
0001de 0029          .dw ')'
0001df f98d          .dw XT_PARSE
0001e0 f56a          .dw XT_2DROP
0001e1 f026          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
0001e2 ff07          .dw $ff07
0001e3 6f63
0001e4 706d
0001e5 6c69
0001e6 0065          .db "compile",0
0001e7 01d9          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
0001e8 f001          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
0001e9 f108          .dw XT_R_FROM
0001ea f0c3          .dw XT_DUP
0001eb fbc2          .dw XT_ICELLPLUS
0001ec f111          .dw XT_TO_R
0001ed f3d9          .dw XT_FETCHI
0001ee 01f3          .dw XT_COMMA
0001ef f026          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0001f0 ff01          .dw $ff01
0001f1 002c          .db ',',0 ; ,
0001f2 01e2          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0001f3 f001          .dw DO_COLON
                 PFA_COMMA:
0001f4 f5aa          .dw XT_DP
0001f5 f37b          .dw XT_STOREI
0001f6 f5aa          .dw XT_DP
0001f7 f241          .dw XT_1PLUS
0001f8 fbb0          .dw XT_DOTO
0001f9 f5ab          .dw PFA_DP
0001fa f026          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
0001fb 0003          .dw $0003
0001fc 275b
0001fd 005d          .db "[']",0
0001fe 01f0          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
0001ff f001          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
000200 f806          .dw XT_TICK
000201 0209          .dw XT_LITERAL
000202 f026          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
000203 0007          .dw $0007
000204 696c
000205 6574
000206 6172
000207 006c          .db "literal",0
000208 01fb          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
000209 f001          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
00020a 01e8              .DW XT_COMPILE
00020b f046              .DW XT_DOLITERAL
00020c 01f3              .DW XT_COMMA
00020d f026              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
00020e 0008        .dw $0008
00020f 6c73
000210 7469
000211 7265
000212 6c61        .db "sliteral"
000213 0203        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
000214 f001          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
000215 01e8          .dw XT_COMPILE
000216 f769          .dw XT_DOSLITERAL    ; ( -- addr n)
000217 f777          .dw XT_SCOMMA
000218 f026          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
000219 f001          .dw DO_COLON
                 PFA_GMARK:
00021a f5aa          .dw XT_DP
00021b 01e8          .dw XT_COMPILE
00021c ffff          .dw -1           ; ffff does not erase flash
00021d f026          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
00021e f001          .dw DO_COLON
                 PFA_GRESOLVE:
00021f fb6e          .dw XT_QSTACK
000220 f5aa          .dw XT_DP
000221 f0d6          .dw XT_SWAP
000222 f37b          .dw XT_STOREI
000223 f026          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
000224 f001          .dw DO_COLON
                 PFA_LMARK:
000225 f5aa          .dw XT_DP
000226 f026          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
000227 f001          .dw DO_COLON
                 PFA_LRESOLVE:
000228 fb6e          .dw XT_QSTACK
000229 01f3          .dw XT_COMMA
00022a f026          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
00022b 0005          .dw $0005
00022c 6861
00022d 6165
00022e 0064          .db "ahead",0
00022f 020e          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
000230 f001          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
000231 01e8          .dw XT_COMPILE
000232 f035          .dw XT_DOBRANCH
000233 0219          .dw XT_GMARK
000234 f026          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
000235 0002          .dw $0002
000236 6669          .db "if"
000237 022b          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
000238 f001          .dw DO_COLON
                 PFA_IF:
                 .endif
000239 01e8          .dw XT_COMPILE
00023a f03f          .dw XT_DOCONDBRANCH
00023b 0219          .dw XT_GMARK
00023c f026          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
00023d 0004          .dw $0004
00023e 6c65
00023f 6573          .db "else"
000240 0235          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
000241 f001          .dw DO_COLON
                 PFA_ELSE:
                 .endif
000242 01e8          .dw XT_COMPILE
000243 f035          .dw XT_DOBRANCH
000244 0219          .dw XT_GMARK
000245 f0d6          .dw XT_SWAP
000246 021e          .dw XT_GRESOLVE
000247 f026          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
000248 0004          .dw $0004
000249 6874
00024a 6e65          .db "then"
00024b 023d          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
00024c f001          .dw DO_COLON
                 PFA_THEN:
                 .endif
00024d 021e          .dw XT_GRESOLVE
00024e f026          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
00024f 0005          .dw $0005
000250 6562
000251 6967
000252 006e          .db "begin",0
000253 0248          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
000254 f001          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
000255 0224          .dw XT_LMARK
000256 f026          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
000257 0005          .dw $0005
000258 6877
000259 6c69
00025a 0065          .db "while",0
00025b 024f          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
00025c f001          .dw DO_COLON
                 PFA_WHILE:
                 .endif
00025d 0238          .dw XT_IF
00025e f0d6          .dw XT_SWAP
00025f f026          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
000260 0006          .dw $0006
000261 6572
000262 6570
000263 7461          .db "repeat"
000264 0257          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
000265 f001          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
000266 0279          .dw XT_AGAIN
000267 024c          .dw XT_THEN
000268 f026          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
000269 0005          .dw $0005
00026a 6e75
00026b 6974
00026c 006c          .db "until",0
00026d 0260          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
00026e f001          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
00026f f046          .dw XT_DOLITERAL
000270 f03f          .dw XT_DOCONDBRANCH
000271 01f3          .dw XT_COMMA
                 
000272 0227          .dw XT_LRESOLVE
000273 f026          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
000274 0005          .dw $0005
000275 6761
000276 6961
000277 006e          .db "again",0
000278 0269          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
000279 f001          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
00027a 01e8          .dw XT_COMPILE
00027b f035          .dw XT_DOBRANCH
00027c 0227          .dw XT_LRESOLVE
00027d f026          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
00027e 0002          .dw $0002
00027f 6f64          .db "do"
000280 0274          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000281 f001          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
000282 01e8          .dw XT_COMPILE
000283 f2ad          .dw XT_DODO
000284 0224          .dw XT_LMARK
000285 f166          .dw XT_ZERO
000286 02dc          .dw XT_TO_L
000287 f026          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
000288 0004          .dw $0004
000289 6f6c
00028a 706f          .db "loop"
00028b 027e          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
00028c f001          .dw DO_COLON
                 PFA_LOOP:
                 .endif
00028d 01e8          .dw XT_COMPILE
00028e f2db          .dw XT_DOLOOP
00028f 02c3          .dw XT_ENDLOOP
000290 f026          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
000291 0005          .dw $0005
000292 6c2b
000293 6f6f
000294 0070          .db "+loop",0
000295 0288          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
000296 f001          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
000297 01e8          .dw XT_COMPILE
000298 f2cc          .dw XT_DOPLUSLOOP
000299 02c3          .dw XT_ENDLOOP
00029a f026          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
00029b 0005         .dw $0005
00029c 656c
00029d 7661
00029e 0065         .db "leave",0
00029f 0291         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
0002a0 f001          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
0002a1 01e8
0002a2 f2e6          .DW XT_COMPILE,XT_UNLOOP
0002a3 0230
0002a4 02dc
0002a5 f026          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
0002a6 0003          .dw $0003
0002a7 643f
0002a8 006f          .db "?do",0
0002a9 029b          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
0002aa f001          .dw DO_COLON
                 PFA_QDO:
                 .endif
0002ab 01e8          .dw XT_COMPILE
0002ac 02b2          .dw XT_QDOCHECK
0002ad 0238          .dw XT_IF
0002ae 0281          .dw XT_DO
0002af f0d6          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
0002b0 02dc          .dw XT_TO_L    ; then follows at the end.
0002b1 f026          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
0002b2 f001          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
0002b3 f561          .dw XT_2DUP
0002b4 f3f1          .dw XT_EQUAL
0002b5 f0c3          .dw XT_DUP
0002b6 f111          .dw XT_TO_R
0002b7 f03f          .dw XT_DOCONDBRANCH
0002b8 02ba          DEST(PFA_QDOCHECK1)
0002b9 f56a          .dw XT_2DROP
                 PFA_QDOCHECK1:
0002ba f108          .dw XT_R_FROM
0002bb f20f          .dw XT_INVERT
0002bc f026          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
0002bd ff07          .dw $ff07
0002be 6e65
0002bf 6c64
0002c0 6f6f
0002c1 0070          .db "endloop",0
0002c2 02a6          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
0002c3 f001          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
0002c4 0227              .DW XT_LRESOLVE
0002c5 02d0
0002c6 f0cb
0002c7 f03f      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
0002c8 02cc               DEST(LOOP2)
0002c9 024c              .DW XT_THEN
0002ca f035      	.dw XT_DOBRANCH
0002cb 02c5               DEST(LOOP1)
0002cc f026      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
0002cd ff02          .dw $ff02
0002ce 3e6c          .db "l>"
0002cf 02bd          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
0002d0 f001          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
0002d1 02ef          .dw XT_LP
0002d2 f08b          .dw XT_FETCH
0002d3 f08b          .dw XT_FETCH
0002d4 f046          .dw XT_DOLITERAL
0002d5 fffe          .dw -2
0002d6 02ef          .dw XT_LP
0002d7 f277          .dw XT_PLUSSTORE
0002d8 f026          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
0002d9 ff02          .dw $ff02
0002da 6c3e          .db ">l"
0002db 02cd          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
0002dc f001          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
0002dd f3fd              .dw XT_TWO
0002de 02ef      	.dw XT_LP
0002df f277      	.dw XT_PLUSSTORE
0002e0 02ef      	.dw XT_LP
0002e1 f08b      	.dw XT_FETCH
0002e2 f093      	.dw XT_STORE
0002e3 f026      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
0002e4 ff03          .dw $ff03
0002e5 706c
0002e6 0030          .db "lp0",0
0002e7 02d9          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
0002e8 f081          .dw PFA_DOVALUE1
                 PFA_LP0:
0002e9 0052          .dw CFG_LP0
0002ea fbcb          .dw XT_EDEFERFETCH
0002eb fbd5          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
0002ec ff02          .dw $ff02
0002ed 706c          .db "lp"
0002ee 02e4          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
0002ef f054          .dw PFA_DOVARIABLE
                 PFA_LP:
0002f0 013b          .dw ram_lp
                 
                 .dseg
00013b           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CREATE:
0002f1 ff06          .dw $ff06
0002f2 7263
0002f3 6165
0002f4 6574          .db "create"
0002f5 02ec          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
0002f6 f001          .dw DO_COLON
                 PFA_CREATE:
                 .endif
0002f7 01ba          .dw XT_DOCREATE
0002f8 0325          .dw XT_REVEAL
0002f9 01e8          .dw XT_COMPILE
0002fa f061          .dw PFA_DOCONSTANT
0002fb f026          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
0002fc ff06          .dw $ff06
0002fd 6568
0002fe 6461
0002ff 7265          .db "header"
000300 02f1          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
000301 f001          .dw DO_COLON
                 PFA_HEADER:
000302 f5aa          .dw XT_DP           ; the new Name Field
000303 f111          .dw XT_TO_R
000304 f111          .dw XT_TO_R		; ( R: NFA WID )
000305 f0c3          .dw XT_DUP    
000306 f138          .dw XT_GREATERZERO 
000307 f03f          .dw XT_DOCONDBRANCH
000308 0313          .dw PFA_HEADER1
000309 f0c3          .dw XT_DUP
00030a f046          .dw XT_DOLITERAL
00030b ff00          .dw $ff00           ; all flags are off (e.g. immediate)
00030c f22e          .dw XT_OR
00030d f77b          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
00030e f108          .dw XT_R_FROM
00030f f367          .dw XT_FETCHE
000310 01f3          .dw XT_COMMA
000311 f108          .dw XT_R_FROM
000312 f026          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
000313 f046          .dw XT_DOLITERAL
000314 fff0          .dw -16
000315 f83d          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
000316 ff07          .dw $ff07
000317 6c77
000318 6373
000319 706f
00031a 0065          .db "wlscope",0
00031b 02fc          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
00031c fc2a          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
00031d 004e          .dw CFG_WLSCOPE
00031e fbcb          .dw XT_EDEFERFETCH
00031f fbd5          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REVEAL:
000320 ff06          .dw $ff06
000321 6572
000322 6576
000323 6c61          .db "reveal"
000324 0316          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
000325 f001          .dw DO_COLON
                 PFA_REVEAL:
                 .endif
000326 01ab
000327 f55a
000328 f08b          .DW XT_NEWEST,XT_CELLPLUS,XT_FETCH ; only if wordlist is in use
000329 f0cb
00032a f03f          .DW XT_QDUP,XT_DOCONDBRANCH
00032b 0330          DEST(REVEAL1)
00032c 01ab
00032d f08b
00032e f0d6
00032f f343          .DW XT_NEWEST,XT_FETCH,XT_SWAP,XT_STOREE
                 ;    .DW XT_ZERO,XT_NEWEST,XT_CELLPLUS,XT_STORE ; clean wordlist entry
                 REVEAL1:
000330 f026          .DW XT_EXIT
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
000331 0005          .dw $0005
000332 6f64
000333 7365
000334 003e          .db "does>",0
000335 0320          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000336 f001          .dw DO_COLON
                 PFA_DOES:
000337 01e8          .dw XT_COMPILE
000338 0349          .dw XT_DODOES
000339 01e8          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
00033a 940e          .dw $940e       ; the address of this compiled
00033b 01e8          .dw XT_COMPILE  ; code will replace the XT of the 
00033c 033e          .dw DO_DODOES   ; word that CREATE created
00033d f026          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
00033e 939a
00033f 938a          savetos
000340 01cb          movw tosl, wl
000341 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
000342 917f          pop wh
000343 916f          pop wl
                 
000344 93bf          push XH
000345 93af          push XL
000346 01db          movw XL, wl
000347 940c f005     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
000349 f001          .dw DO_COLON
                 PFA_DODOES:
00034a f108          .dw XT_R_FROM
00034b 01ab          .dw XT_NEWEST
00034c f55a          .dw XT_CELLPLUS
00034d f08b          .dw XT_FETCH
00034e f367          .dw XT_FETCHE
00034f fc95          .dw XT_NFA2CFA
000350 f37b          .dw XT_STOREI
000351 f026          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
000352 ff01          .dw $ff01
000353 003a          .db ":",0
000354 0331          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000355 f001          .dw DO_COLON
                 PFA_COLON:
                 .endif
000356 01ba          .dw XT_DOCREATE
000357 0360          .dw XT_COLONNONAME
000358 f0eb          .dw XT_DROP
000359 f026          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
00035a ff07          .dw $ff07
00035b 6e3a
00035c 6e6f
00035d 6d61
00035e 0065          .db ":noname",0
00035f 0352          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000360 f001          .dw DO_COLON
                 PFA_COLONNONAME:
000361 f5aa          .dw XT_DP
000362 f0c3          .dw XT_DUP
000363 01b2          .dw XT_LATEST
000364 f093          .dw XT_STORE
                 
000365 01e8          .dw XT_COMPILE
000366 f001          .dw DO_COLON
                 
000367 0375          .dw XT_RBRACKET
000368 f026          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
000369 0001          .dw $0001
00036a 003b          .db $3b,0
00036b 035a          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
00036c f001          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
00036d 01e8          .dw XT_COMPILE
00036e f026          .dw XT_EXIT
00036f 037d          .dw XT_LBRACKET
000370 0325          .dw XT_REVEAL
000371 f026          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
000372 ff01          .dw $ff01
000373 005d          .db "]",0
000374 0369          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000375 f001          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
000376 f3f8          .dw XT_ONE
000377 f547          .dw XT_STATE
000378 f093          .dw XT_STORE
000379 f026          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
00037a 0001          .dw $0001
00037b 005b          .db "[",0
00037c 0372          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
00037d f001          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
00037e f166          .dw XT_ZERO
00037f f547          .dw XT_STATE
000380 f093          .dw XT_STORE
000381 f026          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
000382 ff08          .dw $ff08
000383 6176
000384 6972
000385 6261
000386 656c          .db "variable"
000387 037a          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000388 f001          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
000389 f5bb          .dw XT_HERE
00038a 0394          .dw XT_CONSTANT
00038b f3fd          .dw XT_TWO
00038c f5c4          .dw XT_ALLOT
00038d f026          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
00038e ff08          .dw $ff08
00038f 6f63
000390 736e
000391 6174
000392 746e          .db "constant"
000393 0382          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000394 f001          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
000395 01ba          .dw XT_DOCREATE
000396 0325          .dw XT_REVEAL
000397 01e8          .dw XT_COMPILE
000398 f054          .dw PFA_DOVARIABLE
000399 01f3          .dw XT_COMMA
00039a f026          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
00039b ff04          .dw $ff04
00039c 7375
00039d 7265          .db "user"
00039e 038e          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
00039f f001          .dw DO_COLON
                 PFA_USER:
0003a0 01ba          .dw XT_DOCREATE
0003a1 0325          .dw XT_REVEAL
                 
0003a2 01e8          .dw XT_COMPILE
0003a3 f067          .dw PFA_DOUSER
0003a4 01f3          .dw XT_COMMA
0003a5 f026          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECURSE:
0003a6 0007          .dw $0007
0003a7 6572
0003a8 7563
0003a9 7372
0003aa 0065          .db "recurse",0
0003ab 039b          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
0003ac f001          .dw DO_COLON
                 PFA_RECURSE:
                 .endif
0003ad 01b2          .dw XT_LATEST
0003ae f08b          .dw XT_FETCH
0003af 01f3          .dw XT_COMMA
0003b0 f026          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
0003b1 ff09          .dw $ff09
0003b2 6d69
0003b3 656d
0003b4 6964
0003b5 7461
0003b6 0065          .db "immediate",0
0003b7 03a6          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
0003b8 f001          .dw DO_COLON
                 PFA_IMMEDIATE:
0003b9 045a          .dw XT_GET_CURRENT
0003ba f367          .dw XT_FETCHE
0003bb f0c3          .dw XT_DUP
0003bc f3d9          .dw XT_FETCHI
0003bd f046          .dw XT_DOLITERAL
0003be 7fff          .dw $7fff
0003bf f225          .dw XT_AND
0003c0 f0d6          .dw XT_SWAP
0003c1 f37b          .dw XT_STOREI
0003c2 f026          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
0003c3 0006          .dw $0006
0003c4 635b
0003c5 6168
0003c6 5d72          .db "[char]"
0003c7 03b1          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
0003c8 f001          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
0003c9 01e8          .dw XT_COMPILE
0003ca f046          .dw XT_DOLITERAL
0003cb f8eb          .dw XT_CHAR
0003cc 01f3          .dw XT_COMMA
0003cd f026          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
0003ce 0006          .dw $0006
0003cf 6261
0003d0 726f
0003d1 2274          .db "abort",'"'
0003d2 03c3          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
0003d3 f001          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
0003d4 f4bd          .dw XT_SQUOTE
0003d5 01e8          .dw XT_COMPILE
0003d6 03e5          .dw XT_QABORT
0003d7 f026          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
0003d8 ff05          .dw $ff05
0003d9 6261
0003da 726f
0003db 0074          .db "abort",0
0003dc 03ce          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
0003dd f001          .dw DO_COLON
                 PFA_ABORT:
                 .endif
0003de f15d          .dw XT_TRUE
0003df f83d          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
0003e0 ff06          .dw $ff06
0003e1 613f
0003e2 6f62
0003e3 7472          .db "?abort"
0003e4 03d8          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
0003e5 f001          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
0003e6 f0f3
0003e7 f03f              .DW XT_ROT,XT_DOCONDBRANCH
0003e8 03eb              DEST(QABO1)
0003e9 f79c
0003ea 03dd              .DW XT_ITYPE,XT_ABORT
0003eb f56a
0003ec f026      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
0003ed ff09          .dw $ff09
0003ee 6567
0003ef 2d74
0003f0 7473
0003f1 6361
0003f2 006b          .db "get-stack",0
0003f3 03e0          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
0003f4 f001          .dw DO_COLON
                 .endif
0003f5 f0c3          .dw XT_DUP
0003f6 f55a          .dw XT_CELLPLUS
0003f7 f0d6          .dw XT_SWAP
0003f8 f367          .dw XT_FETCHE
0003f9 f0c3          .dw XT_DUP
0003fa f111          .dw XT_TO_R
0003fb f166          .dw XT_ZERO
0003fc f0d6          .dw XT_SWAP    ; go from bigger to smaller addresses
0003fd 02b2          .dw XT_QDOCHECK
0003fe f03f          .dw XT_DOCONDBRANCH
0003ff 040b          DEST(PFA_N_FETCH_E2)
000400 f2ad          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
000401 f2be          .dw XT_I
000402 f247          .dw XT_1MINUS
000403 f554          .dw XT_CELLS ; ( -- ee-addr i*2 )
000404 f0e1          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
000405 f1af          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
000406 f367          .dw XT_FETCHE ;( -- ee-addr item_i )
000407 f0d6          .dw XT_SWAP   ;( -- item_i ee-addr )
000408 f15d          .dw XT_TRUE  ; shortcut for -1
000409 f2cc          .dw XT_DOPLUSLOOP
00040a 0401          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
00040b f56a          .dw XT_2DROP
00040c f108          .dw XT_R_FROM
00040d f026          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
00040e ff09          .dw $ff09
00040f 6573
000410 2d74
000411 7473
000412 6361
000413 006b          .db "set-stack",0
000414 03ed          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
000415 f001          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
000416 f0e1          .dw XT_OVER
000417 f131          .dw XT_ZEROLESS
000418 f03f          .dw XT_DOCONDBRANCH
000419 041d          DEST(PFA_SET_STACK0)
00041a f046          .dw XT_DOLITERAL
00041b fffc          .dw -4
00041c f83d          .dw XT_THROW
                 PFA_SET_STACK0:
00041d f561          .dw XT_2DUP
00041e f343          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
00041f f0d6          .dw XT_SWAP    
000420 f166          .dw XT_ZERO
000421 02b2          .dw XT_QDOCHECK
000422 f03f          .dw XT_DOCONDBRANCH
000423 042a          DEST(PFA_SET_STACK2)
000424 f2ad          .dw XT_DODO
                 PFA_SET_STACK1:
000425 f55a          .dw XT_CELLPLUS ; ( -- i_x e-addr )
000426 f572          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
000427 f343          .dw XT_STOREE
000428 f2db          .dw XT_DOLOOP
000429 0425          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
00042a f0eb          .dw XT_DROP
00042b f026          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
00042c ff09          .dw $ff09
00042d 616d
00042e 2d70
00042f 7473
000430 6361
000431 006b          .db "map-stack",0
000432 040e          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
000433 f001          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
000434 f0c3          .dw XT_DUP
000435 f55a          .dw XT_CELLPLUS
000436 f0d6          .dw XT_SWAP
000437 f367          .dw XT_FETCHE
000438 f554          .dw XT_CELLS
000439 fd75          .dw XT_BOUNDS
00043a 02b2          .dw XT_QDOCHECK
00043b f03f          .dw XT_DOCONDBRANCH
00043c 044f          DEST(PFA_MAPSTACK3)
00043d f2ad          .dw XT_DODO
                 PFA_MAPSTACK1:
00043e f2be            .dw XT_I
00043f f367            .dw XT_FETCHE   ; -- i*x XT id
000440 f0d6            .dw XT_SWAP
000441 f111            .dw XT_TO_R
000442 f118            .dw XT_R_FETCH
000443 f030            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
000444 f0cb            .dw XT_QDUP
000445 f03f            .dw XT_DOCONDBRANCH
000446 044b            DEST(PFA_MAPSTACK2)
000447 f108               .dw XT_R_FROM
000448 f0eb               .dw XT_DROP
000449 f2e6               .dw XT_UNLOOP
00044a f026               .dw XT_EXIT
                 PFA_MAPSTACK2:
00044b f108            .dw XT_R_FROM
00044c f3fd            .dw XT_TWO
00044d f2cc            .dw XT_DOPLUSLOOP
00044e 043e            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
00044f f0eb          .dw XT_DROP
000450 f166          .dw XT_ZERO
000451 f026          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ; ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000452 ff0b          .dw $ff0b
000453 6567
000454 2d74
000455 7563
000456 7272
000457 6e65
000458 0074          .db "get-current",0
000459 042c          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
00045a f001          .dw DO_COLON
                 PFA_GET_CURRENT:
00045b f046          .dw XT_DOLITERAL
00045c 0058          .dw CFG_CURRENT
00045d f367          .dw XT_FETCHE
00045e f026          .dw XT_EXIT
                 .include "words/cfg-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CFG_ORDER:
00045f ff09          .dw $ff09
000460 6663
000461 2d67
000462 726f
000463 6564
000464 0072          .db "cfg-order",0
000465 0452          .dw VE_HEAD
                     .set VE_HEAD = VE_CFG_ORDER
                 XT_CFG_ORDER:
000466 f054          .dw PFA_DOVARIABLE
                 PFA_CFG_ORDER:
                 .endif
000467 005c          .dw CFG_ORDERLISTLEN
                 .include "words/cfg-recognizer.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CFG_RECOGNIZER:
000468 ff08          .dw $ff08
000469 6663
00046a 2d67
00046b 6572
00046c 7363          .db "cfg-recs"
00046d 045f          .dw VE_HEAD
                     .set VE_HEAD = VE_CFG_RECOGNIZER
                 XT_CFG_RECOGNIZER:
00046e f054          .dw PFA_DOVARIABLE
                 PFA_CFG_RECOGNIZER:
                 .endif
00046f 006e          .dw CFG_RECOGNIZERLISTLEN
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000470 ff07          .dw $ff07
000471 6f63
000472 706d
000473 7261
000474 0065          .db "compare",0
000475 0468          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
000476 0477          .dw PFA_COMPARE
                 PFA_COMPARE:
000477 93bf          push xh
000478 93af          push xl
000479 018c          movw temp0, tosl
00047a 9189
00047b 9199          loadtos
00047c 01dc          movw xl, tosl
00047d 9189
00047e 9199          loadtos
00047f 019c          movw temp2, tosl
000480 9189
000481 9199          loadtos
000482 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000483 90ed          ld temp4, X+
000484 90f1          ld temp5, Z+
000485 14ef          cp temp4, temp5
000486 f451          brne PFA_COMPARE_NOTEQUAL
000487 950a          dec temp0
000488 f019          breq PFA_COMPARE_ENDREACHED2
000489 952a          dec temp2
00048a f7c1          brne PFA_COMPARE_LOOP
00048b c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
00048c 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
00048d 2b02          or temp0, temp2
00048e f411          brne PFA_COMPARE_CHECKLASTCHAR
00048f 2788          clr tosl
000490 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000491 ef8f          ser tosl
000492 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000493 2f98          mov tosh, tosl
000494 91af          pop xl
000495 91bf          pop xh
000496 940c f005     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
000498 ff07         .dw $ff07
000499 666e
00049a 3e61
00049b 666c
00049c 0061         .db "nfa>lfa",0
00049d 0470         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
00049e f001          .dw DO_COLON
                 PFA_NFA2LFA:
00049f fc89          .dw XT_NAME2STRING
0004a0 f241          .dw XT_1PLUS
0004a1 f216          .dw XT_2SLASH
0004a2 f1af          .dw XT_PLUS
0004a3 f026          .dw XT_EXIT
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTS:
0004a4 ff02          .dw $ff02
0004a5 732e          .db ".s"
0004a6 0498          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
0004a7 f001          .dw DO_COLON
                 PFA_DOTS:
                 .endif
0004a8 faaf          .dw XT_DEPTH
0004a9 f47a          .dw XT_UDOT
0004aa f7de          .dw XT_SPACE
0004ab faaf          .dw XT_DEPTH
0004ac f166          .dw XT_ZERO
0004ad 02b2          .dw XT_QDOCHECK
0004ae f03f          .dw XT_DOCONDBRANCH
0004af 04b6          DEST(PFA_DOTS2)
0004b0 f2ad          .dw XT_DODO
                 PFA_DOTS1:
0004b1 f2be          .dw XT_I
0004b2 f4ab          .dw XT_PICK
0004b3 f47a          .dw XT_UDOT
0004b4 f2db          .dw XT_DOLOOP
0004b5 04b1          DEST(PFA_DOTS1)
                 PFA_DOTS2:
0004b6 f026          .dw XT_EXIT
                 .include "words/spirw.asm"
                 
                 ; MCU
                 ; SPI exchange of 1 byte
                 VE_SPIRW:
0004b7 ff06          .dw $ff06
0004b8 2163
0004b9 7340
0004ba 6970          .db "c!@spi"
0004bb 04a4          .dw VE_HEAD
                     .set VE_HEAD  = VE_SPIRW
                 XT_SPIRW:
0004bc 04bd          .dw PFA_SPIRW
                 PFA_SPIRW:
0004bd d003          rcall do_spirw
0004be 2799          clr tosh
0004bf 940c f005     jmp_ DO_NEXT
                 
                 do_spirw:
0004c1 bd8e          out_ SPDR, tosl
                 do_spirw1:
0004c2 b50d          in_ temp0, SPSR
0004c3 7f08          cbr temp0,7
0004c4 bd0d          out_ SPSR, temp0
0004c5 b50d          in_ temp0, SPSR
0004c6 ff07          sbrs temp0, 7
0004c7 cffa          rjmp do_spirw1   ; wait until complete
0004c8 b58e          in_ tosl, SPDR
0004c9 9508          ret
                 .include "words/n-spi.asm"
                 
                 ; MCU
                 ; read len bytes from SPI to addr
                 VE_N_SPIR:
0004ca ff05          .dw $ff05
0004cb 406e
0004cc 7073
0004cd 0069          .db "n@spi",0
0004ce 04b7          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIR
                 XT_N_SPIR:
0004cf 04d0          .dw PFA_N_SPIR
                 PFA_N_SPIR:
0004d0 018c          movw temp0, tosl
0004d1 9189
0004d2 9199          loadtos
0004d3 01fc          movw zl, tosl
0004d4 01c8          movw tosl, temp0
                 PFA_N_SPIR_LOOP:
0004d5 bc2e          out_ SPDR, zerol
                 PFA_N_SPIR_LOOP1:
0004d6 b52d          in_ temp2, SPSR
0004d7 ff27          sbrs temp2, SPIF
0004d8 cffd          rjmp PFA_N_SPIR_LOOP1
0004d9 b52e          in_ temp2, SPDR
0004da 9321          st Z+, temp2
0004db 9701          sbiw tosl, 1
0004dc f7c1          brne PFA_N_SPIR_LOOP
0004dd 9189
0004de 9199          loadtos
0004df 940c f005     jmp_ DO_NEXT
                 
                 ; ( addr len -- ) 
                 ; MCU
                 ; write len bytes to SPI from addr
                 VE_N_SPIW:
0004e1 ff05          .dw $ff05
0004e2 216e
0004e3 7073
0004e4 0069          .db "n!spi",0
0004e5 04ca          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIW
                 XT_N_SPIW:
0004e6 04e7          .dw PFA_N_SPIW
                 PFA_N_SPIW:
0004e7 018c          movw temp0, tosl
0004e8 9189
0004e9 9199          loadtos
0004ea 01fc          movw zl, tosl
0004eb 01c8          movw tosl, temp0
                 PFA_N_SPIW_LOOP:
0004ec 9121          ld temp2, Z+
0004ed bd2e          out_ SPDR, temp2
                 PFA_N_SPIW_LOOP1:
0004ee b52d          in_ temp2, SPSR
0004ef ff27          sbrs temp2, SPIF
0004f0 cffd          rjmp PFA_N_SPIW_LOOP1
0004f1 b52e          in_ temp2, SPDR ; ignore the data
0004f2 9701          sbiw tosl, 1
0004f3 f7c1          brne PFA_N_SPIW_LOOP
0004f4 9189
0004f5 9199          loadtos
0004f6 940c f005     jmp_ DO_NEXT
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
0004f8 ff0b          .dw $ff0b
0004f9 7061
0004fa 6c70
0004fb 7574
0004fc 6e72
0004fd 656b
0004fe 0079          .db "applturnkey",0
0004ff 04e1          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000500 f001          .dw DO_COLON
                 PFA_APPLTURNKEY:
000501 00da          .dw XT_USART
                 
                 .if WANT_INTERRUPTS == 1
000502 fd9c          .dw XT_INTON
                 .endif
000503 fb7b          .dw XT_DOT_VER
000504 f7de          .dw XT_SPACE
000505 f53c          .dw XT_F_CPU
000506 f046          .dw XT_DOLITERAL
000507 03e8          .dw 1000
000508 f1d4          .dw XT_UMSLASHMOD
000509 f102          .dw XT_NIP
00050a f5d9          .dw XT_DECIMAL
00050b f71e          .dw XT_DOT
00050c f769          .dw XT_DOSLITERAL
00050d 0004          .dw 4
00050e 486b
00050f 207a          .db "kHz "
000510 f79c          .dw XT_ITYPE
000511 f026          .dw XT_EXIT
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
000512 ff0b          .dw $ff0b
000513 6573
000514 2d74
000515 7563
000516 7272
000517 6e65
000518 0074          .db "set-current",0
000519 04f8          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
00051a f001          .dw DO_COLON
                 PFA_SET_CURRENT:
00051b f046          .dw XT_DOLITERAL
00051c 0058          .dw CFG_CURRENT
00051d f343          .dw XT_STOREE
00051e f026          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
00051f ff08          .dw $ff08
000520 6f77
000521 6472
000522 696c
000523 7473          .db "wordlist"
000524 0512          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
000525 f001          .dw DO_COLON
                 PFA_WORDLIST:
000526 f5b3          .dw XT_EHERE
000527 f166          .dw XT_ZERO
000528 f0e1          .dw XT_OVER
000529 f343          .dw XT_STOREE
00052a f0c3          .dw XT_DUP
00052b f55a          .dw XT_CELLPLUS
00052c fbb0          .dw XT_DOTO
00052d f5b4          .dw PFA_EHERE
00052e f026          .dw XT_EXIT
                 
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTHWORDLIST:
00052f ff0e          .dw $ff0e
000530 6f66
000531 7472
000532 2d68
000533 6f77
000534 6472
000535 696c
000536 7473          .db "forth-wordlist"
000537 051f          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHWORDLIST
                 XT_FORTHWORDLIST:
000538 f054          .dw PFA_DOVARIABLE
                 PFA_FORTHWORDLIST:
000539 005a          .dw CFG_FORTHWORDLIST
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
00053a ff04          .dw $ff04
00053b 6f63
00053c 6564          .db "code"
00053d 052f          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
00053e f001          .dw DO_COLON
                 PFA_CODE:
00053f 01ba          .dw XT_DOCREATE
000540 0325          .dw XT_REVEAL
000541 f5aa          .dw XT_DP
000542 fbc2          .dw XT_ICELLPLUS
000543 01f3          .dw XT_COMMA
000544 f026          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000545 ff08          .dw $ff08
000546 6e65
000547 2d64
000548 6f63
000549 6564          .db "end-code"
00054a 053a          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
00054b f001          .dw DO_COLON
                 PFA_ENDCODE:
00054c 01e8          .dw XT_COMPILE
00054d 940c          .dw $940c
00054e 01e8          .dw XT_COMPILE
00054f f005          .dw DO_NEXT
000550 f026          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
000551 ff08          .dw $ff08
000552 6d28
000553 7261
000554 656b
000555 2972          .db "(marker)"
000556 0545          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
000557 f081          .dw PFA_DOVALUE1
                 PFA_MARKER:
000558 007a          .dw EE_MARKER
000559 fbcb          .dw XT_EDEFERFETCH
00055a fbd5          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
00055b 0008          .dw $0008
00055c 6f70
00055d 7473
00055e 6f70
00055f 656e          .db "postpone"
000560 0551          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
000561 f001          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
000562 f9ba          .dw XT_PARSENAME
000563 fada          .dw XT_FORTHRECOGNIZER
000564 fae5          .dw XT_RECOGNIZE
000565 f0c3          .dw XT_DUP
000566 f111          .dw XT_TO_R
000567 fbc2          .dw XT_ICELLPLUS
000568 fbc2          .dw XT_ICELLPLUS
000569 f3d9          .dw XT_FETCHI
00056a f030          .dw XT_EXECUTE
00056b f108          .dw XT_R_FROM
00056c fbc2          .dw XT_ICELLPLUS
00056d f3d9          .dw XT_FETCHI
00056e 01f3          .dw XT_COMMA
00056f f026          .dw XT_EXIT
                 .endif
                 .include "words/2r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_2R_FETCH:
000570 ff03          .dw $ff03
000571 7232
000572 0040          .db "2r@",0
000573 055b          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FETCH
                 XT_2R_FETCH:
000574 0575          .dw PFA_2R_FETCH
                 PFA_2R_FETCH:
000575 939a
000576 938a          savetos
000577 91ef          pop zl
000578 91ff          pop zh
000579 918f          pop tosl
00057a 919f          pop tosh
00057b 939f          push tosh
00057c 938f          push tosl
00057d 93ff          push zh
00057e 93ef          push zl
00057f 939a
000580 938a          savetos
000581 01cf          movw tosl, zl
000582 940c f005     jmp_ DO_NEXT
                 
                 .set DPSTART = pc
                 .if(pc>AMFORTH_RO_SEG)
                 .endif
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
00f001 93bf          push XH
00f002 93af          push XL          ; PUSH IP
00f003 01db          movw XL, wl
00f004 9611          adiw xl, 1
                 DO_NEXT:
                 .if WANT_INTERRUPTS == 1
00f005 14b2          cp isrflag, zerol
00f006 f499          brne DO_INTERRUPT
                 .endif
00f007 01fd          movw zl, XL        ; READ IP
00f008 2755
00f009 0fee
00f00a 1fff
00f00b 1f55
00f00c bf5b
00f00d 9167
00f00e 9177          readflashcell wl, wh
00f00f 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00f010 01fb          movw zl, wl
00f011 2755
00f012 0fee
00f013 1fff
00f014 1f55
00f015 bf5b
00f016 9107
00f017 9117          readflashcell temp0,temp1
00f018 01f8          movw zl, temp0
00f019 9409          ijmp
                 
                 .if WANT_INTERRUPTS == 1
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
00f01a 939a
00f01b 938a          savetos
00f01c 2d8b          mov tosl, isrflag
00f01d 24bb          clr isrflag
00f01e 2799          clr tosh
00f01f ec68          ldi wl, LOW(XT_ISREXEC)
00f020 ef7d          ldi wh, HIGH(XT_ISREXEC)
00f021 cfee          rjmp DO_EXECUTE
                 .endif
                 .include "dict/nrww.inc"
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
00f022 ff04          .dw $ff04
00f023 7865
00f024 7469          .db "exit"
00f025 0570          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00f026 f027          .dw PFA_EXIT
                 PFA_EXIT:
00f027 91af          pop XL
00f028 91bf          pop XH
00f029 cfdb          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
00f02a ff07          .dw $ff07
00f02b 7865
00f02c 6365
00f02d 7475
00f02e 0065          .db "execute",0
00f02f f022          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
00f030 f031          .dw PFA_EXECUTE
                 PFA_EXECUTE:
00f031 01bc          movw wl, tosl
00f032 9189
00f033 9199          loadtos
00f034 cfdb          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
00f035 f036          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00f036 01fd          movw zl, XL
00f037 2755
00f038 0fee
00f039 1fff
00f03a 1f55
00f03b bf5b
00f03c 91a7
00f03d 91b7          readflashcell XL,XH
00f03e cfc6          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
00f03f f040          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
00f040 2b98          or tosh, tosl
00f041 9189
00f042 9199          loadtos
00f043 f391          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
00f044 9611          adiw XL, 1
00f045 cfbf          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
00f046 f047          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
00f047 939a
00f048 938a          savetos
00f049 01fd          movw zl, xl
00f04a 2755
00f04b 0fee
00f04c 1fff
00f04d 1f55
00f04e bf5b
00f04f 9187
00f050 9197          readflashcell tosl,tosh
00f051 9611          adiw xl, 1
00f052 cfb2          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
00f053 f054          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
00f054 939a
00f055 938a          savetos
00f056 01fb          movw zl, wl
00f057 9631          adiw zl,1
00f058 2755
00f059 0fee
00f05a 1fff
00f05b 1f55
00f05c bf5b
00f05d 9187
00f05e 9197          readflashcell tosl,tosh
00f05f cfa5          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00f060 f061          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00f061 939a
00f062 938a          savetos
00f063 01cb          movw tosl, wl
00f064 9601          adiw tosl, 1
00f065 cf9f          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
00f066 f067          .dw PFA_DOUSER
                 PFA_DOUSER:
00f067 939a
00f068 938a          savetos
00f069 01fb          movw zl, wl
00f06a 9631          adiw zl, 1
00f06b 2755
00f06c 0fee
00f06d 1fff
00f06e 1f55
00f06f bf5b
00f070 9187
00f071 9197          readflashcell tosl,tosh
00f072 0d84          add tosl, upl
00f073 1d95          adc tosh, uph
00f074 cf90          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
00f075 ff07          .dw $ff07
00f076 7628
00f077 6c61
00f078 6575
00f079 0029          .db "(value)", 0
00f07a f02a          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
00f07b f001          .dw DO_COLON
                 PFA_DOVALUE:
00f07c 01ba          .dw XT_DOCREATE
00f07d 0325          .dw XT_REVEAL
00f07e 01e8          .dw XT_COMPILE
00f07f f081          .dw PFA_DOVALUE1
00f080 f026          .dw XT_EXIT
                 PFA_DOVALUE1:
00f081 940e 033e     call_ DO_DODOES
00f083 f0c3          .dw XT_DUP
00f084 fbc2          .dw XT_ICELLPLUS
00f085 f3d9          .dw XT_FETCHI
00f086 f030          .dw XT_EXECUTE
00f087 f026          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
00f088 ff01          .dw $ff01
00f089 0040          .db "@",0
00f08a f075          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
00f08b f08c          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
00f08c 01fc          movw zl, tosl
                     ; low byte is read before the high byte
00f08d 9181          ld tosl, z+
00f08e 9191          ld tosh, z+
00f08f cf75          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
00f090 ff01          .dw $ff01
00f091 0021          .db "!",0
00f092 f088          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00f093 f094          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00f094 01fc          movw zl, tosl
00f095 9189
00f096 9199          loadtos
                     ; the high byte is written before the low byte
00f097 8391          std Z+1, tosh
00f098 8380          std Z+0, tosl
00f099 9189
00f09a 9199          loadtos
00f09b cf69          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
00f09c ff02          .dw $ff02
00f09d 2163          .db "c!"
00f09e f090          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
00f09f f0a0          .dw PFA_CSTORE
                 PFA_CSTORE:
00f0a0 01fc          movw zl, tosl
00f0a1 9189
00f0a2 9199          loadtos
00f0a3 8380          st Z, tosl
00f0a4 9189
00f0a5 9199          loadtos
00f0a6 cf5e          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
00f0a7 ff02          .dw $ff02
00f0a8 4063          .db "c@"
00f0a9 f09c          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
00f0aa f0ab          .dw PFA_CFETCH
                 PFA_CFETCH:
00f0ab 01fc          movw zl, tosl
00f0ac 2799          clr tosh
00f0ad 8180          ld tosl, Z
00f0ae cf56          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
00f0af ff02          .dw $ff02
00f0b0 7540          .db "@u"
00f0b1 f0a7          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00f0b2 f001          .dw DO_COLON
                 PFA_FETCHU:
00f0b3 f314          .dw XT_UP_FETCH
00f0b4 f1af          .dw XT_PLUS
00f0b5 f08b          .dw XT_FETCH
00f0b6 f026          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
00f0b7 ff02          .dw $ff02
00f0b8 7521          .db "!u"
00f0b9 f0af          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
00f0ba f001          .dw DO_COLON
                 PFA_STOREU:
00f0bb f314          .dw XT_UP_FETCH
00f0bc f1af          .dw XT_PLUS
00f0bd f093          .dw XT_STORE
00f0be f026          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
00f0bf ff03          .dw $ff03
00f0c0 7564
00f0c1 0070          .db "dup",0
00f0c2 f0b7          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
00f0c3 f0c4          .dw PFA_DUP
                 PFA_DUP:
00f0c4 939a
00f0c5 938a          savetos
00f0c6 cf3e          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
00f0c7 ff04          .dw $ff04
00f0c8 643f
00f0c9 7075          .db "?dup"
00f0ca f0bf          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
00f0cb f0cc          .dw PFA_QDUP
                 PFA_QDUP:
00f0cc 2f08          mov temp0, tosl
00f0cd 2b09          or temp0, tosh
00f0ce f011          breq PFA_QDUP1
00f0cf 939a
00f0d0 938a          savetos
                 PFA_QDUP1:
00f0d1 cf33          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
00f0d2 ff04          .dw $ff04
00f0d3 7773
00f0d4 7061          .db "swap"
00f0d5 f0c7          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
00f0d6 f0d7          .dw PFA_SWAP
                 PFA_SWAP:
00f0d7 018c          movw temp0, tosl
00f0d8 9189
00f0d9 9199          loadtos
00f0da 931a          st -Y, temp1
00f0db 930a          st -Y, temp0
00f0dc cf28          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
00f0dd ff04          .dw $ff04
00f0de 766f
00f0df 7265          .db "over"
00f0e0 f0d2          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
00f0e1 f0e2          .dw PFA_OVER
                 PFA_OVER:
00f0e2 939a
00f0e3 938a          savetos
00f0e4 818a          ldd tosl, Y+2
00f0e5 819b          ldd tosh, Y+3
                 
00f0e6 cf1e          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
00f0e7 ff04          .dw $ff04
00f0e8 7264
00f0e9 706f          .db "drop"
00f0ea f0dd          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
00f0eb f0ec          .dw PFA_DROP
                 PFA_DROP:
00f0ec 9189
00f0ed 9199          loadtos
00f0ee cf16          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
00f0ef ff03          .dw $ff03
00f0f0 6f72
00f0f1 0074          .db "rot",0
00f0f2 f0e7          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
00f0f3 f0f4          .dw PFA_ROT
                 PFA_ROT:
00f0f4 018c          movw temp0, tosl
00f0f5 9129          ld temp2, Y+
00f0f6 9139          ld temp3, Y+ 
00f0f7 9189
00f0f8 9199          loadtos
                         
00f0f9 933a          st -Y, temp3
00f0fa 932a          st -Y, temp2
00f0fb 931a          st -Y, temp1
00f0fc 930a          st -Y, temp0
                 
00f0fd cf07          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
00f0fe ff03          .dw $ff03
00f0ff 696e
00f100 0070          .db "nip",0
00f101 f0ef          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
00f102 f103          .dw PFA_NIP
                 PFA_NIP:
00f103 9622          adiw yl, 2
00f104 cf00          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
00f105 ff02          .dw $ff02
00f106 3e72          .db "r>"
00f107 f0fe          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
00f108 f109          .dw PFA_R_FROM
                 PFA_R_FROM:
00f109 939a
00f10a 938a          savetos
00f10b 918f          pop tosl
00f10c 919f          pop tosh
00f10d cef7          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
00f10e ff02          .dw $ff02
00f10f 723e          .db ">r"
00f110 f105          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
00f111 f112          .dw PFA_TO_R
                 PFA_TO_R:
00f112 939f          push tosh
00f113 938f          push tosl
00f114 cfd7          jmp_ PFA_DROP
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
00f115 ff02          .dw $ff02
00f116 4072          .db "r@"
00f117 f10e          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
00f118 f119          .dw PFA_R_FETCH
                 PFA_R_FETCH:
00f119 939a
00f11a 938a          savetos
00f11b 918f          pop tosl
00f11c 919f          pop tosh
00f11d 939f          push tosh
00f11e 938f          push tosl
00f11f cee5          jmp_ DO_NEXT
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
00f120 ff02          .dw $ff02
00f121 3e3c          .db "<>"
00f122 f115          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
00f123 f001          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
00f124 f3f1
00f125 f12a
00f126 f026          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
00f127 ff02          .dw $ff02
00f128 3d30          .db "0="
00f129 f120          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
00f12a f12b          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
00f12b 2b98          or tosh, tosl
00f12c f5e1          brne PFA_ZERO1
00f12d c032          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
00f12e ff02          .dw $ff02
00f12f 3c30          .db "0<"
00f130 f127          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
00f131 f132          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
00f132 fd97          sbrc tosh,7
00f133 c02c          rjmp PFA_TRUE1
00f134 c034          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
00f135 ff02          .dw $ff02
00f136 3e30          .db "0>"
00f137 f12e          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
00f138 f139          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
00f139 1582          cp tosl, zerol
00f13a 0593          cpc tosh, zeroh
00f13b f16c          brlt PFA_ZERO1
00f13c f161          brbs 1, PFA_ZERO1
00f13d c022          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
00f13e ff03          .dw $ff03
00f13f 3064
00f140 003e          .db "d0>",0
00f141 f135          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00f142 f143          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
00f143 1593          cp tosh, zeroh
00f144 f03c          brlt PFA_DGREATERZERO_FALSE ; if MSBit is set, d:arg is negative, we are done (false).
00f145 0582          cpc tosl, zerol
00f146 9189
00f147 9199          loadtos
00f148 0582          cpc tosl, zerol
00f149 0593          cpc tosh, zeroh
00f14a f0f1          brbs 1, PFA_ZERO1           ; if all 4 Bytes of d:arg are zero, we are done (false).
00f14b c014          rjmp PFA_TRUE1              ; if we get this far, d:arg was positive! (true)
                 PFA_DGREATERZERO_FALSE:
00f14c 01c1          movw tosl, zerol            ; ZERO
00f14d cfb5          rjmp PFA_NIP                ; NIP
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
00f14e ff03          .dw $ff03
00f14f 3064
00f150 003c          .db "d0<",0
00f151 f13e          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
00f152 f153          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
00f153 9622          adiw Y,2
00f154 fd97          sbrc tosh,7
00f155 940c f160     jmp PFA_TRUE1
00f157 940c f169     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
00f159 ff04          .dw $ff04
00f15a 7274
00f15b 6575          .db "true"
00f15c f14e          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
00f15d f15e          .dw PFA_TRUE
                 PFA_TRUE:
00f15e 939a
00f15f 938a          savetos
                 PFA_TRUE1:
00f160 ef8f          ser tosl
00f161 ef9f          ser tosh
00f162 cea2          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
00f163 ff01          .dw $ff01
00f164 0030          .db "0",0
00f165 f159          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
00f166 f167          .dw PFA_ZERO
                 PFA_ZERO:
00f167 939a
00f168 938a          savetos
                 PFA_ZERO1:
00f169 01c1          movw tosl, zerol
00f16a ce9a          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
00f16b ff02          .dw $ff02
00f16c 3c75          .db "u<"
00f16d f163          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
00f16e f16f          .dw PFA_ULESS
                 PFA_ULESS:
00f16f 9129          ld temp2, Y+
00f170 9139          ld temp3, Y+
00f171 1782          cp tosl, temp2
00f172 0793          cpc tosh, temp3
00f173 f3a8          brlo PFA_ZERO1
00f174 f3a1          brbs 1, PFA_ZERO1
00f175 cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
00f176 ff02          .dw $ff02
00f177 3e75          .db "u>"
00f178 f16b          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
00f179 f001          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
00f17a f0d6          .DW XT_SWAP
00f17b f16e          .dw XT_ULESS
00f17c f026          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
00f17d ff01          .dw $ff01
00f17e 003c          .db "<",0
00f17f f176          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
00f180 f181          .dw PFA_LESS
                 PFA_LESS:
00f181 9129          ld temp2, Y+
00f182 9139          ld temp3, Y+
00f183 1728          cp temp2, tosl
00f184 0739          cpc temp3, tosh
                 PFA_LESSDONE:
00f185 f71c          brge PFA_ZERO1
00f186 cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
00f187 ff01          .dw $ff01
00f188 003e          .db ">",0
00f189 f17d          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
00f18a f18b          .dw PFA_GREATER
                 PFA_GREATER:
00f18b 9129          ld temp2, Y+
00f18c 9139          ld temp3, Y+
00f18d 1728          cp temp2, tosl
00f18e 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
00f18f f2cc          brlt PFA_ZERO1
00f190 f2c1          brbs 1, PFA_ZERO1
00f191 cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
00f192 ff04          .dw $ff04
00f193 6f6c
00f194 3267          .db "log2"
00f195 f187          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
00f196 f197          .dw PFA_LOG2
                 PFA_LOG2:
00f197 01fc          movw zl, tosl
00f198 2799          clr tosh
00f199 e180          ldi tosl, 16
                 PFA_LOG2_1:
00f19a 958a          dec tosl
00f19b f022          brmi PFA_LOG2_2 ; wrong data
00f19c 0fee          lsl  zl
00f19d 1fff          rol  zh
00f19e f7d8          brcc PFA_LOG2_1
00f19f ce65          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
00f1a0 959a          dec tosh
00f1a1 ce63          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
00f1a2 ff01          .dw $ff01
00f1a3 002d          .db "-",0
00f1a4 f192          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
00f1a5 f1a6          .dw PFA_MINUS
                 PFA_MINUS:
00f1a6 9109          ld temp0, Y+
00f1a7 9119          ld temp1, Y+
00f1a8 1b08          sub temp0, tosl
00f1a9 0b19          sbc temp1, tosh
00f1aa 01c8          movw tosl, temp0
00f1ab ce59          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
00f1ac ff01          .dw $ff01
00f1ad 002b          .db "+",0
00f1ae f1a2          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
00f1af f1b0          .dw PFA_PLUS
                 PFA_PLUS:
00f1b0 9109          ld temp0, Y+
00f1b1 9119          ld temp1, Y+
00f1b2 0f80          add tosl, temp0
00f1b3 1f91          adc tosh, temp1
00f1b4 ce50          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
00f1b5 ff02          .dw $ff02
00f1b6 2a6d          .db "m*"
00f1b7 f1ac          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
00f1b8 f1b9          .dw PFA_MSTAR
                 PFA_MSTAR:
00f1b9 018c          movw temp0, tosl
00f1ba 9189
00f1bb 9199          loadtos
00f1bc 019c          movw temp2, tosl
                     ; high cell ah*bh
00f1bd 0231          muls temp3, temp1
00f1be 0170          movw temp4, r0
                     ; low cell  al*bl
00f1bf 9f20          mul  temp2, temp0
00f1c0 01c0          movw tosl, r0
                     ; signed ah*bl
00f1c1 0330          mulsu temp3, temp0
00f1c2 08f3          sbc   temp5, zeroh
00f1c3 0d90          add   tosh,  r0
00f1c4 1ce1          adc   temp4, r1
00f1c5 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
00f1c6 0312          mulsu temp1, temp2
00f1c7 08f3          sbc   temp5, zeroh
00f1c8 0d90          add   tosh,  r0
00f1c9 1ce1          adc   temp4, r1
00f1ca 1cf3          adc   temp5, zeroh
                 
00f1cb 939a
00f1cc 938a          savetos
00f1cd 01c7          movw tosl, temp4
00f1ce ce36          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
00f1cf ff06          .dw $ff06
00f1d0 6d75
00f1d1 6d2f
00f1d2 646f          .db "um/mod"
00f1d3 f1b5          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
00f1d4 f1d5          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
00f1d5 017c          movw temp4, tosl
                 
00f1d6 9129          ld temp2, Y+
00f1d7 9139          ld temp3, Y+
                   
00f1d8 9109          ld temp0, Y+
00f1d9 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
00f1da e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
00f1db 2755          clr temp7
00f1dc 0f00          lsl temp0
00f1dd 1f11          rol temp1
00f1de 1f22          rol temp2
00f1df 1f33          rol temp3
00f1e0 1f55          rol temp7
                 
                   ; try subtracting divisor
00f1e1 152e          cp temp2, temp4
00f1e2 053f          cpc temp3, temp5
00f1e3 0552          cpc temp7,zerol
                 
00f1e4 f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
00f1e5 9503          inc temp0
00f1e6 192e          sub temp2, temp4
00f1e7 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
00f1e8 954a          dec  temp6
00f1e9 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
00f1ea 933a          st -Y,temp3
00f1eb 932a          st -Y,temp2
                 
                     ; put quotient on stack
00f1ec 01c8          movw tosl, temp0
00f1ed ce17          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
00f1ee ff03          .dw $ff03
00f1ef 6d75
00f1f0 002a          .db "um*",0
00f1f1 f1cf          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
00f1f2 f1f3          .dw PFA_UMSTAR
                 PFA_UMSTAR:
00f1f3 018c          movw temp0, tosl
00f1f4 9189
00f1f5 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
00f1f6 9f80          mul tosl,temp0
00f1f7 01f0          movw zl, r0
00f1f8 2722          clr temp2
00f1f9 2733          clr temp3
                     ; middle bytes
00f1fa 9f90          mul tosh, temp0
00f1fb 0df0          add zh, r0
00f1fc 1d21          adc temp2, r1
00f1fd 1d33          adc temp3, zeroh
                         
00f1fe 9f81          mul tosl, temp1
00f1ff 0df0          add zh, r0
00f200 1d21          adc temp2, r1
00f201 1d33          adc temp3, zeroh
                     
00f202 9f91          mul tosh, temp1
00f203 0d20          add temp2, r0
00f204 1d31          adc temp3, r1
00f205 01cf          movw tosl, zl
00f206 939a
00f207 938a          savetos
00f208 01c9          movw tosl, temp2
00f209 cdfb          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
00f20a ff06          .dw $ff06
00f20b 6e69
00f20c 6576
00f20d 7472          .db "invert"
00f20e f1ee          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
00f20f f210          .dw PFA_INVERT
                 PFA_INVERT:
00f210 9580          com tosl
00f211 9590          com tosh
00f212 cdf2          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
00f213 ff02          .dw $ff02
00f214 2f32          .db "2/"
00f215 f20a          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
00f216 f217          .dw PFA_2SLASH
                 PFA_2SLASH:
00f217 9595          asr tosh
00f218 9587          ror tosl
00f219 cdeb          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
00f21a ff02          .dw $ff02
00f21b 2a32          .db "2*"
00f21c f213          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
00f21d f21e          .dw PFA_2STAR
                 PFA_2STAR:
00f21e 0f88          lsl tosl
00f21f 1f99          rol tosh
00f220 cde4          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
00f221 ff03          .dw $ff03
00f222 6e61
00f223 0064          .db "and",0
00f224 f21a          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
00f225 f226          .dw PFA_AND
                 PFA_AND:
00f226 9109          ld temp0, Y+
00f227 9119          ld temp1, Y+
00f228 2380          and tosl, temp0
00f229 2391          and tosh, temp1
00f22a cdda          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
00f22b ff02          .dw $ff02
00f22c 726f          .db "or"
00f22d f221          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
00f22e f22f          .dw PFA_OR
                 PFA_OR:
00f22f 9109          ld temp0, Y+
00f230 9119          ld temp1, Y+
00f231 2b80          or tosl, temp0
00f232 2b91          or tosh, temp1
00f233 cdd1          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
00f234 ff03          .dw $ff03
00f235 6f78
00f236 0072          .db "xor",0
00f237 f22b          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
00f238 f239          .dw PFA_XOR
                 PFA_XOR:
00f239 9109          ld temp0, Y+
00f23a 9119          ld temp1, Y+
00f23b 2780          eor tosl, temp0
00f23c 2791          eor tosh, temp1
00f23d cdc7          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
00f23e ff02          .dw $ff02
00f23f 2b31          .db "1+"
00f240 f234          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
00f241 f242          .dw PFA_1PLUS
                 PFA_1PLUS:
00f242 9601          adiw tosl,1
00f243 cdc1          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
00f244 ff02          .dw $ff02 
00f245 2d31          .db "1-"
00f246 f23e          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
00f247 f248          .dw PFA_1MINUS
                 PFA_1MINUS:
00f248 9701          sbiw tosl, 1
00f249 cdbb          jmp_ DO_NEXT
                 .include "words/q-negate.asm"
                 
                 ;   0< IF NEGATE THEN ;        ...a common factor
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QNEGATE:
00f24a ff07          .dw $ff07
00f24b 6e3f
00f24c 6765
00f24d 7461
../../common\words/q-negate.asm(11): warning: .cseg .db misalignment - padding zero byte
00f24e 0065          .db "?negate"
00f24f f244          .dw VE_HEAD
                     .set VE_HEAD = VE_QNEGATE
                 XT_QNEGATE:
00f250 f001          .dw DO_COLON
                 PFA_QNEGATE:
                 
                 .endif
00f251 f131
00f252 f03f              .DW XT_ZEROLESS,XT_DOCONDBRANCH
00f253 f255              DEST(QNEG1)
00f254 f63b              .DW XT_NEGATE
00f255 f026      QNEG1:  .DW XT_EXIT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
00f256 ff06          .dw $ff06
00f257 736c
00f258 6968
00f259 7466          .db "lshift"
00f25a f24a          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
00f25b f25c          .dw PFA_LSHIFT
                 PFA_LSHIFT:
00f25c 01fc          movw zl, tosl
00f25d 9189
00f25e 9199          loadtos
                 PFA_LSHIFT1:
00f25f 9731          sbiw zl, 1
00f260 f01a          brmi PFA_LSHIFT2
00f261 0f88          lsl tosl
00f262 1f99          rol tosh
00f263 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
00f264 cda0          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
00f265 ff06          .dw $ff06
00f266 7372
00f267 6968
00f268 7466          .db "rshift"
00f269 f256          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
00f26a f26b          .dw PFA_RSHIFT
                 PFA_RSHIFT:
00f26b 01fc          movw zl, tosl
00f26c 9189
00f26d 9199          loadtos
                 PFA_RSHIFT1:
00f26e 9731          sbiw zl, 1
00f26f f01a          brmi PFA_RSHIFT2
00f270 9596          lsr tosh
00f271 9587          ror tosl
00f272 cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
00f273 cd91          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
00f274 ff02          .dw $ff02
00f275 212b          .db "+!"
00f276 f265          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
00f277 f278          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
00f278 01fc          movw zl, tosl
00f279 9189
00f27a 9199          loadtos
00f27b 8120          ldd temp2, Z+0
00f27c 8131          ldd temp3, Z+1
00f27d 0f82          add tosl, temp2
00f27e 1f93          adc tosh, temp3
00f27f 8380          std Z+0, tosl
00f280 8391          std Z+1, tosh
00f281 9189
00f282 9199          loadtos
00f283 cd81          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
00f284 ff03          .dw $ff03
00f285 7072
00f286 0040          .db "rp@",0
00f287 f274          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
00f288 f289          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
00f289 939a
00f28a 938a          savetos
00f28b b78d          in tosl, SPL
00f28c b79e          in tosh, SPH
00f28d cd77          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
00f28e ff03          .dw $ff03
00f28f 7072
00f290 0021          .db "rp!",0
00f291 f284          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
00f292 f293          .dw PFA_RP_STORE
                 PFA_RP_STORE:
00f293 b72f          in temp2, SREG
00f294 94f8          cli
00f295 bf8d          out SPL, tosl
00f296 bf9e          out SPH, tosh
00f297 bf2f          out SREG, temp2
00f298 9189
00f299 9199          loadtos
00f29a cd6a          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
00f29b ff03          .dw $ff03
00f29c 7073
00f29d 0040          .db "sp@",0
00f29e f28e          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
00f29f f2a0          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
00f2a0 939a
00f2a1 938a          savetos
00f2a2 01ce          movw tosl, yl
00f2a3 cd61          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
00f2a4 ff03          .dw $ff03
00f2a5 7073
00f2a6 0021          .db "sp!",0
00f2a7 f29b          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
00f2a8 f2a9          .dw PFA_SP_STORE
                 PFA_SP_STORE:
00f2a9 01ec          movw yl, tosl
00f2aa 9189
00f2ab 9199          loadtos
00f2ac cd58          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
00f2ad f2ae          .dw PFA_DODO
                 PFA_DODO:
00f2ae 9129          ld temp2, Y+
00f2af 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
00f2b0 e8e0          ldi zl, $80
00f2b1 0f3e          add temp3, zl
00f2b2 1b82          sub  tosl, temp2
00f2b3 0b93          sbc  tosh, temp3
                 
00f2b4 933f          push temp3
00f2b5 932f          push temp2    ; limit  ( --> limit + $8000)
00f2b6 939f          push tosh
00f2b7 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
00f2b8 9189
00f2b9 9199          loadtos
00f2ba cd4a          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
00f2bb ff01          .dw $FF01
00f2bc 0069          .db "i",0
00f2bd f2a4          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
00f2be f2bf          .dw PFA_I
                 PFA_I:
00f2bf 939a
00f2c0 938a          savetos
00f2c1 918f          pop tosl
00f2c2 919f          pop tosh  ; index
00f2c3 91ef          pop zl
00f2c4 91ff          pop zh    ; limit
00f2c5 93ff          push zh
00f2c6 93ef          push zl
00f2c7 939f          push tosh
00f2c8 938f          push tosl
00f2c9 0f8e          add tosl, zl
00f2ca 1f9f          adc tosh, zh
00f2cb cd39          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
00f2cc f2cd          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
00f2cd 91ef          pop zl
00f2ce 91ff          pop zh
00f2cf 0fe8          add zl, tosl
00f2d0 1ff9          adc zh, tosh
00f2d1 9189
00f2d2 9199          loadtos
00f2d3 f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
00f2d4 93ff          push zh
00f2d5 93ef          push zl
00f2d6 cd5f          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
00f2d7 910f          pop  temp0
00f2d8 911f          pop  temp1  ; remove limit
00f2d9 9611          adiw xl, 1  ; skip branch-back address
00f2da cd2a          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
00f2db f2dc          .dw PFA_DOLOOP
                 PFA_DOLOOP:
00f2dc 91ef          pop zl
00f2dd 91ff          pop zh
00f2de 9631          adiw zl,1
00f2df f3bb          brvs PFA_DOPLUSLOOP_LEAVE
00f2e0 cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
00f2e1 ff06          .dw $ff06
00f2e2 6e75
00f2e3 6f6c
00f2e4 706f          .db "unloop"
00f2e5 f2bb          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
00f2e6 f2e7          .dw PFA_UNLOOP
                 PFA_UNLOOP:
00f2e7 911f          pop temp1
00f2e8 910f          pop temp0
00f2e9 911f          pop temp1
00f2ea 910f          pop temp0
00f2eb cd19          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
00f2ec ff06          .dw $ff06
00f2ed 6d63
00f2ee 766f
00f2ef 3e65          .db "cmove>"
00f2f0 f2e1          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
00f2f1 f2f2          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
00f2f2 93bf          push xh
00f2f3 93af          push xl
00f2f4 91e9          ld zl, Y+
00f2f5 91f9          ld zh, Y+ ; addr-to
00f2f6 91a9          ld xl, Y+
00f2f7 91b9          ld xh, Y+ ; addr-from
00f2f8 2f09          mov temp0, tosh
00f2f9 2b08          or temp0, tosl
00f2fa f041          brbs 1, PFA_CMOVE_G1
00f2fb 0fe8          add zl, tosl
00f2fc 1ff9          adc zh, tosh
00f2fd 0fa8          add xl, tosl
00f2fe 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
00f2ff 911e          ld temp1, -X
00f300 9312          st -Z, temp1
00f301 9701          sbiw tosl, 1
00f302 f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
00f303 91af          pop xl
00f304 91bf          pop xh
00f305 9189
00f306 9199          loadtos
00f307 ccfd          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
00f308 ff02          .dw $ff02
00f309 3c3e          .db "><"
00f30a f2ec          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
00f30b f30c          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
00f30c 2f09          mov temp0, tosh
00f30d 2f98          mov tosh, tosl
00f30e 2f80          mov tosl, temp0
00f30f ccf5          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
00f310 ff03          .dw $ff03
00f311 7075
00f312 0040          .db "up@",0
00f313 f308          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
00f314 f315          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
00f315 939a
00f316 938a          savetos
00f317 01c2          movw tosl, upl
00f318 ccec          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
00f319 ff03          .dw $ff03
00f31a 7075
00f31b 0021          .db "up!",0
00f31c f310          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
00f31d f31e          .dw PFA_UP_STORE
                 PFA_UP_STORE:
00f31e 012c          movw upl, tosl
00f31f 9189
00f320 9199          loadtos
00f321 cce3          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
00f322 ff03          .dw $ff03
00f323 3e32
00f324 0072          .db "2>r",0
00f325 f319          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
00f326 f327          .dw PFA_2TO_R
                 PFA_2TO_R:
00f327 01fc          movw zl, tosl
00f328 9189
00f329 9199          loadtos
00f32a 939f          push tosh
00f32b 938f          push tosl
00f32c 93ff          push zh
00f32d 93ef          push zl
00f32e 9189
00f32f 9199          loadtos
00f330 ccd4          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
00f331 ff03          .dw $ff03
00f332 7232
00f333 003e          .db "2r>",0
00f334 f322          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
00f335 f336          .dw PFA_2R_FROM
                 PFA_2R_FROM:
00f336 939a
00f337 938a          savetos
00f338 91ef          pop zl
00f339 91ff          pop zh
00f33a 918f          pop tosl
00f33b 919f          pop tosh
00f33c 939a
00f33d 938a          savetos
00f33e 01cf          movw tosl, zl
00f33f ccc5          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
00f340 ff02          .dw $ff02
00f341 6521          .db "!e"
00f342 f331          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
00f343 f344          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
00f344 01fc          movw zl, tosl
00f345 9189
00f346 9199          loadtos
00f347 b72f          in_ temp2, SREG
00f348 94f8          cli
00f349 d028          rcall PFA_FETCHE2
00f34a b500          in_  temp0, EEDR
00f34b 1708          cp temp0,tosl
00f34c f009          breq PFA_STOREE3
00f34d d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
00f34e 9631          adiw zl,1
00f34f d022          rcall PFA_FETCHE2
00f350 b500          in_  temp0, EEDR
00f351 1709          cp temp0,tosh
00f352 f011          breq PFA_STOREE4
00f353 2f89          mov tosl, tosh
00f354 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
00f355 bf2f          out_ SREG, temp2
00f356 9189
00f357 9199          loadtos
00f358 ccac          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
00f359 99f9          sbic EECR, EEPE
00f35a cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
00f35b b707          in_ temp0, SPMCSR
00f35c fd00          sbrc temp0,SPMEN
00f35d cffd          rjmp PFA_STOREE2
                 
00f35e bdf2          out_ EEARH,zh
00f35f bde1          out_ EEARL,zl
00f360 bd80          out_ EEDR, tosl
00f361 9afa          sbi EECR,EEMPE
00f362 9af9          sbi EECR,EEPE
                 
00f363 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
00f364 ff02          .dw $ff02
00f365 6540          .db "@e"
00f366 f340          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
00f367 f368          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
00f368 b72f          in_ temp2, SREG
00f369 94f8          cli
00f36a 01fc          movw zl, tosl
00f36b d006          rcall PFA_FETCHE2
00f36c b580          in_ tosl, EEDR
                 
00f36d 9631          adiw zl,1
                 
00f36e d003          rcall PFA_FETCHE2
00f36f b590          in_  tosh, EEDR
00f370 bf2f          out_ SREG, temp2
00f371 cc93          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
00f372 99f9          sbic EECR, EEPE
00f373 cffe          rjmp PFA_FETCHE2
                 
00f374 bdf2          out_ EEARH,zh
00f375 bde1          out_ EEARL,zl
                 
00f376 9af8          sbi EECR,EERE
00f377 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
00f378 ff02          .dw $ff02
00f379 6921          .db "!i"
00f37a f364          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
00f37b fc2a          .dw PFA_DODEFER1
                 PFA_STOREI:
00f37c 0078          .dw EE_STOREI
00f37d fbcb          .dw XT_EDEFERFETCH
00f37e fbd5          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                 .else
                   .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
00f37f ff09          .dw $ff09
00f380 2128
00f381 2d69
00f382 726e
00f383 7777
00f384 0029          .db "(!i-nrww)",0
00f385 f378          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
00f386 f387          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
00f387 b71f        in temp1,SREG
00f388 931f        push temp1
00f389 94f8        cli
                 
00f38a 019c        movw temp2, tosl ; save the (word) address
00f38b 9189
00f38c 9199        loadtos          ; get the new value for the flash cell
00f38d 93af        push xl
00f38e 93bf        push xh
00f38f 93cf        push yl
00f390 93df        push yh
00f391 d009        rcall DO_STOREI_atmega
00f392 91df        pop yh
00f393 91cf        pop yl
00f394 91bf        pop xh
00f395 91af        pop xl
                   ; finally clear the stack
00f396 9189
00f397 9199        loadtos
00f398 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
00f399 bf1f        out SREG,temp1
                 
00f39a cc6a        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
00f39b d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
00f39c 94e0        com temp4
00f39d 94f0        com temp5
00f39e 218e        and tosl, temp4
00f39f 219f        and tosh, temp5
00f3a0 2b98        or tosh, tosl
00f3a1 f019        breq DO_STOREI_writepage 
00f3a2 01f9          movw zl, temp2
00f3a3 e002          ldi temp0,(1<<PGERS)
00f3a4 d023          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
00f3a5 01f9        movw zl, temp2
00f3a6 e004        ldi temp0,(1<<PGWRT)
00f3a7 d020        rcall dospm
                 
                   ; reenable RWW section
00f3a8 01f9        movw zl, temp2
00f3a9 e100        ldi temp0,(1<<RWWSRE)
00f3aa d01d        rcall dospm
00f3ab 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
00f3ac 01f9        movw zl, temp2
                   ; get the beginning of page
00f3ad 78e0        andi zl,low(pagemask)
00f3ae 7fff        andi zh,high(pagemask)
00f3af 01ef        movw y, z
                   ; loop counter (in words)
00f3b0 e8a0        ldi xl,low(pagesize)
00f3b1 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
00f3b2 01fe        movw z, y
00f3b3 2755
00f3b4 0fee
00f3b5 1fff
00f3b6 1f55
00f3b7 bf5b
00f3b8 9147
00f3b9 9157        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
00f3ba 01fe        movw z, y
00f3bb 17e2        cp zl, temp2
00f3bc 07f3        cpc zh, temp3
00f3bd f011        breq pageload_newdata
00f3be 010a          movw r0, temp6
00f3bf c002          rjmp pageload_cont
                 pageload_newdata:
00f3c0 017a          movw temp4, temp6
00f3c1 010c          movw r0, tosl
                 pageload_cont:
00f3c2 2700        clr temp0
00f3c3 d004        rcall dospm
00f3c4 9621        adiw y, 1
00f3c5 9711        sbiw x, 1
00f3c6 f759        brne pageload_loop
                 
                 pageload_done:
00f3c7 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
00f3c8 99f9        sbic EECR, EEPE
00f3c9 cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
00f3ca b717        in_  temp1, SPMCSR
00f3cb fd10        sbrc temp1, SPMEN
00f3cc cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
00f3cd 2755
00f3ce 0fee
00f3cf 1fff
00f3d0 1f55
00f3d1 bf5b        writeflashcell
                   ; execute spm
00f3d2 6001        ori temp0, (1<<SPMEN)
00f3d3 bf07        out_ SPMCSR,temp0
00f3d4 95e8        spm
00f3d5 9508        ret
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
00f3d6 ff02          .dw $ff02
00f3d7 6940          .db "@i"
00f3d8 f37f          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
00f3d9 f3da          .dw PFA_FETCHI
                 PFA_FETCHI:
00f3da 01fc          movw zl, tosl
00f3db 2755
00f3dc 0fee
00f3dd 1fff
00f3de 1f55
00f3df bf5b
00f3e0 9187
00f3e1 9197          readflashcell tosl,tosh
00f3e2 cc22          jmp_ DO_NEXT
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2LITERAL:
00f3e3 0008          .dw $0008
00f3e4 6c32
00f3e5 7469
00f3e6 7265
00f3e7 6c61          .db "2literal"
00f3e8 f3d6          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
00f3e9 f001          .dw DO_COLON
                 PFA_2LITERAL:
                 .endif
00f3ea f0d6          .dw XT_SWAP
00f3eb 0209          .dw XT_LITERAL
00f3ec 0209          .dw XT_LITERAL
00f3ed f026          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
00f3ee ff01          .dw $ff01
00f3ef 003d          .db "=",0
00f3f0 f3e3          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
00f3f1 f001          .dw DO_COLON
                 PFA_EQUAL:
00f3f2 f1a5          .dw XT_MINUS
00f3f3 f12a          .dw XT_ZEROEQUAL
00f3f4 f026          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
00f3f5 ff01          .dw $ff01
00f3f6 0031          .db "1",0
00f3f7 f3ee          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
00f3f8 f054          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
00f3f9 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
00f3fa ff01          .dw $ff01
00f3fb 0032          .db "2",0
00f3fc f3f5          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
00f3fd f054          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
00f3fe 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
00f3ff ff02          .dw $ff02
00f400 312d          .db "-1"
00f401 f3fa          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
00f402 f054          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
00f403 ffff              .DW -1
                 
                 .if AMFORTH_NRWW_SIZE>8000
                   .include "dict/core_8k.inc"
                 
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
00f404 ff03          .dw $ff03
00f405 3e6e
00f406 0072          .db "n>r",0
00f407 f3ff          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
00f408 f409          .dw PFA_N_TO_R
                 PFA_N_TO_R:
00f409 01fc          movw zl, tosl
00f40a 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
00f40b 9189
00f40c 9199          loadtos
00f40d 939f          push tosh
00f40e 938f          push tosl
00f40f 950a          dec temp0
00f410 f7d1          brne PFA_N_TO_R1
00f411 93ef          push zl
00f412 93ff          push zh
00f413 9189
00f414 9199          loadtos
00f415 cbef          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
00f416 ff03          .dw $ff03
00f417 726e
00f418 003e          .db "nr>",0
00f419 f404          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
00f41a f41b          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
00f41b 939a
00f41c 938a          savetos
00f41d 91ff          pop zh
00f41e 91ef          pop zl
00f41f 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
00f420 918f          pop tosl
00f421 919f          pop tosh
00f422 939a
00f423 938a          savetos
00f424 950a          dec temp0
00f425 f7d1          brne PFA_N_R_FROM1
00f426 01cf          movw tosl, zl
00f427 cbdd          jmp_ DO_NEXT
                 
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
00f428 ff03          .dw $ff03
00f429 3264
00f42a 002a          .db "d2*",0
00f42b f416          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
00f42c f42d          .dw PFA_D2STAR
                 PFA_D2STAR:
00f42d 9109          ld temp0, Y+
00f42e 9119          ld temp1, Y+
00f42f 0f00          lsl temp0
00f430 1f11          rol temp1
00f431 1f88          rol tosl
00f432 1f99          rol tosh
00f433 931a          st -Y, temp1
00f434 930a          st -Y, temp0
00f435 cbcf          jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
00f436 ff03          .dw $ff03
00f437 3264
00f438 002f          .db "d2/",0
00f439 f428          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
00f43a f43b          .dw PFA_D2SLASH
                 PFA_D2SLASH:
00f43b 9109          ld temp0, Y+
00f43c 9119          ld temp1, Y+
00f43d 9595          asr tosh
00f43e 9587          ror tosl
00f43f 9517          ror temp1
00f440 9507          ror temp0
00f441 931a          st -Y, temp1
00f442 930a          st -Y, temp0
00f443 cbc1          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
00f444 ff02          .dw $ff02
00f445 2b64          .db "d+"
00f446 f436          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
00f447 f448          .dw PFA_DPLUS
                 PFA_DPLUS:
00f448 9129          ld temp2, Y+
00f449 9139          ld temp3, Y+
                 
00f44a 90e9          ld temp4, Y+
00f44b 90f9          ld temp5, Y+
00f44c 9149          ld temp6, Y+
00f44d 9159          ld temp7, Y+
                 
00f44e 0f24          add temp2, temp6
00f44f 1f35          adc temp3, temp7
00f450 1d8e          adc tosl, temp4
00f451 1d9f          adc tosh, temp5
                     
00f452 933a          st -Y, temp3
00f453 932a          st -Y, temp2
00f454 cbb0          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
00f455 ff02          .dw $ff02
00f456 2d64          .db "d-"
00f457 f444          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
00f458 f459          .dw PFA_DMINUS
                 PFA_DMINUS:
00f459 9129          ld temp2, Y+
00f45a 9139          ld temp3, Y+
                 
00f45b 90e9          ld temp4, Y+
00f45c 90f9          ld temp5, Y+
00f45d 9149          ld temp6, Y+
00f45e 9159          ld temp7, Y+
                 
00f45f 1b42          sub temp6, temp2
00f460 0b53          sbc temp7, temp3
00f461 0ae8          sbc temp4, tosl
00f462 0af9          sbc temp5, tosh
                 
00f463 935a          st -Y, temp7
00f464 934a          st -Y, temp6
00f465 01c7          movw tosl, temp4
00f466 cb9e          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
00f467 ff07          .dw $ff07
00f468 6964
00f469 766e
00f46a 7265
00f46b 0074          .db "dinvert",0
00f46c f455          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
00f46d f46e          .dw PFA_DINVERT
                 PFA_DINVERT:
00f46e 9109          ld temp0, Y+
00f46f 9119          ld temp1, Y+
00f470 9580          com tosl
00f471 9590          com tosh
00f472 9500          com temp0
00f473 9510          com temp1
00f474 931a          st -Y, temp1
00f475 930a          st -Y, temp0
00f476 cb8e          jmp_ DO_NEXT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
00f477 ff02          .dw $ff02
00f478 2e75          .db "u."
00f479 f467          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
00f47a f001          .dw DO_COLON
                 PFA_UDOT:
                 .endif
00f47b f166          .dw XT_ZERO
00f47c f726          .dw XT_UDDOT
00f47d f026          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
00f47e ff03          .dw $ff03
00f47f 2e75
00f480 0072          .db "u.r",0
00f481 f477          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
00f482 f001          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
00f483 f166          .dw XT_ZERO
00f484 f0d6          .dw XT_SWAP
00f485 f72f          .dw XT_UDDOTR
00f486 f026          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
00f487 ff0d          .dw $ff0d
00f488 6873
00f489 776f
00f48a 772d
00f48b 726f
00f48c 6c64
00f48d 7369
00f48e 0074          .db "show-wordlist",0
00f48f f47e          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
00f490 f001          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
00f491 f046          .dw XT_DOLITERAL
00f492 f496          .dw XT_SHOWWORD
00f493 f0d6          .dw XT_SWAP
00f494 fc6e          .dw XT_TRAVERSEWORDLIST
00f495 f026          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
00f496 f001          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
00f497 fc89          .dw XT_NAME2STRING
00f498 f79c          .dw XT_ITYPE
00f499 f7de          .dw XT_SPACE         ; ( -- addr n)
00f49a f15d          .dw XT_TRUE
00f49b f026          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_WORDS:
00f49c ff05          .dw $ff05
00f49d 6f77
00f49e 6472
00f49f 0073          .db "words",0
00f4a0 f487          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
00f4a1 f001          .dw DO_COLON
                 PFA_WORDS:
                 .endif
00f4a2 f046          .dw XT_DOLITERAL
00f4a3 005e          .dw CFG_ORDERLISTLEN+2
00f4a4 f367          .dw XT_FETCHE
00f4a5 f490          .dw XT_SHOWWORDLIST
00f4a6 f026          .dw XT_EXIT
                 
                 
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
00f4a7 ff04          .dw $ff04
00f4a8 6970
00f4a9 6b63          .db "pick"
00f4aa f49c          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
00f4ab f001          .dw DO_COLON
                 PFA_PICK:
                 .endif
00f4ac f241          .dw XT_1PLUS
00f4ad f554          .dw XT_CELLS
00f4ae f29f          .dw XT_SP_FETCH
00f4af f1af          .dw XT_PLUS
00f4b0 f08b          .dw XT_FETCH
00f4b1 f026          .dw XT_EXIT
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
00f4b2 0002          .dw $0002
00f4b3 222e          .db ".",$22
00f4b4 f4a7          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
00f4b5 f001          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
00f4b6 f4bd          .dw XT_SQUOTE
00f4b7 01e8          .dw XT_COMPILE
00f4b8 f79c          .dw XT_ITYPE
00f4b9 f026          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
00f4ba 0002        .dw $0002
00f4bb 2273        .db "s",$22
00f4bc f4b2        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
00f4bd f001          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
00f4be f046          .dw XT_DOLITERAL
00f4bf 0022          .dw 34   ; 0x22 
00f4c0 f98d          .dw XT_PARSE       ; ( -- addr n)
00f4c1 f547          .dw XT_STATE
00f4c2 f08b          .dw XT_FETCH
00f4c3 f03f          .dw XT_DOCONDBRANCH
00f4c4 f4c6          DEST(PFA_SQUOTE1)
00f4c5 0214            .dw XT_SLITERAL
                 PFA_SQUOTE1:
00f4c6 f026          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
00f4c7 ff04          .dw $ff04
00f4c8 6966
00f4c9 6c6c          .db "fill"
00f4ca f4ba          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
00f4cb f001          .dw DO_COLON
                 PFA_FILL:
00f4cc f0f3          .dw XT_ROT
00f4cd f0f3          .dw XT_ROT
00f4ce f0cb
00f4cf f03f          .dw XT_QDUP,XT_DOCONDBRANCH
00f4d0 f4d8          DEST(PFA_FILL2)
00f4d1 fd75          .dw XT_BOUNDS
00f4d2 f2ad          .dw XT_DODO
                 PFA_FILL1:
00f4d3 f0c3          .dw XT_DUP
00f4d4 f2be          .dw XT_I
00f4d5 f09f          .dw XT_CSTORE  ; ( -- c c-addr)
00f4d6 f2db          .dw XT_DOLOOP
00f4d7 f4d3          .dw PFA_FILL1
                 PFA_FILL2:
00f4d8 f0eb          .dw XT_DROP
00f4d9 f026          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
00f4da ff0b          .dw $ff0b
00f4db 6e65
00f4dc 6976
00f4dd 6f72
00f4de 6d6e
00f4df 6e65
00f4e0 0074          .db "environment",0
00f4e1 f4c7          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
00f4e2 f054          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
00f4e3 0056          .dw CFG_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
00f4e4 ff09          .dw $ff09
00f4e5 6f77
00f4e6 6472
00f4e7 696c
00f4e8 7473
00f4e9 0073          .db "wordlists",0
00f4ea 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
00f4eb f001          .dw DO_COLON
                 PFA_ENVWORDLISTS:
00f4ec f046          .dw XT_DOLITERAL
00f4ed 0008          .dw NUMWORDLISTS
00f4ee f026          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
00f4ef ff04          .dw $ff04
00f4f0 702f
00f4f1 6461          .db "/pad"
00f4f2 f4e4          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
00f4f3 f001          .dw DO_COLON
                 PFA_ENVSLASHPAD:
00f4f4 f29f          .dw XT_SP_FETCH
00f4f5 f580          .dw XT_PAD
00f4f6 f1a5          .dw XT_MINUS
00f4f7 f026          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENVSLASHHOLD:
00f4f8 ff05          .dw $ff05
00f4f9 682f
00f4fa 6c6f
00f4fb 0064          .db "/hold",0
00f4fc f4ef          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
00f4fd f001          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
                 .endif
00f4fe f580          .dw XT_PAD
00f4ff f5bb          .dw XT_HERE
00f500 f1a5          .dw XT_MINUS
00f501 f026          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
00f502 ff0a          .dw $ff0a
00f503 6f66
00f504 7472
00f505 2d68
00f506 616e
00f507 656d          .db "forth-name"
00f508 f4f8          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
00f509 f001          .dw DO_COLON
                 PFA_EN_FORTHNAME:
00f50a f769          .dw XT_DOSLITERAL
00f50b 0007          .dw 7
                 .endif
00f50c 6d61
00f50d 6f66
00f50e 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
00f50f 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
00f510 f026          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
00f511 ff07          .dw $ff07
00f512 6576
00f513 7372
00f514 6f69
00f515 006e          .db "version",0
00f516 f502          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
00f517 f001          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
00f518 f046          .dw XT_DOLITERAL
00f519 0045          .dw 69
00f51a f026          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
00f51b ff03          .dw $ff03
00f51c 7063
00f51d 0075          .db "cpu",0
00f51e f511          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
00f51f f001          .dw DO_COLON
                 PFA_EN_CPU:
                 .endif
00f520 f046          .dw XT_DOLITERAL
00f521 0049          .dw mcu_name
00f522 f7c8          .dw XT_ICOUNT
00f523 f026          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
00f524 ff08          .dw $ff08
00f525 636d
00f526 2d75
00f527 6e69
00f528 6f66          .db "mcu-info"
00f529 f51b          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
00f52a f001          .dw DO_COLON
                 PFA_EN_MCUINFO:
00f52b f046          .dw XT_DOLITERAL
00f52c 0045          .dw mcu_info
00f52d f026          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_ENVUSERSIZE:
00f52e ff05          .dw $ff05
00f52f 752f
00f530 6573
00f531 0072          .db "/user",0
00f532 f524          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
00f533 f001          .dw DO_COLON
                 PFA_ENVUSERSIZE:
                 .endif
00f534 f046          .dw XT_DOLITERAL
00f535 002e          .dw SYSUSERSIZE + APPUSERSIZE
00f536 f026          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
00f537 ff05          .dw $ff05
00f538 5f66
00f539 7063
00f53a 0075          .db "f_cpu",0
00f53b f4da          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
00f53c f001          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
00f53d f046          .dw XT_DOLITERAL
00f53e 2400          .dw (F_CPU % 65536)
00f53f f046          .dw XT_DOLITERAL
00f540 00f4          .dw (F_CPU / 65536)
00f541 f026          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
00f542 ff05          .dw $ff05
00f543 7473
00f544 7461
00f545 0065          .db "state",0
00f546 f537          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
00f547 f054          .dw PFA_DOVARIABLE
                 PFA_STATE:
00f548 013d          .dw ram_state
                 
                 .dseg
00013d           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
00f549 ff04          .dw $ff04
00f54a 6162
00f54b 6573          .db "base"
00f54c f542          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
00f54d f067          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
00f54e 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
00f54f ff05          .dw $ff05
00f550 6563
00f551 6c6c
00f552 0073          .db "cells",0
00f553 f549          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
00f554 f21e          .dw PFA_2STAR
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
00f555 ff05          .dw $ff05
00f556 6563
00f557 6c6c
00f558 002b          .db "cell+",0
00f559 f54f          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
00f55a f55b          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
00f55b 9602          adiw tosl, CELLSIZE
00f55c caa8          jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
00f55d ff04          .dw $ff04
00f55e 6432
00f55f 7075          .db "2dup"
00f560 f555          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
00f561 f001          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
00f562 f0e1          .dw XT_OVER
00f563 f0e1          .dw XT_OVER
00f564 f026          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
00f565 ff05          .dw $ff05
00f566 6432
00f567 6f72
00f568 0070          .db "2drop",0
00f569 f55d          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
00f56a f001          .dw DO_COLON
                 PFA_2DROP:
                 .endif
00f56b f0eb          .dw XT_DROP
00f56c f0eb          .dw XT_DROP
00f56d f026          .dw XT_EXIT
                 
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
00f56e ff04          .dw $ff04
00f56f 7574
00f570 6b63          .db "tuck"
00f571 f565          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
00f572 f001          .dw DO_COLON
                 PFA_TUCK:
                 .endif
00f573 f0d6          .dw XT_SWAP
00f574 f0e1          .dw XT_OVER
00f575 f026          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
00f576 ff03          .dw $ff03
00f577 693e
00f578 006e          .db ">in",0
00f579 f56e          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
00f57a f067          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
00f57b 0018          .dw USER_TO_IN
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PAD:
00f57c ff03          .dw $ff03
00f57d 6170
00f57e 0064          .db "pad",0
00f57f f576          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
00f580 f001          .dw DO_COLON
                 PFA_PAD:
                 .endif
00f581 f5bb          .dw XT_HERE
00f582 f046          .dw XT_DOLITERAL
00f583 0028          .dw 40
00f584 f1af          .dw XT_PLUS
00f585 f026          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMIT:
00f586 ff04          .dw $ff04
00f587 6d65
00f588 7469          .db "emit"
00f589 f57c          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
00f58a fc2a          .dw PFA_DODEFER1
                 PFA_EMIT:
                 .endif
00f58b 000e          .dw USER_EMIT
00f58c fbf3          .dw XT_UDEFERFETCH
00f58d fbff          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMITQ:
00f58e ff05          .dw $ff05
00f58f 6d65
00f590 7469
00f591 003f          .db "emit?",0
00f592 f586          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
00f593 fc2a          .dw PFA_DODEFER1
                 PFA_EMITQ:
                 .endif
00f594 0010          .dw USER_EMITQ
00f595 fbf3          .dw XT_UDEFERFETCH
00f596 fbff          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEY:
00f597 ff03          .dw $ff03
00f598 656b
00f599 0079          .db "key",0
00f59a f58e          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
00f59b fc2a          .dw PFA_DODEFER1
                 PFA_KEY:
                 .endif
00f59c 0012          .dw USER_KEY
00f59d fbf3          .dw XT_UDEFERFETCH
00f59e fbff          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEYQ:
00f59f ff04          .dw $ff04
00f5a0 656b
00f5a1 3f79          .db "key?"
00f5a2 f597          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
00f5a3 fc2a          .dw PFA_DODEFER1
                 PFA_KEYQ:
                 .endif
00f5a4 0014          .dw USER_KEYQ
00f5a5 fbf3          .dw XT_UDEFERFETCH
00f5a6 fbff          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
00f5a7 ff02          .dw $ff02
00f5a8 7064          .db "dp"
00f5a9 f59f          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
00f5aa f081          .dw PFA_DOVALUE1
                 PFA_DP:
00f5ab 0048          .dw CFG_DP
00f5ac fbcb          .dw XT_EDEFERFETCH
00f5ad fbd5          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
00f5ae ff05          .dw $ff05
00f5af 6865
00f5b0 7265
00f5b1 0065          .db "ehere",0
00f5b2 f5a7          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
00f5b3 f081          .dw PFA_DOVALUE1
                 PFA_EHERE:
00f5b4 004c          .dw EE_EHERE
00f5b5 fbcb          .dw XT_EDEFERFETCH
00f5b6 fbd5          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
00f5b7 ff04          .dw $ff04
00f5b8 6568
00f5b9 6572          .db "here"
00f5ba f5ae          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
00f5bb f081          .dw PFA_DOVALUE1
                 PFA_HERE:
00f5bc 004a          .dw EE_HERE
00f5bd fbcb          .dw XT_EDEFERFETCH
00f5be fbd5          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
00f5bf ff05          .dw $ff05
00f5c0 6c61
00f5c1 6f6c
00f5c2 0074          .db "allot",0
00f5c3 f5b7          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
00f5c4 f001          .dw DO_COLON
                 PFA_ALLOT:
00f5c5 f5bb          .dw XT_HERE
00f5c6 f1af          .dw XT_PLUS
00f5c7 fbb0          .dw XT_DOTO
00f5c8 f5bc          .dw PFA_HERE
00f5c9 f026          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
00f5ca ff03          .dw $ff03
00f5cb 6962
00f5cc 006e          .db "bin",0
00f5cd f5bf          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
00f5ce f001          .dw DO_COLON
                 PFA_BIN:
                 .endif
00f5cf f3fd          .dw XT_TWO
00f5d0 f54d          .dw XT_BASE
00f5d1 f093          .dw XT_STORE
00f5d2 f026          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
00f5d3 ff07          .dw $ff07
00f5d4 6564
00f5d5 6963
00f5d6 616d
00f5d7 006c          .db "decimal",0
00f5d8 f5ca          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
00f5d9 f001          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
00f5da f046          .dw XT_DOLITERAL
00f5db 000a          .dw 10
00f5dc f54d          .dw XT_BASE
00f5dd f093          .dw XT_STORE
00f5de f026          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
00f5df ff03          .dw $ff03
00f5e0 6568
00f5e1 0078          .db "hex",0
00f5e2 f5d3          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
00f5e3 f001          .dw DO_COLON
                 PFA_HEX:
                 .endif
00f5e4 f046          .dw XT_DOLITERAL
00f5e5 0010          .dw 16
00f5e6 f54d          .dw XT_BASE
00f5e7 f093          .dw XT_STORE
00f5e8 f026          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
00f5e9 ff02          .dw $ff02
00f5ea 6c62          .db "bl"
00f5eb f5df          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
00f5ec f054          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
00f5ed 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
00f5ee ff07          .dw $ff07
00f5ef 7574
00f5f0 6e72
00f5f1 656b
00f5f2 0079          .db "turnkey",0
00f5f3 f5e9          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
00f5f4 fc2a          .dw PFA_DODEFER1
                 PFA_TURNKEY:
00f5f5 0054          .dw CFG_TURNKEY
00f5f6 fbcb          .dw XT_EDEFERFETCH
00f5f7 fbd5          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
00f5f8 ff04          .dw $ff04
00f5f9 6d2f
00f5fa 646f          .db "/mod"
00f5fb f5ee          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
00f5fc f5fd          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
00f5fd 019c          movw temp2, tosl
                     
00f5fe 9109          ld temp0, Y+
00f5ff 9119          ld temp1, Y+
                 
00f600 2f41          mov	temp6,temp1	;move dividend High to sign register
00f601 2743          eor	temp6,temp3	;xor divisor High with sign register
00f602 ff17          sbrs	temp1,7	;if MSB in dividend set
00f603 c004          rjmp	PFA_SLASHMOD_1
00f604 9510          com	temp1		;    change sign of dividend
00f605 9500          com	temp0		
00f606 5f0f          subi	temp0,low(-1)
00f607 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
00f608 ff37          sbrs	temp3,7	;if MSB in divisor set
00f609 c004          rjmp	PFA_SLASHMOD_2
00f60a 9530          com	temp3		;    change sign of divisor
00f60b 9520          com	temp2		
00f60c 5f2f          subi	temp2,low(-1)
00f60d 4f3f          sbci	temp3,high(-1)
00f60e 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
00f60f 18ff          sub	temp5,temp5;clear remainder High byte and carry
00f610 e151          ldi	temp7,17	;init loop counter
                 
00f611 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
00f612 1f11          rol	temp1
00f613 955a          dec	temp7		;decrement counter
00f614 f439          brne	PFA_SLASHMOD_5		;if done
00f615 ff47          sbrs	temp6,7		;    if MSB in sign register set
00f616 c004          rjmp	PFA_SLASHMOD_4
00f617 9510          com	temp1	;        change sign of result
00f618 9500          com	temp0
00f619 5f0f          subi	temp0,low(-1)
00f61a 4f1f          sbci	temp1,high(-1)
00f61b c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
00f61c 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
00f61d 1cff          rol	temp5
00f61e 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
00f61f 0af3          sbc	temp5,temp3	;
00f620 f420          brcc	PFA_SLASHMOD_6		;if result negative
00f621 0ee2          add	temp4,temp2	;    restore remainder
00f622 1ef3          adc	temp5,temp3
00f623 9488          clc			;    clear carry to be shifted into result
00f624 cfec          rjmp	PFA_SLASHMOD_3		;else
00f625 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
00f626 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
00f627 92fa          st -Y,temp5
00f628 92ea          st -Y,temp4
                 
                     ; put quotient on stack
00f629 01c8          movw tosl, temp0
00f62a c9da          jmp_ DO_NEXT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
00f62b ff05          .dw $ff05
00f62c 2f75
00f62d 6f6d
00f62e 0064          .db "u/mod",0
00f62f f5f8          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
00f630 f001          .dw DO_COLON
                 PFA_USLASHMOD:
00f631 f111          .dw XT_TO_R
00f632 f166          .dw XT_ZERO
00f633 f108          .dw XT_R_FROM
00f634 f1d4          .dw XT_UMSLASHMOD
00f635 f026          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
00f636 ff06          .dw $ff06
00f637 656e
00f638 6167
00f639 6574          .db "negate"
00f63a f62b          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
00f63b f001          .dw DO_COLON
                 PFA_NEGATE:
00f63c f20f          .dw XT_INVERT
00f63d f241          .dw XT_1PLUS
00f63e f026          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
00f63f ff01          .dw $ff01
00f640 002f          .db "/",0
00f641 f636          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
00f642 f001          .dw DO_COLON
                 PFA_SLASH:
                 .endif
00f643 f5fc          .dw XT_SLASHMOD
00f644 f102          .dw XT_NIP
00f645 f026          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
00f646 ff03          .dw $ff03
00f647 6f6d
00f648 0064          .db "mod",0
00f649 f63f          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
00f64a f001          .dw DO_COLON
                 PFA_MOD:
                 .endif
00f64b f5fc          .dw XT_SLASHMOD
00f64c f0eb          .dw XT_DROP
00f64d f026          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ;   DUP ?NEGATE ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABS:
00f64e ff03          .dw $ff03
00f64f 6261
00f650 0073          .db "abs",0
00f651 f646          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
00f652 f001          .dw DO_COLON
                 PFA_ABS:
                 
                 .endif
                 
00f653 f0c3
00f654 f250
00f655 f026          .DW XT_DUP,XT_QNEGATE,XT_EXIT
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
00f656 ff03          .dw $ff03
00f657 696d
00f658 006e          .db "min",0
00f659 f64e          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
00f65a f001          .dw DO_COLON
                 PFA_MIN:
                 .endif
00f65b f561          .dw XT_2DUP
00f65c f18a          .dw XT_GREATER
00f65d f03f          .dw XT_DOCONDBRANCH
00f65e f660          DEST(PFA_MIN1)
00f65f f0d6          .dw XT_SWAP
                 PFA_MIN1:
00f660 f0eb          .dw XT_DROP
00f661 f026          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
00f662 ff03          .dw $ff03
00f663 616d
00f664 0078          .db "max",0
00f665 f656          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
00f666 f001          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
00f667 f561          .dw XT_2DUP
00f668 f180          .dw XT_LESS
00f669 f03f          .dw XT_DOCONDBRANCH
00f66a f66c          DEST(PFA_MAX1)
00f66b f0d6          .dw XT_SWAP
                 PFA_MAX1:
00f66c f0eb          .dw XT_DROP
00f66d f026          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
00f66e ff06          .dw $ff06
00f66f 6977
00f670 6874
00f671 6e69          .db "within"
00f672 f662          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
00f673 f001          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
00f674 f0e1          .dw XT_OVER
00f675 f1a5          .dw XT_MINUS
00f676 f111          .dw XT_TO_R
00f677 f1a5          .dw XT_MINUS
00f678 f108          .dw XT_R_FROM
00f679 f16e          .dw XT_ULESS
00f67a f026          .dw XT_EXIT
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
00f67b ff07          .dw $ff07 
00f67c 6f74
00f67d 7075
00f67e 6570
00f67f 0072          .db "toupper",0
00f680 f66e          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
00f681 f001          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
00f682 f0c3          .dw XT_DUP 
00f683 f046          .dw XT_DOLITERAL 
00f684 0061          .dw 'a' 
00f685 f046          .dw XT_DOLITERAL 
00f686 007b          .dw 'z'+1
00f687 f673          .dw XT_WITHIN 
00f688 f03f          .dw XT_DOCONDBRANCH
00f689 f68d          DEST(PFA_TOUPPER0)
00f68a f046          .dw XT_DOLITERAL
00f68b 00df          .dw 223 ; inverse of 0x20: 0xdf
00f68c f225          .dw XT_AND 
                 PFA_TOUPPER0:
00f68d f026          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
00f68e ff07          .dw $ff07
00f68f 6f74
00f690 6f6c
00f691 6577
00f692 0072          .db "tolower",0
00f693 f67b          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
00f694 f001          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
00f695 f0c3          .dw XT_DUP
00f696 f046          .dw XT_DOLITERAL
00f697 0041          .dw 'A'
00f698 f046          .dw XT_DOLITERAL
00f699 005b          .dw 'Z'+1
00f69a f673          .dw XT_WITHIN
00f69b f03f          .dw XT_DOCONDBRANCH
00f69c f6a0          DEST(PFA_TOLOWER0)
00f69d f046          .dw XT_DOLITERAL
00f69e 0020          .dw 32
00f69f f22e          .dw XT_OR 
                 PFA_TOLOWER0:
00f6a0 f026          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
00f6a1 ff03          .dw $ff03
00f6a2 6c68
00f6a3 0064          .db "hld",0
00f6a4 f68e          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
00f6a5 f054          .dw PFA_DOVARIABLE
                 PFA_HLD:
00f6a6 013f          .dw ram_hld
                 
                 .dseg
00013f           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
00f6a7 ff04          .dw $ff04
00f6a8 6f68
00f6a9 646c          .db "hold"
00f6aa f6a1          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
00f6ab f001          .dw DO_COLON
                 PFA_HOLD:
                 .endif
00f6ac f6a5          .dw XT_HLD
00f6ad f0c3          .dw XT_DUP
00f6ae f08b          .dw XT_FETCH
00f6af f247          .dw XT_1MINUS
00f6b0 f0c3          .dw XT_DUP
00f6b1 f111          .dw XT_TO_R
00f6b2 f0d6          .dw XT_SWAP
00f6b3 f093          .dw XT_STORE
00f6b4 f108          .dw XT_R_FROM
00f6b5 f09f          .dw XT_CSTORE
00f6b6 f026          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
00f6b7 ff02          .dw $ff02
00f6b8 233c          .db "<#"
00f6b9 f6a7          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
00f6ba f001          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
00f6bb f580          .dw XT_PAD
00f6bc f6a5          .dw XT_HLD
00f6bd f093          .dw XT_STORE
00f6be f026          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
00f6bf ff01          .dw $ff01
00f6c0 0023          .db "#",0
00f6c1 f6b7          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
00f6c2 f001          .dw DO_COLON
                 PFA_SHARP:
                 .endif
00f6c3 f54d          .dw XT_BASE
00f6c4 f08b          .dw XT_FETCH
00f6c5 f73f          .dw XT_UDSLASHMOD
00f6c6 f0f3          .dw XT_ROT
00f6c7 f046          .dw XT_DOLITERAL
00f6c8 0009          .dw 9
00f6c9 f0e1          .dw XT_OVER
00f6ca f180          .dw XT_LESS
00f6cb f03f          .dw XT_DOCONDBRANCH
00f6cc f6d0          DEST(PFA_SHARP1)
00f6cd f046          .dw XT_DOLITERAL
00f6ce 0007          .dw 7
00f6cf f1af          .dw XT_PLUS
                 PFA_SHARP1:
00f6d0 f046          .dw XT_DOLITERAL
00f6d1 0030          .dw 48 ; ASCII 0
00f6d2 f1af          .dw XT_PLUS
00f6d3 f6ab          .dw XT_HOLD
00f6d4 f026          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
00f6d5 ff02          .dw $ff02
00f6d6 7323          .db "#s"
00f6d7 f6bf          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
00f6d8 f001          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
00f6d9 f6c2          .dw XT_SHARP
00f6da f561          .dw XT_2DUP
00f6db f22e          .dw XT_OR
00f6dc f12a          .dw XT_ZEROEQUAL
00f6dd f03f          .dw XT_DOCONDBRANCH
00f6de f6d9          DEST(NUMS1) ; PFA_SHARP_S
00f6df f026          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
00f6e0 ff02          .dw $ff02
00f6e1 3e23          .db "#>"
00f6e2 f6d5          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
00f6e3 f001          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
00f6e4 f56a          .dw XT_2DROP
00f6e5 f6a5          .dw XT_HLD
00f6e6 f08b          .dw XT_FETCH
00f6e7 f580          .dw XT_PAD
00f6e8 f0e1          .dw XT_OVER
00f6e9 f1a5          .dw XT_MINUS
00f6ea f026          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
00f6eb ff04          .dw $ff04
00f6ec 6973
00f6ed 6e67          .db "sign"
00f6ee f6e0          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
00f6ef f001          .dw DO_COLON
                 PFA_SIGN:
                 .endif
00f6f0 f131          .dw XT_ZEROLESS
00f6f1 f03f          .dw XT_DOCONDBRANCH
00f6f2 f6f6          DEST(PFA_SIGN1)
00f6f3 f046          .dw XT_DOLITERAL
00f6f4 002d          .dw 45 ; ascii -
00f6f5 f6ab          .dw XT_HOLD
                 PFA_SIGN1:
00f6f6 f026          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
00f6f7 ff03          .dw $ff03
00f6f8 2e64
00f6f9 0072          .db "d.r",0
00f6fa f6eb          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
00f6fb f001          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
00f6fc f111          .dw XT_TO_R
00f6fd f572          .dw XT_TUCK
00f6fe fceb          .dw XT_DABS
00f6ff f6ba          .dw XT_L_SHARP
00f700 f6d8          .dw XT_SHARP_S
00f701 f0f3          .dw XT_ROT
00f702 f6ef          .dw XT_SIGN
00f703 f6e3          .dw XT_SHARP_G
00f704 f108          .dw XT_R_FROM
00f705 f0e1          .dw XT_OVER
00f706 f1a5          .dw XT_MINUS
00f707 f7e7          .dw XT_SPACES
00f708 f7f7          .dw XT_TYPE
00f709 f026          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
00f70a ff02          .dw $ff02
00f70b 722e          .db ".r"
00f70c f6f7          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
00f70d f001          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
00f70e f111          .dw XT_TO_R
00f70f fd7e          .dw XT_S2D
00f710 f108          .dw XT_R_FROM
00f711 f6fb          .dw XT_DDOTR
00f712 f026          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
00f713 ff02          .dw $ff02
00f714 2e64          .db "d."
00f715 f70a          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
00f716 f001          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
00f717 f166          .dw XT_ZERO
00f718 f6fb          .dw XT_DDOTR
00f719 f7de          .dw XT_SPACE
00f71a f026          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
00f71b ff01          .dw $ff01
00f71c 002e          .db ".",0
00f71d f713          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
00f71e f001          .dw DO_COLON
                 PFA_DOT:
                 .endif
00f71f fd7e          .dw XT_S2D
00f720 f716          .dw XT_DDOT
00f721 f026          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
00f722 ff03          .dw $ff03
00f723 6475
00f724 002e          .db "ud.",0
00f725 f71b          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
00f726 f001          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
00f727 f166          .dw XT_ZERO
00f728 f72f          .dw XT_UDDOTR
00f729 f7de          .dw XT_SPACE
00f72a f026          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
00f72b ff04          .dw $ff04
00f72c 6475
00f72d 722e          .db "ud.r"
00f72e f722          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
00f72f f001          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
00f730 f111          .dw XT_TO_R
00f731 f6ba          .dw XT_L_SHARP
00f732 f6d8          .dw XT_SHARP_S
00f733 f6e3          .dw XT_SHARP_G
00f734 f108          .dw XT_R_FROM
00f735 f0e1          .dw XT_OVER
00f736 f1a5          .dw XT_MINUS
00f737 f7e7          .dw XT_SPACES
00f738 f7f7          .dw XT_TYPE
00f739 f026          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
00f73a ff06          .dw $ff06
00f73b 6475
00f73c 6d2f
00f73d 646f          .db "ud/mod"
00f73e f72b          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
00f73f f001          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
00f740 f111          .dw XT_TO_R
00f741 f166          .dw XT_ZERO
00f742 f118          .dw XT_R_FETCH
00f743 f1d4          .dw XT_UMSLASHMOD
00f744 f108          .dw XT_R_FROM
00f745 f0d6          .dw XT_SWAP
00f746 f111          .dw XT_TO_R
00f747 f1d4          .dw XT_UMSLASHMOD
00f748 f108          .dw XT_R_FROM
00f749 f026          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
00f74a ff06          .dw $ff06 
00f74b 6964
00f74c 6967
00f74d 3f74          .db "digit?"
00f74e f73a          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
00f74f f001          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
00f750 f681          .dw XT_TOUPPER
00f751 f0c3
00f752 f046
00f753 0039
00f754 f18a
00f755 f046
00f756 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
00f757 f225
00f758 f1af
00f759 f0c3
00f75a f046
00f75b 0140
00f75c f18a          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
00f75d f046
00f75e 0107
00f75f f225
00f760 f1a5
00f761 f046
00f762 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
00f763 f1a5
00f764 f0c3
00f765 f54d
00f766 f08b
00f767 f16e          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
00f768 f026          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
00f769 f001        .dw DO_COLON
                 PFA_DOSLITERAL:
00f76a f118        .dw XT_R_FETCH   ; ( -- addr )
00f76b f7c8        .dw XT_ICOUNT
00f76c f108        .dw XT_R_FROM
00f76d f0e1        .dw XT_OVER     ; ( -- addr' n addr n)
00f76e f241        .dw XT_1PLUS
00f76f f216        .dw XT_2SLASH   ; ( -- addr' n addr k )
00f770 f1af        .dw XT_PLUS     ; ( -- addr' n addr'' )
00f771 f241        .dw XT_1PLUS
00f772 f111        .dw XT_TO_R     ; ( -- )
00f773 f026        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
00f774 ff02        .dw $ff02
00f775 2c73        .db "s",$2c
00f776 f74a        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
00f777 f001          .dw DO_COLON
                 PFA_SCOMMA:
00f778 f0c3          .dw XT_DUP
00f779 f77b          .dw XT_DOSCOMMA
00f77a f026          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
00f77b f001          .dw DO_COLON
                 PFA_DOSCOMMA:
00f77c 01f3          .dw XT_COMMA
00f77d f0c3          .dw XT_DUP   ; ( --addr len len)
00f77e f216          .dw XT_2SLASH ; ( -- addr len len/2
00f77f f572          .dw XT_TUCK   ; ( -- addr len/2 len len/2
00f780 f21d          .dw XT_2STAR  ; ( -- addr len/2 len len'
00f781 f1a5          .dw XT_MINUS  ; ( -- addr len/2 rem
00f782 f111          .dw XT_TO_R
00f783 f166          .dw XT_ZERO
00f784 02b2          .dw XT_QDOCHECK
00f785 f03f          .dw XT_DOCONDBRANCH
00f786 f78e          .dw PFA_SCOMMA2
00f787 f2ad          .dw XT_DODO
                 PFA_SCOMMA1:
00f788 f0c3          .dw XT_DUP         ; ( -- addr addr )
00f789 f08b          .dw XT_FETCH       ; ( -- addr c1c2 )
00f78a 01f3          .dw XT_COMMA       ; ( -- addr )
00f78b f55a          .dw XT_CELLPLUS    ; ( -- addr+cell )
00f78c f2db          .dw XT_DOLOOP
00f78d f788          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
00f78e f108          .dw XT_R_FROM
00f78f f138          .dw XT_GREATERZERO
00f790 f03f          .dw XT_DOCONDBRANCH
00f791 f795          .dw PFA_SCOMMA3
00f792 f0c3            .dw XT_DUP     ; well, tricky
00f793 f0aa            .dw XT_CFETCH
00f794 01f3            .dw XT_COMMA
                 PFA_SCOMMA3:
00f795 f0eb          .dw XT_DROP        ; ( -- )
00f796 f026          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
00f797 ff05          .dw $ff05
00f798 7469
00f799 7079
00f79a 0065          .db "itype",0
00f79b f774          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
00f79c f001          .dw DO_COLON
                 PFA_ITYPE:
00f79d f0c3          .dw XT_DUP    ; ( --addr len len)
00f79e f216          .dw XT_2SLASH ; ( -- addr len len/2
00f79f f572          .dw XT_TUCK   ; ( -- addr len/2 len len/2
00f7a0 f21d          .dw XT_2STAR  ; ( -- addr len/2 len len'
00f7a1 f1a5          .dw XT_MINUS  ; ( -- addr len/2 rem
00f7a2 f111          .dw XT_TO_R
00f7a3 f166          .dw XT_ZERO
00f7a4 02b2          .dw XT_QDOCHECK
00f7a5 f03f          .dw XT_DOCONDBRANCH
00f7a6 f7b0          .dw PFA_ITYPE2
00f7a7 f2ad          .dw XT_DODO
                 PFA_ITYPE1:
00f7a8 f0c3          .dw XT_DUP         ; ( -- addr addr )
00f7a9 f3d9          .dw XT_FETCHI      ; ( -- addr c1c2 )
00f7aa f0c3          .dw XT_DUP
00f7ab f7bd          .dw XT_LOWEMIT
00f7ac f7b9          .dw XT_HIEMIT
00f7ad f241          .dw XT_1PLUS    ; ( -- addr+cell )
00f7ae f2db          .dw XT_DOLOOP
00f7af f7a8          .dw PFA_ITYPE1
                 PFA_ITYPE2:
00f7b0 f108          .dw XT_R_FROM
00f7b1 f138          .dw XT_GREATERZERO
00f7b2 f03f          .dw XT_DOCONDBRANCH
00f7b3 f7b7          .dw PFA_ITYPE3
00f7b4 f0c3            .dw XT_DUP     ; make sure the drop below has always something to do
00f7b5 f3d9            .dw XT_FETCHI
00f7b6 f7bd            .dw XT_LOWEMIT
                 PFA_ITYPE3:
00f7b7 f0eb          .dw XT_DROP
00f7b8 f026          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
00f7b9 f001          .dw DO_COLON
                 PFA_HIEMIT:
00f7ba f30b          .dw XT_BYTESWAP
00f7bb f7bd          .dw XT_LOWEMIT
00f7bc f026          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
00f7bd f001          .dw DO_COLON
                 PFA_LOWEMIT:
00f7be f046          .dw XT_DOLITERAL
00f7bf 00ff          .dw $00ff
00f7c0 f225          .dw XT_AND
00f7c1 f58a          .dw XT_EMIT
00f7c2 f026          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
00f7c3 ff06          .dw $ff06
00f7c4 6369
00f7c5 756f
00f7c6 746e          .db "icount"
00f7c7 f797          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
00f7c8 f001          .dw DO_COLON
                 PFA_ICOUNT:
00f7c9 f0c3          .dw XT_DUP
00f7ca f241          .dw XT_1PLUS
00f7cb f0d6          .dw XT_SWAP
00f7cc f3d9          .dw XT_FETCHI
00f7cd f026          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
00f7ce ff02          .dw 0xff02
00f7cf 7263          .db "cr"
00f7d0 f7c3          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
00f7d1 f001          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
00f7d2 f046          .dw XT_DOLITERAL
00f7d3 000d          .dw 13
00f7d4 f58a          .dw XT_EMIT
00f7d5 f046          .dw XT_DOLITERAL
00f7d6 000a          .dw 10
00f7d7 f58a          .dw XT_EMIT
00f7d8 f026          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
00f7d9 ff05          .dw $ff05
00f7da 7073
00f7db 6361
00f7dc 0065          .db "space",0
00f7dd f7ce          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
00f7de f001          .dw DO_COLON
                 PFA_SPACE:
                 .endif
00f7df f5ec          .dw XT_BL
00f7e0 f58a          .dw XT_EMIT
00f7e1 f026          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
00f7e2 ff06          .dw $ff06
00f7e3 7073
00f7e4 6361
00f7e5 7365          .db "spaces"
00f7e6 f7d9          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
00f7e7 f001          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
00f7e8 f166
00f7e9 f666      	.DW XT_ZERO, XT_MAX
00f7ea f0c3
00f7eb f03f      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
00f7ec f7f1              DEST(SPCS2)
00f7ed f7de
00f7ee f247
00f7ef f035              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
00f7f0 f7ea              DEST(SPCS1)
00f7f1 f0eb
00f7f2 f026      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
00f7f3 ff04          .dw $ff04
00f7f4 7974
00f7f5 6570          .db "type"
00f7f6 f7e2          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
00f7f7 f001          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
00f7f8 fd75          .dw XT_BOUNDS
00f7f9 02b2          .dw XT_QDOCHECK
00f7fa f03f          .dw XT_DOCONDBRANCH
00f7fb f802          DEST(PFA_TYPE2)
00f7fc f2ad          .dw XT_DODO
                 PFA_TYPE1:
00f7fd f2be          .dw XT_I
00f7fe f0aa          .dw XT_CFETCH
00f7ff f58a          .dw XT_EMIT
00f800 f2db          .dw XT_DOLOOP
00f801 f7fd          DEST(PFA_TYPE1)
                 PFA_TYPE2:
00f802 f026          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
00f803 ff01          .dw $ff01
00f804 0027          .db "'",0
00f805 f7f3          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
00f806 f001          .dw DO_COLON
                 PFA_TICK:
                 .endif
00f807 f9ba          .dw XT_PARSENAME
00f808 fada          .dw XT_FORTHRECOGNIZER
00f809 fae5          .dw XT_RECOGNIZE
                     ; a word is tickable unless RECTYPE-TOKEN is RECTYPE-NULL or 
                     ; the interpret action is a NOOP
00f80a f0c3          .dw XT_DUP
00f80b fb61          .dw XT_RECTYPE_NULL
00f80c f3f1          .dw XT_EQUAL
00f80d f0d6          .dw XT_SWAP
00f80e f3d9          .dw XT_FETCHI
00f80f f046          .dw XT_DOLITERAL
00f810 fb96          .dw XT_NOOP
00f811 f3f1          .dw XT_EQUAL
00f812 f22e          .dw XT_OR
00f813 f03f          .dw XT_DOCONDBRANCH
00f814 f818          DEST(PFA_TICK1)
00f815 f046            .dw XT_DOLITERAL
00f816 fff3            .dw -13
00f817 f83d            .dw XT_THROW
                 PFA_TICK1:
00f818 f0eb          .dw XT_DROP
00f819 f026          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
00f81a ff07          .dw $ff07
00f81b 6168
00f81c 646e
00f81d 656c
00f81e 0072          .db "handler",0
00f81f f803          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
00f820 f067          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
00f821 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
00f822 ff05          .dw $ff05
00f823 6163
00f824 6374
00f825 0068          .db "catch",0
00f826 f81a          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
00f827 f001          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
00f828 f29f          .dw XT_SP_FETCH
00f829 f111          .dw XT_TO_R
                     ; handler @ >r
00f82a f820          .dw XT_HANDLER
00f82b f08b          .dw XT_FETCH
00f82c f111          .dw XT_TO_R
                     ; rp@ handler !
00f82d f288          .dw XT_RP_FETCH
00f82e f820          .dw XT_HANDLER
00f82f f093          .dw XT_STORE
00f830 f030          .dw XT_EXECUTE
                     ; r> handler !
00f831 f108          .dw XT_R_FROM
00f832 f820          .dw XT_HANDLER
00f833 f093          .dw XT_STORE
00f834 f108          .dw XT_R_FROM
00f835 f0eb          .dw XT_DROP
00f836 f166          .dw XT_ZERO
00f837 f026          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
00f838 ff05          .dw $ff05
00f839 6874
00f83a 6f72
00f83b 0077          .db "throw",0
00f83c f822          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
00f83d f001          .dw DO_COLON
                 PFA_THROW:
                 .endif
00f83e f0cb          .dw XT_QDUP
00f83f f03f          .dw XT_DOCONDBRANCH
00f840 f84d          DEST(PFA_THROW1)
00f841 f820            .dw XT_HANDLER
00f842 f08b            .dw XT_FETCH
00f843 f292            .dw XT_RP_STORE
00f844 f108            .dw XT_R_FROM
00f845 f820            .dw XT_HANDLER
00f846 f093            .dw XT_STORE
00f847 f108            .dw XT_R_FROM
00f848 f0d6            .dw XT_SWAP
00f849 f111            .dw XT_TO_R
00f84a f2a8            .dw XT_SP_STORE
00f84b f0eb            .dw XT_DROP
00f84c f108            .dw XT_R_FROM    
                 PFA_THROW1:
00f84d f026          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
00f84e ff05          .dw $ff05
00f84f 7363
00f850 696b
00f851 0070          .db "cskip",0
00f852 f838          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
00f853 f001          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
00f854 f111          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
00f855 f0c3          .dw XT_DUP            ; ( -- addr' n' n' )
00f856 f03f          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00f857 f862          DEST(PFA_CSKIP2)
00f858 f0e1          .dw XT_OVER           ; ( -- addr' n' addr' )
00f859 f0aa          .dw XT_CFETCH         ; ( -- addr' n' c' )
00f85a f118          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
00f85b f3f1          .dw XT_EQUAL          ; ( -- addr' n' f )
00f85c f03f          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00f85d f862          DEST(PFA_CSKIP2)
00f85e f3f8          .dw XT_ONE
00f85f f9ab          .dw XT_SLASHSTRING
00f860 f035          .dw XT_DOBRANCH
00f861 f855          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
00f862 f108          .dw XT_R_FROM
00f863 f0eb          .dw XT_DROP           ; ( -- addr2 n2)
00f864 f026          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
00f865 ff05          .dw $ff05
00f866 7363
00f867 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
00f868 006e          .db "cscan"
00f869 f84e          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
00f86a f001          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
00f86b f111          .dw XT_TO_R
00f86c f0e1          .dw XT_OVER
                 PFA_CSCAN1:
00f86d f0c3          .dw XT_DUP
00f86e f0aa          .dw XT_CFETCH
00f86f f118          .dw XT_R_FETCH
00f870 f3f1          .dw XT_EQUAL
00f871 f12a          .dw XT_ZEROEQUAL
00f872 f03f          .dw XT_DOCONDBRANCH
00f873 f87f          DEST(PFA_CSCAN2)
00f874 f0d6            .dw XT_SWAP
00f875 f247            .dw XT_1MINUS
00f876 f0d6            .dw XT_SWAP
00f877 f0e1            .dw XT_OVER
00f878 f131            .dw XT_ZEROLESS ; not negative
00f879 f12a            .dw XT_ZEROEQUAL
00f87a f03f            .dw XT_DOCONDBRANCH
00f87b f87f            DEST(PFA_CSCAN2)
00f87c f241              .dw XT_1PLUS
00f87d f035              .dw XT_DOBRANCH
00f87e f86d              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
00f87f f102          .dw XT_NIP
00f880 f0e1          .dw XT_OVER
00f881 f1a5          .dw XT_MINUS
00f882 f108          .dw XT_R_FROM
00f883 f0eb          .dw XT_DROP
00f884 f026          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
00f885 ff06          .dw $ff06
00f886 6361
00f887 6563
00f888 7470          .db "accept"
00f889 f865          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
00f88a f001          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
00f88b f0e1
00f88c f1af
00f88d f0e1              .DW XT_OVER,XT_PLUS,XT_OVER
00f88e f59b
00f88f f0c3
00f890 f8d3
00f891 f12a
00f892 f03f      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
00f893 f8c6              DEST(ACC5)
00f894 f0c3
00f895 f046
00f896 0008
00f897 f3f1
00f898 f03f              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
00f899 f8ac              DEST(ACC3)
00f89a f0eb
00f89b f0f3
00f89c f561
00f89d f18a
00f89e f111
00f89f f0f3
00f8a0 f0f3
00f8a1 f108
00f8a2 f03f              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
00f8a3 f8aa      	DEST(ACC6)
00f8a4 f8cb
00f8a5 f247
00f8a6 f111
00f8a7 f0e1
00f8a8 f108
00f8a9 016f      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
00f8aa f035      ACC6:   .DW XT_DOBRANCH
00f8ab f8c4              DEST(ACC4)
                     
                 
                 ACC3:    ; check for remaining control characters, replace them with blank
00f8ac f0c3      	.dw XT_DUP            ; ( -- addr k k )
00f8ad f5ec              .dw XT_BL
00f8ae f180              .dw XT_LESS
00f8af f03f              .dw XT_DOCONDBRANCH
00f8b0 f8b3              DEST(PFA_ACCEPT6)
00f8b1 f0eb              .dw XT_DROP
00f8b2 f5ec              .dw XT_BL
                 PFA_ACCEPT6:
00f8b3 f111
00f8b4 f561
00f8b5 f18a
00f8b6 f108
00f8b7 f0d6
00f8b8 f03f      	.DW XT_TO_R,XT_2DUP,XT_GREATER,XT_R_FROM,XT_SWAP,XT_DOCONDBRANCH
00f8b9 f8c3              DEST(ACC7)
00f8ba f0c3
00f8bb f58a
00f8bc f0e1
00f8bd f09f
00f8be f241
00f8bf f0e1
00f8c0 017b                  .DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
00f8c1 f035      	    .DW XT_DOBRANCH
00f8c2 f8c4      	    DEST(ACC4)
00f8c3 f0eb      ACC7:   .DW XT_DROP
00f8c4 f035      ACC4:   .DW XT_DOBRANCH
00f8c5 f88e              DEST(ACC1)
00f8c6 f0eb
00f8c7 f102
00f8c8 f0d6
00f8c9 f1a5
00f8ca f026      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
00f8cb f001          .dw DO_COLON
                 .endif
00f8cc f046          .dw XT_DOLITERAL
00f8cd 0008          .dw 8
00f8ce f0c3          .dw XT_DUP
00f8cf f58a          .dw XT_EMIT
00f8d0 f7de          .dw XT_SPACE
00f8d1 f58a          .dw XT_EMIT
00f8d2 f026          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
00f8d3 f001          .dw DO_COLON
                 .endif
00f8d4 f0c3          .dw XT_DUP
00f8d5 f046          .dw XT_DOLITERAL
00f8d6 000d          .dw 13
00f8d7 f3f1          .dw XT_EQUAL
00f8d8 f0d6          .dw XT_SWAP
00f8d9 f046          .dw XT_DOLITERAL
00f8da 000a          .dw 10
00f8db f3f1          .dw XT_EQUAL
00f8dc f22e          .dw XT_OR
00f8dd f026          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILL:
00f8de ff06          .dw $ff06
00f8df 6572
00f8e0 6966
00f8e1 6c6c          .db "refill"
00f8e2 f885          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
00f8e3 fc2a          .dw PFA_DODEFER1
                 PFA_REFILL:
                 .endif
00f8e4 001a          .dw USER_REFILL
00f8e5 fbf3          .dw XT_UDEFERFETCH
00f8e6 fbff          .dw XT_UDEFERSTORE
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
00f8e7 ff04          .dw $ff04
00f8e8 6863
00f8e9 7261          .db "char"
00f8ea f8de          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
00f8eb f001          .dw DO_COLON
                 PFA_CHAR:
                 .endif
00f8ec f9ba          .dw XT_PARSENAME
00f8ed f12a
00f8ee f03f          .dw XT_ZEROEQUAL,XT_DOCONDBRANCH 
00f8ef f8f3          DEST(CHAR_1)
00f8f0 f046
00f8f1 fff0
00f8f2 f83d             .dw XT_DOLITERAL, -16, XT_THROW
                 CHAR_1:
                 
00f8f3 f0aa          .dw XT_CFETCH
00f8f4 f026          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
00f8f5 ff06          .dw $ff06
00f8f6 756e
00f8f7 626d
00f8f8 7265          .db "number"
00f8f9 f8e7          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
00f8fa f001          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
00f8fb f54d          .dw XT_BASE
00f8fc f08b          .dw XT_FETCH
00f8fd f111          .dw XT_TO_R
00f8fe f93e          .dw XT_QSIGN
00f8ff f111          .dw XT_TO_R
00f900 f951          .dw XT_SET_BASE
00f901 f93e          .dw XT_QSIGN
00f902 f108          .dw XT_R_FROM
00f903 f22e          .dw XT_OR
00f904 f111          .dw XT_TO_R
                     ; check whether something is left
00f905 f0c3          .dw XT_DUP
00f906 f12a          .dw XT_ZEROEQUAL
00f907 f03f          .dw XT_DOCONDBRANCH
00f908 f911          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
00f909 f56a            .dw XT_2DROP
00f90a f108            .dw XT_R_FROM
00f90b f0eb            .dw XT_DROP
00f90c f108            .dw XT_R_FROM
00f90d f54d            .dw XT_BASE
00f90e f093            .dw XT_STORE
00f90f f166            .dw XT_ZERO
00f910 f026            .dw XT_EXIT
                 PFA_NUMBER0:
00f911 f326          .dw XT_2TO_R
00f912 f166          .dw XT_ZERO       ; starting value
00f913 f166          .dw XT_ZERO
00f914 f335          .dw XT_2R_FROM
00f915 f96f          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
00f916 f0cb          .dw XT_QDUP
00f917 f03f          .dw XT_DOCONDBRANCH
00f918 f933          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
00f919 f3f8          .dw XT_ONE
00f91a f3f1          .dw XT_EQUAL
00f91b f03f          .dw XT_DOCONDBRANCH
00f91c f92a          DEST(PFA_NUMBER2)
                 	; excatly one character is left
00f91d f0aa      	.dw XT_CFETCH
00f91e f046      	.dw XT_DOLITERAL
00f91f 002e      	.dw 46 ; .
00f920 f3f1      	.dw XT_EQUAL
00f921 f03f      	.dw XT_DOCONDBRANCH
00f922 f92b      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
00f923 f108      	.dw XT_R_FROM
00f924 f03f              .dw XT_DOCONDBRANCH
00f925 f927      	DEST(PFA_NUMBER3)
00f926 fcf8              .dw XT_DNEGATE
                 PFA_NUMBER3:
00f927 f3fd      	.dw XT_TWO
00f928 f035      	.dw XT_DOBRANCH
00f929 f939      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
00f92a f0eb      	.dw XT_DROP
                 PFA_NUMBER6:
00f92b f56a      	.dw XT_2DROP
00f92c f108      	.dw XT_R_FROM
00f92d f0eb      	.dw XT_DROP
00f92e f108              .dw XT_R_FROM
00f92f f54d              .dw XT_BASE
00f930 f093              .dw XT_STORE
00f931 f166      	.dw XT_ZERO
00f932 f026      	.dw XT_EXIT
                 PFA_NUMBER1:
00f933 f56a          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
00f934 f108          .dw XT_R_FROM
00f935 f03f          .dw XT_DOCONDBRANCH
00f936 f938          DEST(PFA_NUMBER4)
00f937 f63b          .dw XT_NEGATE
                 PFA_NUMBER4:
00f938 f3f8          .dw XT_ONE
                 PFA_NUMBER5:
00f939 f108          .dw XT_R_FROM
00f93a f54d          .dw XT_BASE
00f93b f093          .dw XT_STORE
00f93c f15d          .dw XT_TRUE
00f93d f026          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
00f93e f001          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
00f93f f0e1          .dw XT_OVER    ; ( -- addr len addr )
00f940 f0aa          .dw XT_CFETCH
00f941 f046          .dw XT_DOLITERAL
00f942 002d          .dw '-'
00f943 f3f1          .dw XT_EQUAL  ; ( -- addr len flag )
00f944 f0c3          .dw XT_DUP
00f945 f111          .dw XT_TO_R
00f946 f03f          .dw XT_DOCONDBRANCH
00f947 f94a          DEST(PFA_NUMBERSIGN_DONE)
00f948 f3f8          .dw XT_ONE    ; skip sign character
00f949 f9ab          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
00f94a f108          .dw XT_R_FROM
00f94b f026          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
00f94c f061          .dw PFA_DOCONSTANT
                 .endif
00f94d 000a
00f94e 0010
00f94f 0002
00f950 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
00f951 f001          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
00f952 f0e1          .dw XT_OVER
00f953 f0aa          .dw XT_CFETCH
00f954 f046          .dw XT_DOLITERAL
00f955 0023          .dw 35
00f956 f1a5          .dw XT_MINUS
00f957 f0c3          .dw XT_DUP
00f958 f166          .dw XT_ZERO
00f959 f046          .dw XT_DOLITERAL
00f95a 0004          .dw 4
00f95b f673          .dw XT_WITHIN
00f95c f03f          .dw XT_DOCONDBRANCH
00f95d f967          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
00f95e f94c      	.dw XT_BASES
00f95f f1af      	.dw XT_PLUS
00f960 f3d9      	.dw XT_FETCHI
00f961 f54d      	.dw XT_BASE
00f962 f093      	.dw XT_STORE
00f963 f3f8      	.dw XT_ONE
00f964 f9ab      	.dw XT_SLASHSTRING
00f965 f035      	.dw XT_DOBRANCH
00f966 f968      	DEST(SET_BASE2)
                 SET_BASE1:
00f967 f0eb      	.dw XT_DROP
                 SET_BASE2:
00f968 f026          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
00f969 ff07          .dw $ff07
00f96a 6e3e
00f96b 6d75
00f96c 6562
00f96d 0072          .db ">number",0
00f96e f8f5          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
00f96f f001          .dw DO_COLON
                 
                 .endif
                 
00f970 f0c3
00f971 f03f      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
00f972 f987              DEST(TONUM3)
00f973 f0e1
00f974 f0aa
00f975 f74f              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
00f976 f12a
00f977 f03f              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
00f978 f97b              DEST(TONUM2)
00f979 f0eb
00f97a f026              .DW XT_DROP,XT_EXIT
00f97b f111
00f97c fd1c
00f97d f54d
00f97e f08b
00f97f 0160      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
00f980 f108
00f981 0158
00f982 fd1c              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
00f983 f3f8
00f984 f9ab
00f985 f035              .DW XT_ONE,XT_SLASHSTRING,XT_DOBRANCH
00f986 f970              DEST(TONUM1)
00f987 f026      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
00f988 ff05          .dw $ff05
00f989 6170
00f98a 7372
00f98b 0065          .db "parse",0
00f98c f969          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
00f98d f001          .dw DO_COLON
                 PFA_PARSE:
                 .endif
00f98e f111          .dw XT_TO_R     ; ( -- )
00f98f f9a1          .dw XT_SOURCE   ; ( -- addr len)
00f990 f57a          .dw XT_TO_IN     ; ( -- addr len >in)
00f991 f08b          .dw XT_FETCH
00f992 f9ab          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
00f993 f108          .dw XT_R_FROM      ; ( -- addr' len' c)
00f994 f86a          .dw XT_CSCAN       ; ( -- addr' len'')
00f995 f0c3          .dw XT_DUP         ; ( -- addr' len'' len'')
00f996 f241          .dw XT_1PLUS
00f997 f57a          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
00f998 f277          .dw XT_PLUSSTORE   ; ( -- addr' len')
00f999 f3f8          .dw XT_ONE
00f99a f9ab          .dw XT_SLASHSTRING
00f99b f026          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCE:
00f99c ff06          .dw $FF06
00f99d 6f73
00f99e 7275
00f99f 6563          .db "source"
00f9a0 f988          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
00f9a1 fc2a          .dw PFA_DODEFER1
                 PFA_SOURCE:
                 .endif
00f9a2 0016          .dw USER_SOURCE
00f9a3 fbf3          .dw XT_UDEFERFETCH
00f9a4 fbff          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
00f9a5 ff07          .dw $ff07
00f9a6 732f
00f9a7 7274
00f9a8 6e69
00f9a9 0067          .db "/string",0
00f9aa f99c          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
00f9ab f001          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
00f9ac f0f3          .dw XT_ROT
00f9ad f0e1          .dw XT_OVER
00f9ae f1af          .dw XT_PLUS
00f9af f0f3          .dw XT_ROT
00f9b0 f0f3          .dw XT_ROT
00f9b1 f1a5          .dw XT_MINUS
00f9b2 f026          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
00f9b3 ff0a          .dw $FF0A 
00f9b4 6170
00f9b5 7372
00f9b6 2d65
00f9b7 616e
00f9b8 656d          .db "parse-name"
00f9b9 f9a5          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
00f9ba f001          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
00f9bb f5ec          .dw XT_BL
00f9bc f9be          .dw XT_SKIPSCANCHAR
00f9bd f026          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
00f9be f001          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
00f9bf f111          .dw XT_TO_R
00f9c0 f9a1          .dw XT_SOURCE 
00f9c1 f57a          .dw XT_TO_IN 
00f9c2 f08b          .dw XT_FETCH 
00f9c3 f9ab          .dw XT_SLASHSTRING 
                 
00f9c4 f118          .dw XT_R_FETCH
00f9c5 f853          .dw XT_CSKIP
00f9c6 f108          .dw XT_R_FROM
00f9c7 f86a          .dw XT_CSCAN
                 
                     ; adjust >IN
00f9c8 f561          .dw XT_2DUP
00f9c9 f1af          .dw XT_PLUS
00f9ca f9a1          .dw XT_SOURCE 
00f9cb f0eb          .dw XT_DROP
00f9cc f1a5          .dw XT_MINUS
00f9cd f57a          .dw XT_TO_IN
00f9ce f093          .dw XT_STORE
00f9cf f026          .dw XT_EXIT
                 .include "words/find-xt.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the xt from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDXT:
00f9d0 ff07          .dw $ff07
00f9d1 6966
00f9d2 646e
00f9d3 782d
00f9d4 0074          .db "find-xt",0
00f9d5 f9b3          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDXT
                 XT_FINDXT:
00f9d6 f001          .dw DO_COLON
                 PFA_FINDXT:
                 .endif
00f9d7 f046          .dw XT_DOLITERAL
00f9d8 f9e2          .dw XT_FINDXTA
00f9d9 f046          .dw XT_DOLITERAL
00f9da 005c          .dw CFG_ORDERLISTLEN
00f9db 0433          .dw XT_MAPSTACK
00f9dc f12a          .dw XT_ZEROEQUAL
00f9dd f03f          .dw XT_DOCONDBRANCH
00f9de f9e1          DEST(PFA_FINDXT1)
00f9df f56a            .dw XT_2DROP
00f9e0 f166            .dw XT_ZERO
                 PFA_FINDXT1:
00f9e1 f026          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDXTA:
00f9e2 f001          .dw DO_COLON
                 PFA_FINDXTA:
                 .endif
00f9e3 f111          .dw XT_TO_R
00f9e4 f561          .dw XT_2DUP
00f9e5 f108          .dw XT_R_FROM
00f9e6 fc3c          .dw XT_SEARCH_WORDLIST
00f9e7 f0c3          .dw XT_DUP
00f9e8 f03f          .dw XT_DOCONDBRANCH
00f9e9 f9ef          DEST(PFA_FINDXTA1)
00f9ea f111            .dw XT_TO_R
00f9eb f102            .dw XT_NIP
00f9ec f102            .dw XT_NIP
00f9ed f108            .dw XT_R_FROM
00f9ee f15d            .dw XT_TRUE
                 PFA_FINDXTA1:
00f9ef f026          .dw XT_EXIT
                 
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_DEFAULT_PROMPTOK:
00f9f0 f001          .dw DO_COLON
                 PFA_DEFAULT_PROMPTOK:
00f9f1 f769          .dw XT_DOSLITERAL
00f9f2 0003          .dw 3
00f9f3 6f20
00f9f4 006b          .db " ok",0
                 .endif
00f9f5 f79c          .dw XT_ITYPE
00f9f6 f026          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTOK:
00f9f7 ff03          .dw $FF03
00f9f8 6f2e
../../common\words/prompt-ok.asm(43): warning: .cseg .db misalignment - padding zero byte
00f9f9 006b          .db ".ok"
00f9fa f9d0          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
00f9fb fc2a          .dw PFA_DODEFER1
                 PFA_PROMPTOK:
                 .endif
00f9fc 001c          .dw USER_P_OK
00f9fd fbf3          .dw XT_UDEFERFETCH
00f9fe fbff          .dw XT_UDEFERSTORE
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_DEFAULT_PROMPTREADY:
00f9ff f001          .dw DO_COLON
                 PFA_DEFAULT_PROMPTREADY:
00fa00 f769          .dw XT_DOSLITERAL
00fa01 0002          .dw 2
00fa02 203e          .db "> "
                 .endif
00fa03 f7d1          .dw XT_CR
00fa04 f79c          .dw XT_ITYPE
00fa05 f026          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTREADY:
00fa06 ff06          .dw $FF06
00fa07 722e
00fa08 6165
00fa09 7964          .db ".ready"
00fa0a f9f7          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTREADY
                 XT_PROMPTREADY:
00fa0b fc2a          .dw PFA_DODEFER1
                 PFA_PROMPTREADY:
                 .endif
00fa0c 0020          .dw USER_P_RDY
00fa0d fbf3          .dw XT_UDEFERFETCH
00fa0e fbff          .dw XT_UDEFERSTORE
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_DEFAULT_PROMPTERROR:
00fa0f f001          .dw DO_COLON
                 PFA_DEFAULT_PROMPTERROR:
00fa10 f769      	.dw XT_DOSLITERAL
00fa11 0004          .dw 4
00fa12 3f20
00fa13 203f          .db " ?? "
                 .endif
00fa14 f79c          .dw XT_ITYPE
00fa15 f54d          .dw XT_BASE
00fa16 f08b          .dw XT_FETCH
00fa17 f111          .dw XT_TO_R
00fa18 f5d9          .dw XT_DECIMAL
00fa19 f71e          .dw XT_DOT
00fa1a f57a          .dw XT_TO_IN
00fa1b f08b          .dw XT_FETCH
00fa1c f71e          .dw XT_DOT
00fa1d f108          .dw XT_R_FROM
00fa1e f54d          .dw XT_BASE
00fa1f f093          .dw XT_STORE
00fa20 f026          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTERROR:
00fa21 ff06          .dw $FF06
00fa22 652e
00fa23 7272
00fa24 726f          .db ".error"
00fa25 fa06          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
00fa26 fc2a          .dw PFA_DODEFER1
                 PFA_PROMPTERROR:
                 .endif
00fa27 001e          .dw USER_P_ERR
00fa28 fbf3          .dw XT_UDEFERFETCH
00fa29 fbff          .dw XT_UDEFERSTORE
                 .include "words/prompt-input.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_DEFAULT_PROMPTINPUT:
00fa2a f001          .dw DO_COLON
                 PFA_DEFAULT_PROMPTINPUT:
                 .endif
00fa2b f7d1          .dw XT_CR
00fa2c f026          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTINPUT:
00fa2d ff06          .dw $FF06
00fa2e 692e
00fa2f 706e
00fa30 7475          .db ".input"
00fa31 fa21          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTINPUT
                 XT_PROMPTINPUT:
00fa32 fc2a          .dw PFA_DODEFER1
                 PFA_PROMPTINPUT:
                 .endif
00fa33 0022          .dw USER_P_INPUT
00fa34 fbf3          .dw XT_UDEFERFETCH
00fa35 fbff          .dw XT_UDEFERSTORE
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
00fa36 ff04          .dw $ff04
00fa37 7571
00fa38 7469          .db "quit"
00fa39 fa2d          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
00fa3a f001          .dw DO_COLON
                 .endif
                 PFA_QUIT:
00fa3b 02e8
00fa3c 02ef
00fa3d f093          .dw XT_LP0,XT_LP,XT_STORE
00fa3e fa9c          .dw XT_SP0
00fa3f f2a8          .dw XT_SP_STORE
00fa40 faa4          .dw XT_RP0
00fa41 f292          .dw XT_RP_STORE
00fa42 037d          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
00fa43 f547          .dw XT_STATE
00fa44 f08b          .dw XT_FETCH
00fa45 f12a          .dw XT_ZEROEQUAL
00fa46 f03f          .dw XT_DOCONDBRANCH
00fa47 fa49          DEST(PFA_QUIT4)
00fa48 fa0b          .dw XT_PROMPTREADY
                 PFA_QUIT4:
00fa49 f8e3          .dw XT_REFILL
00fa4a fa32          .dw XT_PROMPTINPUT
00fa4b f03f          .dw XT_DOCONDBRANCH
00fa4c fa5c          DEST(PFA_QUIT3)
00fa4d f046          .dw XT_DOLITERAL
00fa4e fabd          .dw XT_INTERPRET
00fa4f f827          .dw XT_CATCH
00fa50 f0cb          .dw XT_QDUP
00fa51 f03f          .dw XT_DOCONDBRANCH
00fa52 fa5c          DEST(PFA_QUIT3)
00fa53 f0c3      	.dw XT_DUP
00fa54 f046      	.dw XT_DOLITERAL
00fa55 fffe      	.dw -2
00fa56 f180      	.dw XT_LESS
00fa57 f03f      	.dw XT_DOCONDBRANCH
00fa58 fa5a      	DEST(PFA_QUIT5)
00fa59 fa26      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
00fa5a f035      	.dw XT_DOBRANCH
00fa5b fa3b      	DEST(PFA_QUIT)
                 PFA_QUIT3:
00fa5c f9fb          .dw XT_PROMPTOK
00fa5d f035          .dw XT_DOBRANCH
00fa5e fa43          DEST(PFA_QUIT2)
                 ;    .dw XT_EXIT ; never reached
                 
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
00fa5f ff05          .dw $ff05
00fa60 6170
00fa61 7375
00fa62 0065          .db "pause",0
00fa63 fa36          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
00fa64 fc2a          .dw PFA_DODEFER1
                 PFA_PAUSE:
00fa65 0141          .dw ram_pause
00fa66 fbdf          .dw XT_RDEFERFETCH
00fa67 fbe9          .dw XT_RDEFERSTORE
                 
                 .dseg
000141           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
00fa68 ff04          .dw $ff04
00fa69 6f63
00fa6a 646c          .db "cold"
00fa6b fa5f          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
00fa6c fa6d          .dw PFA_COLD
                 PFA_COLD:
00fa6d b6a4          in_ mcu_boot, MCUSR
00fa6e 2422          clr zerol
00fa6f 2433          clr zeroh
00fa70 24bb          clr isrflag
00fa71 be24          out_ MCUSR, zerol
                     ; clear RAM
00fa72 e0e0          ldi zl, low(ramstart)
00fa73 e0f1          ldi zh, high(ramstart)
                 clearloop:
00fa74 9221          st Z+, zerol
00fa75 30e0          cpi zl, low(sram_size+ramstart)
00fa76 f7e9          brne clearloop
00fa77 34f1          cpi zh, high(sram_size+ramstart)
00fa78 f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000143           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
00fa79 e4e3          ldi zl, low(ram_user1)
00fa7a e0f1          ldi zh, high(ram_user1)
00fa7b 012f          movw upl, zl
                     ; init return stack pointer
00fa7c ef0f          ldi temp0,low(rstackstart)
00fa7d bf0d          out_ SPL,temp0
00fa7e 8304          std Z+4, temp0
00fa7f e410          ldi temp1,high(rstackstart)
00fa80 bf1e          out_ SPH,temp1
00fa81 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
00fa82 eacf          ldi yl,low(stackstart)
00fa83 83c6          std Z+6, yl
00fa84 e4d0          ldi yh,high(stackstart)
00fa85 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
00fa86 e8af          ldi XL, low(PFA_WARM)
00fa87 efba          ldi XH, high(PFA_WARM)
                     ; its a far jump...
00fa88 940c f005     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WARM:
00fa8a ff04          .dw $ff04
00fa8b 6177
00fa8c 6d72          .db "warm"
00fa8d fa68          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
00fa8e f001          .dw DO_COLON
                 PFA_WARM:
                 .endif
00fa8f fd67          .dw XT_INIT_RAM
00fa90 f046          .dw XT_DOLITERAL
00fa91 fb96          .dw XT_NOOP
00fa92 f046          .dw XT_DOLITERAL
00fa93 fa64          .dw XT_PAUSE
00fa94 fc0a          .dw XT_DEFERSTORE
00fa95 037d          .dw XT_LBRACKET
00fa96 f5f4          .dw XT_TURNKEY
00fa97 fa3a          .dw XT_QUIT     ; never returns
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
00fa98 ff03          .dw $ff03
00fa99 7073
00fa9a 0030          .db "sp0",0
00fa9b fa8a          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
00fa9c f081          .dw PFA_DOVALUE1
                 PFA_SP0:
00fa9d 0006          .dw USER_SP0
00fa9e fbf3          .dw XT_UDEFERFETCH
00fa9f fbff          .dw XT_UDEFERSTORE
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
00faa0 ff03          .dw $ff03
00faa1 7072
00faa2 0030          .db "rp0",0
00faa3 fa98          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
00faa4 f001          .dw DO_COLON
                 PFA_RP0:
00faa5 faa8          .dw XT_DORP0
00faa6 f08b          .dw XT_FETCH
00faa7 f026          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
00faa8 f067          .dw PFA_DOUSER
                 PFA_DORP0:
00faa9 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
00faaa ff05          .dw $ff05
00faab 6564
00faac 7470
00faad 0068          .db "depth",0
00faae faa0          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
00faaf f001          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
00fab0 fa9c          .dw XT_SP0
00fab1 f29f          .dw XT_SP_FETCH
00fab2 f1a5          .dw XT_MINUS
00fab3 f216          .dw XT_2SLASH
00fab4 f247          .dw XT_1MINUS
00fab5 f026          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
00fab6 ff09          .dw $ff09
00fab7 6e69
00fab8 6574
00fab9 7072
00faba 6572
00fabb 0074          .db "interpret",0
00fabc faaa          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
00fabd f001          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
00fabe f9ba          .dw XT_PARSENAME ; ( -- addr len )
00fabf f0c3          .dw XT_DUP   ; ( -- addr len flag)
00fac0 f03f          .dw XT_DOCONDBRANCH
00fac1 face          DEST(PFA_INTERPRET2)
00fac2 fada            .dw XT_FORTHRECOGNIZER
00fac3 fae5            .dw XT_RECOGNIZE
00fac4 f547            .dw XT_STATE
00fac5 f08b            .dw XT_FETCH
00fac6 f03f            .dw XT_DOCONDBRANCH
00fac7 fac9          DEST(PFA_INTERPRET1)
00fac8 fbc2            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
00fac9 f3d9            .dw XT_FETCHI
00faca f030            .dw XT_EXECUTE
00facb fb6e            .dw XT_QSTACK
00facc f035          .dw XT_DOBRANCH
00facd fabe          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
00face f56a          .dw XT_2DROP
00facf f026          .dw XT_EXIT
                 .include "words/forth-recognizer.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_FORTHRECOGNIZER:
00fad0 ff10          .dw $ff10
00fad1 6f66
00fad2 7472
00fad3 2d68
00fad4 6572
00fad5 6f63
00fad6 6e67
00fad7 7a69
00fad8 7265          .db "forth-recognizer"
00fad9 fab6          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHRECOGNIZER
                 XT_FORTHRECOGNIZER:
00fada f081          .dw PFA_DOVALUE1
                 PFA_FORTHRECOGNIZER:
00fadb 0050          .dw CFG_FORTHRECOGNIZER
00fadc fbcb          .dw XT_EDEFERFETCH
00fadd fbd5          .dw XT_EDEFERSTORE
                 .include "words/recognize.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECOGNIZE:
00fade ff09          .dw $ff09
00fadf 6572
00fae0 6f63
00fae1 6e67
00fae2 7a69
00fae3 0065          .db "recognize",0
00fae4 fad0          .dw VE_HEAD
                     .set VE_HEAD = VE_RECOGNIZE
                 XT_RECOGNIZE:
00fae5 f001          .dw DO_COLON
                 PFA_RECOGNIZE:
                 .endif
00fae6 f046          .dw XT_DOLITERAL
00fae7 faf0          .dw XT_RECOGNIZE_A
00fae8 f0d6          .dw XT_SWAP
00fae9 0433          .dw XT_MAPSTACK
00faea f12a          .dw XT_ZEROEQUAL
00faeb f03f          .dw XT_DOCONDBRANCH
00faec faef          DEST(PFA_RECOGNIZE1)
00faed f56a            .dw XT_2DROP
00faee fb61            .dw XT_RECTYPE_NULL
                 PFA_RECOGNIZE1:
00faef f026          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ; ( addr len XT -- addr len [ rectype-* -1 | 0 ] )
                 XT_RECOGNIZE_A:
00faf0 f001         .dw DO_COLON
                 PFA_RECOGNIZE_A:
                 .endif
00faf1 f0f3         .dw XT_ROT  ; -- len xt addr
00faf2 f0f3         .dw XT_ROT  ; -- xt addr len
00faf3 f561         .dw XT_2DUP 
00faf4 f326         .dw XT_2TO_R
00faf5 f0f3         .dw XT_ROT  ; -- addr len xt
00faf6 f030         .dw XT_EXECUTE ; -- i*x rectype-* | rectype-null
00faf7 f335         .dw XT_2R_FROM
00faf8 f0f3         .dw XT_ROT
00faf9 f0c3         .dw XT_DUP
00fafa fb61         .dw XT_RECTYPE_NULL
00fafb f3f1         .dw XT_EQUAL
00fafc f03f         .dw XT_DOCONDBRANCH
00fafd fb01         DEST(PFA_RECOGNIZE_A1)
00fafe f0eb           .dw XT_DROP
00faff f166           .dw XT_ZERO
00fb00 f026           .dw XT_EXIT
                 PFA_RECOGNIZE_A1:
00fb01 f102         .dw XT_NIP 
00fb02 f102         .dw XT_NIP
00fb03 f15d         .dw XT_TRUE
00fb04 f026         .dw XT_EXIT
                 
                 ; : recognize ( addr len stack-id -- i*x rectype-* | rectype-null )
                 ;   [: ( addr len -- addr len 0 | i*x rectype-* -1 )
                 ;      rot rot 2dup 2>r rot execute 2r> rot 
                 ;      dup rectype-null = ( -- addr len rectype-* f )
                 ;      if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    map-stack ( -- i*x addr len rectype-* f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop rectype-null
                 ;    then ;
                 ;
                 .include "words/rec-intnum.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_NUM:
00fb05 ff0b          .dw $ff0b
00fb06 6572
00fb07 7463
00fb08 7079
00fb09 2d65
00fb0a 756e
00fb0b 006d          .db "rectype-num",0
00fb0c fade          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_NUM
                 XT_RECTYPE_NUM:
00fb0d f061          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_NUM:
                 .endif
00fb0e fb96          .dw XT_NOOP    ; interpret
00fb0f 0209          .dw XT_LITERAL ; compile
00fb10 0209          .dw XT_LITERAL ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_DNUM:
00fb11 ff0c          .dw $ff0c
00fb12 6572
00fb13 7463
00fb14 7079
00fb15 2d65
00fb16 6e64
00fb17 6d75          .db "rectype-dnum"
00fb18 fb05          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_DNUM
                 XT_RECTYPE_DNUM:
00fb19 f061          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_DNUM:
                 .endif
00fb1a fb96          .dw XT_NOOP     ; interpret
00fb1b f3e9          .dw XT_2LITERAL ; compile
00fb1c f3e9          .dw XT_2LITERAL ; postpone
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
00fb1d ff07          .dw $ff07
00fb1e 6572
00fb1f 2d63
00fb20 756e
00fb21 006d          .db "rec-num",0
00fb22 fb11          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
00fb23 f001          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
00fb24 f8fa          .dw XT_NUMBER
00fb25 f03f          .dw XT_DOCONDBRANCH
00fb26 fb2f          DEST(PFA_REC_NONUMBER)
00fb27 f3f8          .dw XT_ONE
00fb28 f3f1          .dw XT_EQUAL
00fb29 f03f          .dw XT_DOCONDBRANCH
00fb2a fb2d          DEST(PFA_REC_INTNUM2)
00fb2b fb0d            .dw XT_RECTYPE_NUM
00fb2c f026            .dw XT_EXIT
                 PFA_REC_INTNUM2:
00fb2d fb19            .dw XT_RECTYPE_DNUM
00fb2e f026            .dw XT_EXIT
                 PFA_REC_NONUMBER:
00fb2f fb61          .dw XT_RECTYPE_NULL
00fb30 f026          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_FIND:
00fb31 ff08          .dw $ff08
00fb32 6572
00fb33 2d63
00fb34 6966
00fb35 646e          .db "rec-find"
00fb36 fb1d          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
00fb37 f001          .dw DO_COLON
                 PFA_REC_FIND:
                 .endif
00fb38 f9d6          .DW XT_FINDXT
00fb39 f0c3          .dw XT_DUP
00fb3a f12a          .dw XT_ZEROEQUAL
00fb3b f03f          .dw XT_DOCONDBRANCH
00fb3c fb40          DEST(PFA_REC_WORD_FOUND)
00fb3d f0eb              .dw XT_DROP
00fb3e fb61      	.dw XT_RECTYPE_NULL
00fb3f f026      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
00fb40 fb49          .dw XT_RECTYPE_XT
                 
00fb41 f026          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_XT:
00fb42 ff0a          .dw $ff0a
00fb43 6572
00fb44 7463
00fb45 7079
00fb46 2d65
00fb47 7478          .db "rectype-xt"
00fb48 fb31          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_XT
                 XT_RECTYPE_XT:
00fb49 f061          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_XT:
                 .endif
00fb4a fb4d          .dw XT_R_WORD_INTERPRET
00fb4b fb51          .dw XT_R_WORD_COMPILE
00fb4c f3e9          .dw XT_2LITERAL
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
00fb4d f001          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
00fb4e f0eb          .dw XT_DROP ; the flags are in the way
00fb4f f030          .dw XT_EXECUTE
00fb50 f026          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
00fb51 f001          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
00fb52 f131          .dw XT_ZEROLESS
00fb53 f03f          .dw XT_DOCONDBRANCH
00fb54 fb57          DEST(PFA_R_WORD_COMPILE1)
00fb55 01f3      	.dw XT_COMMA
00fb56 f026              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
00fb57 f030              .dw XT_EXECUTE
00fb58 f026          .dw XT_EXIT
                 .include "words/rec-null.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_NULL:
00fb59 ff0c          .dw $ff0c
00fb5a 6572
00fb5b 7463
00fb5c 7079
00fb5d 2d65
00fb5e 756e
00fb5f 6c6c          .db "rectype-null"
00fb60 fb42          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_NULL
                 XT_RECTYPE_NULL:
00fb61 f061          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_NULL:
                 .endif
00fb62 fb65          .dw XT_FAIL  ; interpret
00fb63 fb65          .dw XT_FAIL  ; compile
00fb64 fb65          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
00fb65 f001          .dw DO_COLON
                 PFA_FAIL:
                 .endif
00fb66 f046          .dw XT_DOLITERAL
00fb67 fff3          .dw -13
00fb68 f83d          .dw XT_THROW
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
00fb69 ff06          .dw $ff06
00fb6a 733f
00fb6b 6174
00fb6c 6b63          .db "?stack"
00fb6d fb59          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
00fb6e f001          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
00fb6f faaf          .dw XT_DEPTH
00fb70 f131          .dw XT_ZEROLESS
00fb71 f03f          .dw XT_DOCONDBRANCH
00fb72 fb76          DEST(PFA_QSTACK1)
00fb73 f046            .dw XT_DOLITERAL
00fb74 fffc            .dw -4
00fb75 f83d            .dw XT_THROW
                 PFA_QSTACK1:
00fb76 f026          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
00fb77 ff03          .dw $ff03
00fb78 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
00fb79 0072          .db "ver"
00fb7a fb69          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
00fb7b f001          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
00fb7c f509          .dw XT_ENV_FORTHNAME
00fb7d f79c          .dw XT_ITYPE
00fb7e f7de          .dw XT_SPACE
00fb7f f54d          .dw XT_BASE
00fb80 f08b          .dw XT_FETCH
                 
00fb81 f517          .dw XT_ENV_FORTHVERSION
00fb82 f5d9          .dw XT_DECIMAL
00fb83 fd7e          .dw XT_S2D
00fb84 f6ba          .dw XT_L_SHARP
00fb85 f6c2          .dw XT_SHARP
00fb86 f046          .dw XT_DOLITERAL
00fb87 002e          .dw '.'
00fb88 f6ab          .dw XT_HOLD
00fb89 f6d8          .dw XT_SHARP_S
00fb8a f6e3          .dw XT_SHARP_G
00fb8b f7f7          .dw XT_TYPE
00fb8c f54d          .dw XT_BASE
00fb8d f093          .dw XT_STORE
00fb8e f7de          .dw XT_SPACE
00fb8f f51f          .dw XT_ENV_CPU
00fb90 f79c          .dw XT_ITYPE
                 
00fb91 f026          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOOP:
00fb92 ff04          .dw $ff04
00fb93 6f6e
00fb94 706f          .db "noop"
00fb95 fb77          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
00fb96 f001          .dw DO_COLON
                 PFA_NOOP:
                 .endif
00fb97 f026         .DW XT_EXIT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
00fb98 ff06          .dw $ff06
00fb99 6e75
00fb9a 7375
00fb9b 6465          .db "unused"
00fb9c fb92          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
00fb9d f001          .dw DO_COLON
                 PFA_UNUSED:
00fb9e f29f          .dw XT_SP_FETCH
00fb9f f5bb          .dw XT_HERE
00fba0 f1a5          .dw XT_MINUS
00fba1 f026          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
00fba2 0002          .dw $0002
00fba3 6f74          .db "to"
00fba4 fb98          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
00fba5 f001          .dw DO_COLON
                 PFA_TO:
                 .endif
00fba6 f806          .dw XT_TICK
00fba7 fd87          .dw XT_TO_BODY
00fba8 f547          .dw XT_STATE
00fba9 f08b          .dw XT_FETCH
00fbaa f03f          .dw XT_DOCONDBRANCH
00fbab fbb6          DEST(PFA_TO1)
00fbac 01e8          .dw XT_COMPILE
00fbad fbb0          .dw XT_DOTO
00fbae 01f3          .dw XT_COMMA
00fbaf f026          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
00fbb0 f001          .dw DO_COLON
                 PFA_DOTO:
                 .endif
00fbb1 f108          .dw XT_R_FROM
00fbb2 f0c3          .dw XT_DUP
00fbb3 fbc2          .dw XT_ICELLPLUS
00fbb4 f111          .dw XT_TO_R
00fbb5 f3d9          .dw XT_FETCHI
                 PFA_TO1:
00fbb6 f0c3          .dw XT_DUP
00fbb7 fbc2          .dw XT_ICELLPLUS
00fbb8 fbc2          .dw XT_ICELLPLUS
00fbb9 f3d9          .dw XT_FETCHI
00fbba f030          .dw XT_EXECUTE
00fbbb f026          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
00fbbc ff07          .dw $FF07
00fbbd 2d69
00fbbe 6563
00fbbf 6c6c
00fbc0 002b          .db "i-cell+",0
00fbc1 fba2          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
00fbc2 f001          .dw DO_COLON
                 PFA_ICELLPLUS:
00fbc3 f241          .dw XT_1PLUS
00fbc4 f026          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
00fbc5 ff07          .dw $ff07
00fbc6 6445
00fbc7 6665
00fbc8 7265
00fbc9 0040          .db "Edefer@",0
00fbca fbbc          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
00fbcb f001          .dw DO_COLON
                 PFA_EDEFERFETCH:
00fbcc f3d9          .dw XT_FETCHI
00fbcd f367          .dw XT_FETCHE
00fbce f026          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
00fbcf ff07          .dw $ff07
00fbd0 6445
00fbd1 6665
00fbd2 7265
00fbd3 0021          .db "Edefer!",0
00fbd4 fbc5          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
00fbd5 f001          .dw DO_COLON
                 PFA_EDEFERSTORE:
00fbd6 f3d9          .dw XT_FETCHI
00fbd7 f343          .dw XT_STOREE
00fbd8 f026          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
00fbd9 ff07          .dw $ff07
00fbda 6452
00fbdb 6665
00fbdc 7265
00fbdd 0040          .db "Rdefer@",0
00fbde fbcf          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
00fbdf f001          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
00fbe0 f3d9          .dw XT_FETCHI
00fbe1 f08b          .dw XT_FETCH
00fbe2 f026          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
00fbe3 ff07          .dw $ff07
00fbe4 6452
00fbe5 6665
00fbe6 7265
00fbe7 0021          .db "Rdefer!",0
00fbe8 fbd9          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
00fbe9 f001          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
00fbea f3d9          .dw XT_FETCHI
00fbeb f093          .dw XT_STORE
00fbec f026          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
00fbed ff07          .dw $ff07
00fbee 6455
00fbef 6665
00fbf0 7265
00fbf1 0040          .db "Udefer@",0
00fbf2 fbe3          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
00fbf3 f001          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
00fbf4 f3d9          .dw XT_FETCHI
00fbf5 f314          .dw XT_UP_FETCH
00fbf6 f1af          .dw XT_PLUS
00fbf7 f08b          .dw XT_FETCH
00fbf8 f026          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
00fbf9 ff07          .dw $ff07
00fbfa 6455
00fbfb 6665
00fbfc 7265
00fbfd 0021          .db "Udefer!",0
00fbfe fbed          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
00fbff f001          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
00fc00 f3d9          .dw XT_FETCHI
00fc01 f314          .dw XT_UP_FETCH
00fc02 f1af          .dw XT_PLUS
00fc03 f093          .dw XT_STORE
00fc04 f026          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
00fc05 ff06          .dw $ff06
00fc06 6564
00fc07 6566
00fc08 2172          .db "defer!"
00fc09 fbf9          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
00fc0a f001          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
00fc0b fd87          .dw XT_TO_BODY
00fc0c f0c3          .dw XT_DUP
00fc0d fbc2          .dw XT_ICELLPLUS
00fc0e fbc2          .dw XT_ICELLPLUS
00fc0f f3d9          .dw XT_FETCHI
00fc10 f030          .dw XT_EXECUTE
00fc11 f026          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
00fc12 ff06          .dw $ff06
00fc13 6564
00fc14 6566
00fc15 4072          .db "defer@"
00fc16 fc05          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
00fc17 f001          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
00fc18 fd87          .dw XT_TO_BODY 
00fc19 f0c3          .dw XT_DUP
00fc1a fbc2          .dw XT_ICELLPLUS
00fc1b f3d9          .dw XT_FETCHI
00fc1c f030          .dw XT_EXECUTE
00fc1d f026          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
00fc1e ff07          .dw $ff07
00fc1f 6428
00fc20 6665
00fc21 7265
00fc22 0029          .db "(defer)", 0
00fc23 fc12          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
00fc24 f001          .dw DO_COLON
                 PFA_DODEFER:
00fc25 01ba          .dw XT_DOCREATE
00fc26 0325          .dw XT_REVEAL
00fc27 01e8          .dw XT_COMPILE
00fc28 fc2a          .dw PFA_DODEFER1
00fc29 f026          .dw XT_EXIT
                 PFA_DODEFER1:
00fc2a 940e 033e     call_ DO_DODOES
00fc2c f0c3          .dw XT_DUP
00fc2d fbc2          .dw XT_ICELLPLUS
00fc2e f3d9          .dw XT_FETCHI
00fc2f f030          .dw XT_EXECUTE 
00fc30 f030          .dw XT_EXECUTE
00fc31 f026          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
00fc32 ff0f          .dw $ff0f
00fc33 6573
00fc34 7261
00fc35 6863
00fc36 772d
00fc37 726f
00fc38 6c64
00fc39 7369
00fc3a 0074          .db "search-wordlist",0
00fc3b fc1e          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
00fc3c f001          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
00fc3d f111          .dw XT_TO_R
00fc3e f166          .dw XT_ZERO
00fc3f f046          .dw XT_DOLITERAL
00fc40 fc51          .dw XT_ISWORD
00fc41 f108          .dw XT_R_FROM
00fc42 fc6e          .dw XT_TRAVERSEWORDLIST
00fc43 f0c3          .dw XT_DUP
00fc44 f12a          .dw XT_ZEROEQUAL
00fc45 f03f          .dw XT_DOCONDBRANCH
00fc46 fc4b          DEST(PFA_SEARCH_WORDLIST1)
00fc47 f56a             .dw XT_2DROP
00fc48 f0eb             .dw XT_DROP
00fc49 f166             .dw XT_ZERO
00fc4a f026             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
00fc4b f0c3            .dw XT_DUP
00fc4c fc95            .dw XT_NFA2CFA
                       ; .. and get the header flag
00fc4d f0d6            .dw XT_SWAP
00fc4e 0195            .dw XT_NAME2FLAGS
00fc4f 0183            .dw XT_IMMEDIATEQ
00fc50 f026          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
00fc51 f001          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
00fc52 f111          .dw XT_TO_R
00fc53 f0eb          .dw XT_DROP
00fc54 f561          .dw XT_2DUP
00fc55 f118          .dw XT_R_FETCH  ; -- addr len addr len nt
00fc56 fc89          .dw XT_NAME2STRING
00fc57 fc9f          .dw XT_ICOMPARE      ; (-- addr len f )
00fc58 f03f          .dw XT_DOCONDBRANCH
00fc59 fc5f          DEST(PFA_ISWORD3)
                       ; not now
00fc5a f108            .dw XT_R_FROM
00fc5b f0eb            .dw XT_DROP
00fc5c f166            .dw XT_ZERO
00fc5d f15d            .dw XT_TRUE         ; maybe next word
00fc5e f026            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
00fc5f f56a            .dw XT_2DROP
00fc60 f108            .dw XT_R_FROM
00fc61 f166            .dw XT_ZERO       ; finish traverse-wordlist
00fc62 f026            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
00fc63 ff11          .dw $ff11
00fc64 7274
00fc65 7661
00fc66 7265
00fc67 6573
00fc68 772d
00fc69 726f
00fc6a 6c64
00fc6b 7369
00fc6c 0074          .db "traverse-wordlist",0
00fc6d fc32          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
00fc6e f001          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
00fc6f f367          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
00fc70 f0c3          .dw XT_DUP           ; ( -- xt nt nt )
00fc71 f03f          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
00fc72 fc7f          DEST(PFA_TRAVERSEWORDLIST2)
00fc73 f561          .dw XT_2DUP
00fc74 f326          .dw XT_2TO_R
00fc75 f0d6          .dw XT_SWAP
00fc76 f030          .dw XT_EXECUTE
00fc77 f335          .dw XT_2R_FROM
00fc78 f0f3          .dw XT_ROT
00fc79 f03f          .dw XT_DOCONDBRANCH
00fc7a fc7f          DEST(PFA_TRAVERSEWORDLIST2)
00fc7b 049e          .dw XT_NFA2LFA
00fc7c f3d9          .dw XT_FETCHI
00fc7d f035          .dw XT_DOBRANCH      ; ( -- addr )
00fc7e fc70          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
00fc7f f56a          .dw XT_2DROP
00fc80 f026          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' )
                 ;        begin @ dup
                 ;        while
                 ;          2dup 2>r
                 ;          swap execute ( i*x nt -- i*x' f )
                 ;          2r> rot
                 ;        while
                 ;          nfa>lfa @i
                 ;        repeat then 2drop ;
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
00fc81 ff0b          .dw $ff0b
00fc82 616e
00fc83 656d
00fc84 733e
00fc85 7274
00fc86 6e69
00fc87 0067          .db "name>string",0
00fc88 fc63          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
00fc89 f001          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
00fc8a f7c8          .dw XT_ICOUNT   ; ( -- addr n )
00fc8b f046          .dw XT_DOLITERAL
00fc8c 00ff          .dw 255
00fc8d f225          .dw XT_AND      ; mask immediate bit
00fc8e f026          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
00fc8f ff07          .dw $ff07
00fc90 666e
00fc91 3e61
00fc92 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
00fc93 0061          .db "nfa>cfa"
00fc94 fc81          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
00fc95 f001          .dw DO_COLON
                 PFA_NFA2CFA:
00fc96 049e          .dw XT_NFA2LFA ; skip to link field
00fc97 f241          .dw XT_1PLUS   ; next is the execution token
00fc98 f026          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
00fc99 ff08          .dw $ff08
00fc9a 6369
00fc9b 6d6f
00fc9c 6170
00fc9d 6572          .db "icompare"
00fc9e fc8f          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
00fc9f f001          .dw DO_COLON
                 PFA_ICOMPARE:
00fca0 f111          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
00fca1 f0e1          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
00fca2 f108          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
00fca3 f123          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
00fca4 f03f          .dw XT_DOCONDBRANCH
00fca5 fcaa          .dw PFA_ICOMPARE_SAMELEN
00fca6 f56a            .dw XT_2DROP
00fca7 f0eb            .dw XT_DROP
00fca8 f15d            .dw XT_TRUE
00fca9 f026            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
00fcaa f0d6          .dw XT_SWAP ; ( -- r-addr f-addr len )
00fcab f166          .dw XT_ZERO
00fcac 02b2          .dw XT_QDOCHECK
00fcad f03f          .dw XT_DOCONDBRANCH
00fcae fccd          .dw PFA_ICOMPARE_DONE
00fcaf f2ad          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
00fcb0 f0e1          .dw XT_OVER
00fcb1 f08b          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
00fcb2 f0e1          .dw XT_OVER
00fcb3 f3d9          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
00fcb4 f0c3          .dw XT_DUP
                     ;.dw XT_BYTESWAP
00fcb5 f046          .dw XT_DOLITERAL
00fcb6 0100          .dw $100
00fcb7 f16e          .dw XT_ULESS
00fcb8 f03f          .dw XT_DOCONDBRANCH
00fcb9 fcbe          .dw PFA_ICOMPARE_LASTCELL
00fcba f0d6          .dw XT_SWAP
00fcbb f046          .dw XT_DOLITERAL
00fcbc 00ff          .dw $00FF
00fcbd f225          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
00fcbe f123          .dw XT_NOTEQUAL
00fcbf f03f          .dw XT_DOCONDBRANCH
00fcc0 fcc5          .dw PFA_ICOMPARE_NEXTLOOP
00fcc1 f56a          .dw XT_2DROP
00fcc2 f15d          .dw XT_TRUE
00fcc3 f2e6          .dw XT_UNLOOP
00fcc4 f026          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
00fcc5 f241          .dw XT_1PLUS
00fcc6 f0d6          .dw XT_SWAP
00fcc7 f55a          .dw XT_CELLPLUS
00fcc8 f0d6          .dw XT_SWAP
00fcc9 f046          .dw XT_DOLITERAL
00fcca 0002          .dw 2
00fccb f2cc          .dw XT_DOPLUSLOOP
00fccc fcb0          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
00fccd f56a          .dw XT_2DROP
00fcce f166          .dw XT_ZERO
00fccf f026          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
00fcd0 ff01          .dw $ff01
00fcd1 002a          .db "*",0
00fcd2 fc99          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
00fcd3 f001          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
00fcd4 f1b8          .dw XT_MSTAR
00fcd5 f0eb          .dw XT_DROP
00fcd6 f026          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
00fcd7 ff01          .dw $FF01
00fcd8 006a          .db "j",0
00fcd9 fcd0          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
00fcda f001          .dw DO_COLON
                 PFA_J:
00fcdb f288          .dw XT_RP_FETCH
00fcdc f046          .dw XT_DOLITERAL
00fcdd 0007          .dw 7
00fcde f1af          .dw XT_PLUS
00fcdf f08b          .dw XT_FETCH
00fce0 f288          .dw XT_RP_FETCH
00fce1 f046          .dw XT_DOLITERAL
00fce2 0009          .dw 9
00fce3 f1af          .dw XT_PLUS
00fce4 f08b          .dw XT_FETCH
00fce5 f1af          .dw XT_PLUS
00fce6 f026          .dw XT_EXIT
                 
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
00fce7 ff04          .dw $ff04
00fce8 6164
00fce9 7362          .db "dabs"
00fcea fcd7          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
00fceb f001          .dw DO_COLON
                 PFA_DABS:
00fcec f0c3          .dw XT_DUP
00fced f131          .dw XT_ZEROLESS
00fcee f03f          .dw XT_DOCONDBRANCH
00fcef fcf1          .dw PFA_DABS1
00fcf0 fcf8          .dw XT_DNEGATE
                 PFA_DABS1:
00fcf1 f026          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
00fcf2 ff07          .dw $ff07
00fcf3 6e64
00fcf4 6765
00fcf5 7461
00fcf6 0065          .db "dnegate",0
00fcf7 fce7          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
00fcf8 f001          .dw DO_COLON
                 PFA_DNEGATE:
00fcf9 f46d          .dw XT_DINVERT
00fcfa f3f8          .dw XT_ONE
00fcfb f166          .dw XT_ZERO
00fcfc f447          .dw XT_DPLUS
00fcfd f026          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
00fcfe ff05          .dw $ff05
00fcff 6d63
00fd00 766f
00fd01 0065          .db "cmove",0
00fd02 fcf2          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
00fd03 fd04          .dw PFA_CMOVE
                 PFA_CMOVE:
00fd04 93bf          push xh
00fd05 93af          push xl
00fd06 91e9          ld zl, Y+
00fd07 91f9          ld zh, Y+ ; addr-to
00fd08 91a9          ld xl, Y+
00fd09 91b9          ld xh, Y+ ; addr-from
00fd0a 2f09          mov temp0, tosh
00fd0b 2b08          or temp0, tosl
00fd0c f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
00fd0d 911d          ld temp1, X+
00fd0e 9311          st Z+, temp1
00fd0f 9701          sbiw tosl, 1
00fd10 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
00fd11 91af          pop xl
00fd12 91bf          pop xh
00fd13 9189
00fd14 9199          loadtos
00fd15 940c f005     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
00fd17 ff05          .dw $ff05
00fd18 7332
00fd19 6177
00fd1a 0070          .db "2swap",0
00fd1b fcfe          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
00fd1c f001          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
00fd1d f0f3          .dw XT_ROT
00fd1e f111          .dw XT_TO_R
00fd1f f0f3          .dw XT_ROT
00fd20 f108          .dw XT_R_FROM
00fd21 f026          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System
                 ; refills the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILLTIB:
00fd22 ff0a          .dw $ff0a
00fd23 6572
00fd24 6966
00fd25 6c6c
00fd26 742d
00fd27 6269          .db "refill-tib"
00fd28 fd17          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
00fd29 f001          .dw DO_COLON
                 PFA_REFILLTIB:
                 .endif
00fd2a fd45          .dw XT_TIB
00fd2b f046          .dw XT_DOLITERAL
00fd2c 005a          .dw TIB_SIZE
00fd2d f88a          .dw XT_ACCEPT
00fd2e fd4b          .dw XT_NUMBERTIB
00fd2f f093          .dw XT_STORE
00fd30 f166          .dw XT_ZERO
00fd31 f57a          .dw XT_TO_IN
00fd32 f093          .dw XT_STORE
00fd33 f15d          .dw XT_TRUE ; -1
00fd34 f026          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCETIB:
00fd35 ff0a          .dw $FF0A
00fd36 6f73
00fd37 7275
00fd38 6563
00fd39 742d
00fd3a 6269          .db "source-tib"
00fd3b fd22          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
00fd3c f001          .dw DO_COLON
                 PFA_SOURCETIB:
                 .endif
00fd3d fd45          .dw XT_TIB
00fd3e fd4b          .dw XT_NUMBERTIB
00fd3f f08b          .dw XT_FETCH
00fd40 f026          .dw XT_EXIT
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; terminal input buffer address
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TIB:
00fd41 ff03          .dw $ff03
00fd42 6974
00fd43 0062          .db "tib",0
00fd44 fd35          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
00fd45 f054          .dw PFA_DOVARIABLE
                 PFA_TIB:
00fd46 0171          .dw ram_tib
                 .dseg
000171           ram_tib: .byte TIB_SIZE
                 .cseg
                 .endif
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBERTIB:
00fd47 ff04          .dw $ff04
00fd48 7423
00fd49 6269          .db "#tib"
00fd4a fd41          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
00fd4b f054          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
00fd4c 01cb          .dw ram_sharptib
                 .dseg
0001cb           ram_sharptib: .byte 2
                 .cseg
                 .endif
                 
                 .include "words/init-ram.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
00fd4d ff06        .dw $ff06
00fd4e 6565
00fd4f 723e
00fd50 6d61        .db "ee>ram"
00fd51 fd47        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
00fd52 f001        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
00fd53 f166          .dw XT_ZERO
00fd54 f2ad          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
00fd55 f0e1          .dw XT_OVER
00fd56 f367          .dw XT_FETCHE
00fd57 f0e1          .dw XT_OVER
00fd58 f093          .dw XT_STORE
00fd59 f55a          .dw XT_CELLPLUS
00fd5a f0d6          .dw XT_SWAP
00fd5b f55a          .dw XT_CELLPLUS
00fd5c f0d6          .dw XT_SWAP
00fd5d f2db          .dw XT_DOLOOP
00fd5e fd55          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
00fd5f f56a          .dw XT_2DROP
00fd60 f026          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INIT_RAM:
00fd61 ff08        .dw $ff08
00fd62 6e69
00fd63 7469
00fd64 722d
00fd65 6d61        .db "init-ram"
00fd66 fd4d        .dw VE_HEAD
                   .set VE_HEAD = VE_INIT_RAM
                 XT_INIT_RAM:
00fd67 f001        .dw DO_COLON
                 PFA_INI_RAM:          ; ( -- )
00fd68 f046          .dw XT_DOLITERAL
00fd69 007c          .dw EE_INITUSER
00fd6a f314          .dw XT_UP_FETCH
00fd6b f046          .dw XT_DOLITERAL
00fd6c 0024          .dw SYSUSERSIZE
00fd6d f216          .dw XT_2SLASH
00fd6e fd52          .dw XT_EE2RAM
00fd6f f026          .dw XT_EXIT
                 
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
00fd70 ff06          .dw $ff06
00fd71 6f62
00fd72 6e75
00fd73 7364          .db "bounds"
00fd74 fd61          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
00fd75 f001          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
00fd76 f0e1          .dw XT_OVER
00fd77 f1af          .dw XT_PLUS
00fd78 f0d6          .dw XT_SWAP
00fd79 f026          .dw XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
00fd7a ff03          .dw $ff03
00fd7b 3e73
00fd7c 0064          .db "s>d",0
00fd7d fd70          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
00fd7e f001          .dw DO_COLON
                 PFA_S2D:
                 .endif
00fd7f f0c3          .dw XT_DUP
00fd80 f131          .dw XT_ZEROLESS
00fd81 f026          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
00fd82 ff05          .dw $ff05
00fd83 623e
00fd84 646f
00fd85 0079          .db ">body",0
00fd86 fd7a          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
00fd87 f242          .dw PFA_1PLUS
                 
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .endif
                 .include "dict/interrupt.inc"
                 
                 .if WANT_INTERRUPTS == 1
                 
                 .if WANT_INTERRUPT_COUNTERS == 1
                   .include "words/irqcnt.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_IRQCNTADDR:
00fd88 ff06          .dw $ff06
00fd89 7269
00fd8a 5b71
00fd8b 235d          .db "irq[]#"
00fd8c fd82          .dw VE_HEAD
                     .set VE_HEAD = VE_IRQCNTADDR
                 XT_IRQCNTADDR:
00fd8d f001          .dw DO_COLON
                 PFA_IRQCNTADDR:
00fd8e f046          .dw XT_DOLITERAL
00fd8f 0112          .dw intcnt
00fd90 f1af          .dw XT_PLUS
00fd91 f026          .dw XT_EXIT
                   .include "words/int-num.asm"
                 
                 ; Interrupt
                 ; number of interrupt vectors (0 based)
                 VE_NUMINT:
00fd92 ff04          .dw $ff04
00fd93 6923
00fd94 746e          .db "#int"
00fd95 fd88          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMINT
                 XT_NUMINT:
00fd96 f054          .dw PFA_DOVARIABLE
                 PFA_NUMINT:
00fd97 0023          .dw INTVECTORS
                 .endif
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
00fd98 ff04          .dw $ff04
00fd99 692b
00fd9a 746e          .db "+int"
00fd9b fd92          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
00fd9c fd9d          .dw PFA_INTON
                 PFA_INTON:
00fd9d 9478          sei
00fd9e 940c f005     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
00fda0 ff04          .dw $ff04
00fda1 692d
00fda2 746e          .db "-int"
00fda3 fd98          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
00fda4 fda5          .dw PFA_INTOFF
                 PFA_INTOFF:
00fda5 94f8          cli
00fda6 940c f005     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
00fda8 ff04          .dw $ff04
00fda9 6e69
00fdaa 2174          .db "int!"
00fdab fda0          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
00fdac f001          .dw DO_COLON
                 PFA_INTSTORE:
00fdad f046          .dw XT_DOLITERAL
00fdae 0000          .dw intvec
00fdaf f1af          .dw XT_PLUS
00fdb0 f343          .dw XT_STOREE
00fdb1 f026          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
00fdb2 ff04          .dw $ff04
00fdb3 6e69
00fdb4 4074          .db "int@"
00fdb5 fda8          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
00fdb6 f001          .dw DO_COLON
                 PFA_INTFETCH:
00fdb7 f046          .dw XT_DOLITERAL
00fdb8 0000          .dw intvec
00fdb9 f1af          .dw XT_PLUS
00fdba f367          .dw XT_FETCHE
00fdbb f026          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
00fdbc ff08          .dw $ff08
00fdbd 6e69
00fdbe 2d74
00fdbf 7274
00fdc0 7061          .db "int-trap"
00fdc1 fdb2          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
00fdc2 fdc3          .dw PFA_INTTRAP
                 PFA_INTTRAP:
00fdc3 2eb8          mov isrflag, tosl
00fdc4 9189
00fdc5 9199          loadtos
00fdc6 940c f005     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
00fdc8 f001          .dw DO_COLON
                 PFA_ISREXEC:
00fdc9 fdb6          .dw XT_INTFETCH
00fdca f030          .dw XT_EXECUTE
00fdcb fdcd          .dw XT_ISREND
00fdcc f026          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
00fdcd fdce          .dw PFA_ISREND
                 PFA_ISREND:
00fdce d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
00fdcf 940c f005     jmp_ DO_NEXT
                 PFA_ISREND1:
00fdd1 9518          reti
                 .endif
                 .elif AMFORTH_NRWW_SIZE>4000
                 .elif AMFORTH_NRWW_SIZE>2000
                 .else
                 .endif
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000046 ff ff     
                 ; some configs
000048 84 05     CFG_DP:      .dw DPSTART         ; Dictionary Pointer
00004a cd 01     EE_HERE:     .dw HERESTART       ; Memory Allocation
00004c a2 00     EE_EHERE:    .dw EHERESTART      ; EEProm Memory Allocation
00004e 5a 04     CFG_WLSCOPE: .dw XT_GET_CURRENT  ; default wordlist scope
000050 6e 00     CFG_FORTHRECOGNIZER: .dw CFG_RECOGNIZERLISTLEN ; Recognizer word set
                 ; LEAVE stack is between data stack and return stack.
000052 b0 40     CFG_LP0:     .dw stackstart+1
000054 00 05     CFG_TURNKEY: .dw XT_APPLTURNKEY    ; TURNKEY
000056 2e f5     CFG_ENVIRONMENT:.dw VE_ENVHEAD     ; environmental queries
000058 5a 00     CFG_CURRENT: .dw CFG_FORTHWORDLIST ; forth-wordlist
00005a bc fd     CFG_FORTHWORDLIST:.dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
00005c 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
00005e 5a 00         .dw CFG_FORTHWORDLIST      ; get/set-order
000060               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
00006e 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
000070 37 fb         .dw XT_REC_FIND
000072 23 fb         .dw XT_REC_NUM
000074               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_STOREI:
000078 86 f3         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
00007a 7a 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
00007c 00 00         .dw 0  ; USER_STATE
00007e 00 00         .dw 0  ; USER_FOLLOWER
000080 ff 40         .dw rstackstart  ; USER_RP
000082 af 40         .dw stackstart   ; USER_SP0
000084 af 40         .dw stackstart   ; USER_SP
                     
000086 00 00         .dw 0  ; USER_HANDLER
000088 0a 00         .dw 10 ; USER_BASE
                     
00008a b6 00         .dw XT_TX  ; USER_EMIT
00008c c4 00         .dw XT_TXQ ; USER_EMITQ
00008e 8b 00         .dw XT_RX  ; USER_KEY
000090 a6 00         .dw XT_RXQ ; USER_KEYQ
000092 3c fd         .dw XT_SOURCETIB ; USER_SOURCE
000094 00 00         .dw 0            ; USER_G_IN
000096 29 fd         .dw XT_REFILLTIB ; USER_REFILL  
000098 f0 f9         .dw XT_DEFAULT_PROMPTOK
00009a 0f fa         .dw XT_DEFAULT_PROMPTERROR
00009c ff f9         .dw XT_DEFAULT_PROMPTREADY
00009e 2a fa         .dw XT_DEFAULT_PROMPTINPUT
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
0000a0 19 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega1284P" register use summary:
r0 :  25 r1 :   5 r2 :  11 r3 :  12 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   7 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  89 r17:  61 r18:  61 r19:  37 r20:  13 r21:  38 r22:  11 r23:   3 
r24: 212 r25: 144 r26:  28 r27:  17 r28:   7 r29:   4 r30:  90 r31:  49 
x  :   4 y  : 215 z  :  50 
Registers used: 29 out of 35 (82.9%)

"ATmega1284P" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  22 add   :  17 adiw  :  17 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   3 brcs  :   1 break :   0 breq  :   7 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  22 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   7 cbr   :   1 
clc   :   2 clh   :   0 cli   :   7 cln   :   0 clr   :  23 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  14 cp    :  11 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :  10 elpm  :  16 eor   :   3 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :  25 inc   :   3 
jmp   :  19 ld    : 143 ldd   :   4 ldi   :  41 lds   :   1 lpm   :   0 
lsl   :  14 lsr   :   2 mov   :  16 movw  :  73 mul   :   5 muls  :   1 
mulsu :   2 neg   :   0 nop   :   0 or    :   9 ori   :   2 out   :  31 
pop   :  49 push  :  43 rcall :  48 ret   :   7 reti  :   1 rjmp  : 101 
rol   :  32 ror   :   6 sbc   :   9 sbci  :   3 sbi   :   8 sbic  :   3 
sbis  :   0 sbiw  :  16 sbr   :   0 sbrc  :   5 sbrs  :   7 sec   :   1 
seh   :   0 sei   :   1 sen   :   0 ser   :   4 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   2 st    :  81 std   :   8 
sts   :   1 sub   :   6 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 

Instructions used: 73 out of 114 (64.0%)

"ATmega1284P" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x01fba4   2170  14736  16906  131072  12.9%
[.dseg] 0x000100 0x0001cd      0    205    205   16384   1.3%
[.eseg] 0x000000 0x0000a2      0    162    162    4096   4.0%

Assembly complete, 0 errors, 8 warnings
