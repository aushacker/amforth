
AVRASM ver. 2.1.52  p644-16.asm Sun Oct 18 18:22:44 2020

p644-16.asm(5): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega644\device.asm'
../../avr8/devices/atmega644\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m644def.inc'
p644-16.asm(14): Including file '../../avr8\drivers/usart_0.asm'
../../avr8\drivers/usart_0.asm(32): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(11): Including file '../../avr8\drivers/usart-rx-buffer.asm'
../../avr8\drivers/usart_common.asm(24): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(29): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(30): Including file '../../avr8\words/usart.asm'
p644-16.asm(19): Including file '../../avr8\drivers/1wire.asm'
p644-16.asm(21): Including file '../../avr8\amforth.asm'
../../avr8\amforth.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth.asm(14): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(7): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/rww.inc(10): Including file '../../avr8\dict/appl_8k.inc'
../../avr8\dict/appl_8k.inc(1): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/newest.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/do-create.asm'
../../avr8\dict/compiler1.inc(5): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(9): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(10): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(17): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(33): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(38): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../common\words/create.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../common\words/reveal.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(53): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../common\words/recurse.asm'
../../avr8\dict/compiler1.inc(56): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(61): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(67): Including file '../../common\words/cfg-order.asm'
../../avr8\dict/compiler1.inc(68): Including file '../../common\words/cfg-recognizer.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(70): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(3): Including file '../../common\words/dot-s.asm'
dict_appl.inc(4): Including file '../../avr8\words/spirw.asm'
dict_appl.inc(5): Including file '../../avr8\words/n-spi.asm'
dict_appl.inc(6): Including file 'words/applturnkey.asm'
dict_appl.inc(7): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../common\words/postpone.asm'
dict_appl.inc(8): Including file '../../avr8\words/2r_fetch.asm'
../../avr8\amforth.asm(23): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth.asm(24): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(35): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(36): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(42): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(45): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(46): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(49): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(56): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(63): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../common\words/q-negate.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(89): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(95): Including file '../../avr8\words/store-i_nrww.asm'
../../avr8\dict/nrww.inc(97): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(98): Including file '../../common\words/2literal.asm'
../../avr8\dict/nrww.inc(99): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(100): Including file '../../common\words/num-constants.asm'
../../avr8\dict/nrww.inc(103): Including file '../../avr8\dict/core_8k.inc'
../../avr8\dict/core_8k.inc(2): Including file '../../avr8\words/n_to_r.asm'
../../avr8\dict/core_8k.inc(3): Including file '../../avr8\words/n_r_from.asm'
../../avr8\dict/core_8k.inc(5): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/core_8k.inc(6): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/core_8k.inc(7): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/core_8k.inc(8): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/core_8k.inc(9): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/core_8k.inc(10): Including file '../../common\words/u-dot.asm'
../../avr8\dict/core_8k.inc(11): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/core_8k.inc(13): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/core_8k.inc(14): Including file '../../common\words/words.asm'
../../avr8\dict/core_8k.inc(17): Including file '../../common\words/pick.asm'
../../avr8\dict/core_8k.inc(18): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/core_8k.inc(19): Including file '../../common\words/squote.asm'
../../avr8\dict/core_8k.inc(21): Including file '../../avr8\words/fill.asm'
../../avr8\dict/core_8k.inc(23): Including file '../../avr8\words/environment.asm'
../../avr8\dict/core_8k.inc(24): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/core_8k.inc(25): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/core_8k.inc(26): Including file '../../common\words/env-slashhold.asm'
../../avr8\dict/core_8k.inc(27): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/core_8k.inc(28): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/core_8k.inc(29): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/core_8k.inc(30): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/core_8k.inc(31): Including file '../../common\words/env-usersize.asm'
../../avr8\dict/core_8k.inc(33): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/core_8k.inc(34): Including file '../../avr8\words/state.asm'
../../avr8\dict/core_8k.inc(35): Including file '../../common\words/base.asm'
../../avr8\dict/core_8k.inc(37): Including file '../../avr8\words/cells.asm'
../../avr8\dict/core_8k.inc(38): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/core_8k.inc(40): Including file '../../common\words/2dup.asm'
../../avr8\dict/core_8k.inc(41): Including file '../../common\words/2drop.asm'
../../avr8\dict/core_8k.inc(43): Including file '../../common\words/tuck.asm'
../../avr8\dict/core_8k.inc(45): Including file '../../common\words/to-in.asm'
../../avr8\dict/core_8k.inc(46): Including file '../../common\words/pad.asm'
../../avr8\dict/core_8k.inc(47): Including file '../../common\words/emit.asm'
../../avr8\dict/core_8k.inc(48): Including file '../../common\words/emitq.asm'
../../avr8\dict/core_8k.inc(49): Including file '../../common\words/key.asm'
../../avr8\dict/core_8k.inc(50): Including file '../../common\words/keyq.asm'
../../avr8\dict/core_8k.inc(52): Including file '../../avr8\words/dp.asm'
../../avr8\dict/core_8k.inc(53): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/core_8k.inc(54): Including file '../../avr8\words/here.asm'
../../avr8\dict/core_8k.inc(55): Including file '../../avr8\words/allot.asm'
../../avr8\dict/core_8k.inc(57): Including file '../../common\words/bin.asm'
../../avr8\dict/core_8k.inc(58): Including file '../../common\words/decimal.asm'
../../avr8\dict/core_8k.inc(59): Including file '../../common\words/hex.asm'
../../avr8\dict/core_8k.inc(60): Including file '../../common\words/bl.asm'
../../avr8\dict/core_8k.inc(62): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/core_8k.inc(64): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/core_8k.inc(65): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/core_8k.inc(66): Including file '../../avr8\words/negate.asm'
../../avr8\dict/core_8k.inc(67): Including file '../../common\words/slash.asm'
../../avr8\dict/core_8k.inc(68): Including file '../../common\words/mod.asm'
../../avr8\dict/core_8k.inc(69): Including file '../../common\words/abs.asm'
../../avr8\dict/core_8k.inc(70): Including file '../../common\words/min.asm'
../../avr8\dict/core_8k.inc(71): Including file '../../common\words/max.asm'
../../avr8\dict/core_8k.inc(72): Including file '../../common\words/within.asm'
../../avr8\dict/core_8k.inc(74): Including file '../../common\words/to-upper.asm'
../../avr8\dict/core_8k.inc(75): Including file '../../common\words/to-lower.asm'
../../avr8\dict/core_8k.inc(77): Including file '../../avr8\words/hld.asm'
../../avr8\dict/core_8k.inc(78): Including file '../../common\words/hold.asm'
../../avr8\dict/core_8k.inc(79): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/core_8k.inc(80): Including file '../../common\words/sharp.asm'
../../avr8\dict/core_8k.inc(81): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/core_8k.inc(82): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/core_8k.inc(83): Including file '../../common\words/sign.asm'
../../avr8\dict/core_8k.inc(84): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/core_8k.inc(85): Including file '../../common\words/dot-r.asm'
../../avr8\dict/core_8k.inc(86): Including file '../../common\words/d-dot.asm'
../../avr8\dict/core_8k.inc(87): Including file '../../common\words/dot.asm'
../../avr8\dict/core_8k.inc(88): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/core_8k.inc(89): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/core_8k.inc(90): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/core_8k.inc(91): Including file '../../common\words/digit-q.asm'
../../avr8\dict/core_8k.inc(93): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/core_8k.inc(94): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/core_8k.inc(95): Including file '../../avr8\words/itype.asm'
../../avr8\dict/core_8k.inc(96): Including file '../../avr8\words/icount.asm'
../../avr8\dict/core_8k.inc(97): Including file '../../common\words/cr.asm'
../../avr8\dict/core_8k.inc(98): Including file '../../common\words/space.asm'
../../avr8\dict/core_8k.inc(99): Including file '../../common\words/spaces.asm'
../../avr8\dict/core_8k.inc(100): Including file '../../common\words/type.asm'
../../avr8\dict/core_8k.inc(101): Including file '../../common\words/tick.asm'
../../avr8\dict/core_8k.inc(103): Including file '../../common\words/handler.asm'
../../avr8\dict/core_8k.inc(104): Including file '../../common\words/catch.asm'
../../avr8\dict/core_8k.inc(105): Including file '../../common\words/throw.asm'
../../avr8\dict/core_8k.inc(107): Including file '../../common\words/cskip.asm'
../../avr8\dict/core_8k.inc(108): Including file '../../common\words/cscan.asm'
../../avr8\dict/core_8k.inc(109): Including file '../../common\words/accept.asm'
../../avr8\dict/core_8k.inc(110): Including file '../../common\words/refill.asm'
../../avr8\dict/core_8k.inc(111): Including file '../../common\words/char.asm'
../../avr8\dict/core_8k.inc(112): Including file '../../common\words/number.asm'
../../avr8\dict/core_8k.inc(113): Including file '../../common\words/q-sign.asm'
../../avr8\dict/core_8k.inc(114): Including file '../../common\words/set-base.asm'
../../avr8\dict/core_8k.inc(115): Including file '../../common\words/to-number.asm'
../../avr8\dict/core_8k.inc(116): Including file '../../common\words/parse.asm'
../../avr8\dict/core_8k.inc(117): Including file '../../common\words/source.asm'
../../avr8\dict/core_8k.inc(118): Including file '../../common\words/slash-string.asm'
../../avr8\dict/core_8k.inc(119): Including file '../../common\words/parse-name.asm'
../../avr8\dict/core_8k.inc(120): Including file '../../common\words/find-xt.asm'
../../avr8\dict/core_8k.inc(122): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/core_8k.inc(123): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/core_8k.inc(124): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/core_8k.inc(125): Including file '../../common\words/prompt-input.asm'
../../avr8\dict/core_8k.inc(126): Including file '../../common\words/quit.asm'
../../avr8\dict/core_8k.inc(127): Including file '../../avr8\words/pause.asm'
../../avr8\dict/core_8k.inc(128): Including file '../../avr8\words/cold.asm'
../../avr8\dict/core_8k.inc(129): Including file '../../common\words/warm.asm'
../../avr8\dict/core_8k.inc(131): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/core_8k.inc(132): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/core_8k.inc(133): Including file '../../common\words/depth.asm'
../../avr8\dict/core_8k.inc(134): Including file '../../common\words/interpret.asm'
../../avr8\dict/core_8k.inc(135): Including file '../../avr8\words/forth-recognizer.asm'
../../avr8\dict/core_8k.inc(136): Including file '../../common\words/recognize.asm'
../../avr8\dict/core_8k.inc(137): Including file '../../common\words/rec-intnum.asm'
../../avr8\dict/core_8k.inc(138): Including file '../../common\words/rec-find.asm'
../../avr8\dict/core_8k.inc(139): Including file '../../common\words/rec-null.asm'
../../avr8\dict/core_8k.inc(141): Including file '../../common\words/q-stack.asm'
../../avr8\dict/core_8k.inc(142): Including file '../../common\words/ver.asm'
../../avr8\dict/core_8k.inc(144): Including file '../../common\words/noop.asm'
../../avr8\dict/core_8k.inc(145): Including file '../../avr8\words/unused.asm'
../../avr8\dict/core_8k.inc(147): Including file '../../common\words/to.asm'
../../avr8\dict/core_8k.inc(148): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/core_8k.inc(150): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/core_8k.inc(151): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/core_8k.inc(152): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/core_8k.inc(153): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/core_8k.inc(154): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/core_8k.inc(155): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/core_8k.inc(156): Including file '../../common\words/defer-store.asm'
../../avr8\dict/core_8k.inc(157): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/core_8k.inc(158): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/core_8k.inc(160): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/core_8k.inc(161): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/core_8k.inc(162): Including file '../../common\words/name2string.asm'
../../avr8\dict/core_8k.inc(163): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/core_8k.inc(164): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/core_8k.inc(166): Including file '../../common\words/star.asm'
../../avr8\dict/core_8k.inc(167): Including file '../../avr8\words/j.asm'
../../avr8\dict/core_8k.inc(169): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/core_8k.inc(170): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/core_8k.inc(171): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/core_8k.inc(172): Including file '../../common\words/2swap.asm'
../../avr8\dict/core_8k.inc(174): Including file '../../common\words/tib.asm'
../../avr8\dict/core_8k.inc(176): Including file '../../avr8\words/init-ram.asm'
../../avr8\dict/core_8k.inc(178): Including file '../../common\words/bounds.asm'
../../avr8\dict/core_8k.inc(179): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/core_8k.inc(180): Including file '../../avr8\words/to-body.asm'
../../avr8\dict/core_8k.inc(182): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/core_8k.inc(183): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/irqcnt.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-num.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(10): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(11): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(12): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(13): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(15): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(16): Including file '../../avr8\words/isr-end.asm'
../../avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
../../avr8\amforth.asm(36): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; file see ../template/template.asm. You may want to
                 ; copy that file to this one and edit it afterwards.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set USER_P_OK    = 28
                 .set USER_P_ERR   = 30
                 .set USER_P_RDY   = 32
                 .set USER_P_INPUT = 34
                 
                 .set SYSUSERSIZE = 36
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot = r10
                   .def isrflag  = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  256
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_JTAG = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TWI = 0
                 .set WANT_SPI = 0
                 .set WANT_CPU = 0
                 .equ intvecsize = 2 ; please verify; flash size: 65536 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d12a      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d128      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d126      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d124      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 10
00000a d122      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 12
00000c d120      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 14
00000e d11e      	 rcall isr ; Pin Change Interrupt Request 3
                 .org 16
000010 d11c      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 18
000012 d11a      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 20
000014 d118      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 22
000016 d116      	 rcall isr ; Timer/Counter2 Overflow
                 .org 24
000018 d114      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 26
00001a d112      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 28
00001c d110      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 30
00001e d10e      	 rcall isr ; Timer/Counter1 Overflow
                 .org 32
000020 d10c      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 34
000022 d10a      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 36
000024 d108      	 rcall isr ; Timer/Counter0 Overflow
                 .org 38
000026 d106      	 rcall isr ; SPI Serial Transfer Complete
                 .org 40
000028 d104      	 rcall isr ; USART0, Rx Complete
                 .org 42
00002a d102      	 rcall isr ; USART0 Data register Empty
                 .org 44
00002c d100      	 rcall isr ; USART0, Tx Complete
                 .org 46
00002e d0fe      	 rcall isr ; Analog Comparator
                 .org 48
000030 d0fc      	 rcall isr ; ADC Conversion Complete
                 .org 50
000032 d0fa      	 rcall isr ; EEPROM Ready
                 .org 52
000034 d0f8      	 rcall isr ; 2-wire Serial Interface
                 .org 54
000036 d0f6      	 rcall isr ; Store Program Memory Read
                 .equ INTVECTORS = 28
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000037 1000      	.dw 4096
                 mcu_eepromsize:
000038 0800      	.dw 2048
                 mcu_maxdp:
000039 e000      	.dw 57344 
                 mcu_numints:
00003a 001c      	.dw 28
                 mcu_name:
00003b 0009      	.dw  9
00003c 5441
00003d 656d
00003e 6167
00003f 3436
000040 0034      	.db "ATmega644",0
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 ; enabling Interrupts, disabling them affects
                 ; other settings as well. 
                 .set WANT_INTERRUPTS = 1
                 
                 ; count the number of interrupts individually.
                 ; requires a lot of RAM (one byte per interrupt)
                 ; disabled by default.
                 .set WANT_INTERRUPT_COUNTERS = 1
                 
                 ; receiving is asynchronously, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIB_SIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR+1
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 16000000
                 .set BAUD_MAXERROR = 30
                 .equ TIMER_INT = OVF2addr
                 
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .equ URXCaddr = URXC0addr
                   .equ UDREaddr = UDRE0addr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_INTERRUPTS == 0
                   .if WANT_ISR_RX == 1
                   .endif
                 .endif
                 
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-rx-buffer.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100            usart_rx_data: .byte usart_rx_size
000110            usart_rx_in:   .byte 1
000111            usart_rx_out:  .byte 1
                 .cseg
                 
                 VE_TO_RXBUF:
000041 ff07          .dw $ff07
000042 723e
000043 2d78
000044 7562
000045 0066          .db ">rx-buf",0
000046 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_RXBUF
                 XT_TO_RXBUF:
000047 0048          .dw PFA_rx_tobuf
                 PFA_rx_tobuf:
000048 2f08          mov temp0, tosl
000049 9110 0110     lds temp1, usart_rx_in
00004b e0e0          ldi zl, low(usart_rx_data)
00004c e0f1          ldi zh, high(usart_rx_data)
00004d 0fe1          add zl, temp1
00004e 1df3          adc zh, zeroh
00004f 8300          st Z, temp0
000050 9513          inc temp1
000051 701f          andi temp1,usart_rx_mask
000052 9310 0110     sts usart_rx_in, temp1
000054 9189
000055 9199          loadtos
000056 940c 7005     jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; setup with
                 ; ' isr-rx URXCaddr int!
                 VE_ISR_RX:
000058 ff06          .dw $ff06
000059 7369
00005a 2d72
00005b 7872          .db "isr-rx"
00005c 0041          .dw VE_HEAD
                     .set VE_HEAD = VE_ISR_RX
                 XT_ISR_RX:
00005d 7001          .dw DO_COLON
                 usart_rx_isr:
00005e 703d        .dw XT_DOLITERAL
00005f 00c6        .dw usart_data
000060 7098        .dw XT_CFETCH
000061 70b1        .dw XT_DUP
000062 703d        .dw XT_DOLITERAL
000063 0003        .dw 3
000064 73d6        .dw XT_EQUAL
000065 7036        .dw XT_DOCONDBRANCH
000066 0068        .dw usart_rx_isr1
000067 7a51        .dw XT_COLD
                 usart_rx_isr1:
000068 0047        .dw XT_TO_RXBUF
000069 7020        .dw XT_EXIT
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RXBUFFER:
                 ;  .dw $ff0x
                 ;  .db "+usart-buffer"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RXBUFFER
                 XT_USART_INIT_RX_BUFFER:
00006a 7001        .dw DO_COLON
                 PFA_USART_INIT_RX_BUFFER:          ; ( -- )
00006b 703d
00006c 005d        .dw XT_DOLITERAL, XT_ISR_RX
00006d 703d
00006e 0028        .dw XT_DOLITERAL, URXCaddr
00006f 7d91        .dw XT_INTSTORE
                 
000070 703d        .dw XT_DOLITERAL
000071 0100        .dw usart_rx_data
000072 703d        .dw XT_DOLITERAL
000073 0016        .dw usart_rx_size + 6
000074 7154        .dw XT_ZERO
000075 74b0        .dw XT_FILL
000076 7020        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_BUFFER:
000077 ff06          .dw $ff06
000078 7872
000079 622d
00007a 6675          .db "rx-buf"
00007b 0058          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_BUFFER
                 XT_RX_BUFFER:
00007c 7001          .dw DO_COLON
                 PFA_RX_BUFFER:
00007d 0097        .dw XT_RXQ_BUFFER
00007e 7036        .dw XT_DOCONDBRANCH
00007f 007d        .dw PFA_RX_BUFFER
000080 703d        .dw XT_DOLITERAL
000081 0111        .dw usart_rx_out
000082 7098        .dw XT_CFETCH
000083 70b1        .dw XT_DUP
000084 703d        .dw XT_DOLITERAL
000085 0100        .dw usart_rx_data
000086 719d        .dw XT_PLUS
000087 7098        .dw XT_CFETCH
000088 70c4        .dw XT_SWAP
000089 722f        .dw XT_1PLUS
00008a 703d        .dw XT_DOLITERAL
00008b 000f        .dw usart_rx_mask
00008c 7213        .dw XT_AND
00008d 703d        .dw XT_DOLITERAL
00008e 0111        .dw usart_rx_out
00008f 708d        .dw XT_CSTORE
000090 7020        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue
                 VE_RXQ_BUFFER:
000091 ff07          .dw $ff07
000092 7872
000093 2d3f
000094 7562
000095 0066          .db "rx?-buf",0
000096 0077          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_BUFFER
                 XT_RXQ_BUFFER:
000097 7001          .dw DO_COLON
                 PFA_RXQ_BUFFER:
000098 7a49        .dw XT_PAUSE
000099 703d        .dw XT_DOLITERAL
00009a 0111        .dw usart_rx_out
00009b 7098        .dw XT_CFETCH
00009c 703d        .dw XT_DOLITERAL
00009d 0110        .dw usart_rx_in
00009e 7098        .dw XT_CFETCH
00009f 7111        .dw XT_NOTEQUAL
0000a0 7020        .dw XT_EXIT
                 ;  .include "drivers/timer-usart-isr.asm"
                   .set XT_RX  = XT_RX_BUFFER
                   .set XT_RXQ = XT_RXQ_BUFFER
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_BUFFER
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
0000a1 ff07          .dw $ff07
0000a2 7874
0000a3 702d
0000a4 6c6f
0000a5 006c          .db "tx-poll",0
0000a6 0091          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
0000a7 7001          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
0000a8 00b5        .dw XT_TXQ_POLL
0000a9 7036        .dw XT_DOCONDBRANCH
0000aa 00a8        .dw PFA_TX_POLL
                   ; send to usart
0000ab 703d        .dw XT_DOLITERAL
0000ac 00c6        .dw USART_DATA
0000ad 708d        .dw XT_CSTORE
0000ae 7020        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
0000af ff08          .dw $ff08
0000b0 7874
0000b1 2d3f
0000b2 6f70
0000b3 6c6c          .db "tx?-poll"
0000b4 00a1          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000b5 7001          .dw DO_COLON
                 PFA_TXQ_POLL:
0000b6 7a49        .dw XT_PAUSE
0000b7 703d        .dw XT_DOLITERAL
0000b8 00c0        .dw USART_A
0000b9 7098        .dw XT_CFETCH
0000ba 703d        .dw XT_DOLITERAL
0000bb 0020        .dw bm_USART_TXRD
0000bc 7213        .dw XT_AND
0000bd 7020        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000be ff04        .dw $ff04
0000bf 6275
0000c0 7272        .db "ubrr"
0000c1 00af        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000c2 706f        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000c3 0092        .dw EE_UBRRVAL
0000c4 7bb0        .dw XT_EDEFERFETCH
0000c5 7bba        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000c6 ff06        .dw $ff06
0000c7 752b
0000c8 6173
0000c9 7472        .db "+usart"
0000ca 00be        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000cb 7001        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000cc 703d        .dw XT_DOLITERAL
0000cd 0098        .dw USART_B_VALUE
0000ce 703d        .dw XT_DOLITERAL
0000cf 00c1        .dw USART_B
0000d0 708d        .dw XT_CSTORE
                 
0000d1 703d        .dw XT_DOLITERAL
0000d2 0006        .dw USART_C_VALUE
0000d3 703d        .dw XT_DOLITERAL
0000d4 00c2        .dw USART_C | bm_USARTC_en
0000d5 708d        .dw XT_CSTORE
                 
0000d6 00c2        .dw XT_UBRR
0000d7 70b1        .dw XT_DUP
0000d8 72f9        .dw XT_BYTESWAP
0000d9 703d        .dw XT_DOLITERAL
0000da 00c5        .dw BAUDRATE_HIGH
0000db 708d        .dw XT_CSTORE
0000dc 703d        .dw XT_DOLITERAL
0000dd 00c4        .dw BAUDRATE_LOW
0000de 708d        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
0000df 006a        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
0000e0 7020        .dw XT_EXIT
                 
                 ; settings for 1wire interface
                 .equ OW_PORT=PORTB
                 .EQU OW_BIT=4
                 .include "drivers/1wire.asm"
                 
                 ;   B. J. Rodriguez (MSP 430)
                 ;   Matthias Trute (AVR Atmega)
                 ; COPYRIGHT
                 ;   (c) 2012 Bradford J. Rodriguez for the 430 code and API
                 
                 ;  adapted 430 assembly code to AVR
                 ;  wishlist: 
                 ;     use a configurable pin at runtime, compatible with bitnames.frt
                 ;     no external pull up, no external power supply for devices
                 ;     ???
                 ;
                 ;.EQU OW_BIT=4
                 ;.equ OW_PORT=PORTE
                 .set OW_DDR=(OW_PORT-1)
                 .set OW_PIN=(OW_DDR-1)
                 
                 ;****f* 1W.RESET
                 ; NAME
                 ;   1W.RESET
                 ; SYNOPSIS
                 ;   1W.RESET ( -- f )  Initialize 1-wire devices; return true if present
                 ; DESCRIPTION
                 ;   This configures the port pin used by the 1-wire interface, and then
                 ;   sends an "initialize" sequence to the 1-wire devices.  If any device
                 ;   is present, it will be detected.
                 ;
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" (drive output low) for >480 usec.
                 ;   b) Output "1" (let output float).
                 ;   c) After 15 to 60 usec, device will drive pin low for 60 to 240 usec.
                 ;      So, wait 75 usec and sample input.
                 ;   d) Leave output high (floating) for at least 480 usec.
                 ;******
                 ; ( -- f )
                 ; Hardware
                 ; Initialize 1-wire devices; return true if present
                 VE_OW_RESET:
0000e1 ff08          .dw $ff08
0000e2 7731
0000e3 722e
0000e4 7365
0000e5 7465          .db "1w.reset"
0000e6 00c6          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_RESET
                 XT_OW_RESET:
0000e7 00e8          .dw PFA_OW_RESET
                 PFA_OW_RESET:
0000e8 939a
0000e9 938a          savetos
                     ; setup to output
0000ea 9a24          sbi OW_DDR, OW_BIT
                     ; Pull output low
0000eb 982c          cbi OW_PORT, OW_BIT
                     ; Delay >480 usec        
0000ec e8e0
0000ed e0f7
0000ee 9731
0000ef f7f1          DELAY   480
                     ; Critical timing period, disable interrupts.
0000f0 b71f          in temp1, SREG
0000f1 94f8          cli
                     ; Pull output high
0000f2 9a2c          sbi OW_PORT, OW_BIT
                     ; make pin input, sends "1"
0000f3 9824          cbi OW_DDR, OW_BIT 
0000f4 e0e0
0000f5 e0f1
0000f6 9731
0000f7 f7f1          DELAY   64 ; delayB
                     ; Sample input pin, set TOS if input is zero
0000f8 b183          in tosl, OW_PIN
0000f9 ff84          sbrs tosl, OW_BIT
0000fa ef9f          ser  tosh
                     ; End critical timing period, enable interrupts
0000fb bf1f          out SREG, temp1
                     ; release bus
0000fc 9824          cbi OW_DDR, OW_BIT
0000fd 982c          cbi OW_PORT, OW_BIT
                 
                     ; Delay rest of 480 usec 
0000fe e8e0
0000ff e0f6
000100 9731
000101 f7f1          DELAY   416
                     ; we now have the result flag in TOS        
000102 2f89          mov tosl, tosh
000103 940c 7005     jmp_ DO_NEXT
                     
                 ;****f* 1W.SLOT
                 ; NAME
                 ;   1W.SLOT
                 ; SYNOPSIS
                 ;   1W.SLOT ( c -- c' ) Write and read one bit to/from 1-wire.
                 ; DESCRIPTION
                 ;   The "touch byte" function is described in Dallas App Note 74.
                 ;   It outputs a byte to the 1-wire pin, LSB first, and reads back
                 ;   the state of the 1-wire pin after a suitable delay.
                 ;   To read a byte, output $FF and read the reply data.
                 ;   To write a byte, output that byte and discard the reply.
                 ;
                 ;   This function performs one bit of the "touch" operation --
                 ;   one read/write "slot" in Dallas jargon.  Perform this eight
                 ;   times in a row to get the "touch byte" function.
                 ;
                 ; PARAMETERS
                 ;   The input parameter is xxxxxxxxbbbbbbbo where
                 ;   'xxxxxxxx' are don't cares,
                 ;   'bbbbbbb' are bits to be shifted down, and
                 ;   'o' is the bit to be output in the slot.  This must be 1
                 ;   to create a read slot.
                 ;
                 ;   The returned value is xxxxxxxxibbbbbbb where
                 ;   'xxxxxxxx' are not known (the input shifted down 1 position),
                 ;   'i' is the bit read during the slot.  This has no meaning
                 ;   if it was a write slot.
                 ;   'bbbbbbb' are the 7 input bits, shifted down one position.
                 ;
                 ;   This peculiar parameter usage allows OWTOUCH to be written as
                 ;     OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT 
                 ;
                 ; NOTES 
                 ;   Interrupts are disabled during each bit.
                 
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" for start period.  (> 1 us, < 15 us, typ. 6 us*)
                 ;   b) Output data bit (0 or 1), open drain 
                 ;   c) After MS from start of cycle, sample input (15 to 60 us, typ. 25 us*)
                 ;   d) After write-0 period from start of cycle, output "1" (>60 us)
                 ;   e) After recovery period, loop or return. (> 1 us)
                 ;   For writes, DS18B20 samples input 15 to 60 usec from start of cycle.
                 ;   * "Typical" values are per App Note 132 for a 300m cable length.
                 
                 ;   ---------        -------------------------------
                 ;            \      /                        /
                 ;             ------------------------------- 
                 ;            a      b          c             d     e
                 ;            |  6us |   19us   |    35us     | 2us |
                 ;******
                 ; ( c -- c' )
                 ; Hardware
                 ; Write and read one bit to/from 1-wire.
                 VE_OW_SLOT:
000105 ff07          .dw $ff07
000106 7731
000107 732e
000108 6f6c
000109 0074          .db "1w.slot",0
00010a 00e1          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_SLOT
                 XT_OW_SLOT:
00010b 010c          .dw PFA_OW_SLOT
                 PFA_OW_SLOT:
                     ; pull low
00010c 982c          cbi OW_PORT, OW_BIT
00010d 9a24          sbi OW_DDR, OW_BIT
                     ; disable interrupts
00010e b71f          in temp1, SREG
00010f 94f8          cli
000110 e1e8
000111 e0f0
000112 9731
000113 f7f1          DELAY   6 ; DELAY A
                     ; check bit
000114 9488          clc
000115 9587          ror tosl
000116 f410          brcc PFA_OW_SLOT0 ; a 0 keeps the bus low
                       ; release bus, a 1 is written
000117 9a2c            sbi OW_PORT, OW_BIT
000118 9824            cbi OW_DDR, OW_BIT
                 PFA_OW_SLOT0:
                     ; sample the input (no action required if zero)
000119 e2e4
00011a e0f0
00011b 9731
00011c f7f1          DELAY 9   ; wait DELAY E to sample
00011d b103          in temp0, OW_PIN
00011e fd04          sbrc temp0, OW_BIT
00011f 6880          ori tosl, $80
                 
000120 ecec
000121 e0f0
000122 9731
000123 f7f1          DELAY   51 ; DELAY B
000124 9a2c          sbi OW_PORT, OW_BIT ; release bus
000125 9824          cbi OW_DDR, OW_BIT
000126 e0e8
000127 e0f0
000128 9731
000129 f7f1          delay 2
                     ; re-enable interrupts
00012a bf1f          out SREG, temp1
00012b 940c 7005     jmp_ DO_NEXT
                 
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 
                 .set corepc = pc
                 .org $0000
000000 940c 7a52   jmp_ PFA_COLD
                 
                 .org corepc
                 .include "drivers/generic-isr.asm"
                 
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .if WANT_INTERRUPT_COUNTERS==1
                 .dseg
000112           intcnt: .byte INTVECTORS
                 .endif
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
00012d 920a          st -Y, r0
00012e b60f          in r0, SREG
00012f 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
000130 900f          pop r0
000131 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
000132 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
                     ; check whether isrflag is zero. if not,
                     ; there is an still unhandled interrupt pending.
000133 20bb          tst isrflag
000134 f001          breq isr_clean
                     ; there is a collision. the previous interrupt is not yet
                     ; handled by the forth inner interpreter
                 isr_clean:
000135 2cb0          mov isrflag, r0
                 .if WANT_INTERRUPT_COUNTERS==1
000136 93ff          push zh
000137 93ef          push zl
000138 e1e2          ldi zl, low(intcnt)
000139 e0f1          ldi zh, high(intcnt)
00013a 9406          lsr r0 ; we use byte addresses in the counter array, not words
00013b 0de0          add zl, r0
00013c 1df3          adc zh, zeroh
00013d 8000          ld r0, Z
00013e 9403          inc r0
00013f 8200          st Z, r0
000140 91ef          pop zl
000141 91ff          pop zh
                 .endif
000142 9009          ld r0, Y+
000143 be0f          out SREG, r0
000144 9009          ld r0, Y+
000145 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                     ; no reti here, see words/isr-end.asm
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000146 ff02          .dw $ff02
000147 2b6d          .db "m+"
000148 0105          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
000149 7001          .dw DO_COLON
                 PFA_MPLUS:
00014a 7d63          .dw XT_S2D
00014b 742c          .dw XT_DPLUS
00014c 7020          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
00014d ff03          .dw $ff03
00014e 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
00014f 002a          .db "ud*"
000150 0146          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
000151 7001          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
000152 70b1
000153 70ff
000154 71e0
000155 70d9              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000156 70c4
000157 70f6
000158 71e0
000159 70e1
00015a 719d
00015b 7020              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
00015c ff04          .dw $ff04
00015d 6d75
00015e 7861          .db "umax"
00015f 014d          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
000160 7001          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
000161 7546
000162 715c              .DW XT_2DUP,XT_ULESS
000163 7036      	.dw XT_DOCONDBRANCH
000164 0166      	 DEST(UMAX1)
000165 70c4              .DW XT_SWAP
000166 70d9      UMAX1:  .DW XT_DROP
000167 7020      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
000168 ff04          .dw $ff04
000169 6d75
00016a 6e69          .db "umin"
00016b 015c          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
00016c 7001          .dw DO_COLON
                 PFA_UMIN:
                 .endif
00016d 7546
00016e 7167              .DW XT_2DUP,XT_UGREATER
00016f 7036      	.dw XT_DOCONDBRANCH
000170 0172      	DEST(UMIN1)
000171 70c4              .DW XT_SWAP
000172 70d9      UMIN1:  .DW XT_DROP
000173 7020      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; return +1 if immediate, -1 otherwise, flag from name>flags
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
000174 7001          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000175 703d          .dw XT_DOLITERAL
000176 8000          .dw $8000
000177 7213          .dw XT_AND
000178 7118          .dw XT_ZEROEQUAL
000179 7036          .dw XT_DOCONDBRANCH
00017a 017d          DEST(IMMEDIATEQ1)
00017b 73dd           .dw XT_ONE
00017c 7020           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
00017d 714b          .dw XT_TRUE
00017e 7020          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
00017f ff0a          .dw $ff0a
000180 616e
000181 656d
000182 663e
000183 616c
000184 7367          .db "name>flags"
000185 0168          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
000186 7001          .dw DO_COLON
                 PFA_NAME2FLAGS:
000187 73c1          .dw XT_FETCHI ; skip to link field
000188 703d          .dw XT_DOLITERAL
000189 ff00          .dw $ff00
00018a 7213          .dw XT_AND
00018b 7020          .dw XT_EXIT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
00018c ff03          .dw $ff03
00018d 6d31
00018e 0073          .db "1ms",0
00018f 017f          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
000190 0191          .dw PFA_1MS
                 PFA_1MS:
000191 eae0
000192 e0ff
000193 9731
000194 f7f1          delay 1000
000195 940c 7005     jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .include "dict/appl_8k.inc"
                 
                 
                 .include "words/newest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_NEWEST:
000197 ff06          .dw $ff06
000198 656e
000199 6577
00019a 7473          .db "newest"
00019b 018c          .dw VE_HEAD
                     .set VE_HEAD = VE_NEWEST
                 XT_NEWEST:
00019c 7048          .dw PFA_DOVARIABLE
                 PFA_NEWEST:
00019d 012e          .dw ram_newest
                 
                 .dseg
00012e           ram_newest: .byte 4
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_LATEST:
00019e ff06          .dw $ff06
00019f 616c
0001a0 6574
0001a1 7473          .db "latest"
0001a2 0197          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
0001a3 7048          .dw PFA_DOVARIABLE
                 PFA_LATEST:
0001a4 0132          .dw ram_latest
                 
                 .dseg
000132           ram_latest: .byte 2
                 .include "words/do-create.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE:
0001a5 ff08          .dw $ff08
0001a6 6328
0001a7 6572
0001a8 7461
0001a9 2965          .db "(create)"
0001aa 019e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
0001ab 7001          .dw DO_COLON
                 PFA_DOCREATE:
                 .endif
0001ac 799f
0001ad 030d          .DW XT_PARSENAME,XT_WLSCOPE  ; ( -- addr len wid)
0001ae 01b8          .DW XT_DOCREATE_IN           ; ( addr len wid -- )
0001af 7020          .DW XT_EXIT
                 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE_IN:
0001b0 ff0b          .dw $ff0b
0001b1 6328
0001b2 6572
0001b3 7461
0001b4 2d65
0001b5 6e69
../../common\words/do-create.asm(31): warning: .cseg .db misalignment - padding zero byte
0001b6 0029          .db "(create-in)"
0001b7 01a5          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE_IN
                 XT_DOCREATE_IN:
0001b8 7001          .dw DO_COLON
                 PFA_DOCREATE_IN:
                 .endif
0001b9 70b1
0001ba 019c
0001bb 753f
0001bc 7081          .DW XT_DUP,XT_NEWEST,XT_CELLPLUS,XT_STORE ; save the wid
0001bd 02f2
0001be 019c
0001bf 7081          .DW XT_HEADER,XT_NEWEST,XT_STORE          ; save the nt
0001c0 7020          .DW XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
0001c1 0001          .dw $0001
0001c2 005c          .db $5c,0
0001c3 01b0          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
0001c4 7001          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
0001c5 7986          .dw XT_SOURCE
0001c6 70f0          .dw XT_NIP
0001c7 755f          .dw XT_TO_IN
0001c8 7081          .dw XT_STORE
0001c9 7020          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
0001ca 0001          .dw $0001
0001cb 0028          .db "(" ,0
0001cc 01c1          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
0001cd 7001          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
0001ce 703d          .dw XT_DOLITERAL
0001cf 0029          .dw ')'
0001d0 7972          .dw XT_PARSE
0001d1 754f          .dw XT_2DROP
0001d2 7020          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
0001d3 ff07          .dw $ff07
0001d4 6f63
0001d5 706d
0001d6 6c69
0001d7 0065          .db "compile",0
0001d8 01ca          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
0001d9 7001          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
0001da 70f6          .dw XT_R_FROM
0001db 70b1          .dw XT_DUP
0001dc 7ba7          .dw XT_ICELLPLUS
0001dd 70ff          .dw XT_TO_R
0001de 73c1          .dw XT_FETCHI
0001df 01e4          .dw XT_COMMA
0001e0 7020          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0001e1 ff01          .dw $ff01
0001e2 002c          .db ',',0 ; ,
0001e3 01d3          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0001e4 7001          .dw DO_COLON
                 PFA_COMMA:
0001e5 758f          .dw XT_DP
0001e6 7369          .dw XT_STOREI
0001e7 758f          .dw XT_DP
0001e8 722f          .dw XT_1PLUS
0001e9 7b95          .dw XT_DOTO
0001ea 7590          .dw PFA_DP
0001eb 7020          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
0001ec 0003          .dw $0003
0001ed 275b
0001ee 005d          .db "[']",0
0001ef 01e1          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
0001f0 7001          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
0001f1 77eb          .dw XT_TICK
0001f2 01fa          .dw XT_LITERAL
0001f3 7020          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
0001f4 0007          .dw $0007
0001f5 696c
0001f6 6574
0001f7 6172
0001f8 006c          .db "literal",0
0001f9 01ec          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
0001fa 7001          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
0001fb 01d9              .DW XT_COMPILE
0001fc 703d              .DW XT_DOLITERAL
0001fd 01e4              .DW XT_COMMA
0001fe 7020              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
0001ff 0008        .dw $0008
000200 6c73
000201 7469
000202 7265
000203 6c61        .db "sliteral"
000204 01f4        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
000205 7001          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
000206 01d9          .dw XT_COMPILE
000207 774e          .dw XT_DOSLITERAL    ; ( -- addr n)
000208 775c          .dw XT_SCOMMA
000209 7020          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
00020a 7001          .dw DO_COLON
                 PFA_GMARK:
00020b 758f          .dw XT_DP
00020c 01d9          .dw XT_COMPILE
00020d ffff          .dw -1           ; ffff does not erase flash
00020e 7020          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
00020f 7001          .dw DO_COLON
                 PFA_GRESOLVE:
000210 7b53          .dw XT_QSTACK
000211 758f          .dw XT_DP
000212 70c4          .dw XT_SWAP
000213 7369          .dw XT_STOREI
000214 7020          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
000215 7001          .dw DO_COLON
                 PFA_LMARK:
000216 758f          .dw XT_DP
000217 7020          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
000218 7001          .dw DO_COLON
                 PFA_LRESOLVE:
000219 7b53          .dw XT_QSTACK
00021a 01e4          .dw XT_COMMA
00021b 7020          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
00021c 0005          .dw $0005
00021d 6861
00021e 6165
00021f 0064          .db "ahead",0
000220 01ff          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
000221 7001          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
000222 01d9          .dw XT_COMPILE
000223 702f          .dw XT_DOBRANCH
000224 020a          .dw XT_GMARK
000225 7020          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
000226 0002          .dw $0002
000227 6669          .db "if"
000228 021c          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
000229 7001          .dw DO_COLON
                 PFA_IF:
                 .endif
00022a 01d9          .dw XT_COMPILE
00022b 7036          .dw XT_DOCONDBRANCH
00022c 020a          .dw XT_GMARK
00022d 7020          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
00022e 0004          .dw $0004
00022f 6c65
000230 6573          .db "else"
000231 0226          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
000232 7001          .dw DO_COLON
                 PFA_ELSE:
                 .endif
000233 01d9          .dw XT_COMPILE
000234 702f          .dw XT_DOBRANCH
000235 020a          .dw XT_GMARK
000236 70c4          .dw XT_SWAP
000237 020f          .dw XT_GRESOLVE
000238 7020          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
000239 0004          .dw $0004
00023a 6874
00023b 6e65          .db "then"
00023c 022e          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
00023d 7001          .dw DO_COLON
                 PFA_THEN:
                 .endif
00023e 020f          .dw XT_GRESOLVE
00023f 7020          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
000240 0005          .dw $0005
000241 6562
000242 6967
000243 006e          .db "begin",0
000244 0239          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
000245 7001          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
000246 0215          .dw XT_LMARK
000247 7020          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
000248 0005          .dw $0005
000249 6877
00024a 6c69
00024b 0065          .db "while",0
00024c 0240          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
00024d 7001          .dw DO_COLON
                 PFA_WHILE:
                 .endif
00024e 0229          .dw XT_IF
00024f 70c4          .dw XT_SWAP
000250 7020          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
000251 0006          .dw $0006
000252 6572
000253 6570
000254 7461          .db "repeat"
000255 0248          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
000256 7001          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
000257 026a          .dw XT_AGAIN
000258 023d          .dw XT_THEN
000259 7020          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
00025a 0005          .dw $0005
00025b 6e75
00025c 6974
00025d 006c          .db "until",0
00025e 0251          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
00025f 7001          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
000260 703d          .dw XT_DOLITERAL
000261 7036          .dw XT_DOCONDBRANCH
000262 01e4          .dw XT_COMMA
                 
000263 0218          .dw XT_LRESOLVE
000264 7020          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
000265 0005          .dw $0005
000266 6761
000267 6961
000268 006e          .db "again",0
000269 025a          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
00026a 7001          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
00026b 01d9          .dw XT_COMPILE
00026c 702f          .dw XT_DOBRANCH
00026d 0218          .dw XT_LRESOLVE
00026e 7020          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
00026f 0002          .dw $0002
000270 6f64          .db "do"
000271 0265          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000272 7001          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
000273 01d9          .dw XT_COMPILE
000274 729b          .dw XT_DODO
000275 0215          .dw XT_LMARK
000276 7154          .dw XT_ZERO
000277 02cd          .dw XT_TO_L
000278 7020          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
000279 0004          .dw $0004
00027a 6f6c
00027b 706f          .db "loop"
00027c 026f          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
00027d 7001          .dw DO_COLON
                 PFA_LOOP:
                 .endif
00027e 01d9          .dw XT_COMPILE
00027f 72c9          .dw XT_DOLOOP
000280 02b4          .dw XT_ENDLOOP
000281 7020          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
000282 0005          .dw $0005
000283 6c2b
000284 6f6f
000285 0070          .db "+loop",0
000286 0279          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
000287 7001          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
000288 01d9          .dw XT_COMPILE
000289 72ba          .dw XT_DOPLUSLOOP
00028a 02b4          .dw XT_ENDLOOP
00028b 7020          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
00028c 0005         .dw $0005
00028d 656c
00028e 7661
00028f 0065         .db "leave",0
000290 0282         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
000291 7001          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
000292 01d9
000293 72d4          .DW XT_COMPILE,XT_UNLOOP
000294 0221
000295 02cd
000296 7020          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
000297 0003          .dw $0003
000298 643f
000299 006f          .db "?do",0
00029a 028c          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
00029b 7001          .dw DO_COLON
                 PFA_QDO:
                 .endif
00029c 01d9          .dw XT_COMPILE
00029d 02a3          .dw XT_QDOCHECK
00029e 0229          .dw XT_IF
00029f 0272          .dw XT_DO
0002a0 70c4          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
0002a1 02cd          .dw XT_TO_L    ; then follows at the end.
0002a2 7020          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
0002a3 7001          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
0002a4 7546          .dw XT_2DUP
0002a5 73d6          .dw XT_EQUAL
0002a6 70b1          .dw XT_DUP
0002a7 70ff          .dw XT_TO_R
0002a8 7036          .dw XT_DOCONDBRANCH
0002a9 02ab          DEST(PFA_QDOCHECK1)
0002aa 754f          .dw XT_2DROP
                 PFA_QDOCHECK1:
0002ab 70f6          .dw XT_R_FROM
0002ac 71fd          .dw XT_INVERT
0002ad 7020          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
0002ae ff07          .dw $ff07
0002af 6e65
0002b0 6c64
0002b1 6f6f
0002b2 0070          .db "endloop",0
0002b3 0297          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
0002b4 7001          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
0002b5 0218              .DW XT_LRESOLVE
0002b6 02c1
0002b7 70b9
0002b8 7036      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
0002b9 02bd               DEST(LOOP2)
0002ba 023d              .DW XT_THEN
0002bb 702f      	.dw XT_DOBRANCH
0002bc 02b6               DEST(LOOP1)
0002bd 7020      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
0002be ff02          .dw $ff02
0002bf 3e6c          .db "l>"
0002c0 02ae          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
0002c1 7001          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
0002c2 02e0          .dw XT_LP
0002c3 7079          .dw XT_FETCH
0002c4 7079          .dw XT_FETCH
0002c5 703d          .dw XT_DOLITERAL
0002c6 fffe          .dw -2
0002c7 02e0          .dw XT_LP
0002c8 7265          .dw XT_PLUSSTORE
0002c9 7020          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
0002ca ff02          .dw $ff02
0002cb 6c3e          .db ">l"
0002cc 02be          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
0002cd 7001          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
0002ce 73e2              .dw XT_TWO
0002cf 02e0      	.dw XT_LP
0002d0 7265      	.dw XT_PLUSSTORE
0002d1 02e0      	.dw XT_LP
0002d2 7079      	.dw XT_FETCH
0002d3 7081      	.dw XT_STORE
0002d4 7020      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
0002d5 ff03          .dw $ff03
0002d6 706c
0002d7 0030          .db "lp0",0
0002d8 02ca          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
0002d9 706f          .dw PFA_DOVALUE1
                 PFA_LP0:
0002da 0044          .dw CFG_LP0
0002db 7bb0          .dw XT_EDEFERFETCH
0002dc 7bba          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
0002dd ff02          .dw $ff02
0002de 706c          .db "lp"
0002df 02d5          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
0002e0 7048          .dw PFA_DOVARIABLE
                 PFA_LP:
0002e1 0134          .dw ram_lp
                 
                 .dseg
000134           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CREATE:
0002e2 ff06          .dw $ff06
0002e3 7263
0002e4 6165
0002e5 6574          .db "create"
0002e6 02dd          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
0002e7 7001          .dw DO_COLON
                 PFA_CREATE:
                 .endif
0002e8 01ab          .dw XT_DOCREATE
0002e9 0316          .dw XT_REVEAL
0002ea 01d9          .dw XT_COMPILE
0002eb 7052          .dw PFA_DOCONSTANT
0002ec 7020          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
0002ed ff06          .dw $ff06
0002ee 6568
0002ef 6461
0002f0 7265          .db "header"
0002f1 02e2          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
0002f2 7001          .dw DO_COLON
                 PFA_HEADER:
0002f3 758f          .dw XT_DP           ; the new Name Field
0002f4 70ff          .dw XT_TO_R
0002f5 70ff          .dw XT_TO_R		; ( R: NFA WID )
0002f6 70b1          .dw XT_DUP    
0002f7 7126          .dw XT_GREATERZERO 
0002f8 7036          .dw XT_DOCONDBRANCH
0002f9 0304          .dw PFA_HEADER1
0002fa 70b1          .dw XT_DUP
0002fb 703d          .dw XT_DOLITERAL
0002fc ff00          .dw $ff00           ; all flags are off (e.g. immediate)
0002fd 721c          .dw XT_OR
0002fe 7760          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
0002ff 70f6          .dw XT_R_FROM
000300 7355          .dw XT_FETCHE
000301 01e4          .dw XT_COMMA
000302 70f6          .dw XT_R_FROM
000303 7020          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
000304 703d          .dw XT_DOLITERAL
000305 fff0          .dw -16
000306 7822          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
000307 ff07          .dw $ff07
000308 6c77
000309 6373
00030a 706f
00030b 0065          .db "wlscope",0
00030c 02ed          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
00030d 7c0f          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
00030e 0040          .dw CFG_WLSCOPE
00030f 7bb0          .dw XT_EDEFERFETCH
000310 7bba          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REVEAL:
000311 ff06          .dw $ff06
000312 6572
000313 6576
000314 6c61          .db "reveal"
000315 0307          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
000316 7001          .dw DO_COLON
                 PFA_REVEAL:
                 .endif
000317 019c
000318 753f
000319 7079          .DW XT_NEWEST,XT_CELLPLUS,XT_FETCH ; only if wordlist is in use
00031a 70b9
00031b 7036          .DW XT_QDUP,XT_DOCONDBRANCH
00031c 0321          DEST(REVEAL1)
00031d 019c
00031e 7079
00031f 70c4
000320 7331          .DW XT_NEWEST,XT_FETCH,XT_SWAP,XT_STOREE
                 ;    .DW XT_ZERO,XT_NEWEST,XT_CELLPLUS,XT_STORE ; clean wordlist entry
                 REVEAL1:
000321 7020          .DW XT_EXIT
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
000322 0005          .dw $0005
000323 6f64
000324 7365
000325 003e          .db "does>",0
000326 0311          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000327 7001          .dw DO_COLON
                 PFA_DOES:
000328 01d9          .dw XT_COMPILE
000329 033a          .dw XT_DODOES
00032a 01d9          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
00032b 940e          .dw $940e       ; the address of this compiled
00032c 01d9          .dw XT_COMPILE  ; code will replace the XT of the 
00032d 032f          .dw DO_DODOES   ; word that CREATE created
00032e 7020          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
00032f 939a
000330 938a          savetos
000331 01cb          movw tosl, wl
000332 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
000333 917f          pop wh
000334 916f          pop wl
                 
000335 93bf          push XH
000336 93af          push XL
000337 01db          movw XL, wl
000338 940c 7005     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
00033a 7001          .dw DO_COLON
                 PFA_DODOES:
00033b 70f6          .dw XT_R_FROM
00033c 019c          .dw XT_NEWEST
00033d 753f          .dw XT_CELLPLUS
00033e 7079          .dw XT_FETCH
00033f 7355          .dw XT_FETCHE
000340 7c7a          .dw XT_NFA2CFA
000341 7369          .dw XT_STOREI
000342 7020          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
000343 ff01          .dw $ff01
000344 003a          .db ":",0
000345 0322          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000346 7001          .dw DO_COLON
                 PFA_COLON:
                 .endif
000347 01ab          .dw XT_DOCREATE
000348 0351          .dw XT_COLONNONAME
000349 70d9          .dw XT_DROP
00034a 7020          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
00034b ff07          .dw $ff07
00034c 6e3a
00034d 6e6f
00034e 6d61
00034f 0065          .db ":noname",0
000350 0343          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000351 7001          .dw DO_COLON
                 PFA_COLONNONAME:
000352 758f          .dw XT_DP
000353 70b1          .dw XT_DUP
000354 01a3          .dw XT_LATEST
000355 7081          .dw XT_STORE
                 
000356 01d9          .dw XT_COMPILE
000357 7001          .dw DO_COLON
                 
000358 0366          .dw XT_RBRACKET
000359 7020          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
00035a 0001          .dw $0001
00035b 003b          .db $3b,0
00035c 034b          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
00035d 7001          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
00035e 01d9          .dw XT_COMPILE
00035f 7020          .dw XT_EXIT
000360 036e          .dw XT_LBRACKET
000361 0316          .dw XT_REVEAL
000362 7020          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
000363 ff01          .dw $ff01
000364 005d          .db "]",0
000365 035a          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000366 7001          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
000367 73dd          .dw XT_ONE
000368 752c          .dw XT_STATE
000369 7081          .dw XT_STORE
00036a 7020          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
00036b 0001          .dw $0001
00036c 005b          .db "[",0
00036d 0363          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
00036e 7001          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
00036f 7154          .dw XT_ZERO
000370 752c          .dw XT_STATE
000371 7081          .dw XT_STORE
000372 7020          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
000373 ff08          .dw $ff08
000374 6176
000375 6972
000376 6261
000377 656c          .db "variable"
000378 036b          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000379 7001          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
00037a 75a0          .dw XT_HERE
00037b 0385          .dw XT_CONSTANT
00037c 73e2          .dw XT_TWO
00037d 75a9          .dw XT_ALLOT
00037e 7020          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
00037f ff08          .dw $ff08
000380 6f63
000381 736e
000382 6174
000383 746e          .db "constant"
000384 0373          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000385 7001          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
000386 01ab          .dw XT_DOCREATE
000387 0316          .dw XT_REVEAL
000388 01d9          .dw XT_COMPILE
000389 7048          .dw PFA_DOVARIABLE
00038a 01e4          .dw XT_COMMA
00038b 7020          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
00038c ff04          .dw $ff04
00038d 7375
00038e 7265          .db "user"
00038f 037f          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
000390 7001          .dw DO_COLON
                 PFA_USER:
000391 01ab          .dw XT_DOCREATE
000392 0316          .dw XT_REVEAL
                 
000393 01d9          .dw XT_COMPILE
000394 7058          .dw PFA_DOUSER
000395 01e4          .dw XT_COMMA
000396 7020          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECURSE:
000397 0007          .dw $0007
000398 6572
000399 7563
00039a 7372
00039b 0065          .db "recurse",0
00039c 038c          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
00039d 7001          .dw DO_COLON
                 PFA_RECURSE:
                 .endif
00039e 01a3          .dw XT_LATEST
00039f 7079          .dw XT_FETCH
0003a0 01e4          .dw XT_COMMA
0003a1 7020          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
0003a2 ff09          .dw $ff09
0003a3 6d69
0003a4 656d
0003a5 6964
0003a6 7461
0003a7 0065          .db "immediate",0
0003a8 0397          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
0003a9 7001          .dw DO_COLON
                 PFA_IMMEDIATE:
0003aa 044b          .dw XT_GET_CURRENT
0003ab 7355          .dw XT_FETCHE
0003ac 70b1          .dw XT_DUP
0003ad 73c1          .dw XT_FETCHI
0003ae 703d          .dw XT_DOLITERAL
0003af 7fff          .dw $7fff
0003b0 7213          .dw XT_AND
0003b1 70c4          .dw XT_SWAP
0003b2 7369          .dw XT_STOREI
0003b3 7020          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
0003b4 0006          .dw $0006
0003b5 635b
0003b6 6168
0003b7 5d72          .db "[char]"
0003b8 03a2          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
0003b9 7001          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
0003ba 01d9          .dw XT_COMPILE
0003bb 703d          .dw XT_DOLITERAL
0003bc 78d0          .dw XT_CHAR
0003bd 01e4          .dw XT_COMMA
0003be 7020          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
0003bf 0006          .dw $0006
0003c0 6261
0003c1 726f
0003c2 2274          .db "abort",'"'
0003c3 03b4          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
0003c4 7001          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
0003c5 74a2          .dw XT_SQUOTE
0003c6 01d9          .dw XT_COMPILE
0003c7 03d6          .dw XT_QABORT
0003c8 7020          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
0003c9 ff05          .dw $ff05
0003ca 6261
0003cb 726f
0003cc 0074          .db "abort",0
0003cd 03bf          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
0003ce 7001          .dw DO_COLON
                 PFA_ABORT:
                 .endif
0003cf 714b          .dw XT_TRUE
0003d0 7822          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
0003d1 ff06          .dw $ff06
0003d2 613f
0003d3 6f62
0003d4 7472          .db "?abort"
0003d5 03c9          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
0003d6 7001          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
0003d7 70e1
0003d8 7036              .DW XT_ROT,XT_DOCONDBRANCH
0003d9 03dc              DEST(QABO1)
0003da 7781
0003db 03ce              .DW XT_ITYPE,XT_ABORT
0003dc 754f
0003dd 7020      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
0003de ff09          .dw $ff09
0003df 6567
0003e0 2d74
0003e1 7473
0003e2 6361
0003e3 006b          .db "get-stack",0
0003e4 03d1          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
0003e5 7001          .dw DO_COLON
                 .endif
0003e6 70b1          .dw XT_DUP
0003e7 753f          .dw XT_CELLPLUS
0003e8 70c4          .dw XT_SWAP
0003e9 7355          .dw XT_FETCHE
0003ea 70b1          .dw XT_DUP
0003eb 70ff          .dw XT_TO_R
0003ec 7154          .dw XT_ZERO
0003ed 70c4          .dw XT_SWAP    ; go from bigger to smaller addresses
0003ee 02a3          .dw XT_QDOCHECK
0003ef 7036          .dw XT_DOCONDBRANCH
0003f0 03fc          DEST(PFA_N_FETCH_E2)
0003f1 729b          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
0003f2 72ac          .dw XT_I
0003f3 7235          .dw XT_1MINUS
0003f4 7539          .dw XT_CELLS ; ( -- ee-addr i*2 )
0003f5 70cf          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
0003f6 719d          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
0003f7 7355          .dw XT_FETCHE ;( -- ee-addr item_i )
0003f8 70c4          .dw XT_SWAP   ;( -- item_i ee-addr )
0003f9 714b          .dw XT_TRUE  ; shortcut for -1
0003fa 72ba          .dw XT_DOPLUSLOOP
0003fb 03f2          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
0003fc 754f          .dw XT_2DROP
0003fd 70f6          .dw XT_R_FROM
0003fe 7020          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
0003ff ff09          .dw $ff09
000400 6573
000401 2d74
000402 7473
000403 6361
000404 006b          .db "set-stack",0
000405 03de          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
000406 7001          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
000407 70cf          .dw XT_OVER
000408 711f          .dw XT_ZEROLESS
000409 7036          .dw XT_DOCONDBRANCH
00040a 040e          DEST(PFA_SET_STACK0)
00040b 703d          .dw XT_DOLITERAL
00040c fffc          .dw -4
00040d 7822          .dw XT_THROW
                 PFA_SET_STACK0:
00040e 7546          .dw XT_2DUP
00040f 7331          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
000410 70c4          .dw XT_SWAP    
000411 7154          .dw XT_ZERO
000412 02a3          .dw XT_QDOCHECK
000413 7036          .dw XT_DOCONDBRANCH
000414 041b          DEST(PFA_SET_STACK2)
000415 729b          .dw XT_DODO
                 PFA_SET_STACK1:
000416 753f          .dw XT_CELLPLUS ; ( -- i_x e-addr )
000417 7557          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
000418 7331          .dw XT_STOREE
000419 72c9          .dw XT_DOLOOP
00041a 0416          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
00041b 70d9          .dw XT_DROP
00041c 7020          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
00041d ff09          .dw $ff09
00041e 616d
00041f 2d70
000420 7473
000421 6361
000422 006b          .db "map-stack",0
000423 03ff          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
000424 7001          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
000425 70b1          .dw XT_DUP
000426 753f          .dw XT_CELLPLUS
000427 70c4          .dw XT_SWAP
000428 7355          .dw XT_FETCHE
000429 7539          .dw XT_CELLS
00042a 7d5a          .dw XT_BOUNDS
00042b 02a3          .dw XT_QDOCHECK
00042c 7036          .dw XT_DOCONDBRANCH
00042d 0440          DEST(PFA_MAPSTACK3)
00042e 729b          .dw XT_DODO
                 PFA_MAPSTACK1:
00042f 72ac            .dw XT_I
000430 7355            .dw XT_FETCHE   ; -- i*x XT id
000431 70c4            .dw XT_SWAP
000432 70ff            .dw XT_TO_R
000433 7106            .dw XT_R_FETCH
000434 702a            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
000435 70b9            .dw XT_QDUP
000436 7036            .dw XT_DOCONDBRANCH
000437 043c            DEST(PFA_MAPSTACK2)
000438 70f6               .dw XT_R_FROM
000439 70d9               .dw XT_DROP
00043a 72d4               .dw XT_UNLOOP
00043b 7020               .dw XT_EXIT
                 PFA_MAPSTACK2:
00043c 70f6            .dw XT_R_FROM
00043d 73e2            .dw XT_TWO
00043e 72ba            .dw XT_DOPLUSLOOP
00043f 042f            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
000440 70d9          .dw XT_DROP
000441 7154          .dw XT_ZERO
000442 7020          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ; ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000443 ff0b          .dw $ff0b
000444 6567
000445 2d74
000446 7563
000447 7272
000448 6e65
000449 0074          .db "get-current",0
00044a 041d          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
00044b 7001          .dw DO_COLON
                 PFA_GET_CURRENT:
00044c 703d          .dw XT_DOLITERAL
00044d 004a          .dw CFG_CURRENT
00044e 7355          .dw XT_FETCHE
00044f 7020          .dw XT_EXIT
                 .include "words/cfg-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CFG_ORDER:
000450 ff09          .dw $ff09
000451 6663
000452 2d67
000453 726f
000454 6564
000455 0072          .db "cfg-order",0
000456 0443          .dw VE_HEAD
                     .set VE_HEAD = VE_CFG_ORDER
                 XT_CFG_ORDER:
000457 7048          .dw PFA_DOVARIABLE
                 PFA_CFG_ORDER:
                 .endif
000458 004e          .dw CFG_ORDERLISTLEN
                 .include "words/cfg-recognizer.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CFG_RECOGNIZER:
000459 ff08          .dw $ff08
00045a 6663
00045b 2d67
00045c 6572
00045d 7363          .db "cfg-recs"
00045e 0450          .dw VE_HEAD
                     .set VE_HEAD = VE_CFG_RECOGNIZER
                 XT_CFG_RECOGNIZER:
00045f 7048          .dw PFA_DOVARIABLE
                 PFA_CFG_RECOGNIZER:
                 .endif
000460 0060          .dw CFG_RECOGNIZERLISTLEN
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000461 ff07          .dw $ff07
000462 6f63
000463 706d
000464 7261
000465 0065          .db "compare",0
000466 0459          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
000467 0468          .dw PFA_COMPARE
                 PFA_COMPARE:
000468 93bf          push xh
000469 93af          push xl
00046a 018c          movw temp0, tosl
00046b 9189
00046c 9199          loadtos
00046d 01dc          movw xl, tosl
00046e 9189
00046f 9199          loadtos
000470 019c          movw temp2, tosl
000471 9189
000472 9199          loadtos
000473 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000474 90ed          ld temp4, X+
000475 90f1          ld temp5, Z+
000476 14ef          cp temp4, temp5
000477 f451          brne PFA_COMPARE_NOTEQUAL
000478 950a          dec temp0
000479 f019          breq PFA_COMPARE_ENDREACHED2
00047a 952a          dec temp2
00047b f7c1          brne PFA_COMPARE_LOOP
00047c c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
00047d 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
00047e 2b02          or temp0, temp2
00047f f411          brne PFA_COMPARE_CHECKLASTCHAR
000480 2788          clr tosl
000481 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000482 ef8f          ser tosl
000483 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000484 2f98          mov tosh, tosl
000485 91af          pop xl
000486 91bf          pop xh
000487 940c 7005     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
000489 ff07         .dw $ff07
00048a 666e
00048b 3e61
00048c 666c
00048d 0061         .db "nfa>lfa",0
00048e 0461         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
00048f 7001          .dw DO_COLON
                 PFA_NFA2LFA:
000490 7c6e          .dw XT_NAME2STRING
000491 722f          .dw XT_1PLUS
000492 7204          .dw XT_2SLASH
000493 719d          .dw XT_PLUS
000494 7020          .dw XT_EXIT
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTS:
000495 ff02          .dw $ff02
000496 732e          .db ".s"
000497 0489          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
000498 7001          .dw DO_COLON
                 PFA_DOTS:
                 .endif
000499 7a94          .dw XT_DEPTH
00049a 745f          .dw XT_UDOT
00049b 77c3          .dw XT_SPACE
00049c 7a94          .dw XT_DEPTH
00049d 7154          .dw XT_ZERO
00049e 02a3          .dw XT_QDOCHECK
00049f 7036          .dw XT_DOCONDBRANCH
0004a0 04a7          DEST(PFA_DOTS2)
0004a1 729b          .dw XT_DODO
                 PFA_DOTS1:
0004a2 72ac          .dw XT_I
0004a3 7490          .dw XT_PICK
0004a4 745f          .dw XT_UDOT
0004a5 72c9          .dw XT_DOLOOP
0004a6 04a2          DEST(PFA_DOTS1)
                 PFA_DOTS2:
0004a7 7020          .dw XT_EXIT
                 .include "words/spirw.asm"
                 
                 ; MCU
                 ; SPI exchange of 1 byte
                 VE_SPIRW:
0004a8 ff06          .dw $ff06
0004a9 2163
0004aa 7340
0004ab 6970          .db "c!@spi"
0004ac 0495          .dw VE_HEAD
                     .set VE_HEAD  = VE_SPIRW
                 XT_SPIRW:
0004ad 04ae          .dw PFA_SPIRW
                 PFA_SPIRW:
0004ae d003          rcall do_spirw
0004af 2799          clr tosh
0004b0 940c 7005     jmp_ DO_NEXT
                 
                 do_spirw:
0004b2 bd8e          out_ SPDR, tosl
                 do_spirw1:
0004b3 b50d          in_ temp0, SPSR
0004b4 7f08          cbr temp0,7
0004b5 bd0d          out_ SPSR, temp0
0004b6 b50d          in_ temp0, SPSR
0004b7 ff07          sbrs temp0, 7
0004b8 cffa          rjmp do_spirw1   ; wait until complete
0004b9 b58e          in_ tosl, SPDR
0004ba 9508          ret
                 .include "words/n-spi.asm"
                 
                 ; MCU
                 ; read len bytes from SPI to addr
                 VE_N_SPIR:
0004bb ff05          .dw $ff05
0004bc 406e
0004bd 7073
0004be 0069          .db "n@spi",0
0004bf 04a8          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIR
                 XT_N_SPIR:
0004c0 04c1          .dw PFA_N_SPIR
                 PFA_N_SPIR:
0004c1 018c          movw temp0, tosl
0004c2 9189
0004c3 9199          loadtos
0004c4 01fc          movw zl, tosl
0004c5 01c8          movw tosl, temp0
                 PFA_N_SPIR_LOOP:
0004c6 bc2e          out_ SPDR, zerol
                 PFA_N_SPIR_LOOP1:
0004c7 b52d          in_ temp2, SPSR
0004c8 ff27          sbrs temp2, SPIF
0004c9 cffd          rjmp PFA_N_SPIR_LOOP1
0004ca b52e          in_ temp2, SPDR
0004cb 9321          st Z+, temp2
0004cc 9701          sbiw tosl, 1
0004cd f7c1          brne PFA_N_SPIR_LOOP
0004ce 9189
0004cf 9199          loadtos
0004d0 940c 7005     jmp_ DO_NEXT
                 
                 ; ( addr len -- ) 
                 ; MCU
                 ; write len bytes to SPI from addr
                 VE_N_SPIW:
0004d2 ff05          .dw $ff05
0004d3 216e
0004d4 7073
0004d5 0069          .db "n!spi",0
0004d6 04bb          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIW
                 XT_N_SPIW:
0004d7 04d8          .dw PFA_N_SPIW
                 PFA_N_SPIW:
0004d8 018c          movw temp0, tosl
0004d9 9189
0004da 9199          loadtos
0004db 01fc          movw zl, tosl
0004dc 01c8          movw tosl, temp0
                 PFA_N_SPIW_LOOP:
0004dd 9121          ld temp2, Z+
0004de bd2e          out_ SPDR, temp2
                 PFA_N_SPIW_LOOP1:
0004df b52d          in_ temp2, SPSR
0004e0 ff27          sbrs temp2, SPIF
0004e1 cffd          rjmp PFA_N_SPIW_LOOP1
0004e2 b52e          in_ temp2, SPDR ; ignore the data
0004e3 9701          sbiw tosl, 1
0004e4 f7c1          brne PFA_N_SPIW_LOOP
0004e5 9189
0004e6 9199          loadtos
0004e7 940c 7005     jmp_ DO_NEXT
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
0004e9 ff0b          .dw $ff0b
0004ea 7061
0004eb 6c70
0004ec 7574
0004ed 6e72
0004ee 656b
0004ef 0079          .db "applturnkey",0
0004f0 04d2          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
0004f1 7001          .dw DO_COLON
                 PFA_APPLTURNKEY:
0004f2 00cb          .dw XT_USART
                 
                 .if WANT_INTERRUPTS == 1
0004f3 7d81          .dw XT_INTON
                 .endif
0004f4 7b60          .dw XT_DOT_VER
0004f5 77c3          .dw XT_SPACE
0004f6 7521          .dw XT_F_CPU
0004f7 703d          .dw XT_DOLITERAL
0004f8 03e8          .dw 1000
0004f9 71c2          .dw XT_UMSLASHMOD
0004fa 70f0          .dw XT_NIP
0004fb 75be          .dw XT_DECIMAL
0004fc 7703          .dw XT_DOT
0004fd 774e          .dw XT_DOSLITERAL
0004fe 0004          .dw 4
0004ff 486b
000500 207a          .db "kHz "
000501 7781          .dw XT_ITYPE
000502 7020          .dw XT_EXIT
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
000503 ff0b          .dw $ff0b
000504 6573
000505 2d74
000506 7563
000507 7272
000508 6e65
000509 0074          .db "set-current",0
00050a 04e9          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
00050b 7001          .dw DO_COLON
                 PFA_SET_CURRENT:
00050c 703d          .dw XT_DOLITERAL
00050d 004a          .dw CFG_CURRENT
00050e 7331          .dw XT_STOREE
00050f 7020          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
000510 ff08          .dw $ff08
000511 6f77
000512 6472
000513 696c
000514 7473          .db "wordlist"
000515 0503          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
000516 7001          .dw DO_COLON
                 PFA_WORDLIST:
000517 7598          .dw XT_EHERE
000518 7154          .dw XT_ZERO
000519 70cf          .dw XT_OVER
00051a 7331          .dw XT_STOREE
00051b 70b1          .dw XT_DUP
00051c 753f          .dw XT_CELLPLUS
00051d 7b95          .dw XT_DOTO
00051e 7599          .dw PFA_EHERE
00051f 7020          .dw XT_EXIT
                 
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTHWORDLIST:
000520 ff0e          .dw $ff0e
000521 6f66
000522 7472
000523 2d68
000524 6f77
000525 6472
000526 696c
000527 7473          .db "forth-wordlist"
000528 0510          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHWORDLIST
                 XT_FORTHWORDLIST:
000529 7048          .dw PFA_DOVARIABLE
                 PFA_FORTHWORDLIST:
00052a 004c          .dw CFG_FORTHWORDLIST
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
00052b ff04          .dw $ff04
00052c 6f63
00052d 6564          .db "code"
00052e 0520          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
00052f 7001          .dw DO_COLON
                 PFA_CODE:
000530 01ab          .dw XT_DOCREATE
000531 0316          .dw XT_REVEAL
000532 758f          .dw XT_DP
000533 7ba7          .dw XT_ICELLPLUS
000534 01e4          .dw XT_COMMA
000535 7020          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000536 ff08          .dw $ff08
000537 6e65
000538 2d64
000539 6f63
00053a 6564          .db "end-code"
00053b 052b          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
00053c 7001          .dw DO_COLON
                 PFA_ENDCODE:
00053d 01d9          .dw XT_COMPILE
00053e 940c          .dw $940c
00053f 01d9          .dw XT_COMPILE
000540 7005          .dw DO_NEXT
000541 7020          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
000542 ff08          .dw $ff08
000543 6d28
000544 7261
000545 656b
000546 2972          .db "(marker)"
000547 0536          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
000548 706f          .dw PFA_DOVALUE1
                 PFA_MARKER:
000549 006c          .dw EE_MARKER
00054a 7bb0          .dw XT_EDEFERFETCH
00054b 7bba          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
00054c 0008          .dw $0008
00054d 6f70
00054e 7473
00054f 6f70
000550 656e          .db "postpone"
000551 0542          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
000552 7001          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
000553 799f          .dw XT_PARSENAME
000554 7abf          .dw XT_FORTHRECOGNIZER
000555 7aca          .dw XT_RECOGNIZE
000556 70b1          .dw XT_DUP
000557 70ff          .dw XT_TO_R
000558 7ba7          .dw XT_ICELLPLUS
000559 7ba7          .dw XT_ICELLPLUS
00055a 73c1          .dw XT_FETCHI
00055b 702a          .dw XT_EXECUTE
00055c 70f6          .dw XT_R_FROM
00055d 7ba7          .dw XT_ICELLPLUS
00055e 73c1          .dw XT_FETCHI
00055f 01e4          .dw XT_COMMA
000560 7020          .dw XT_EXIT
                 .endif
                 .include "words/2r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_2R_FETCH:
000561 ff03          .dw $ff03
000562 7232
000563 0040          .db "2r@",0
000564 054c          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FETCH
                 XT_2R_FETCH:
000565 0566          .dw PFA_2R_FETCH
                 PFA_2R_FETCH:
000566 939a
000567 938a          savetos
000568 91ef          pop zl
000569 91ff          pop zh
00056a 918f          pop tosl
00056b 919f          pop tosh
00056c 939f          push tosh
00056d 938f          push tosl
00056e 93ff          push zh
00056f 93ef          push zl
000570 939a
000571 938a          savetos
000572 01cf          movw tosl, zl
000573 940c 7005     jmp_ DO_NEXT
                 
                 .set DPSTART = pc
                 .if(pc>AMFORTH_RO_SEG)
                 .endif
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
007001 93bf          push XH
007002 93af          push XL          ; PUSH IP
007003 01db          movw XL, wl
007004 9611          adiw xl, 1
                 DO_NEXT:
                 .if WANT_INTERRUPTS == 1
007005 14b2          cp isrflag, zerol
007006 f469          brne DO_INTERRUPT
                 .endif
007007 01fd          movw zl, XL        ; READ IP
007008 0fee
007009 1fff
00700a 9165
00700b 9175          readflashcell wl, wh
00700c 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00700d 01fb          movw zl, wl
00700e 0fee
00700f 1fff
007010 9105
007011 9115          readflashcell temp0,temp1
007012 01f8          movw zl, temp0
007013 9409          ijmp
                 
                 .if WANT_INTERRUPTS == 1
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
007014 939a
007015 938a          savetos
007016 2d8b          mov tosl, isrflag
007017 24bb          clr isrflag
007018 2799          clr tosh
007019 ea6d          ldi wl, LOW(XT_ISREXEC)
00701a e77d          ldi wh, HIGH(XT_ISREXEC)
00701b cff1          rjmp DO_EXECUTE
                 .endif
                 .include "dict/nrww.inc"
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
00701c ff04          .dw $ff04
00701d 7865
00701e 7469          .db "exit"
00701f 0561          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
007020 7021          .dw PFA_EXIT
                 PFA_EXIT:
007021 91af          pop XL
007022 91bf          pop XH
007023 cfe1          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
007024 ff07          .dw $ff07
007025 7865
007026 6365
007027 7475
007028 0065          .db "execute",0
007029 701c          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
00702a 702b          .dw PFA_EXECUTE
                 PFA_EXECUTE:
00702b 01bc          movw wl, tosl
00702c 9189
00702d 9199          loadtos
00702e cfde          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
00702f 7030          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
007030 01fd          movw zl, XL
007031 0fee
007032 1fff
007033 91a5
007034 91b5          readflashcell XL,XH
007035 cfcf          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
007036 7037          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
007037 2b98          or tosh, tosl
007038 9189
007039 9199          loadtos
00703a f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
00703b 9611          adiw XL, 1
00703c cfc8          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
00703d 703e          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
00703e 939a
00703f 938a          savetos
007040 01fd          movw zl, xl
007041 0fee
007042 1fff
007043 9185
007044 9195          readflashcell tosl,tosh
007045 9611          adiw xl, 1
007046 cfbe          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
007047 7048          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
007048 939a
007049 938a          savetos
00704a 01fb          movw zl, wl
00704b 9631          adiw zl,1
00704c 0fee
00704d 1fff
00704e 9185
00704f 9195          readflashcell tosl,tosh
007050 cfb4          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
007051 7052          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
007052 939a
007053 938a          savetos
007054 01cb          movw tosl, wl
007055 9601          adiw tosl, 1
007056 cfae          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
007057 7058          .dw PFA_DOUSER
                 PFA_DOUSER:
007058 939a
007059 938a          savetos
00705a 01fb          movw zl, wl
00705b 9631          adiw zl, 1
00705c 0fee
00705d 1fff
00705e 9185
00705f 9195          readflashcell tosl,tosh
007060 0d84          add tosl, upl
007061 1d95          adc tosh, uph
007062 cfa2          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
007063 ff07          .dw $ff07
007064 7628
007065 6c61
007066 6575
007067 0029          .db "(value)", 0
007068 7024          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
007069 7001          .dw DO_COLON
                 PFA_DOVALUE:
00706a 01ab          .dw XT_DOCREATE
00706b 0316          .dw XT_REVEAL
00706c 01d9          .dw XT_COMPILE
00706d 706f          .dw PFA_DOVALUE1
00706e 7020          .dw XT_EXIT
                 PFA_DOVALUE1:
00706f 940e 032f     call_ DO_DODOES
007071 70b1          .dw XT_DUP
007072 7ba7          .dw XT_ICELLPLUS
007073 73c1          .dw XT_FETCHI
007074 702a          .dw XT_EXECUTE
007075 7020          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
007076 ff01          .dw $ff01
007077 0040          .db "@",0
007078 7063          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
007079 707a          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
00707a 01fc          movw zl, tosl
                     ; low byte is read before the high byte
00707b 9181          ld tosl, z+
00707c 9191          ld tosh, z+
00707d cf87          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
00707e ff01          .dw $ff01
00707f 0021          .db "!",0
007080 7076          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
007081 7082          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
007082 01fc          movw zl, tosl
007083 9189
007084 9199          loadtos
                     ; the high byte is written before the low byte
007085 8391          std Z+1, tosh
007086 8380          std Z+0, tosl
007087 9189
007088 9199          loadtos
007089 cf7b          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
00708a ff02          .dw $ff02
00708b 2163          .db "c!"
00708c 707e          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
00708d 708e          .dw PFA_CSTORE
                 PFA_CSTORE:
00708e 01fc          movw zl, tosl
00708f 9189
007090 9199          loadtos
007091 8380          st Z, tosl
007092 9189
007093 9199          loadtos
007094 cf70          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
007095 ff02          .dw $ff02
007096 4063          .db "c@"
007097 708a          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
007098 7099          .dw PFA_CFETCH
                 PFA_CFETCH:
007099 01fc          movw zl, tosl
00709a 2799          clr tosh
00709b 8180          ld tosl, Z
00709c cf68          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
00709d ff02          .dw $ff02
00709e 7540          .db "@u"
00709f 7095          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
0070a0 7001          .dw DO_COLON
                 PFA_FETCHU:
0070a1 7302          .dw XT_UP_FETCH
0070a2 719d          .dw XT_PLUS
0070a3 7079          .dw XT_FETCH
0070a4 7020          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
0070a5 ff02          .dw $ff02
0070a6 7521          .db "!u"
0070a7 709d          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
0070a8 7001          .dw DO_COLON
                 PFA_STOREU:
0070a9 7302          .dw XT_UP_FETCH
0070aa 719d          .dw XT_PLUS
0070ab 7081          .dw XT_STORE
0070ac 7020          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
0070ad ff03          .dw $ff03
0070ae 7564
0070af 0070          .db "dup",0
0070b0 70a5          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
0070b1 70b2          .dw PFA_DUP
                 PFA_DUP:
0070b2 939a
0070b3 938a          savetos
0070b4 cf50          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
0070b5 ff04          .dw $ff04
0070b6 643f
0070b7 7075          .db "?dup"
0070b8 70ad          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
0070b9 70ba          .dw PFA_QDUP
                 PFA_QDUP:
0070ba 2f08          mov temp0, tosl
0070bb 2b09          or temp0, tosh
0070bc f011          breq PFA_QDUP1
0070bd 939a
0070be 938a          savetos
                 PFA_QDUP1:
0070bf cf45          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
0070c0 ff04          .dw $ff04
0070c1 7773
0070c2 7061          .db "swap"
0070c3 70b5          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
0070c4 70c5          .dw PFA_SWAP
                 PFA_SWAP:
0070c5 018c          movw temp0, tosl
0070c6 9189
0070c7 9199          loadtos
0070c8 931a          st -Y, temp1
0070c9 930a          st -Y, temp0
0070ca cf3a          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
0070cb ff04          .dw $ff04
0070cc 766f
0070cd 7265          .db "over"
0070ce 70c0          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
0070cf 70d0          .dw PFA_OVER
                 PFA_OVER:
0070d0 939a
0070d1 938a          savetos
0070d2 818a          ldd tosl, Y+2
0070d3 819b          ldd tosh, Y+3
                 
0070d4 cf30          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
0070d5 ff04          .dw $ff04
0070d6 7264
0070d7 706f          .db "drop"
0070d8 70cb          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
0070d9 70da          .dw PFA_DROP
                 PFA_DROP:
0070da 9189
0070db 9199          loadtos
0070dc cf28          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
0070dd ff03          .dw $ff03
0070de 6f72
0070df 0074          .db "rot",0
0070e0 70d5          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
0070e1 70e2          .dw PFA_ROT
                 PFA_ROT:
0070e2 018c          movw temp0, tosl
0070e3 9129          ld temp2, Y+
0070e4 9139          ld temp3, Y+ 
0070e5 9189
0070e6 9199          loadtos
                         
0070e7 933a          st -Y, temp3
0070e8 932a          st -Y, temp2
0070e9 931a          st -Y, temp1
0070ea 930a          st -Y, temp0
                 
0070eb cf19          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
0070ec ff03          .dw $ff03
0070ed 696e
0070ee 0070          .db "nip",0
0070ef 70dd          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
0070f0 70f1          .dw PFA_NIP
                 PFA_NIP:
0070f1 9622          adiw yl, 2
0070f2 cf12          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
0070f3 ff02          .dw $ff02
0070f4 3e72          .db "r>"
0070f5 70ec          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
0070f6 70f7          .dw PFA_R_FROM
                 PFA_R_FROM:
0070f7 939a
0070f8 938a          savetos
0070f9 918f          pop tosl
0070fa 919f          pop tosh
0070fb cf09          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
0070fc ff02          .dw $ff02
0070fd 723e          .db ">r"
0070fe 70f3          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
0070ff 7100          .dw PFA_TO_R
                 PFA_TO_R:
007100 939f          push tosh
007101 938f          push tosl
007102 cfd7          jmp_ PFA_DROP
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
007103 ff02          .dw $ff02
007104 4072          .db "r@"
007105 70fc          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
007106 7107          .dw PFA_R_FETCH
                 PFA_R_FETCH:
007107 939a
007108 938a          savetos
007109 918f          pop tosl
00710a 919f          pop tosh
00710b 939f          push tosh
00710c 938f          push tosl
00710d cef7          jmp_ DO_NEXT
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
00710e ff02          .dw $ff02
00710f 3e3c          .db "<>"
007110 7103          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
007111 7001          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
007112 73d6
007113 7118
007114 7020          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
007115 ff02          .dw $ff02
007116 3d30          .db "0="
007117 710e          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
007118 7119          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
007119 2b98          or tosh, tosl
00711a f5e1          brne PFA_ZERO1
00711b c032          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
00711c ff02          .dw $ff02
00711d 3c30          .db "0<"
00711e 7115          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
00711f 7120          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
007120 fd97          sbrc tosh,7
007121 c02c          rjmp PFA_TRUE1
007122 c034          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
007123 ff02          .dw $ff02
007124 3e30          .db "0>"
007125 711c          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
007126 7127          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
007127 1582          cp tosl, zerol
007128 0593          cpc tosh, zeroh
007129 f16c          brlt PFA_ZERO1
00712a f161          brbs 1, PFA_ZERO1
00712b c022          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
00712c ff03          .dw $ff03
00712d 3064
00712e 003e          .db "d0>",0
00712f 7123          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
007130 7131          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
007131 1593          cp tosh, zeroh
007132 f03c          brlt PFA_DGREATERZERO_FALSE ; if MSBit is set, d:arg is negative, we are done (false).
007133 0582          cpc tosl, zerol
007134 9189
007135 9199          loadtos
007136 0582          cpc tosl, zerol
007137 0593          cpc tosh, zeroh
007138 f0f1          brbs 1, PFA_ZERO1           ; if all 4 Bytes of d:arg are zero, we are done (false).
007139 c014          rjmp PFA_TRUE1              ; if we get this far, d:arg was positive! (true)
                 PFA_DGREATERZERO_FALSE:
00713a 01c1          movw tosl, zerol            ; ZERO
00713b cfb5          rjmp PFA_NIP                ; NIP
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
00713c ff03          .dw $ff03
00713d 3064
00713e 003c          .db "d0<",0
00713f 712c          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
007140 7141          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
007141 9622          adiw Y,2
007142 fd97          sbrc tosh,7
007143 940c 714e     jmp PFA_TRUE1
007145 940c 7157     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
007147 ff04          .dw $ff04
007148 7274
007149 6575          .db "true"
00714a 713c          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
00714b 714c          .dw PFA_TRUE
                 PFA_TRUE:
00714c 939a
00714d 938a          savetos
                 PFA_TRUE1:
00714e ef8f          ser tosl
00714f ef9f          ser tosh
007150 ceb4          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
007151 ff01          .dw $ff01
007152 0030          .db "0",0
007153 7147          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
007154 7155          .dw PFA_ZERO
                 PFA_ZERO:
007155 939a
007156 938a          savetos
                 PFA_ZERO1:
007157 01c1          movw tosl, zerol
007158 ceac          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
007159 ff02          .dw $ff02
00715a 3c75          .db "u<"
00715b 7151          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
00715c 715d          .dw PFA_ULESS
                 PFA_ULESS:
00715d 9129          ld temp2, Y+
00715e 9139          ld temp3, Y+
00715f 1782          cp tosl, temp2
007160 0793          cpc tosh, temp3
007161 f3a8          brlo PFA_ZERO1
007162 f3a1          brbs 1, PFA_ZERO1
007163 cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
007164 ff02          .dw $ff02
007165 3e75          .db "u>"
007166 7159          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
007167 7001          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
007168 70c4          .DW XT_SWAP
007169 715c          .dw XT_ULESS
00716a 7020          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
00716b ff01          .dw $ff01
00716c 003c          .db "<",0
00716d 7164          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
00716e 716f          .dw PFA_LESS
                 PFA_LESS:
00716f 9129          ld temp2, Y+
007170 9139          ld temp3, Y+
007171 1728          cp temp2, tosl
007172 0739          cpc temp3, tosh
                 PFA_LESSDONE:
007173 f71c          brge PFA_ZERO1
007174 cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
007175 ff01          .dw $ff01
007176 003e          .db ">",0
007177 716b          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
007178 7179          .dw PFA_GREATER
                 PFA_GREATER:
007179 9129          ld temp2, Y+
00717a 9139          ld temp3, Y+
00717b 1728          cp temp2, tosl
00717c 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
00717d f2cc          brlt PFA_ZERO1
00717e f2c1          brbs 1, PFA_ZERO1
00717f cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
007180 ff04          .dw $ff04
007181 6f6c
007182 3267          .db "log2"
007183 7175          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
007184 7185          .dw PFA_LOG2
                 PFA_LOG2:
007185 01fc          movw zl, tosl
007186 2799          clr tosh
007187 e180          ldi tosl, 16
                 PFA_LOG2_1:
007188 958a          dec tosl
007189 f022          brmi PFA_LOG2_2 ; wrong data
00718a 0fee          lsl  zl
00718b 1fff          rol  zh
00718c f7d8          brcc PFA_LOG2_1
00718d ce77          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
00718e 959a          dec tosh
00718f ce75          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
007190 ff01          .dw $ff01
007191 002d          .db "-",0
007192 7180          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
007193 7194          .dw PFA_MINUS
                 PFA_MINUS:
007194 9109          ld temp0, Y+
007195 9119          ld temp1, Y+
007196 1b08          sub temp0, tosl
007197 0b19          sbc temp1, tosh
007198 01c8          movw tosl, temp0
007199 ce6b          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
00719a ff01          .dw $ff01
00719b 002b          .db "+",0
00719c 7190          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
00719d 719e          .dw PFA_PLUS
                 PFA_PLUS:
00719e 9109          ld temp0, Y+
00719f 9119          ld temp1, Y+
0071a0 0f80          add tosl, temp0
0071a1 1f91          adc tosh, temp1
0071a2 ce62          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
0071a3 ff02          .dw $ff02
0071a4 2a6d          .db "m*"
0071a5 719a          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
0071a6 71a7          .dw PFA_MSTAR
                 PFA_MSTAR:
0071a7 018c          movw temp0, tosl
0071a8 9189
0071a9 9199          loadtos
0071aa 019c          movw temp2, tosl
                     ; high cell ah*bh
0071ab 0231          muls temp3, temp1
0071ac 0170          movw temp4, r0
                     ; low cell  al*bl
0071ad 9f20          mul  temp2, temp0
0071ae 01c0          movw tosl, r0
                     ; signed ah*bl
0071af 0330          mulsu temp3, temp0
0071b0 08f3          sbc   temp5, zeroh
0071b1 0d90          add   tosh,  r0
0071b2 1ce1          adc   temp4, r1
0071b3 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
0071b4 0312          mulsu temp1, temp2
0071b5 08f3          sbc   temp5, zeroh
0071b6 0d90          add   tosh,  r0
0071b7 1ce1          adc   temp4, r1
0071b8 1cf3          adc   temp5, zeroh
                 
0071b9 939a
0071ba 938a          savetos
0071bb 01c7          movw tosl, temp4
0071bc ce48          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
0071bd ff06          .dw $ff06
0071be 6d75
0071bf 6d2f
0071c0 646f          .db "um/mod"
0071c1 71a3          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
0071c2 71c3          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
0071c3 017c          movw temp4, tosl
                 
0071c4 9129          ld temp2, Y+
0071c5 9139          ld temp3, Y+
                   
0071c6 9109          ld temp0, Y+
0071c7 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
0071c8 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
0071c9 2755          clr temp7
0071ca 0f00          lsl temp0
0071cb 1f11          rol temp1
0071cc 1f22          rol temp2
0071cd 1f33          rol temp3
0071ce 1f55          rol temp7
                 
                   ; try subtracting divisor
0071cf 152e          cp temp2, temp4
0071d0 053f          cpc temp3, temp5
0071d1 0552          cpc temp7,zerol
                 
0071d2 f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
0071d3 9503          inc temp0
0071d4 192e          sub temp2, temp4
0071d5 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
0071d6 954a          dec  temp6
0071d7 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
0071d8 933a          st -Y,temp3
0071d9 932a          st -Y,temp2
                 
                     ; put quotient on stack
0071da 01c8          movw tosl, temp0
0071db ce29          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
0071dc ff03          .dw $ff03
0071dd 6d75
0071de 002a          .db "um*",0
0071df 71bd          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
0071e0 71e1          .dw PFA_UMSTAR
                 PFA_UMSTAR:
0071e1 018c          movw temp0, tosl
0071e2 9189
0071e3 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
0071e4 9f80          mul tosl,temp0
0071e5 01f0          movw zl, r0
0071e6 2722          clr temp2
0071e7 2733          clr temp3
                     ; middle bytes
0071e8 9f90          mul tosh, temp0
0071e9 0df0          add zh, r0
0071ea 1d21          adc temp2, r1
0071eb 1d33          adc temp3, zeroh
                         
0071ec 9f81          mul tosl, temp1
0071ed 0df0          add zh, r0
0071ee 1d21          adc temp2, r1
0071ef 1d33          adc temp3, zeroh
                     
0071f0 9f91          mul tosh, temp1
0071f1 0d20          add temp2, r0
0071f2 1d31          adc temp3, r1
0071f3 01cf          movw tosl, zl
0071f4 939a
0071f5 938a          savetos
0071f6 01c9          movw tosl, temp2
0071f7 ce0d          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
0071f8 ff06          .dw $ff06
0071f9 6e69
0071fa 6576
0071fb 7472          .db "invert"
0071fc 71dc          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
0071fd 71fe          .dw PFA_INVERT
                 PFA_INVERT:
0071fe 9580          com tosl
0071ff 9590          com tosh
007200 ce04          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
007201 ff02          .dw $ff02
007202 2f32          .db "2/"
007203 71f8          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
007204 7205          .dw PFA_2SLASH
                 PFA_2SLASH:
007205 9595          asr tosh
007206 9587          ror tosl
007207 cdfd          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
007208 ff02          .dw $ff02
007209 2a32          .db "2*"
00720a 7201          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
00720b 720c          .dw PFA_2STAR
                 PFA_2STAR:
00720c 0f88          lsl tosl
00720d 1f99          rol tosh
00720e cdf6          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
00720f ff03          .dw $ff03
007210 6e61
007211 0064          .db "and",0
007212 7208          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
007213 7214          .dw PFA_AND
                 PFA_AND:
007214 9109          ld temp0, Y+
007215 9119          ld temp1, Y+
007216 2380          and tosl, temp0
007217 2391          and tosh, temp1
007218 cdec          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
007219 ff02          .dw $ff02
00721a 726f          .db "or"
00721b 720f          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
00721c 721d          .dw PFA_OR
                 PFA_OR:
00721d 9109          ld temp0, Y+
00721e 9119          ld temp1, Y+
00721f 2b80          or tosl, temp0
007220 2b91          or tosh, temp1
007221 cde3          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
007222 ff03          .dw $ff03
007223 6f78
007224 0072          .db "xor",0
007225 7219          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
007226 7227          .dw PFA_XOR
                 PFA_XOR:
007227 9109          ld temp0, Y+
007228 9119          ld temp1, Y+
007229 2780          eor tosl, temp0
00722a 2791          eor tosh, temp1
00722b cdd9          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
00722c ff02          .dw $ff02
00722d 2b31          .db "1+"
00722e 7222          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
00722f 7230          .dw PFA_1PLUS
                 PFA_1PLUS:
007230 9601          adiw tosl,1
007231 cdd3          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
007232 ff02          .dw $ff02 
007233 2d31          .db "1-"
007234 722c          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
007235 7236          .dw PFA_1MINUS
                 PFA_1MINUS:
007236 9701          sbiw tosl, 1
007237 cdcd          jmp_ DO_NEXT
                 .include "words/q-negate.asm"
                 
                 ;   0< IF NEGATE THEN ;        ...a common factor
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QNEGATE:
007238 ff07          .dw $ff07
007239 6e3f
00723a 6765
00723b 7461
../../common\words/q-negate.asm(11): warning: .cseg .db misalignment - padding zero byte
00723c 0065          .db "?negate"
00723d 7232          .dw VE_HEAD
                     .set VE_HEAD = VE_QNEGATE
                 XT_QNEGATE:
00723e 7001          .dw DO_COLON
                 PFA_QNEGATE:
                 
                 .endif
00723f 711f
007240 7036              .DW XT_ZEROLESS,XT_DOCONDBRANCH
007241 7243              DEST(QNEG1)
007242 7620              .DW XT_NEGATE
007243 7020      QNEG1:  .DW XT_EXIT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
007244 ff06          .dw $ff06
007245 736c
007246 6968
007247 7466          .db "lshift"
007248 7238          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
007249 724a          .dw PFA_LSHIFT
                 PFA_LSHIFT:
00724a 01fc          movw zl, tosl
00724b 9189
00724c 9199          loadtos
                 PFA_LSHIFT1:
00724d 9731          sbiw zl, 1
00724e f01a          brmi PFA_LSHIFT2
00724f 0f88          lsl tosl
007250 1f99          rol tosh
007251 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
007252 cdb2          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
007253 ff06          .dw $ff06
007254 7372
007255 6968
007256 7466          .db "rshift"
007257 7244          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
007258 7259          .dw PFA_RSHIFT
                 PFA_RSHIFT:
007259 01fc          movw zl, tosl
00725a 9189
00725b 9199          loadtos
                 PFA_RSHIFT1:
00725c 9731          sbiw zl, 1
00725d f01a          brmi PFA_RSHIFT2
00725e 9596          lsr tosh
00725f 9587          ror tosl
007260 cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
007261 cda3          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
007262 ff02          .dw $ff02
007263 212b          .db "+!"
007264 7253          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
007265 7266          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
007266 01fc          movw zl, tosl
007267 9189
007268 9199          loadtos
007269 8120          ldd temp2, Z+0
00726a 8131          ldd temp3, Z+1
00726b 0f82          add tosl, temp2
00726c 1f93          adc tosh, temp3
00726d 8380          std Z+0, tosl
00726e 8391          std Z+1, tosh
00726f 9189
007270 9199          loadtos
007271 cd93          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
007272 ff03          .dw $ff03
007273 7072
007274 0040          .db "rp@",0
007275 7262          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
007276 7277          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
007277 939a
007278 938a          savetos
007279 b78d          in tosl, SPL
00727a b79e          in tosh, SPH
00727b cd89          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
00727c ff03          .dw $ff03
00727d 7072
00727e 0021          .db "rp!",0
00727f 7272          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
007280 7281          .dw PFA_RP_STORE
                 PFA_RP_STORE:
007281 b72f          in temp2, SREG
007282 94f8          cli
007283 bf8d          out SPL, tosl
007284 bf9e          out SPH, tosh
007285 bf2f          out SREG, temp2
007286 9189
007287 9199          loadtos
007288 cd7c          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
007289 ff03          .dw $ff03
00728a 7073
00728b 0040          .db "sp@",0
00728c 727c          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
00728d 728e          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
00728e 939a
00728f 938a          savetos
007290 01ce          movw tosl, yl
007291 cd73          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
007292 ff03          .dw $ff03
007293 7073
007294 0021          .db "sp!",0
007295 7289          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
007296 7297          .dw PFA_SP_STORE
                 PFA_SP_STORE:
007297 01ec          movw yl, tosl
007298 9189
007299 9199          loadtos
00729a cd6a          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
00729b 729c          .dw PFA_DODO
                 PFA_DODO:
00729c 9129          ld temp2, Y+
00729d 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
00729e e8e0          ldi zl, $80
00729f 0f3e          add temp3, zl
0072a0 1b82          sub  tosl, temp2
0072a1 0b93          sbc  tosh, temp3
                 
0072a2 933f          push temp3
0072a3 932f          push temp2    ; limit  ( --> limit + $8000)
0072a4 939f          push tosh
0072a5 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
0072a6 9189
0072a7 9199          loadtos
0072a8 cd5c          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
0072a9 ff01          .dw $FF01
0072aa 0069          .db "i",0
0072ab 7292          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
0072ac 72ad          .dw PFA_I
                 PFA_I:
0072ad 939a
0072ae 938a          savetos
0072af 918f          pop tosl
0072b0 919f          pop tosh  ; index
0072b1 91ef          pop zl
0072b2 91ff          pop zh    ; limit
0072b3 93ff          push zh
0072b4 93ef          push zl
0072b5 939f          push tosh
0072b6 938f          push tosl
0072b7 0f8e          add tosl, zl
0072b8 1f9f          adc tosh, zh
0072b9 cd4b          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
0072ba 72bb          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
0072bb 91ef          pop zl
0072bc 91ff          pop zh
0072bd 0fe8          add zl, tosl
0072be 1ff9          adc zh, tosh
0072bf 9189
0072c0 9199          loadtos
0072c1 f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
0072c2 93ff          push zh
0072c3 93ef          push zl
0072c4 cd6b          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
0072c5 910f          pop  temp0
0072c6 911f          pop  temp1  ; remove limit
0072c7 9611          adiw xl, 1  ; skip branch-back address
0072c8 cd3c          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
0072c9 72ca          .dw PFA_DOLOOP
                 PFA_DOLOOP:
0072ca 91ef          pop zl
0072cb 91ff          pop zh
0072cc 9631          adiw zl,1
0072cd f3bb          brvs PFA_DOPLUSLOOP_LEAVE
0072ce cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
0072cf ff06          .dw $ff06
0072d0 6e75
0072d1 6f6c
0072d2 706f          .db "unloop"
0072d3 72a9          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
0072d4 72d5          .dw PFA_UNLOOP
                 PFA_UNLOOP:
0072d5 911f          pop temp1
0072d6 910f          pop temp0
0072d7 911f          pop temp1
0072d8 910f          pop temp0
0072d9 cd2b          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
0072da ff06          .dw $ff06
0072db 6d63
0072dc 766f
0072dd 3e65          .db "cmove>"
0072de 72cf          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
0072df 72e0          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
0072e0 93bf          push xh
0072e1 93af          push xl
0072e2 91e9          ld zl, Y+
0072e3 91f9          ld zh, Y+ ; addr-to
0072e4 91a9          ld xl, Y+
0072e5 91b9          ld xh, Y+ ; addr-from
0072e6 2f09          mov temp0, tosh
0072e7 2b08          or temp0, tosl
0072e8 f041          brbs 1, PFA_CMOVE_G1
0072e9 0fe8          add zl, tosl
0072ea 1ff9          adc zh, tosh
0072eb 0fa8          add xl, tosl
0072ec 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
0072ed 911e          ld temp1, -X
0072ee 9312          st -Z, temp1
0072ef 9701          sbiw tosl, 1
0072f0 f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
0072f1 91af          pop xl
0072f2 91bf          pop xh
0072f3 9189
0072f4 9199          loadtos
0072f5 cd0f          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
0072f6 ff02          .dw $ff02
0072f7 3c3e          .db "><"
0072f8 72da          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
0072f9 72fa          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
0072fa 2f09          mov temp0, tosh
0072fb 2f98          mov tosh, tosl
0072fc 2f80          mov tosl, temp0
0072fd cd07          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
0072fe ff03          .dw $ff03
0072ff 7075
007300 0040          .db "up@",0
007301 72f6          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
007302 7303          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
007303 939a
007304 938a          savetos
007305 01c2          movw tosl, upl
007306 ccfe          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
007307 ff03          .dw $ff03
007308 7075
007309 0021          .db "up!",0
00730a 72fe          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
00730b 730c          .dw PFA_UP_STORE
                 PFA_UP_STORE:
00730c 012c          movw upl, tosl
00730d 9189
00730e 9199          loadtos
00730f ccf5          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
007310 ff03          .dw $ff03
007311 3e32
007312 0072          .db "2>r",0
007313 7307          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
007314 7315          .dw PFA_2TO_R
                 PFA_2TO_R:
007315 01fc          movw zl, tosl
007316 9189
007317 9199          loadtos
007318 939f          push tosh
007319 938f          push tosl
00731a 93ff          push zh
00731b 93ef          push zl
00731c 9189
00731d 9199          loadtos
00731e cce6          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
00731f ff03          .dw $ff03
007320 7232
007321 003e          .db "2r>",0
007322 7310          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
007323 7324          .dw PFA_2R_FROM
                 PFA_2R_FROM:
007324 939a
007325 938a          savetos
007326 91ef          pop zl
007327 91ff          pop zh
007328 918f          pop tosl
007329 919f          pop tosh
00732a 939a
00732b 938a          savetos
00732c 01cf          movw tosl, zl
00732d ccd7          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
00732e ff02          .dw $ff02
00732f 6521          .db "!e"
007330 731f          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
007331 7332          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
007332 01fc          movw zl, tosl
007333 9189
007334 9199          loadtos
007335 b72f          in_ temp2, SREG
007336 94f8          cli
007337 d028          rcall PFA_FETCHE2
007338 b500          in_  temp0, EEDR
007339 1708          cp temp0,tosl
00733a f009          breq PFA_STOREE3
00733b d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
00733c 9631          adiw zl,1
00733d d022          rcall PFA_FETCHE2
00733e b500          in_  temp0, EEDR
00733f 1709          cp temp0,tosh
007340 f011          breq PFA_STOREE4
007341 2f89          mov tosl, tosh
007342 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
007343 bf2f          out_ SREG, temp2
007344 9189
007345 9199          loadtos
007346 ccbe          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
007347 99f9          sbic EECR, EEPE
007348 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
007349 b707          in_ temp0, SPMCSR
00734a fd00          sbrc temp0,SPMEN
00734b cffd          rjmp PFA_STOREE2
                 
00734c bdf2          out_ EEARH,zh
00734d bde1          out_ EEARL,zl
00734e bd80          out_ EEDR, tosl
00734f 9afa          sbi EECR,EEMPE
007350 9af9          sbi EECR,EEPE
                 
007351 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
007352 ff02          .dw $ff02
007353 6540          .db "@e"
007354 732e          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
007355 7356          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
007356 b72f          in_ temp2, SREG
007357 94f8          cli
007358 01fc          movw zl, tosl
007359 d006          rcall PFA_FETCHE2
00735a b580          in_ tosl, EEDR
                 
00735b 9631          adiw zl,1
                 
00735c d003          rcall PFA_FETCHE2
00735d b590          in_  tosh, EEDR
00735e bf2f          out_ SREG, temp2
00735f cca5          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
007360 99f9          sbic EECR, EEPE
007361 cffe          rjmp PFA_FETCHE2
                 
007362 bdf2          out_ EEARH,zh
007363 bde1          out_ EEARL,zl
                 
007364 9af8          sbi EECR,EERE
007365 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
007366 ff02          .dw $ff02
007367 6921          .db "!i"
007368 7352          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
007369 7c0f          .dw PFA_DODEFER1
                 PFA_STOREI:
00736a 006a          .dw EE_STOREI
00736b 7bb0          .dw XT_EDEFERFETCH
00736c 7bba          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                 .else
                   .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
00736d ff09          .dw $ff09
00736e 2128
00736f 2d69
007370 726e
007371 7777
007372 0029          .db "(!i-nrww)",0
007373 7366          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
007374 7375          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
007375 b71f        in temp1,SREG
007376 931f        push temp1
007377 94f8        cli
                 
007378 019c        movw temp2, tosl ; save the (word) address
007379 9189
00737a 9199        loadtos          ; get the new value for the flash cell
00737b 93af        push xl
00737c 93bf        push xh
00737d 93cf        push yl
00737e 93df        push yh
00737f d009        rcall DO_STOREI_atmega
007380 91df        pop yh
007381 91cf        pop yl
007382 91bf        pop xh
007383 91af        pop xl
                   ; finally clear the stack
007384 9189
007385 9199        loadtos
007386 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
007387 bf1f        out SREG,temp1
                 
007388 cc7c        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
007389 d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
00738a 94e0        com temp4
00738b 94f0        com temp5
00738c 218e        and tosl, temp4
00738d 219f        and tosh, temp5
00738e 2b98        or tosh, tosl
00738f f019        breq DO_STOREI_writepage 
007390 01f9          movw zl, temp2
007391 e002          ldi temp0,(1<<PGERS)
007392 d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
007393 01f9        movw zl, temp2
007394 e004        ldi temp0,(1<<PGWRT)
007395 d01d        rcall dospm
                 
                   ; reenable RWW section
007396 01f9        movw zl, temp2
007397 e100        ldi temp0,(1<<RWWSRE)
007398 d01a        rcall dospm
007399 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
00739a 01f9        movw zl, temp2
                   ; get the beginning of page
00739b 78e0        andi zl,low(pagemask)
00739c 7fff        andi zh,high(pagemask)
00739d 01ef        movw y, z
                   ; loop counter (in words)
00739e e8a0        ldi xl,low(pagesize)
00739f e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
0073a0 01fe        movw z, y
0073a1 0fee
0073a2 1fff
0073a3 9145
0073a4 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
0073a5 01fe        movw z, y
0073a6 17e2        cp zl, temp2
0073a7 07f3        cpc zh, temp3
0073a8 f011        breq pageload_newdata
0073a9 010a          movw r0, temp6
0073aa c002          rjmp pageload_cont
                 pageload_newdata:
0073ab 017a          movw temp4, temp6
0073ac 010c          movw r0, tosl
                 pageload_cont:
0073ad 2700        clr temp0
0073ae d004        rcall dospm
0073af 9621        adiw y, 1
0073b0 9711        sbiw x, 1
0073b1 f771        brne pageload_loop
                 
                 pageload_done:
0073b2 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
0073b3 99f9        sbic EECR, EEPE
0073b4 cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
0073b5 b717        in_  temp1, SPMCSR
0073b6 fd10        sbrc temp1, SPMEN
0073b7 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
0073b8 0fee
0073b9 1fff        writeflashcell
                   ; execute spm
0073ba 6001        ori temp0, (1<<SPMEN)
0073bb bf07        out_ SPMCSR,temp0
0073bc 95e8        spm
0073bd 9508        ret
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
0073be ff02          .dw $ff02
0073bf 6940          .db "@i"
0073c0 736d          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
0073c1 73c2          .dw PFA_FETCHI
                 PFA_FETCHI:
0073c2 01fc          movw zl, tosl
0073c3 0fee
0073c4 1fff
0073c5 9185
0073c6 9195          readflashcell tosl,tosh
0073c7 cc3d          jmp_ DO_NEXT
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2LITERAL:
0073c8 0008          .dw $0008
0073c9 6c32
0073ca 7469
0073cb 7265
0073cc 6c61          .db "2literal"
0073cd 73be          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
0073ce 7001          .dw DO_COLON
                 PFA_2LITERAL:
                 .endif
0073cf 70c4          .dw XT_SWAP
0073d0 01fa          .dw XT_LITERAL
0073d1 01fa          .dw XT_LITERAL
0073d2 7020          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
0073d3 ff01          .dw $ff01
0073d4 003d          .db "=",0
0073d5 73c8          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
0073d6 7001          .dw DO_COLON
                 PFA_EQUAL:
0073d7 7193          .dw XT_MINUS
0073d8 7118          .dw XT_ZEROEQUAL
0073d9 7020          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
0073da ff01          .dw $ff01
0073db 0031          .db "1",0
0073dc 73d3          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
0073dd 7048          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
0073de 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
0073df ff01          .dw $ff01
0073e0 0032          .db "2",0
0073e1 73da          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
0073e2 7048          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
0073e3 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
0073e4 ff02          .dw $ff02
0073e5 312d          .db "-1"
0073e6 73df          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
0073e7 7048          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
0073e8 ffff              .DW -1
                 
                 .if AMFORTH_NRWW_SIZE>8000
                   .include "dict/core_8k.inc"
                 
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
0073e9 ff03          .dw $ff03
0073ea 3e6e
0073eb 0072          .db "n>r",0
0073ec 73e4          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
0073ed 73ee          .dw PFA_N_TO_R
                 PFA_N_TO_R:
0073ee 01fc          movw zl, tosl
0073ef 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
0073f0 9189
0073f1 9199          loadtos
0073f2 939f          push tosh
0073f3 938f          push tosl
0073f4 950a          dec temp0
0073f5 f7d1          brne PFA_N_TO_R1
0073f6 93ef          push zl
0073f7 93ff          push zh
0073f8 9189
0073f9 9199          loadtos
0073fa cc0a          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
0073fb ff03          .dw $ff03
0073fc 726e
0073fd 003e          .db "nr>",0
0073fe 73e9          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
0073ff 7400          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
007400 939a
007401 938a          savetos
007402 91ff          pop zh
007403 91ef          pop zl
007404 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
007405 918f          pop tosl
007406 919f          pop tosh
007407 939a
007408 938a          savetos
007409 950a          dec temp0
00740a f7d1          brne PFA_N_R_FROM1
00740b 01cf          movw tosl, zl
00740c cbf8          jmp_ DO_NEXT
                 
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
00740d ff03          .dw $ff03
00740e 3264
00740f 002a          .db "d2*",0
007410 73fb          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
007411 7412          .dw PFA_D2STAR
                 PFA_D2STAR:
007412 9109          ld temp0, Y+
007413 9119          ld temp1, Y+
007414 0f00          lsl temp0
007415 1f11          rol temp1
007416 1f88          rol tosl
007417 1f99          rol tosh
007418 931a          st -Y, temp1
007419 930a          st -Y, temp0
00741a cbea          jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
00741b ff03          .dw $ff03
00741c 3264
00741d 002f          .db "d2/",0
00741e 740d          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
00741f 7420          .dw PFA_D2SLASH
                 PFA_D2SLASH:
007420 9109          ld temp0, Y+
007421 9119          ld temp1, Y+
007422 9595          asr tosh
007423 9587          ror tosl
007424 9517          ror temp1
007425 9507          ror temp0
007426 931a          st -Y, temp1
007427 930a          st -Y, temp0
007428 cbdc          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
007429 ff02          .dw $ff02
00742a 2b64          .db "d+"
00742b 741b          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
00742c 742d          .dw PFA_DPLUS
                 PFA_DPLUS:
00742d 9129          ld temp2, Y+
00742e 9139          ld temp3, Y+
                 
00742f 90e9          ld temp4, Y+
007430 90f9          ld temp5, Y+
007431 9149          ld temp6, Y+
007432 9159          ld temp7, Y+
                 
007433 0f24          add temp2, temp6
007434 1f35          adc temp3, temp7
007435 1d8e          adc tosl, temp4
007436 1d9f          adc tosh, temp5
                     
007437 933a          st -Y, temp3
007438 932a          st -Y, temp2
007439 cbcb          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
00743a ff02          .dw $ff02
00743b 2d64          .db "d-"
00743c 7429          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
00743d 743e          .dw PFA_DMINUS
                 PFA_DMINUS:
00743e 9129          ld temp2, Y+
00743f 9139          ld temp3, Y+
                 
007440 90e9          ld temp4, Y+
007441 90f9          ld temp5, Y+
007442 9149          ld temp6, Y+
007443 9159          ld temp7, Y+
                 
007444 1b42          sub temp6, temp2
007445 0b53          sbc temp7, temp3
007446 0ae8          sbc temp4, tosl
007447 0af9          sbc temp5, tosh
                 
007448 935a          st -Y, temp7
007449 934a          st -Y, temp6
00744a 01c7          movw tosl, temp4
00744b cbb9          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
00744c ff07          .dw $ff07
00744d 6964
00744e 766e
00744f 7265
007450 0074          .db "dinvert",0
007451 743a          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
007452 7453          .dw PFA_DINVERT
                 PFA_DINVERT:
007453 9109          ld temp0, Y+
007454 9119          ld temp1, Y+
007455 9580          com tosl
007456 9590          com tosh
007457 9500          com temp0
007458 9510          com temp1
007459 931a          st -Y, temp1
00745a 930a          st -Y, temp0
00745b cba9          jmp_ DO_NEXT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
00745c ff02          .dw $ff02
00745d 2e75          .db "u."
00745e 744c          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
00745f 7001          .dw DO_COLON
                 PFA_UDOT:
                 .endif
007460 7154          .dw XT_ZERO
007461 770b          .dw XT_UDDOT
007462 7020          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
007463 ff03          .dw $ff03
007464 2e75
007465 0072          .db "u.r",0
007466 745c          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
007467 7001          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
007468 7154          .dw XT_ZERO
007469 70c4          .dw XT_SWAP
00746a 7714          .dw XT_UDDOTR
00746b 7020          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
00746c ff0d          .dw $ff0d
00746d 6873
00746e 776f
00746f 772d
007470 726f
007471 6c64
007472 7369
007473 0074          .db "show-wordlist",0
007474 7463          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
007475 7001          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
007476 703d          .dw XT_DOLITERAL
007477 747b          .dw XT_SHOWWORD
007478 70c4          .dw XT_SWAP
007479 7c53          .dw XT_TRAVERSEWORDLIST
00747a 7020          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
00747b 7001          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
00747c 7c6e          .dw XT_NAME2STRING
00747d 7781          .dw XT_ITYPE
00747e 77c3          .dw XT_SPACE         ; ( -- addr n)
00747f 714b          .dw XT_TRUE
007480 7020          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_WORDS:
007481 ff05          .dw $ff05
007482 6f77
007483 6472
007484 0073          .db "words",0
007485 746c          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
007486 7001          .dw DO_COLON
                 PFA_WORDS:
                 .endif
007487 703d          .dw XT_DOLITERAL
007488 0050          .dw CFG_ORDERLISTLEN+2
007489 7355          .dw XT_FETCHE
00748a 7475          .dw XT_SHOWWORDLIST
00748b 7020          .dw XT_EXIT
                 
                 
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
00748c ff04          .dw $ff04
00748d 6970
00748e 6b63          .db "pick"
00748f 7481          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
007490 7001          .dw DO_COLON
                 PFA_PICK:
                 .endif
007491 722f          .dw XT_1PLUS
007492 7539          .dw XT_CELLS
007493 728d          .dw XT_SP_FETCH
007494 719d          .dw XT_PLUS
007495 7079          .dw XT_FETCH
007496 7020          .dw XT_EXIT
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
007497 0002          .dw $0002
007498 222e          .db ".",$22
007499 748c          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
00749a 7001          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
00749b 74a2          .dw XT_SQUOTE
00749c 01d9          .dw XT_COMPILE
00749d 7781          .dw XT_ITYPE
00749e 7020          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
00749f 0002        .dw $0002
0074a0 2273        .db "s",$22
0074a1 7497        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
0074a2 7001          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
0074a3 703d          .dw XT_DOLITERAL
0074a4 0022          .dw 34   ; 0x22 
0074a5 7972          .dw XT_PARSE       ; ( -- addr n)
0074a6 752c          .dw XT_STATE
0074a7 7079          .dw XT_FETCH
0074a8 7036          .dw XT_DOCONDBRANCH
0074a9 74ab          DEST(PFA_SQUOTE1)
0074aa 0205            .dw XT_SLITERAL
                 PFA_SQUOTE1:
0074ab 7020          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
0074ac ff04          .dw $ff04
0074ad 6966
0074ae 6c6c          .db "fill"
0074af 749f          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
0074b0 7001          .dw DO_COLON
                 PFA_FILL:
0074b1 70e1          .dw XT_ROT
0074b2 70e1          .dw XT_ROT
0074b3 70b9
0074b4 7036          .dw XT_QDUP,XT_DOCONDBRANCH
0074b5 74bd          DEST(PFA_FILL2)
0074b6 7d5a          .dw XT_BOUNDS
0074b7 729b          .dw XT_DODO
                 PFA_FILL1:
0074b8 70b1          .dw XT_DUP
0074b9 72ac          .dw XT_I
0074ba 708d          .dw XT_CSTORE  ; ( -- c c-addr)
0074bb 72c9          .dw XT_DOLOOP
0074bc 74b8          .dw PFA_FILL1
                 PFA_FILL2:
0074bd 70d9          .dw XT_DROP
0074be 7020          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
0074bf ff0b          .dw $ff0b
0074c0 6e65
0074c1 6976
0074c2 6f72
0074c3 6d6e
0074c4 6e65
0074c5 0074          .db "environment",0
0074c6 74ac          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
0074c7 7048          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
0074c8 0048          .dw CFG_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
0074c9 ff09          .dw $ff09
0074ca 6f77
0074cb 6472
0074cc 696c
0074cd 7473
0074ce 0073          .db "wordlists",0
0074cf 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
0074d0 7001          .dw DO_COLON
                 PFA_ENVWORDLISTS:
0074d1 703d          .dw XT_DOLITERAL
0074d2 0008          .dw NUMWORDLISTS
0074d3 7020          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
0074d4 ff04          .dw $ff04
0074d5 702f
0074d6 6461          .db "/pad"
0074d7 74c9          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
0074d8 7001          .dw DO_COLON
                 PFA_ENVSLASHPAD:
0074d9 728d          .dw XT_SP_FETCH
0074da 7565          .dw XT_PAD
0074db 7193          .dw XT_MINUS
0074dc 7020          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENVSLASHHOLD:
0074dd ff05          .dw $ff05
0074de 682f
0074df 6c6f
0074e0 0064          .db "/hold",0
0074e1 74d4          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
0074e2 7001          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
                 .endif
0074e3 7565          .dw XT_PAD
0074e4 75a0          .dw XT_HERE
0074e5 7193          .dw XT_MINUS
0074e6 7020          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
0074e7 ff0a          .dw $ff0a
0074e8 6f66
0074e9 7472
0074ea 2d68
0074eb 616e
0074ec 656d          .db "forth-name"
0074ed 74dd          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
0074ee 7001          .dw DO_COLON
                 PFA_EN_FORTHNAME:
0074ef 774e          .dw XT_DOSLITERAL
0074f0 0007          .dw 7
                 .endif
0074f1 6d61
0074f2 6f66
0074f3 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
0074f4 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
0074f5 7020          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
0074f6 ff07          .dw $ff07
0074f7 6576
0074f8 7372
0074f9 6f69
0074fa 006e          .db "version",0
0074fb 74e7          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
0074fc 7001          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
0074fd 703d          .dw XT_DOLITERAL
0074fe 0045          .dw 69
0074ff 7020          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
007500 ff03          .dw $ff03
007501 7063
007502 0075          .db "cpu",0
007503 74f6          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
007504 7001          .dw DO_COLON
                 PFA_EN_CPU:
                 .endif
007505 703d          .dw XT_DOLITERAL
007506 003b          .dw mcu_name
007507 77ad          .dw XT_ICOUNT
007508 7020          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
007509 ff08          .dw $ff08
00750a 636d
00750b 2d75
00750c 6e69
00750d 6f66          .db "mcu-info"
00750e 7500          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
00750f 7001          .dw DO_COLON
                 PFA_EN_MCUINFO:
007510 703d          .dw XT_DOLITERAL
007511 0037          .dw mcu_info
007512 7020          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_ENVUSERSIZE:
007513 ff05          .dw $ff05
007514 752f
007515 6573
007516 0072          .db "/user",0
007517 7509          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
007518 7001          .dw DO_COLON
                 PFA_ENVUSERSIZE:
                 .endif
007519 703d          .dw XT_DOLITERAL
00751a 002e          .dw SYSUSERSIZE + APPUSERSIZE
00751b 7020          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
00751c ff05          .dw $ff05
00751d 5f66
00751e 7063
00751f 0075          .db "f_cpu",0
007520 74bf          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
007521 7001          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
007522 703d          .dw XT_DOLITERAL
007523 2400          .dw (F_CPU % 65536)
007524 703d          .dw XT_DOLITERAL
007525 00f4          .dw (F_CPU / 65536)
007526 7020          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
007527 ff05          .dw $ff05
007528 7473
007529 7461
00752a 0065          .db "state",0
00752b 751c          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
00752c 7048          .dw PFA_DOVARIABLE
                 PFA_STATE:
00752d 0136          .dw ram_state
                 
                 .dseg
000136           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
00752e ff04          .dw $ff04
00752f 6162
007530 6573          .db "base"
007531 7527          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
007532 7058          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
007533 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
007534 ff05          .dw $ff05
007535 6563
007536 6c6c
007537 0073          .db "cells",0
007538 752e          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
007539 720c          .dw PFA_2STAR
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
00753a ff05          .dw $ff05
00753b 6563
00753c 6c6c
00753d 002b          .db "cell+",0
00753e 7534          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
00753f 7540          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
007540 9602          adiw tosl, CELLSIZE
007541 cac3          jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
007542 ff04          .dw $ff04
007543 6432
007544 7075          .db "2dup"
007545 753a          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
007546 7001          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
007547 70cf          .dw XT_OVER
007548 70cf          .dw XT_OVER
007549 7020          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
00754a ff05          .dw $ff05
00754b 6432
00754c 6f72
00754d 0070          .db "2drop",0
00754e 7542          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
00754f 7001          .dw DO_COLON
                 PFA_2DROP:
                 .endif
007550 70d9          .dw XT_DROP
007551 70d9          .dw XT_DROP
007552 7020          .dw XT_EXIT
                 
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
007553 ff04          .dw $ff04
007554 7574
007555 6b63          .db "tuck"
007556 754a          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
007557 7001          .dw DO_COLON
                 PFA_TUCK:
                 .endif
007558 70c4          .dw XT_SWAP
007559 70cf          .dw XT_OVER
00755a 7020          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
00755b ff03          .dw $ff03
00755c 693e
00755d 006e          .db ">in",0
00755e 7553          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
00755f 7058          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
007560 0018          .dw USER_TO_IN
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PAD:
007561 ff03          .dw $ff03
007562 6170
007563 0064          .db "pad",0
007564 755b          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
007565 7001          .dw DO_COLON
                 PFA_PAD:
                 .endif
007566 75a0          .dw XT_HERE
007567 703d          .dw XT_DOLITERAL
007568 0028          .dw 40
007569 719d          .dw XT_PLUS
00756a 7020          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMIT:
00756b ff04          .dw $ff04
00756c 6d65
00756d 7469          .db "emit"
00756e 7561          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
00756f 7c0f          .dw PFA_DODEFER1
                 PFA_EMIT:
                 .endif
007570 000e          .dw USER_EMIT
007571 7bd8          .dw XT_UDEFERFETCH
007572 7be4          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMITQ:
007573 ff05          .dw $ff05
007574 6d65
007575 7469
007576 003f          .db "emit?",0
007577 756b          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
007578 7c0f          .dw PFA_DODEFER1
                 PFA_EMITQ:
                 .endif
007579 0010          .dw USER_EMITQ
00757a 7bd8          .dw XT_UDEFERFETCH
00757b 7be4          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEY:
00757c ff03          .dw $ff03
00757d 656b
00757e 0079          .db "key",0
00757f 7573          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
007580 7c0f          .dw PFA_DODEFER1
                 PFA_KEY:
                 .endif
007581 0012          .dw USER_KEY
007582 7bd8          .dw XT_UDEFERFETCH
007583 7be4          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEYQ:
007584 ff04          .dw $ff04
007585 656b
007586 3f79          .db "key?"
007587 757c          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
007588 7c0f          .dw PFA_DODEFER1
                 PFA_KEYQ:
                 .endif
007589 0014          .dw USER_KEYQ
00758a 7bd8          .dw XT_UDEFERFETCH
00758b 7be4          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
00758c ff02          .dw $ff02
00758d 7064          .db "dp"
00758e 7584          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
00758f 706f          .dw PFA_DOVALUE1
                 PFA_DP:
007590 003a          .dw CFG_DP
007591 7bb0          .dw XT_EDEFERFETCH
007592 7bba          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
007593 ff05          .dw $ff05
007594 6865
007595 7265
007596 0065          .db "ehere",0
007597 758c          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
007598 706f          .dw PFA_DOVALUE1
                 PFA_EHERE:
007599 003e          .dw EE_EHERE
00759a 7bb0          .dw XT_EDEFERFETCH
00759b 7bba          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
00759c ff04          .dw $ff04
00759d 6568
00759e 6572          .db "here"
00759f 7593          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
0075a0 706f          .dw PFA_DOVALUE1
                 PFA_HERE:
0075a1 003c          .dw EE_HERE
0075a2 7bb0          .dw XT_EDEFERFETCH
0075a3 7bba          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
0075a4 ff05          .dw $ff05
0075a5 6c61
0075a6 6f6c
0075a7 0074          .db "allot",0
0075a8 759c          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
0075a9 7001          .dw DO_COLON
                 PFA_ALLOT:
0075aa 75a0          .dw XT_HERE
0075ab 719d          .dw XT_PLUS
0075ac 7b95          .dw XT_DOTO
0075ad 75a1          .dw PFA_HERE
0075ae 7020          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
0075af ff03          .dw $ff03
0075b0 6962
0075b1 006e          .db "bin",0
0075b2 75a4          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
0075b3 7001          .dw DO_COLON
                 PFA_BIN:
                 .endif
0075b4 73e2          .dw XT_TWO
0075b5 7532          .dw XT_BASE
0075b6 7081          .dw XT_STORE
0075b7 7020          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
0075b8 ff07          .dw $ff07
0075b9 6564
0075ba 6963
0075bb 616d
0075bc 006c          .db "decimal",0
0075bd 75af          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
0075be 7001          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
0075bf 703d          .dw XT_DOLITERAL
0075c0 000a          .dw 10
0075c1 7532          .dw XT_BASE
0075c2 7081          .dw XT_STORE
0075c3 7020          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
0075c4 ff03          .dw $ff03
0075c5 6568
0075c6 0078          .db "hex",0
0075c7 75b8          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
0075c8 7001          .dw DO_COLON
                 PFA_HEX:
                 .endif
0075c9 703d          .dw XT_DOLITERAL
0075ca 0010          .dw 16
0075cb 7532          .dw XT_BASE
0075cc 7081          .dw XT_STORE
0075cd 7020          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
0075ce ff02          .dw $ff02
0075cf 6c62          .db "bl"
0075d0 75c4          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
0075d1 7048          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
0075d2 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
0075d3 ff07          .dw $ff07
0075d4 7574
0075d5 6e72
0075d6 656b
0075d7 0079          .db "turnkey",0
0075d8 75ce          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
0075d9 7c0f          .dw PFA_DODEFER1
                 PFA_TURNKEY:
0075da 0046          .dw CFG_TURNKEY
0075db 7bb0          .dw XT_EDEFERFETCH
0075dc 7bba          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
0075dd ff04          .dw $ff04
0075de 6d2f
0075df 646f          .db "/mod"
0075e0 75d3          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
0075e1 75e2          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
0075e2 019c          movw temp2, tosl
                     
0075e3 9109          ld temp0, Y+
0075e4 9119          ld temp1, Y+
                 
0075e5 2f41          mov	temp6,temp1	;move dividend High to sign register
0075e6 2743          eor	temp6,temp3	;xor divisor High with sign register
0075e7 ff17          sbrs	temp1,7	;if MSB in dividend set
0075e8 c004          rjmp	PFA_SLASHMOD_1
0075e9 9510          com	temp1		;    change sign of dividend
0075ea 9500          com	temp0		
0075eb 5f0f          subi	temp0,low(-1)
0075ec 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
0075ed ff37          sbrs	temp3,7	;if MSB in divisor set
0075ee c004          rjmp	PFA_SLASHMOD_2
0075ef 9530          com	temp3		;    change sign of divisor
0075f0 9520          com	temp2		
0075f1 5f2f          subi	temp2,low(-1)
0075f2 4f3f          sbci	temp3,high(-1)
0075f3 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
0075f4 18ff          sub	temp5,temp5;clear remainder High byte and carry
0075f5 e151          ldi	temp7,17	;init loop counter
                 
0075f6 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
0075f7 1f11          rol	temp1
0075f8 955a          dec	temp7		;decrement counter
0075f9 f439          brne	PFA_SLASHMOD_5		;if done
0075fa ff47          sbrs	temp6,7		;    if MSB in sign register set
0075fb c004          rjmp	PFA_SLASHMOD_4
0075fc 9510          com	temp1	;        change sign of result
0075fd 9500          com	temp0
0075fe 5f0f          subi	temp0,low(-1)
0075ff 4f1f          sbci	temp1,high(-1)
007600 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
007601 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
007602 1cff          rol	temp5
007603 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
007604 0af3          sbc	temp5,temp3	;
007605 f420          brcc	PFA_SLASHMOD_6		;if result negative
007606 0ee2          add	temp4,temp2	;    restore remainder
007607 1ef3          adc	temp5,temp3
007608 9488          clc			;    clear carry to be shifted into result
007609 cfec          rjmp	PFA_SLASHMOD_3		;else
00760a 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
00760b cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
00760c 92fa          st -Y,temp5
00760d 92ea          st -Y,temp4
                 
                     ; put quotient on stack
00760e 01c8          movw tosl, temp0
00760f c9f5          jmp_ DO_NEXT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
007610 ff05          .dw $ff05
007611 2f75
007612 6f6d
007613 0064          .db "u/mod",0
007614 75dd          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
007615 7001          .dw DO_COLON
                 PFA_USLASHMOD:
007616 70ff          .dw XT_TO_R
007617 7154          .dw XT_ZERO
007618 70f6          .dw XT_R_FROM
007619 71c2          .dw XT_UMSLASHMOD
00761a 7020          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
00761b ff06          .dw $ff06
00761c 656e
00761d 6167
00761e 6574          .db "negate"
00761f 7610          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
007620 7001          .dw DO_COLON
                 PFA_NEGATE:
007621 71fd          .dw XT_INVERT
007622 722f          .dw XT_1PLUS
007623 7020          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
007624 ff01          .dw $ff01
007625 002f          .db "/",0
007626 761b          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
007627 7001          .dw DO_COLON
                 PFA_SLASH:
                 .endif
007628 75e1          .dw XT_SLASHMOD
007629 70f0          .dw XT_NIP
00762a 7020          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
00762b ff03          .dw $ff03
00762c 6f6d
00762d 0064          .db "mod",0
00762e 7624          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
00762f 7001          .dw DO_COLON
                 PFA_MOD:
                 .endif
007630 75e1          .dw XT_SLASHMOD
007631 70d9          .dw XT_DROP
007632 7020          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ;   DUP ?NEGATE ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABS:
007633 ff03          .dw $ff03
007634 6261
007635 0073          .db "abs",0
007636 762b          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
007637 7001          .dw DO_COLON
                 PFA_ABS:
                 
                 .endif
                 
007638 70b1
007639 723e
00763a 7020          .DW XT_DUP,XT_QNEGATE,XT_EXIT
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
00763b ff03          .dw $ff03
00763c 696d
00763d 006e          .db "min",0
00763e 7633          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
00763f 7001          .dw DO_COLON
                 PFA_MIN:
                 .endif
007640 7546          .dw XT_2DUP
007641 7178          .dw XT_GREATER
007642 7036          .dw XT_DOCONDBRANCH
007643 7645          DEST(PFA_MIN1)
007644 70c4          .dw XT_SWAP
                 PFA_MIN1:
007645 70d9          .dw XT_DROP
007646 7020          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
007647 ff03          .dw $ff03
007648 616d
007649 0078          .db "max",0
00764a 763b          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
00764b 7001          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
00764c 7546          .dw XT_2DUP
00764d 716e          .dw XT_LESS
00764e 7036          .dw XT_DOCONDBRANCH
00764f 7651          DEST(PFA_MAX1)
007650 70c4          .dw XT_SWAP
                 PFA_MAX1:
007651 70d9          .dw XT_DROP
007652 7020          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
007653 ff06          .dw $ff06
007654 6977
007655 6874
007656 6e69          .db "within"
007657 7647          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
007658 7001          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
007659 70cf          .dw XT_OVER
00765a 7193          .dw XT_MINUS
00765b 70ff          .dw XT_TO_R
00765c 7193          .dw XT_MINUS
00765d 70f6          .dw XT_R_FROM
00765e 715c          .dw XT_ULESS
00765f 7020          .dw XT_EXIT
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
007660 ff07          .dw $ff07 
007661 6f74
007662 7075
007663 6570
007664 0072          .db "toupper",0
007665 7653          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
007666 7001          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
007667 70b1          .dw XT_DUP 
007668 703d          .dw XT_DOLITERAL 
007669 0061          .dw 'a' 
00766a 703d          .dw XT_DOLITERAL 
00766b 007b          .dw 'z'+1
00766c 7658          .dw XT_WITHIN 
00766d 7036          .dw XT_DOCONDBRANCH
00766e 7672          DEST(PFA_TOUPPER0)
00766f 703d          .dw XT_DOLITERAL
007670 00df          .dw 223 ; inverse of 0x20: 0xdf
007671 7213          .dw XT_AND 
                 PFA_TOUPPER0:
007672 7020          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
007673 ff07          .dw $ff07
007674 6f74
007675 6f6c
007676 6577
007677 0072          .db "tolower",0
007678 7660          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
007679 7001          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
00767a 70b1          .dw XT_DUP
00767b 703d          .dw XT_DOLITERAL
00767c 0041          .dw 'A'
00767d 703d          .dw XT_DOLITERAL
00767e 005b          .dw 'Z'+1
00767f 7658          .dw XT_WITHIN
007680 7036          .dw XT_DOCONDBRANCH
007681 7685          DEST(PFA_TOLOWER0)
007682 703d          .dw XT_DOLITERAL
007683 0020          .dw 32
007684 721c          .dw XT_OR 
                 PFA_TOLOWER0:
007685 7020          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
007686 ff03          .dw $ff03
007687 6c68
007688 0064          .db "hld",0
007689 7673          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
00768a 7048          .dw PFA_DOVARIABLE
                 PFA_HLD:
00768b 0138          .dw ram_hld
                 
                 .dseg
000138           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
00768c ff04          .dw $ff04
00768d 6f68
00768e 646c          .db "hold"
00768f 7686          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
007690 7001          .dw DO_COLON
                 PFA_HOLD:
                 .endif
007691 768a          .dw XT_HLD
007692 70b1          .dw XT_DUP
007693 7079          .dw XT_FETCH
007694 7235          .dw XT_1MINUS
007695 70b1          .dw XT_DUP
007696 70ff          .dw XT_TO_R
007697 70c4          .dw XT_SWAP
007698 7081          .dw XT_STORE
007699 70f6          .dw XT_R_FROM
00769a 708d          .dw XT_CSTORE
00769b 7020          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
00769c ff02          .dw $ff02
00769d 233c          .db "<#"
00769e 768c          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
00769f 7001          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
0076a0 7565          .dw XT_PAD
0076a1 768a          .dw XT_HLD
0076a2 7081          .dw XT_STORE
0076a3 7020          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
0076a4 ff01          .dw $ff01
0076a5 0023          .db "#",0
0076a6 769c          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
0076a7 7001          .dw DO_COLON
                 PFA_SHARP:
                 .endif
0076a8 7532          .dw XT_BASE
0076a9 7079          .dw XT_FETCH
0076aa 7724          .dw XT_UDSLASHMOD
0076ab 70e1          .dw XT_ROT
0076ac 703d          .dw XT_DOLITERAL
0076ad 0009          .dw 9
0076ae 70cf          .dw XT_OVER
0076af 716e          .dw XT_LESS
0076b0 7036          .dw XT_DOCONDBRANCH
0076b1 76b5          DEST(PFA_SHARP1)
0076b2 703d          .dw XT_DOLITERAL
0076b3 0007          .dw 7
0076b4 719d          .dw XT_PLUS
                 PFA_SHARP1:
0076b5 703d          .dw XT_DOLITERAL
0076b6 0030          .dw 48 ; ASCII 0
0076b7 719d          .dw XT_PLUS
0076b8 7690          .dw XT_HOLD
0076b9 7020          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
0076ba ff02          .dw $ff02
0076bb 7323          .db "#s"
0076bc 76a4          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
0076bd 7001          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
0076be 76a7          .dw XT_SHARP
0076bf 7546          .dw XT_2DUP
0076c0 721c          .dw XT_OR
0076c1 7118          .dw XT_ZEROEQUAL
0076c2 7036          .dw XT_DOCONDBRANCH
0076c3 76be          DEST(NUMS1) ; PFA_SHARP_S
0076c4 7020          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
0076c5 ff02          .dw $ff02
0076c6 3e23          .db "#>"
0076c7 76ba          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
0076c8 7001          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
0076c9 754f          .dw XT_2DROP
0076ca 768a          .dw XT_HLD
0076cb 7079          .dw XT_FETCH
0076cc 7565          .dw XT_PAD
0076cd 70cf          .dw XT_OVER
0076ce 7193          .dw XT_MINUS
0076cf 7020          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
0076d0 ff04          .dw $ff04
0076d1 6973
0076d2 6e67          .db "sign"
0076d3 76c5          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
0076d4 7001          .dw DO_COLON
                 PFA_SIGN:
                 .endif
0076d5 711f          .dw XT_ZEROLESS
0076d6 7036          .dw XT_DOCONDBRANCH
0076d7 76db          DEST(PFA_SIGN1)
0076d8 703d          .dw XT_DOLITERAL
0076d9 002d          .dw 45 ; ascii -
0076da 7690          .dw XT_HOLD
                 PFA_SIGN1:
0076db 7020          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
0076dc ff03          .dw $ff03
0076dd 2e64
0076de 0072          .db "d.r",0
0076df 76d0          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
0076e0 7001          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
0076e1 70ff          .dw XT_TO_R
0076e2 7557          .dw XT_TUCK
0076e3 7cd0          .dw XT_DABS
0076e4 769f          .dw XT_L_SHARP
0076e5 76bd          .dw XT_SHARP_S
0076e6 70e1          .dw XT_ROT
0076e7 76d4          .dw XT_SIGN
0076e8 76c8          .dw XT_SHARP_G
0076e9 70f6          .dw XT_R_FROM
0076ea 70cf          .dw XT_OVER
0076eb 7193          .dw XT_MINUS
0076ec 77cc          .dw XT_SPACES
0076ed 77dc          .dw XT_TYPE
0076ee 7020          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
0076ef ff02          .dw $ff02
0076f0 722e          .db ".r"
0076f1 76dc          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
0076f2 7001          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
0076f3 70ff          .dw XT_TO_R
0076f4 7d63          .dw XT_S2D
0076f5 70f6          .dw XT_R_FROM
0076f6 76e0          .dw XT_DDOTR
0076f7 7020          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
0076f8 ff02          .dw $ff02
0076f9 2e64          .db "d."
0076fa 76ef          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
0076fb 7001          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
0076fc 7154          .dw XT_ZERO
0076fd 76e0          .dw XT_DDOTR
0076fe 77c3          .dw XT_SPACE
0076ff 7020          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
007700 ff01          .dw $ff01
007701 002e          .db ".",0
007702 76f8          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
007703 7001          .dw DO_COLON
                 PFA_DOT:
                 .endif
007704 7d63          .dw XT_S2D
007705 76fb          .dw XT_DDOT
007706 7020          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
007707 ff03          .dw $ff03
007708 6475
007709 002e          .db "ud.",0
00770a 7700          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
00770b 7001          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
00770c 7154          .dw XT_ZERO
00770d 7714          .dw XT_UDDOTR
00770e 77c3          .dw XT_SPACE
00770f 7020          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
007710 ff04          .dw $ff04
007711 6475
007712 722e          .db "ud.r"
007713 7707          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
007714 7001          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
007715 70ff          .dw XT_TO_R
007716 769f          .dw XT_L_SHARP
007717 76bd          .dw XT_SHARP_S
007718 76c8          .dw XT_SHARP_G
007719 70f6          .dw XT_R_FROM
00771a 70cf          .dw XT_OVER
00771b 7193          .dw XT_MINUS
00771c 77cc          .dw XT_SPACES
00771d 77dc          .dw XT_TYPE
00771e 7020          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
00771f ff06          .dw $ff06
007720 6475
007721 6d2f
007722 646f          .db "ud/mod"
007723 7710          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
007724 7001          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
007725 70ff          .dw XT_TO_R
007726 7154          .dw XT_ZERO
007727 7106          .dw XT_R_FETCH
007728 71c2          .dw XT_UMSLASHMOD
007729 70f6          .dw XT_R_FROM
00772a 70c4          .dw XT_SWAP
00772b 70ff          .dw XT_TO_R
00772c 71c2          .dw XT_UMSLASHMOD
00772d 70f6          .dw XT_R_FROM
00772e 7020          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
00772f ff06          .dw $ff06 
007730 6964
007731 6967
007732 3f74          .db "digit?"
007733 771f          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
007734 7001          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
007735 7666          .dw XT_TOUPPER
007736 70b1
007737 703d
007738 0039
007739 7178
00773a 703d
00773b 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
00773c 7213
00773d 719d
00773e 70b1
00773f 703d
007740 0140
007741 7178          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
007742 703d
007743 0107
007744 7213
007745 7193
007746 703d
007747 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
007748 7193
007749 70b1
00774a 7532
00774b 7079
00774c 715c          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
00774d 7020          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
00774e 7001        .dw DO_COLON
                 PFA_DOSLITERAL:
00774f 7106        .dw XT_R_FETCH   ; ( -- addr )
007750 77ad        .dw XT_ICOUNT
007751 70f6        .dw XT_R_FROM
007752 70cf        .dw XT_OVER     ; ( -- addr' n addr n)
007753 722f        .dw XT_1PLUS
007754 7204        .dw XT_2SLASH   ; ( -- addr' n addr k )
007755 719d        .dw XT_PLUS     ; ( -- addr' n addr'' )
007756 722f        .dw XT_1PLUS
007757 70ff        .dw XT_TO_R     ; ( -- )
007758 7020        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
007759 ff02        .dw $ff02
00775a 2c73        .db "s",$2c
00775b 772f        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
00775c 7001          .dw DO_COLON
                 PFA_SCOMMA:
00775d 70b1          .dw XT_DUP
00775e 7760          .dw XT_DOSCOMMA
00775f 7020          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
007760 7001          .dw DO_COLON
                 PFA_DOSCOMMA:
007761 01e4          .dw XT_COMMA
007762 70b1          .dw XT_DUP   ; ( --addr len len)
007763 7204          .dw XT_2SLASH ; ( -- addr len len/2
007764 7557          .dw XT_TUCK   ; ( -- addr len/2 len len/2
007765 720b          .dw XT_2STAR  ; ( -- addr len/2 len len'
007766 7193          .dw XT_MINUS  ; ( -- addr len/2 rem
007767 70ff          .dw XT_TO_R
007768 7154          .dw XT_ZERO
007769 02a3          .dw XT_QDOCHECK
00776a 7036          .dw XT_DOCONDBRANCH
00776b 7773          .dw PFA_SCOMMA2
00776c 729b          .dw XT_DODO
                 PFA_SCOMMA1:
00776d 70b1          .dw XT_DUP         ; ( -- addr addr )
00776e 7079          .dw XT_FETCH       ; ( -- addr c1c2 )
00776f 01e4          .dw XT_COMMA       ; ( -- addr )
007770 753f          .dw XT_CELLPLUS    ; ( -- addr+cell )
007771 72c9          .dw XT_DOLOOP
007772 776d          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
007773 70f6          .dw XT_R_FROM
007774 7126          .dw XT_GREATERZERO
007775 7036          .dw XT_DOCONDBRANCH
007776 777a          .dw PFA_SCOMMA3
007777 70b1            .dw XT_DUP     ; well, tricky
007778 7098            .dw XT_CFETCH
007779 01e4            .dw XT_COMMA
                 PFA_SCOMMA3:
00777a 70d9          .dw XT_DROP        ; ( -- )
00777b 7020          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
00777c ff05          .dw $ff05
00777d 7469
00777e 7079
00777f 0065          .db "itype",0
007780 7759          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
007781 7001          .dw DO_COLON
                 PFA_ITYPE:
007782 70b1          .dw XT_DUP    ; ( --addr len len)
007783 7204          .dw XT_2SLASH ; ( -- addr len len/2
007784 7557          .dw XT_TUCK   ; ( -- addr len/2 len len/2
007785 720b          .dw XT_2STAR  ; ( -- addr len/2 len len'
007786 7193          .dw XT_MINUS  ; ( -- addr len/2 rem
007787 70ff          .dw XT_TO_R
007788 7154          .dw XT_ZERO
007789 02a3          .dw XT_QDOCHECK
00778a 7036          .dw XT_DOCONDBRANCH
00778b 7795          .dw PFA_ITYPE2
00778c 729b          .dw XT_DODO
                 PFA_ITYPE1:
00778d 70b1          .dw XT_DUP         ; ( -- addr addr )
00778e 73c1          .dw XT_FETCHI      ; ( -- addr c1c2 )
00778f 70b1          .dw XT_DUP
007790 77a2          .dw XT_LOWEMIT
007791 779e          .dw XT_HIEMIT
007792 722f          .dw XT_1PLUS    ; ( -- addr+cell )
007793 72c9          .dw XT_DOLOOP
007794 778d          .dw PFA_ITYPE1
                 PFA_ITYPE2:
007795 70f6          .dw XT_R_FROM
007796 7126          .dw XT_GREATERZERO
007797 7036          .dw XT_DOCONDBRANCH
007798 779c          .dw PFA_ITYPE3
007799 70b1            .dw XT_DUP     ; make sure the drop below has always something to do
00779a 73c1            .dw XT_FETCHI
00779b 77a2            .dw XT_LOWEMIT
                 PFA_ITYPE3:
00779c 70d9          .dw XT_DROP
00779d 7020          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
00779e 7001          .dw DO_COLON
                 PFA_HIEMIT:
00779f 72f9          .dw XT_BYTESWAP
0077a0 77a2          .dw XT_LOWEMIT
0077a1 7020          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
0077a2 7001          .dw DO_COLON
                 PFA_LOWEMIT:
0077a3 703d          .dw XT_DOLITERAL
0077a4 00ff          .dw $00ff
0077a5 7213          .dw XT_AND
0077a6 756f          .dw XT_EMIT
0077a7 7020          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
0077a8 ff06          .dw $ff06
0077a9 6369
0077aa 756f
0077ab 746e          .db "icount"
0077ac 777c          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
0077ad 7001          .dw DO_COLON
                 PFA_ICOUNT:
0077ae 70b1          .dw XT_DUP
0077af 722f          .dw XT_1PLUS
0077b0 70c4          .dw XT_SWAP
0077b1 73c1          .dw XT_FETCHI
0077b2 7020          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
0077b3 ff02          .dw 0xff02
0077b4 7263          .db "cr"
0077b5 77a8          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
0077b6 7001          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
0077b7 703d          .dw XT_DOLITERAL
0077b8 000d          .dw 13
0077b9 756f          .dw XT_EMIT
0077ba 703d          .dw XT_DOLITERAL
0077bb 000a          .dw 10
0077bc 756f          .dw XT_EMIT
0077bd 7020          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
0077be ff05          .dw $ff05
0077bf 7073
0077c0 6361
0077c1 0065          .db "space",0
0077c2 77b3          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
0077c3 7001          .dw DO_COLON
                 PFA_SPACE:
                 .endif
0077c4 75d1          .dw XT_BL
0077c5 756f          .dw XT_EMIT
0077c6 7020          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
0077c7 ff06          .dw $ff06
0077c8 7073
0077c9 6361
0077ca 7365          .db "spaces"
0077cb 77be          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
0077cc 7001          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
0077cd 7154
0077ce 764b      	.DW XT_ZERO, XT_MAX
0077cf 70b1
0077d0 7036      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
0077d1 77d6              DEST(SPCS2)
0077d2 77c3
0077d3 7235
0077d4 702f              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
0077d5 77cf              DEST(SPCS1)
0077d6 70d9
0077d7 7020      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
0077d8 ff04          .dw $ff04
0077d9 7974
0077da 6570          .db "type"
0077db 77c7          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
0077dc 7001          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
0077dd 7d5a          .dw XT_BOUNDS
0077de 02a3          .dw XT_QDOCHECK
0077df 7036          .dw XT_DOCONDBRANCH
0077e0 77e7          DEST(PFA_TYPE2)
0077e1 729b          .dw XT_DODO
                 PFA_TYPE1:
0077e2 72ac          .dw XT_I
0077e3 7098          .dw XT_CFETCH
0077e4 756f          .dw XT_EMIT
0077e5 72c9          .dw XT_DOLOOP
0077e6 77e2          DEST(PFA_TYPE1)
                 PFA_TYPE2:
0077e7 7020          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
0077e8 ff01          .dw $ff01
0077e9 0027          .db "'",0
0077ea 77d8          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
0077eb 7001          .dw DO_COLON
                 PFA_TICK:
                 .endif
0077ec 799f          .dw XT_PARSENAME
0077ed 7abf          .dw XT_FORTHRECOGNIZER
0077ee 7aca          .dw XT_RECOGNIZE
                     ; a word is tickable unless RECTYPE-TOKEN is RECTYPE-NULL or 
                     ; the interpret action is a NOOP
0077ef 70b1          .dw XT_DUP
0077f0 7b46          .dw XT_RECTYPE_NULL
0077f1 73d6          .dw XT_EQUAL
0077f2 70c4          .dw XT_SWAP
0077f3 73c1          .dw XT_FETCHI
0077f4 703d          .dw XT_DOLITERAL
0077f5 7b7b          .dw XT_NOOP
0077f6 73d6          .dw XT_EQUAL
0077f7 721c          .dw XT_OR
0077f8 7036          .dw XT_DOCONDBRANCH
0077f9 77fd          DEST(PFA_TICK1)
0077fa 703d            .dw XT_DOLITERAL
0077fb fff3            .dw -13
0077fc 7822            .dw XT_THROW
                 PFA_TICK1:
0077fd 70d9          .dw XT_DROP
0077fe 7020          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
0077ff ff07          .dw $ff07
007800 6168
007801 646e
007802 656c
007803 0072          .db "handler",0
007804 77e8          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
007805 7058          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
007806 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
007807 ff05          .dw $ff05
007808 6163
007809 6374
00780a 0068          .db "catch",0
00780b 77ff          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
00780c 7001          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
00780d 728d          .dw XT_SP_FETCH
00780e 70ff          .dw XT_TO_R
                     ; handler @ >r
00780f 7805          .dw XT_HANDLER
007810 7079          .dw XT_FETCH
007811 70ff          .dw XT_TO_R
                     ; rp@ handler !
007812 7276          .dw XT_RP_FETCH
007813 7805          .dw XT_HANDLER
007814 7081          .dw XT_STORE
007815 702a          .dw XT_EXECUTE
                     ; r> handler !
007816 70f6          .dw XT_R_FROM
007817 7805          .dw XT_HANDLER
007818 7081          .dw XT_STORE
007819 70f6          .dw XT_R_FROM
00781a 70d9          .dw XT_DROP
00781b 7154          .dw XT_ZERO
00781c 7020          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
00781d ff05          .dw $ff05
00781e 6874
00781f 6f72
007820 0077          .db "throw",0
007821 7807          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
007822 7001          .dw DO_COLON
                 PFA_THROW:
                 .endif
007823 70b9          .dw XT_QDUP
007824 7036          .dw XT_DOCONDBRANCH
007825 7832          DEST(PFA_THROW1)
007826 7805            .dw XT_HANDLER
007827 7079            .dw XT_FETCH
007828 7280            .dw XT_RP_STORE
007829 70f6            .dw XT_R_FROM
00782a 7805            .dw XT_HANDLER
00782b 7081            .dw XT_STORE
00782c 70f6            .dw XT_R_FROM
00782d 70c4            .dw XT_SWAP
00782e 70ff            .dw XT_TO_R
00782f 7296            .dw XT_SP_STORE
007830 70d9            .dw XT_DROP
007831 70f6            .dw XT_R_FROM    
                 PFA_THROW1:
007832 7020          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
007833 ff05          .dw $ff05
007834 7363
007835 696b
007836 0070          .db "cskip",0
007837 781d          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
007838 7001          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
007839 70ff          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
00783a 70b1          .dw XT_DUP            ; ( -- addr' n' n' )
00783b 7036          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00783c 7847          DEST(PFA_CSKIP2)
00783d 70cf          .dw XT_OVER           ; ( -- addr' n' addr' )
00783e 7098          .dw XT_CFETCH         ; ( -- addr' n' c' )
00783f 7106          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
007840 73d6          .dw XT_EQUAL          ; ( -- addr' n' f )
007841 7036          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
007842 7847          DEST(PFA_CSKIP2)
007843 73dd          .dw XT_ONE
007844 7990          .dw XT_SLASHSTRING
007845 702f          .dw XT_DOBRANCH
007846 783a          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
007847 70f6          .dw XT_R_FROM
007848 70d9          .dw XT_DROP           ; ( -- addr2 n2)
007849 7020          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
00784a ff05          .dw $ff05
00784b 7363
00784c 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
00784d 006e          .db "cscan"
00784e 7833          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
00784f 7001          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
007850 70ff          .dw XT_TO_R
007851 70cf          .dw XT_OVER
                 PFA_CSCAN1:
007852 70b1          .dw XT_DUP
007853 7098          .dw XT_CFETCH
007854 7106          .dw XT_R_FETCH
007855 73d6          .dw XT_EQUAL
007856 7118          .dw XT_ZEROEQUAL
007857 7036          .dw XT_DOCONDBRANCH
007858 7864          DEST(PFA_CSCAN2)
007859 70c4            .dw XT_SWAP
00785a 7235            .dw XT_1MINUS
00785b 70c4            .dw XT_SWAP
00785c 70cf            .dw XT_OVER
00785d 711f            .dw XT_ZEROLESS ; not negative
00785e 7118            .dw XT_ZEROEQUAL
00785f 7036            .dw XT_DOCONDBRANCH
007860 7864            DEST(PFA_CSCAN2)
007861 722f              .dw XT_1PLUS
007862 702f              .dw XT_DOBRANCH
007863 7852              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
007864 70f0          .dw XT_NIP
007865 70cf          .dw XT_OVER
007866 7193          .dw XT_MINUS
007867 70f6          .dw XT_R_FROM
007868 70d9          .dw XT_DROP
007869 7020          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
00786a ff06          .dw $ff06
00786b 6361
00786c 6563
00786d 7470          .db "accept"
00786e 784a          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
00786f 7001          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
007870 70cf
007871 719d
007872 70cf              .DW XT_OVER,XT_PLUS,XT_OVER
007873 7580
007874 70b1
007875 78b8
007876 7118
007877 7036      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
007878 78ab              DEST(ACC5)
007879 70b1
00787a 703d
00787b 0008
00787c 73d6
00787d 7036              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
00787e 7891              DEST(ACC3)
00787f 70d9
007880 70e1
007881 7546
007882 7178
007883 70ff
007884 70e1
007885 70e1
007886 70f6
007887 7036              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
007888 788f      	DEST(ACC6)
007889 78b0
00788a 7235
00788b 70ff
00788c 70cf
00788d 70f6
00788e 0160      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
00788f 702f      ACC6:   .DW XT_DOBRANCH
007890 78a9              DEST(ACC4)
                     
                 
                 ACC3:    ; check for remaining control characters, replace them with blank
007891 70b1      	.dw XT_DUP            ; ( -- addr k k )
007892 75d1              .dw XT_BL
007893 716e              .dw XT_LESS
007894 7036              .dw XT_DOCONDBRANCH
007895 7898              DEST(PFA_ACCEPT6)
007896 70d9              .dw XT_DROP
007897 75d1              .dw XT_BL
                 PFA_ACCEPT6:
007898 70ff
007899 7546
00789a 7178
00789b 70f6
00789c 70c4
00789d 7036      	.DW XT_TO_R,XT_2DUP,XT_GREATER,XT_R_FROM,XT_SWAP,XT_DOCONDBRANCH
00789e 78a8              DEST(ACC7)
00789f 70b1
0078a0 756f
0078a1 70cf
0078a2 708d
0078a3 722f
0078a4 70cf
0078a5 016c                  .DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
0078a6 702f      	    .DW XT_DOBRANCH
0078a7 78a9      	    DEST(ACC4)
0078a8 70d9      ACC7:   .DW XT_DROP
0078a9 702f      ACC4:   .DW XT_DOBRANCH
0078aa 7873              DEST(ACC1)
0078ab 70d9
0078ac 70f0
0078ad 70c4
0078ae 7193
0078af 7020      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
0078b0 7001          .dw DO_COLON
                 .endif
0078b1 703d          .dw XT_DOLITERAL
0078b2 0008          .dw 8
0078b3 70b1          .dw XT_DUP
0078b4 756f          .dw XT_EMIT
0078b5 77c3          .dw XT_SPACE
0078b6 756f          .dw XT_EMIT
0078b7 7020          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
0078b8 7001          .dw DO_COLON
                 .endif
0078b9 70b1          .dw XT_DUP
0078ba 703d          .dw XT_DOLITERAL
0078bb 000d          .dw 13
0078bc 73d6          .dw XT_EQUAL
0078bd 70c4          .dw XT_SWAP
0078be 703d          .dw XT_DOLITERAL
0078bf 000a          .dw 10
0078c0 73d6          .dw XT_EQUAL
0078c1 721c          .dw XT_OR
0078c2 7020          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILL:
0078c3 ff06          .dw $ff06
0078c4 6572
0078c5 6966
0078c6 6c6c          .db "refill"
0078c7 786a          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
0078c8 7c0f          .dw PFA_DODEFER1
                 PFA_REFILL:
                 .endif
0078c9 001a          .dw USER_REFILL
0078ca 7bd8          .dw XT_UDEFERFETCH
0078cb 7be4          .dw XT_UDEFERSTORE
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
0078cc ff04          .dw $ff04
0078cd 6863
0078ce 7261          .db "char"
0078cf 78c3          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
0078d0 7001          .dw DO_COLON
                 PFA_CHAR:
                 .endif
0078d1 799f          .dw XT_PARSENAME
0078d2 7118
0078d3 7036          .dw XT_ZEROEQUAL,XT_DOCONDBRANCH 
0078d4 78d8          DEST(CHAR_1)
0078d5 703d
0078d6 fff0
0078d7 7822             .dw XT_DOLITERAL, -16, XT_THROW
                 CHAR_1:
                 
0078d8 7098          .dw XT_CFETCH
0078d9 7020          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
0078da ff06          .dw $ff06
0078db 756e
0078dc 626d
0078dd 7265          .db "number"
0078de 78cc          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
0078df 7001          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
0078e0 7532          .dw XT_BASE
0078e1 7079          .dw XT_FETCH
0078e2 70ff          .dw XT_TO_R
0078e3 7923          .dw XT_QSIGN
0078e4 70ff          .dw XT_TO_R
0078e5 7936          .dw XT_SET_BASE
0078e6 7923          .dw XT_QSIGN
0078e7 70f6          .dw XT_R_FROM
0078e8 721c          .dw XT_OR
0078e9 70ff          .dw XT_TO_R
                     ; check whether something is left
0078ea 70b1          .dw XT_DUP
0078eb 7118          .dw XT_ZEROEQUAL
0078ec 7036          .dw XT_DOCONDBRANCH
0078ed 78f6          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
0078ee 754f            .dw XT_2DROP
0078ef 70f6            .dw XT_R_FROM
0078f0 70d9            .dw XT_DROP
0078f1 70f6            .dw XT_R_FROM
0078f2 7532            .dw XT_BASE
0078f3 7081            .dw XT_STORE
0078f4 7154            .dw XT_ZERO
0078f5 7020            .dw XT_EXIT
                 PFA_NUMBER0:
0078f6 7314          .dw XT_2TO_R
0078f7 7154          .dw XT_ZERO       ; starting value
0078f8 7154          .dw XT_ZERO
0078f9 7323          .dw XT_2R_FROM
0078fa 7954          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
0078fb 70b9          .dw XT_QDUP
0078fc 7036          .dw XT_DOCONDBRANCH
0078fd 7918          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
0078fe 73dd          .dw XT_ONE
0078ff 73d6          .dw XT_EQUAL
007900 7036          .dw XT_DOCONDBRANCH
007901 790f          DEST(PFA_NUMBER2)
                 	; excatly one character is left
007902 7098      	.dw XT_CFETCH
007903 703d      	.dw XT_DOLITERAL
007904 002e      	.dw 46 ; .
007905 73d6      	.dw XT_EQUAL
007906 7036      	.dw XT_DOCONDBRANCH
007907 7910      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
007908 70f6      	.dw XT_R_FROM
007909 7036              .dw XT_DOCONDBRANCH
00790a 790c      	DEST(PFA_NUMBER3)
00790b 7cdd              .dw XT_DNEGATE
                 PFA_NUMBER3:
00790c 73e2      	.dw XT_TWO
00790d 702f      	.dw XT_DOBRANCH
00790e 791e      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
00790f 70d9      	.dw XT_DROP
                 PFA_NUMBER6:
007910 754f      	.dw XT_2DROP
007911 70f6      	.dw XT_R_FROM
007912 70d9      	.dw XT_DROP
007913 70f6              .dw XT_R_FROM
007914 7532              .dw XT_BASE
007915 7081              .dw XT_STORE
007916 7154      	.dw XT_ZERO
007917 7020      	.dw XT_EXIT
                 PFA_NUMBER1:
007918 754f          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
007919 70f6          .dw XT_R_FROM
00791a 7036          .dw XT_DOCONDBRANCH
00791b 791d          DEST(PFA_NUMBER4)
00791c 7620          .dw XT_NEGATE
                 PFA_NUMBER4:
00791d 73dd          .dw XT_ONE
                 PFA_NUMBER5:
00791e 70f6          .dw XT_R_FROM
00791f 7532          .dw XT_BASE
007920 7081          .dw XT_STORE
007921 714b          .dw XT_TRUE
007922 7020          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
007923 7001          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
007924 70cf          .dw XT_OVER    ; ( -- addr len addr )
007925 7098          .dw XT_CFETCH
007926 703d          .dw XT_DOLITERAL
007927 002d          .dw '-'
007928 73d6          .dw XT_EQUAL  ; ( -- addr len flag )
007929 70b1          .dw XT_DUP
00792a 70ff          .dw XT_TO_R
00792b 7036          .dw XT_DOCONDBRANCH
00792c 792f          DEST(PFA_NUMBERSIGN_DONE)
00792d 73dd          .dw XT_ONE    ; skip sign character
00792e 7990          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
00792f 70f6          .dw XT_R_FROM
007930 7020          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
007931 7052          .dw PFA_DOCONSTANT
                 .endif
007932 000a
007933 0010
007934 0002
007935 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
007936 7001          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
007937 70cf          .dw XT_OVER
007938 7098          .dw XT_CFETCH
007939 703d          .dw XT_DOLITERAL
00793a 0023          .dw 35
00793b 7193          .dw XT_MINUS
00793c 70b1          .dw XT_DUP
00793d 7154          .dw XT_ZERO
00793e 703d          .dw XT_DOLITERAL
00793f 0004          .dw 4
007940 7658          .dw XT_WITHIN
007941 7036          .dw XT_DOCONDBRANCH
007942 794c          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
007943 7931      	.dw XT_BASES
007944 719d      	.dw XT_PLUS
007945 73c1      	.dw XT_FETCHI
007946 7532      	.dw XT_BASE
007947 7081      	.dw XT_STORE
007948 73dd      	.dw XT_ONE
007949 7990      	.dw XT_SLASHSTRING
00794a 702f      	.dw XT_DOBRANCH
00794b 794d      	DEST(SET_BASE2)
                 SET_BASE1:
00794c 70d9      	.dw XT_DROP
                 SET_BASE2:
00794d 7020          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
00794e ff07          .dw $ff07
00794f 6e3e
007950 6d75
007951 6562
007952 0072          .db ">number",0
007953 78da          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
007954 7001          .dw DO_COLON
                 
                 .endif
                 
007955 70b1
007956 7036      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
007957 796c              DEST(TONUM3)
007958 70cf
007959 7098
00795a 7734              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
00795b 7118
00795c 7036              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
00795d 7960              DEST(TONUM2)
00795e 70d9
00795f 7020              .DW XT_DROP,XT_EXIT
007960 70ff
007961 7d01
007962 7532
007963 7079
007964 0151      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
007965 70f6
007966 0149
007967 7d01              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
007968 73dd
007969 7990
00796a 702f              .DW XT_ONE,XT_SLASHSTRING,XT_DOBRANCH
00796b 7955              DEST(TONUM1)
00796c 7020      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
00796d ff05          .dw $ff05
00796e 6170
00796f 7372
007970 0065          .db "parse",0
007971 794e          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
007972 7001          .dw DO_COLON
                 PFA_PARSE:
                 .endif
007973 70ff          .dw XT_TO_R     ; ( -- )
007974 7986          .dw XT_SOURCE   ; ( -- addr len)
007975 755f          .dw XT_TO_IN     ; ( -- addr len >in)
007976 7079          .dw XT_FETCH
007977 7990          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
007978 70f6          .dw XT_R_FROM      ; ( -- addr' len' c)
007979 784f          .dw XT_CSCAN       ; ( -- addr' len'')
00797a 70b1          .dw XT_DUP         ; ( -- addr' len'' len'')
00797b 722f          .dw XT_1PLUS
00797c 755f          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
00797d 7265          .dw XT_PLUSSTORE   ; ( -- addr' len')
00797e 73dd          .dw XT_ONE
00797f 7990          .dw XT_SLASHSTRING
007980 7020          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCE:
007981 ff06          .dw $FF06
007982 6f73
007983 7275
007984 6563          .db "source"
007985 796d          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
007986 7c0f          .dw PFA_DODEFER1
                 PFA_SOURCE:
                 .endif
007987 0016          .dw USER_SOURCE
007988 7bd8          .dw XT_UDEFERFETCH
007989 7be4          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
00798a ff07          .dw $ff07
00798b 732f
00798c 7274
00798d 6e69
00798e 0067          .db "/string",0
00798f 7981          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
007990 7001          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
007991 70e1          .dw XT_ROT
007992 70cf          .dw XT_OVER
007993 719d          .dw XT_PLUS
007994 70e1          .dw XT_ROT
007995 70e1          .dw XT_ROT
007996 7193          .dw XT_MINUS
007997 7020          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
007998 ff0a          .dw $FF0A 
007999 6170
00799a 7372
00799b 2d65
00799c 616e
00799d 656d          .db "parse-name"
00799e 798a          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
00799f 7001          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
0079a0 75d1          .dw XT_BL
0079a1 79a3          .dw XT_SKIPSCANCHAR
0079a2 7020          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
0079a3 7001          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
0079a4 70ff          .dw XT_TO_R
0079a5 7986          .dw XT_SOURCE 
0079a6 755f          .dw XT_TO_IN 
0079a7 7079          .dw XT_FETCH 
0079a8 7990          .dw XT_SLASHSTRING 
                 
0079a9 7106          .dw XT_R_FETCH
0079aa 7838          .dw XT_CSKIP
0079ab 70f6          .dw XT_R_FROM
0079ac 784f          .dw XT_CSCAN
                 
                     ; adjust >IN
0079ad 7546          .dw XT_2DUP
0079ae 719d          .dw XT_PLUS
0079af 7986          .dw XT_SOURCE 
0079b0 70d9          .dw XT_DROP
0079b1 7193          .dw XT_MINUS
0079b2 755f          .dw XT_TO_IN
0079b3 7081          .dw XT_STORE
0079b4 7020          .dw XT_EXIT
                 .include "words/find-xt.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the xt from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDXT:
0079b5 ff07          .dw $ff07
0079b6 6966
0079b7 646e
0079b8 782d
0079b9 0074          .db "find-xt",0
0079ba 7998          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDXT
                 XT_FINDXT:
0079bb 7001          .dw DO_COLON
                 PFA_FINDXT:
                 .endif
0079bc 703d          .dw XT_DOLITERAL
0079bd 79c7          .dw XT_FINDXTA
0079be 703d          .dw XT_DOLITERAL
0079bf 004e          .dw CFG_ORDERLISTLEN
0079c0 0424          .dw XT_MAPSTACK
0079c1 7118          .dw XT_ZEROEQUAL
0079c2 7036          .dw XT_DOCONDBRANCH
0079c3 79c6          DEST(PFA_FINDXT1)
0079c4 754f            .dw XT_2DROP
0079c5 7154            .dw XT_ZERO
                 PFA_FINDXT1:
0079c6 7020          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDXTA:
0079c7 7001          .dw DO_COLON
                 PFA_FINDXTA:
                 .endif
0079c8 70ff          .dw XT_TO_R
0079c9 7546          .dw XT_2DUP
0079ca 70f6          .dw XT_R_FROM
0079cb 7c21          .dw XT_SEARCH_WORDLIST
0079cc 70b1          .dw XT_DUP
0079cd 7036          .dw XT_DOCONDBRANCH
0079ce 79d4          DEST(PFA_FINDXTA1)
0079cf 70ff            .dw XT_TO_R
0079d0 70f0            .dw XT_NIP
0079d1 70f0            .dw XT_NIP
0079d2 70f6            .dw XT_R_FROM
0079d3 714b            .dw XT_TRUE
                 PFA_FINDXTA1:
0079d4 7020          .dw XT_EXIT
                 
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_DEFAULT_PROMPTOK:
0079d5 7001          .dw DO_COLON
                 PFA_DEFAULT_PROMPTOK:
0079d6 774e          .dw XT_DOSLITERAL
0079d7 0003          .dw 3
0079d8 6f20
0079d9 006b          .db " ok",0
                 .endif
0079da 7781          .dw XT_ITYPE
0079db 7020          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTOK:
0079dc ff03          .dw $FF03
0079dd 6f2e
../../common\words/prompt-ok.asm(43): warning: .cseg .db misalignment - padding zero byte
0079de 006b          .db ".ok"
0079df 79b5          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
0079e0 7c0f          .dw PFA_DODEFER1
                 PFA_PROMPTOK:
                 .endif
0079e1 001c          .dw USER_P_OK
0079e2 7bd8          .dw XT_UDEFERFETCH
0079e3 7be4          .dw XT_UDEFERSTORE
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_DEFAULT_PROMPTREADY:
0079e4 7001          .dw DO_COLON
                 PFA_DEFAULT_PROMPTREADY:
0079e5 774e          .dw XT_DOSLITERAL
0079e6 0002          .dw 2
0079e7 203e          .db "> "
                 .endif
0079e8 77b6          .dw XT_CR
0079e9 7781          .dw XT_ITYPE
0079ea 7020          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTREADY:
0079eb ff06          .dw $FF06
0079ec 722e
0079ed 6165
0079ee 7964          .db ".ready"
0079ef 79dc          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTREADY
                 XT_PROMPTREADY:
0079f0 7c0f          .dw PFA_DODEFER1
                 PFA_PROMPTREADY:
                 .endif
0079f1 0020          .dw USER_P_RDY
0079f2 7bd8          .dw XT_UDEFERFETCH
0079f3 7be4          .dw XT_UDEFERSTORE
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_DEFAULT_PROMPTERROR:
0079f4 7001          .dw DO_COLON
                 PFA_DEFAULT_PROMPTERROR:
0079f5 774e      	.dw XT_DOSLITERAL
0079f6 0004          .dw 4
0079f7 3f20
0079f8 203f          .db " ?? "
                 .endif
0079f9 7781          .dw XT_ITYPE
0079fa 7532          .dw XT_BASE
0079fb 7079          .dw XT_FETCH
0079fc 70ff          .dw XT_TO_R
0079fd 75be          .dw XT_DECIMAL
0079fe 7703          .dw XT_DOT
0079ff 755f          .dw XT_TO_IN
007a00 7079          .dw XT_FETCH
007a01 7703          .dw XT_DOT
007a02 70f6          .dw XT_R_FROM
007a03 7532          .dw XT_BASE
007a04 7081          .dw XT_STORE
007a05 7020          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTERROR:
007a06 ff06          .dw $FF06
007a07 652e
007a08 7272
007a09 726f          .db ".error"
007a0a 79eb          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
007a0b 7c0f          .dw PFA_DODEFER1
                 PFA_PROMPTERROR:
                 .endif
007a0c 001e          .dw USER_P_ERR
007a0d 7bd8          .dw XT_UDEFERFETCH
007a0e 7be4          .dw XT_UDEFERSTORE
                 .include "words/prompt-input.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_DEFAULT_PROMPTINPUT:
007a0f 7001          .dw DO_COLON
                 PFA_DEFAULT_PROMPTINPUT:
                 .endif
007a10 77b6          .dw XT_CR
007a11 7020          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTINPUT:
007a12 ff06          .dw $FF06
007a13 692e
007a14 706e
007a15 7475          .db ".input"
007a16 7a06          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTINPUT
                 XT_PROMPTINPUT:
007a17 7c0f          .dw PFA_DODEFER1
                 PFA_PROMPTINPUT:
                 .endif
007a18 0022          .dw USER_P_INPUT
007a19 7bd8          .dw XT_UDEFERFETCH
007a1a 7be4          .dw XT_UDEFERSTORE
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
007a1b ff04          .dw $ff04
007a1c 7571
007a1d 7469          .db "quit"
007a1e 7a12          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
007a1f 7001          .dw DO_COLON
                 .endif
                 PFA_QUIT:
007a20 02d9
007a21 02e0
007a22 7081          .dw XT_LP0,XT_LP,XT_STORE
007a23 7a81          .dw XT_SP0
007a24 7296          .dw XT_SP_STORE
007a25 7a89          .dw XT_RP0
007a26 7280          .dw XT_RP_STORE
007a27 036e          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
007a28 752c          .dw XT_STATE
007a29 7079          .dw XT_FETCH
007a2a 7118          .dw XT_ZEROEQUAL
007a2b 7036          .dw XT_DOCONDBRANCH
007a2c 7a2e          DEST(PFA_QUIT4)
007a2d 79f0          .dw XT_PROMPTREADY
                 PFA_QUIT4:
007a2e 78c8          .dw XT_REFILL
007a2f 7a17          .dw XT_PROMPTINPUT
007a30 7036          .dw XT_DOCONDBRANCH
007a31 7a41          DEST(PFA_QUIT3)
007a32 703d          .dw XT_DOLITERAL
007a33 7aa2          .dw XT_INTERPRET
007a34 780c          .dw XT_CATCH
007a35 70b9          .dw XT_QDUP
007a36 7036          .dw XT_DOCONDBRANCH
007a37 7a41          DEST(PFA_QUIT3)
007a38 70b1      	.dw XT_DUP
007a39 703d      	.dw XT_DOLITERAL
007a3a fffe      	.dw -2
007a3b 716e      	.dw XT_LESS
007a3c 7036      	.dw XT_DOCONDBRANCH
007a3d 7a3f      	DEST(PFA_QUIT5)
007a3e 7a0b      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
007a3f 702f      	.dw XT_DOBRANCH
007a40 7a20      	DEST(PFA_QUIT)
                 PFA_QUIT3:
007a41 79e0          .dw XT_PROMPTOK
007a42 702f          .dw XT_DOBRANCH
007a43 7a28          DEST(PFA_QUIT2)
                 ;    .dw XT_EXIT ; never reached
                 
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
007a44 ff05          .dw $ff05
007a45 6170
007a46 7375
007a47 0065          .db "pause",0
007a48 7a1b          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
007a49 7c0f          .dw PFA_DODEFER1
                 PFA_PAUSE:
007a4a 013a          .dw ram_pause
007a4b 7bc4          .dw XT_RDEFERFETCH
007a4c 7bce          .dw XT_RDEFERSTORE
                 
                 .dseg
00013a           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
007a4d ff04          .dw $ff04
007a4e 6f63
007a4f 646c          .db "cold"
007a50 7a44          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
007a51 7a52          .dw PFA_COLD
                 PFA_COLD:
007a52 b6a4          in_ mcu_boot, MCUSR
007a53 2422          clr zerol
007a54 2433          clr zeroh
007a55 24bb          clr isrflag
007a56 be24          out_ MCUSR, zerol
                     ; clear RAM
007a57 e0e0          ldi zl, low(ramstart)
007a58 e0f1          ldi zh, high(ramstart)
                 clearloop:
007a59 9221          st Z+, zerol
007a5a 30e0          cpi zl, low(sram_size+ramstart)
007a5b f7e9          brne clearloop
007a5c 31f1          cpi zh, high(sram_size+ramstart)
007a5d f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
00013c           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
007a5e e3ec          ldi zl, low(ram_user1)
007a5f e0f1          ldi zh, high(ram_user1)
007a60 012f          movw upl, zl
                     ; init return stack pointer
007a61 ef0f          ldi temp0,low(rstackstart)
007a62 bf0d          out_ SPL,temp0
007a63 8304          std Z+4, temp0
007a64 e110          ldi temp1,high(rstackstart)
007a65 bf1e          out_ SPH,temp1
007a66 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
007a67 eacf          ldi yl,low(stackstart)
007a68 83c6          std Z+6, yl
007a69 e1d0          ldi yh,high(stackstart)
007a6a 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
007a6b e7a4          ldi XL, low(PFA_WARM)
007a6c e7ba          ldi XH, high(PFA_WARM)
                     ; its a far jump...
007a6d 940c 7005     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WARM:
007a6f ff04          .dw $ff04
007a70 6177
007a71 6d72          .db "warm"
007a72 7a4d          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
007a73 7001          .dw DO_COLON
                 PFA_WARM:
                 .endif
007a74 7d4c          .dw XT_INIT_RAM
007a75 703d          .dw XT_DOLITERAL
007a76 7b7b          .dw XT_NOOP
007a77 703d          .dw XT_DOLITERAL
007a78 7a49          .dw XT_PAUSE
007a79 7bef          .dw XT_DEFERSTORE
007a7a 036e          .dw XT_LBRACKET
007a7b 75d9          .dw XT_TURNKEY
007a7c 7a1f          .dw XT_QUIT     ; never returns
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
007a7d ff03          .dw $ff03
007a7e 7073
007a7f 0030          .db "sp0",0
007a80 7a6f          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
007a81 706f          .dw PFA_DOVALUE1
                 PFA_SP0:
007a82 0006          .dw USER_SP0
007a83 7bd8          .dw XT_UDEFERFETCH
007a84 7be4          .dw XT_UDEFERSTORE
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
007a85 ff03          .dw $ff03
007a86 7072
007a87 0030          .db "rp0",0
007a88 7a7d          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
007a89 7001          .dw DO_COLON
                 PFA_RP0:
007a8a 7a8d          .dw XT_DORP0
007a8b 7079          .dw XT_FETCH
007a8c 7020          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
007a8d 7058          .dw PFA_DOUSER
                 PFA_DORP0:
007a8e 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
007a8f ff05          .dw $ff05
007a90 6564
007a91 7470
007a92 0068          .db "depth",0
007a93 7a85          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
007a94 7001          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
007a95 7a81          .dw XT_SP0
007a96 728d          .dw XT_SP_FETCH
007a97 7193          .dw XT_MINUS
007a98 7204          .dw XT_2SLASH
007a99 7235          .dw XT_1MINUS
007a9a 7020          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
007a9b ff09          .dw $ff09
007a9c 6e69
007a9d 6574
007a9e 7072
007a9f 6572
007aa0 0074          .db "interpret",0
007aa1 7a8f          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
007aa2 7001          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
007aa3 799f          .dw XT_PARSENAME ; ( -- addr len )
007aa4 70b1          .dw XT_DUP   ; ( -- addr len flag)
007aa5 7036          .dw XT_DOCONDBRANCH
007aa6 7ab3          DEST(PFA_INTERPRET2)
007aa7 7abf            .dw XT_FORTHRECOGNIZER
007aa8 7aca            .dw XT_RECOGNIZE
007aa9 752c            .dw XT_STATE
007aaa 7079            .dw XT_FETCH
007aab 7036            .dw XT_DOCONDBRANCH
007aac 7aae          DEST(PFA_INTERPRET1)
007aad 7ba7            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
007aae 73c1            .dw XT_FETCHI
007aaf 702a            .dw XT_EXECUTE
007ab0 7b53            .dw XT_QSTACK
007ab1 702f          .dw XT_DOBRANCH
007ab2 7aa3          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
007ab3 754f          .dw XT_2DROP
007ab4 7020          .dw XT_EXIT
                 .include "words/forth-recognizer.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_FORTHRECOGNIZER:
007ab5 ff10          .dw $ff10
007ab6 6f66
007ab7 7472
007ab8 2d68
007ab9 6572
007aba 6f63
007abb 6e67
007abc 7a69
007abd 7265          .db "forth-recognizer"
007abe 7a9b          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHRECOGNIZER
                 XT_FORTHRECOGNIZER:
007abf 706f          .dw PFA_DOVALUE1
                 PFA_FORTHRECOGNIZER:
007ac0 0042          .dw CFG_FORTHRECOGNIZER
007ac1 7bb0          .dw XT_EDEFERFETCH
007ac2 7bba          .dw XT_EDEFERSTORE
                 .include "words/recognize.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECOGNIZE:
007ac3 ff09          .dw $ff09
007ac4 6572
007ac5 6f63
007ac6 6e67
007ac7 7a69
007ac8 0065          .db "recognize",0
007ac9 7ab5          .dw VE_HEAD
                     .set VE_HEAD = VE_RECOGNIZE
                 XT_RECOGNIZE:
007aca 7001          .dw DO_COLON
                 PFA_RECOGNIZE:
                 .endif
007acb 703d          .dw XT_DOLITERAL
007acc 7ad5          .dw XT_RECOGNIZE_A
007acd 70c4          .dw XT_SWAP
007ace 0424          .dw XT_MAPSTACK
007acf 7118          .dw XT_ZEROEQUAL
007ad0 7036          .dw XT_DOCONDBRANCH
007ad1 7ad4          DEST(PFA_RECOGNIZE1)
007ad2 754f            .dw XT_2DROP
007ad3 7b46            .dw XT_RECTYPE_NULL
                 PFA_RECOGNIZE1:
007ad4 7020          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ; ( addr len XT -- addr len [ rectype-* -1 | 0 ] )
                 XT_RECOGNIZE_A:
007ad5 7001         .dw DO_COLON
                 PFA_RECOGNIZE_A:
                 .endif
007ad6 70e1         .dw XT_ROT  ; -- len xt addr
007ad7 70e1         .dw XT_ROT  ; -- xt addr len
007ad8 7546         .dw XT_2DUP 
007ad9 7314         .dw XT_2TO_R
007ada 70e1         .dw XT_ROT  ; -- addr len xt
007adb 702a         .dw XT_EXECUTE ; -- i*x rectype-* | rectype-null
007adc 7323         .dw XT_2R_FROM
007add 70e1         .dw XT_ROT
007ade 70b1         .dw XT_DUP
007adf 7b46         .dw XT_RECTYPE_NULL
007ae0 73d6         .dw XT_EQUAL
007ae1 7036         .dw XT_DOCONDBRANCH
007ae2 7ae6         DEST(PFA_RECOGNIZE_A1)
007ae3 70d9           .dw XT_DROP
007ae4 7154           .dw XT_ZERO
007ae5 7020           .dw XT_EXIT
                 PFA_RECOGNIZE_A1:
007ae6 70f0         .dw XT_NIP 
007ae7 70f0         .dw XT_NIP
007ae8 714b         .dw XT_TRUE
007ae9 7020         .dw XT_EXIT
                 
                 ; : recognize ( addr len stack-id -- i*x rectype-* | rectype-null )
                 ;   [: ( addr len -- addr len 0 | i*x rectype-* -1 )
                 ;      rot rot 2dup 2>r rot execute 2r> rot 
                 ;      dup rectype-null = ( -- addr len rectype-* f )
                 ;      if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    map-stack ( -- i*x addr len rectype-* f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop rectype-null
                 ;    then ;
                 ;
                 .include "words/rec-intnum.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_NUM:
007aea ff0b          .dw $ff0b
007aeb 6572
007aec 7463
007aed 7079
007aee 2d65
007aef 756e
007af0 006d          .db "rectype-num",0
007af1 7ac3          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_NUM
                 XT_RECTYPE_NUM:
007af2 7052          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_NUM:
                 .endif
007af3 7b7b          .dw XT_NOOP    ; interpret
007af4 01fa          .dw XT_LITERAL ; compile
007af5 01fa          .dw XT_LITERAL ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_DNUM:
007af6 ff0c          .dw $ff0c
007af7 6572
007af8 7463
007af9 7079
007afa 2d65
007afb 6e64
007afc 6d75          .db "rectype-dnum"
007afd 7aea          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_DNUM
                 XT_RECTYPE_DNUM:
007afe 7052          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_DNUM:
                 .endif
007aff 7b7b          .dw XT_NOOP     ; interpret
007b00 73ce          .dw XT_2LITERAL ; compile
007b01 73ce          .dw XT_2LITERAL ; postpone
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
007b02 ff07          .dw $ff07
007b03 6572
007b04 2d63
007b05 756e
007b06 006d          .db "rec-num",0
007b07 7af6          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
007b08 7001          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
007b09 78df          .dw XT_NUMBER
007b0a 7036          .dw XT_DOCONDBRANCH
007b0b 7b14          DEST(PFA_REC_NONUMBER)
007b0c 73dd          .dw XT_ONE
007b0d 73d6          .dw XT_EQUAL
007b0e 7036          .dw XT_DOCONDBRANCH
007b0f 7b12          DEST(PFA_REC_INTNUM2)
007b10 7af2            .dw XT_RECTYPE_NUM
007b11 7020            .dw XT_EXIT
                 PFA_REC_INTNUM2:
007b12 7afe            .dw XT_RECTYPE_DNUM
007b13 7020            .dw XT_EXIT
                 PFA_REC_NONUMBER:
007b14 7b46          .dw XT_RECTYPE_NULL
007b15 7020          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_FIND:
007b16 ff08          .dw $ff08
007b17 6572
007b18 2d63
007b19 6966
007b1a 646e          .db "rec-find"
007b1b 7b02          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
007b1c 7001          .dw DO_COLON
                 PFA_REC_FIND:
                 .endif
007b1d 79bb          .DW XT_FINDXT
007b1e 70b1          .dw XT_DUP
007b1f 7118          .dw XT_ZEROEQUAL
007b20 7036          .dw XT_DOCONDBRANCH
007b21 7b25          DEST(PFA_REC_WORD_FOUND)
007b22 70d9              .dw XT_DROP
007b23 7b46      	.dw XT_RECTYPE_NULL
007b24 7020      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
007b25 7b2e          .dw XT_RECTYPE_XT
                 
007b26 7020          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_XT:
007b27 ff0a          .dw $ff0a
007b28 6572
007b29 7463
007b2a 7079
007b2b 2d65
007b2c 7478          .db "rectype-xt"
007b2d 7b16          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_XT
                 XT_RECTYPE_XT:
007b2e 7052          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_XT:
                 .endif
007b2f 7b32          .dw XT_R_WORD_INTERPRET
007b30 7b36          .dw XT_R_WORD_COMPILE
007b31 73ce          .dw XT_2LITERAL
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
007b32 7001          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
007b33 70d9          .dw XT_DROP ; the flags are in the way
007b34 702a          .dw XT_EXECUTE
007b35 7020          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
007b36 7001          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
007b37 711f          .dw XT_ZEROLESS
007b38 7036          .dw XT_DOCONDBRANCH
007b39 7b3c          DEST(PFA_R_WORD_COMPILE1)
007b3a 01e4      	.dw XT_COMMA
007b3b 7020              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
007b3c 702a              .dw XT_EXECUTE
007b3d 7020          .dw XT_EXIT
                 .include "words/rec-null.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_NULL:
007b3e ff0c          .dw $ff0c
007b3f 6572
007b40 7463
007b41 7079
007b42 2d65
007b43 756e
007b44 6c6c          .db "rectype-null"
007b45 7b27          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_NULL
                 XT_RECTYPE_NULL:
007b46 7052          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_NULL:
                 .endif
007b47 7b4a          .dw XT_FAIL  ; interpret
007b48 7b4a          .dw XT_FAIL  ; compile
007b49 7b4a          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
007b4a 7001          .dw DO_COLON
                 PFA_FAIL:
                 .endif
007b4b 703d          .dw XT_DOLITERAL
007b4c fff3          .dw -13
007b4d 7822          .dw XT_THROW
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
007b4e ff06          .dw $ff06
007b4f 733f
007b50 6174
007b51 6b63          .db "?stack"
007b52 7b3e          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
007b53 7001          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
007b54 7a94          .dw XT_DEPTH
007b55 711f          .dw XT_ZEROLESS
007b56 7036          .dw XT_DOCONDBRANCH
007b57 7b5b          DEST(PFA_QSTACK1)
007b58 703d            .dw XT_DOLITERAL
007b59 fffc            .dw -4
007b5a 7822            .dw XT_THROW
                 PFA_QSTACK1:
007b5b 7020          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
007b5c ff03          .dw $ff03
007b5d 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
007b5e 0072          .db "ver"
007b5f 7b4e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
007b60 7001          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
007b61 74ee          .dw XT_ENV_FORTHNAME
007b62 7781          .dw XT_ITYPE
007b63 77c3          .dw XT_SPACE
007b64 7532          .dw XT_BASE
007b65 7079          .dw XT_FETCH
                 
007b66 74fc          .dw XT_ENV_FORTHVERSION
007b67 75be          .dw XT_DECIMAL
007b68 7d63          .dw XT_S2D
007b69 769f          .dw XT_L_SHARP
007b6a 76a7          .dw XT_SHARP
007b6b 703d          .dw XT_DOLITERAL
007b6c 002e          .dw '.'
007b6d 7690          .dw XT_HOLD
007b6e 76bd          .dw XT_SHARP_S
007b6f 76c8          .dw XT_SHARP_G
007b70 77dc          .dw XT_TYPE
007b71 7532          .dw XT_BASE
007b72 7081          .dw XT_STORE
007b73 77c3          .dw XT_SPACE
007b74 7504          .dw XT_ENV_CPU
007b75 7781          .dw XT_ITYPE
                 
007b76 7020          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOOP:
007b77 ff04          .dw $ff04
007b78 6f6e
007b79 706f          .db "noop"
007b7a 7b5c          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
007b7b 7001          .dw DO_COLON
                 PFA_NOOP:
                 .endif
007b7c 7020         .DW XT_EXIT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
007b7d ff06          .dw $ff06
007b7e 6e75
007b7f 7375
007b80 6465          .db "unused"
007b81 7b77          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
007b82 7001          .dw DO_COLON
                 PFA_UNUSED:
007b83 728d          .dw XT_SP_FETCH
007b84 75a0          .dw XT_HERE
007b85 7193          .dw XT_MINUS
007b86 7020          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
007b87 0002          .dw $0002
007b88 6f74          .db "to"
007b89 7b7d          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
007b8a 7001          .dw DO_COLON
                 PFA_TO:
                 .endif
007b8b 77eb          .dw XT_TICK
007b8c 7d6c          .dw XT_TO_BODY
007b8d 752c          .dw XT_STATE
007b8e 7079          .dw XT_FETCH
007b8f 7036          .dw XT_DOCONDBRANCH
007b90 7b9b          DEST(PFA_TO1)
007b91 01d9          .dw XT_COMPILE
007b92 7b95          .dw XT_DOTO
007b93 01e4          .dw XT_COMMA
007b94 7020          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
007b95 7001          .dw DO_COLON
                 PFA_DOTO:
                 .endif
007b96 70f6          .dw XT_R_FROM
007b97 70b1          .dw XT_DUP
007b98 7ba7          .dw XT_ICELLPLUS
007b99 70ff          .dw XT_TO_R
007b9a 73c1          .dw XT_FETCHI
                 PFA_TO1:
007b9b 70b1          .dw XT_DUP
007b9c 7ba7          .dw XT_ICELLPLUS
007b9d 7ba7          .dw XT_ICELLPLUS
007b9e 73c1          .dw XT_FETCHI
007b9f 702a          .dw XT_EXECUTE
007ba0 7020          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
007ba1 ff07          .dw $FF07
007ba2 2d69
007ba3 6563
007ba4 6c6c
007ba5 002b          .db "i-cell+",0
007ba6 7b87          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
007ba7 7001          .dw DO_COLON
                 PFA_ICELLPLUS:
007ba8 722f          .dw XT_1PLUS
007ba9 7020          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
007baa ff07          .dw $ff07
007bab 6445
007bac 6665
007bad 7265
007bae 0040          .db "Edefer@",0
007baf 7ba1          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
007bb0 7001          .dw DO_COLON
                 PFA_EDEFERFETCH:
007bb1 73c1          .dw XT_FETCHI
007bb2 7355          .dw XT_FETCHE
007bb3 7020          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
007bb4 ff07          .dw $ff07
007bb5 6445
007bb6 6665
007bb7 7265
007bb8 0021          .db "Edefer!",0
007bb9 7baa          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
007bba 7001          .dw DO_COLON
                 PFA_EDEFERSTORE:
007bbb 73c1          .dw XT_FETCHI
007bbc 7331          .dw XT_STOREE
007bbd 7020          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
007bbe ff07          .dw $ff07
007bbf 6452
007bc0 6665
007bc1 7265
007bc2 0040          .db "Rdefer@",0
007bc3 7bb4          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
007bc4 7001          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
007bc5 73c1          .dw XT_FETCHI
007bc6 7079          .dw XT_FETCH
007bc7 7020          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
007bc8 ff07          .dw $ff07
007bc9 6452
007bca 6665
007bcb 7265
007bcc 0021          .db "Rdefer!",0
007bcd 7bbe          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
007bce 7001          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
007bcf 73c1          .dw XT_FETCHI
007bd0 7081          .dw XT_STORE
007bd1 7020          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
007bd2 ff07          .dw $ff07
007bd3 6455
007bd4 6665
007bd5 7265
007bd6 0040          .db "Udefer@",0
007bd7 7bc8          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
007bd8 7001          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
007bd9 73c1          .dw XT_FETCHI
007bda 7302          .dw XT_UP_FETCH
007bdb 719d          .dw XT_PLUS
007bdc 7079          .dw XT_FETCH
007bdd 7020          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
007bde ff07          .dw $ff07
007bdf 6455
007be0 6665
007be1 7265
007be2 0021          .db "Udefer!",0
007be3 7bd2          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
007be4 7001          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
007be5 73c1          .dw XT_FETCHI
007be6 7302          .dw XT_UP_FETCH
007be7 719d          .dw XT_PLUS
007be8 7081          .dw XT_STORE
007be9 7020          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
007bea ff06          .dw $ff06
007beb 6564
007bec 6566
007bed 2172          .db "defer!"
007bee 7bde          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
007bef 7001          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
007bf0 7d6c          .dw XT_TO_BODY
007bf1 70b1          .dw XT_DUP
007bf2 7ba7          .dw XT_ICELLPLUS
007bf3 7ba7          .dw XT_ICELLPLUS
007bf4 73c1          .dw XT_FETCHI
007bf5 702a          .dw XT_EXECUTE
007bf6 7020          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
007bf7 ff06          .dw $ff06
007bf8 6564
007bf9 6566
007bfa 4072          .db "defer@"
007bfb 7bea          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
007bfc 7001          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
007bfd 7d6c          .dw XT_TO_BODY 
007bfe 70b1          .dw XT_DUP
007bff 7ba7          .dw XT_ICELLPLUS
007c00 73c1          .dw XT_FETCHI
007c01 702a          .dw XT_EXECUTE
007c02 7020          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
007c03 ff07          .dw $ff07
007c04 6428
007c05 6665
007c06 7265
007c07 0029          .db "(defer)", 0
007c08 7bf7          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
007c09 7001          .dw DO_COLON
                 PFA_DODEFER:
007c0a 01ab          .dw XT_DOCREATE
007c0b 0316          .dw XT_REVEAL
007c0c 01d9          .dw XT_COMPILE
007c0d 7c0f          .dw PFA_DODEFER1
007c0e 7020          .dw XT_EXIT
                 PFA_DODEFER1:
007c0f 940e 032f     call_ DO_DODOES
007c11 70b1          .dw XT_DUP
007c12 7ba7          .dw XT_ICELLPLUS
007c13 73c1          .dw XT_FETCHI
007c14 702a          .dw XT_EXECUTE 
007c15 702a          .dw XT_EXECUTE
007c16 7020          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
007c17 ff0f          .dw $ff0f
007c18 6573
007c19 7261
007c1a 6863
007c1b 772d
007c1c 726f
007c1d 6c64
007c1e 7369
007c1f 0074          .db "search-wordlist",0
007c20 7c03          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
007c21 7001          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
007c22 70ff          .dw XT_TO_R
007c23 7154          .dw XT_ZERO
007c24 703d          .dw XT_DOLITERAL
007c25 7c36          .dw XT_ISWORD
007c26 70f6          .dw XT_R_FROM
007c27 7c53          .dw XT_TRAVERSEWORDLIST
007c28 70b1          .dw XT_DUP
007c29 7118          .dw XT_ZEROEQUAL
007c2a 7036          .dw XT_DOCONDBRANCH
007c2b 7c30          DEST(PFA_SEARCH_WORDLIST1)
007c2c 754f             .dw XT_2DROP
007c2d 70d9             .dw XT_DROP
007c2e 7154             .dw XT_ZERO
007c2f 7020             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
007c30 70b1            .dw XT_DUP
007c31 7c7a            .dw XT_NFA2CFA
                       ; .. and get the header flag
007c32 70c4            .dw XT_SWAP
007c33 0186            .dw XT_NAME2FLAGS
007c34 0174            .dw XT_IMMEDIATEQ
007c35 7020          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
007c36 7001          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
007c37 70ff          .dw XT_TO_R
007c38 70d9          .dw XT_DROP
007c39 7546          .dw XT_2DUP
007c3a 7106          .dw XT_R_FETCH  ; -- addr len addr len nt
007c3b 7c6e          .dw XT_NAME2STRING
007c3c 7c84          .dw XT_ICOMPARE      ; (-- addr len f )
007c3d 7036          .dw XT_DOCONDBRANCH
007c3e 7c44          DEST(PFA_ISWORD3)
                       ; not now
007c3f 70f6            .dw XT_R_FROM
007c40 70d9            .dw XT_DROP
007c41 7154            .dw XT_ZERO
007c42 714b            .dw XT_TRUE         ; maybe next word
007c43 7020            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
007c44 754f            .dw XT_2DROP
007c45 70f6            .dw XT_R_FROM
007c46 7154            .dw XT_ZERO       ; finish traverse-wordlist
007c47 7020            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
007c48 ff11          .dw $ff11
007c49 7274
007c4a 7661
007c4b 7265
007c4c 6573
007c4d 772d
007c4e 726f
007c4f 6c64
007c50 7369
007c51 0074          .db "traverse-wordlist",0
007c52 7c17          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
007c53 7001          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
007c54 7355          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
007c55 70b1          .dw XT_DUP           ; ( -- xt nt nt )
007c56 7036          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
007c57 7c64          DEST(PFA_TRAVERSEWORDLIST2)
007c58 7546          .dw XT_2DUP
007c59 7314          .dw XT_2TO_R
007c5a 70c4          .dw XT_SWAP
007c5b 702a          .dw XT_EXECUTE
007c5c 7323          .dw XT_2R_FROM
007c5d 70e1          .dw XT_ROT
007c5e 7036          .dw XT_DOCONDBRANCH
007c5f 7c64          DEST(PFA_TRAVERSEWORDLIST2)
007c60 048f          .dw XT_NFA2LFA
007c61 73c1          .dw XT_FETCHI
007c62 702f          .dw XT_DOBRANCH      ; ( -- addr )
007c63 7c55          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
007c64 754f          .dw XT_2DROP
007c65 7020          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' )
                 ;        begin @ dup
                 ;        while
                 ;          2dup 2>r
                 ;          swap execute ( i*x nt -- i*x' f )
                 ;          2r> rot
                 ;        while
                 ;          nfa>lfa @i
                 ;        repeat then 2drop ;
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
007c66 ff0b          .dw $ff0b
007c67 616e
007c68 656d
007c69 733e
007c6a 7274
007c6b 6e69
007c6c 0067          .db "name>string",0
007c6d 7c48          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
007c6e 7001          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
007c6f 77ad          .dw XT_ICOUNT   ; ( -- addr n )
007c70 703d          .dw XT_DOLITERAL
007c71 00ff          .dw 255
007c72 7213          .dw XT_AND      ; mask immediate bit
007c73 7020          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
007c74 ff07          .dw $ff07
007c75 666e
007c76 3e61
007c77 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
007c78 0061          .db "nfa>cfa"
007c79 7c66          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
007c7a 7001          .dw DO_COLON
                 PFA_NFA2CFA:
007c7b 048f          .dw XT_NFA2LFA ; skip to link field
007c7c 722f          .dw XT_1PLUS   ; next is the execution token
007c7d 7020          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
007c7e ff08          .dw $ff08
007c7f 6369
007c80 6d6f
007c81 6170
007c82 6572          .db "icompare"
007c83 7c74          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
007c84 7001          .dw DO_COLON
                 PFA_ICOMPARE:
007c85 70ff          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
007c86 70cf          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
007c87 70f6          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
007c88 7111          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
007c89 7036          .dw XT_DOCONDBRANCH
007c8a 7c8f          .dw PFA_ICOMPARE_SAMELEN
007c8b 754f            .dw XT_2DROP
007c8c 70d9            .dw XT_DROP
007c8d 714b            .dw XT_TRUE
007c8e 7020            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
007c8f 70c4          .dw XT_SWAP ; ( -- r-addr f-addr len )
007c90 7154          .dw XT_ZERO
007c91 02a3          .dw XT_QDOCHECK
007c92 7036          .dw XT_DOCONDBRANCH
007c93 7cb2          .dw PFA_ICOMPARE_DONE
007c94 729b          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
007c95 70cf          .dw XT_OVER
007c96 7079          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
007c97 70cf          .dw XT_OVER
007c98 73c1          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
007c99 70b1          .dw XT_DUP
                     ;.dw XT_BYTESWAP
007c9a 703d          .dw XT_DOLITERAL
007c9b 0100          .dw $100
007c9c 715c          .dw XT_ULESS
007c9d 7036          .dw XT_DOCONDBRANCH
007c9e 7ca3          .dw PFA_ICOMPARE_LASTCELL
007c9f 70c4          .dw XT_SWAP
007ca0 703d          .dw XT_DOLITERAL
007ca1 00ff          .dw $00FF
007ca2 7213          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
007ca3 7111          .dw XT_NOTEQUAL
007ca4 7036          .dw XT_DOCONDBRANCH
007ca5 7caa          .dw PFA_ICOMPARE_NEXTLOOP
007ca6 754f          .dw XT_2DROP
007ca7 714b          .dw XT_TRUE
007ca8 72d4          .dw XT_UNLOOP
007ca9 7020          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
007caa 722f          .dw XT_1PLUS
007cab 70c4          .dw XT_SWAP
007cac 753f          .dw XT_CELLPLUS
007cad 70c4          .dw XT_SWAP
007cae 703d          .dw XT_DOLITERAL
007caf 0002          .dw 2
007cb0 72ba          .dw XT_DOPLUSLOOP
007cb1 7c95          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
007cb2 754f          .dw XT_2DROP
007cb3 7154          .dw XT_ZERO
007cb4 7020          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
007cb5 ff01          .dw $ff01
007cb6 002a          .db "*",0
007cb7 7c7e          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
007cb8 7001          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
007cb9 71a6          .dw XT_MSTAR
007cba 70d9          .dw XT_DROP
007cbb 7020          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
007cbc ff01          .dw $FF01
007cbd 006a          .db "j",0
007cbe 7cb5          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
007cbf 7001          .dw DO_COLON
                 PFA_J:
007cc0 7276          .dw XT_RP_FETCH
007cc1 703d          .dw XT_DOLITERAL
007cc2 0007          .dw 7
007cc3 719d          .dw XT_PLUS
007cc4 7079          .dw XT_FETCH
007cc5 7276          .dw XT_RP_FETCH
007cc6 703d          .dw XT_DOLITERAL
007cc7 0009          .dw 9
007cc8 719d          .dw XT_PLUS
007cc9 7079          .dw XT_FETCH
007cca 719d          .dw XT_PLUS
007ccb 7020          .dw XT_EXIT
                 
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
007ccc ff04          .dw $ff04
007ccd 6164
007cce 7362          .db "dabs"
007ccf 7cbc          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
007cd0 7001          .dw DO_COLON
                 PFA_DABS:
007cd1 70b1          .dw XT_DUP
007cd2 711f          .dw XT_ZEROLESS
007cd3 7036          .dw XT_DOCONDBRANCH
007cd4 7cd6          .dw PFA_DABS1
007cd5 7cdd          .dw XT_DNEGATE
                 PFA_DABS1:
007cd6 7020          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
007cd7 ff07          .dw $ff07
007cd8 6e64
007cd9 6765
007cda 7461
007cdb 0065          .db "dnegate",0
007cdc 7ccc          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
007cdd 7001          .dw DO_COLON
                 PFA_DNEGATE:
007cde 7452          .dw XT_DINVERT
007cdf 73dd          .dw XT_ONE
007ce0 7154          .dw XT_ZERO
007ce1 742c          .dw XT_DPLUS
007ce2 7020          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
007ce3 ff05          .dw $ff05
007ce4 6d63
007ce5 766f
007ce6 0065          .db "cmove",0
007ce7 7cd7          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
007ce8 7ce9          .dw PFA_CMOVE
                 PFA_CMOVE:
007ce9 93bf          push xh
007cea 93af          push xl
007ceb 91e9          ld zl, Y+
007cec 91f9          ld zh, Y+ ; addr-to
007ced 91a9          ld xl, Y+
007cee 91b9          ld xh, Y+ ; addr-from
007cef 2f09          mov temp0, tosh
007cf0 2b08          or temp0, tosl
007cf1 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
007cf2 911d          ld temp1, X+
007cf3 9311          st Z+, temp1
007cf4 9701          sbiw tosl, 1
007cf5 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
007cf6 91af          pop xl
007cf7 91bf          pop xh
007cf8 9189
007cf9 9199          loadtos
007cfa 940c 7005     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
007cfc ff05          .dw $ff05
007cfd 7332
007cfe 6177
007cff 0070          .db "2swap",0
007d00 7ce3          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
007d01 7001          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
007d02 70e1          .dw XT_ROT
007d03 70ff          .dw XT_TO_R
007d04 70e1          .dw XT_ROT
007d05 70f6          .dw XT_R_FROM
007d06 7020          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System
                 ; refills the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILLTIB:
007d07 ff0a          .dw $ff0a
007d08 6572
007d09 6966
007d0a 6c6c
007d0b 742d
007d0c 6269          .db "refill-tib"
007d0d 7cfc          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
007d0e 7001          .dw DO_COLON
                 PFA_REFILLTIB:
                 .endif
007d0f 7d2a          .dw XT_TIB
007d10 703d          .dw XT_DOLITERAL
007d11 005a          .dw TIB_SIZE
007d12 786f          .dw XT_ACCEPT
007d13 7d30          .dw XT_NUMBERTIB
007d14 7081          .dw XT_STORE
007d15 7154          .dw XT_ZERO
007d16 755f          .dw XT_TO_IN
007d17 7081          .dw XT_STORE
007d18 714b          .dw XT_TRUE ; -1
007d19 7020          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCETIB:
007d1a ff0a          .dw $FF0A
007d1b 6f73
007d1c 7275
007d1d 6563
007d1e 742d
007d1f 6269          .db "source-tib"
007d20 7d07          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
007d21 7001          .dw DO_COLON
                 PFA_SOURCETIB:
                 .endif
007d22 7d2a          .dw XT_TIB
007d23 7d30          .dw XT_NUMBERTIB
007d24 7079          .dw XT_FETCH
007d25 7020          .dw XT_EXIT
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; terminal input buffer address
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TIB:
007d26 ff03          .dw $ff03
007d27 6974
007d28 0062          .db "tib",0
007d29 7d1a          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
007d2a 7048          .dw PFA_DOVARIABLE
                 PFA_TIB:
007d2b 016a          .dw ram_tib
                 .dseg
00016a           ram_tib: .byte TIB_SIZE
                 .cseg
                 .endif
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBERTIB:
007d2c ff04          .dw $ff04
007d2d 7423
007d2e 6269          .db "#tib"
007d2f 7d26          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
007d30 7048          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
007d31 01c4          .dw ram_sharptib
                 .dseg
0001c4           ram_sharptib: .byte 2
                 .cseg
                 .endif
                 
                 .include "words/init-ram.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
007d32 ff06        .dw $ff06
007d33 6565
007d34 723e
007d35 6d61        .db "ee>ram"
007d36 7d2c        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
007d37 7001        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
007d38 7154          .dw XT_ZERO
007d39 729b          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
007d3a 70cf          .dw XT_OVER
007d3b 7355          .dw XT_FETCHE
007d3c 70cf          .dw XT_OVER
007d3d 7081          .dw XT_STORE
007d3e 753f          .dw XT_CELLPLUS
007d3f 70c4          .dw XT_SWAP
007d40 753f          .dw XT_CELLPLUS
007d41 70c4          .dw XT_SWAP
007d42 72c9          .dw XT_DOLOOP
007d43 7d3a          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
007d44 754f          .dw XT_2DROP
007d45 7020          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INIT_RAM:
007d46 ff08        .dw $ff08
007d47 6e69
007d48 7469
007d49 722d
007d4a 6d61        .db "init-ram"
007d4b 7d32        .dw VE_HEAD
                   .set VE_HEAD = VE_INIT_RAM
                 XT_INIT_RAM:
007d4c 7001        .dw DO_COLON
                 PFA_INI_RAM:          ; ( -- )
007d4d 703d          .dw XT_DOLITERAL
007d4e 006e          .dw EE_INITUSER
007d4f 7302          .dw XT_UP_FETCH
007d50 703d          .dw XT_DOLITERAL
007d51 0024          .dw SYSUSERSIZE
007d52 7204          .dw XT_2SLASH
007d53 7d37          .dw XT_EE2RAM
007d54 7020          .dw XT_EXIT
                 
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
007d55 ff06          .dw $ff06
007d56 6f62
007d57 6e75
007d58 7364          .db "bounds"
007d59 7d46          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
007d5a 7001          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
007d5b 70cf          .dw XT_OVER
007d5c 719d          .dw XT_PLUS
007d5d 70c4          .dw XT_SWAP
007d5e 7020          .dw XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
007d5f ff03          .dw $ff03
007d60 3e73
007d61 0064          .db "s>d",0
007d62 7d55          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
007d63 7001          .dw DO_COLON
                 PFA_S2D:
                 .endif
007d64 70b1          .dw XT_DUP
007d65 711f          .dw XT_ZEROLESS
007d66 7020          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
007d67 ff05          .dw $ff05
007d68 623e
007d69 646f
007d6a 0079          .db ">body",0
007d6b 7d5f          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
007d6c 7230          .dw PFA_1PLUS
                 
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .endif
                 .include "dict/interrupt.inc"
                 
                 .if WANT_INTERRUPTS == 1
                 
                 .if WANT_INTERRUPT_COUNTERS == 1
                   .include "words/irqcnt.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_IRQCNTADDR:
007d6d ff06          .dw $ff06
007d6e 7269
007d6f 5b71
007d70 235d          .db "irq[]#"
007d71 7d67          .dw VE_HEAD
                     .set VE_HEAD = VE_IRQCNTADDR
                 XT_IRQCNTADDR:
007d72 7001          .dw DO_COLON
                 PFA_IRQCNTADDR:
007d73 703d          .dw XT_DOLITERAL
007d74 0112          .dw intcnt
007d75 719d          .dw XT_PLUS
007d76 7020          .dw XT_EXIT
                   .include "words/int-num.asm"
                 
                 ; Interrupt
                 ; number of interrupt vectors (0 based)
                 VE_NUMINT:
007d77 ff04          .dw $ff04
007d78 6923
007d79 746e          .db "#int"
007d7a 7d6d          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMINT
                 XT_NUMINT:
007d7b 7048          .dw PFA_DOVARIABLE
                 PFA_NUMINT:
007d7c 001c          .dw INTVECTORS
                 .endif
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
007d7d ff04          .dw $ff04
007d7e 692b
007d7f 746e          .db "+int"
007d80 7d77          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
007d81 7d82          .dw PFA_INTON
                 PFA_INTON:
007d82 9478          sei
007d83 940c 7005     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
007d85 ff04          .dw $ff04
007d86 692d
007d87 746e          .db "-int"
007d88 7d7d          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
007d89 7d8a          .dw PFA_INTOFF
                 PFA_INTOFF:
007d8a 94f8          cli
007d8b 940c 7005     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
007d8d ff04          .dw $ff04
007d8e 6e69
007d8f 2174          .db "int!"
007d90 7d85          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
007d91 7001          .dw DO_COLON
                 PFA_INTSTORE:
007d92 703d          .dw XT_DOLITERAL
007d93 0000          .dw intvec
007d94 719d          .dw XT_PLUS
007d95 7331          .dw XT_STOREE
007d96 7020          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
007d97 ff04          .dw $ff04
007d98 6e69
007d99 4074          .db "int@"
007d9a 7d8d          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
007d9b 7001          .dw DO_COLON
                 PFA_INTFETCH:
007d9c 703d          .dw XT_DOLITERAL
007d9d 0000          .dw intvec
007d9e 719d          .dw XT_PLUS
007d9f 7355          .dw XT_FETCHE
007da0 7020          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
007da1 ff08          .dw $ff08
007da2 6e69
007da3 2d74
007da4 7274
007da5 7061          .db "int-trap"
007da6 7d97          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
007da7 7da8          .dw PFA_INTTRAP
                 PFA_INTTRAP:
007da8 2eb8          mov isrflag, tosl
007da9 9189
007daa 9199          loadtos
007dab 940c 7005     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
007dad 7001          .dw DO_COLON
                 PFA_ISREXEC:
007dae 7d9b          .dw XT_INTFETCH
007daf 702a          .dw XT_EXECUTE
007db0 7db2          .dw XT_ISREND
007db1 7020          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
007db2 7db3          .dw PFA_ISREND
                 PFA_ISREND:
007db3 d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
007db4 940c 7005     jmp_ DO_NEXT
                 PFA_ISREND1:
007db6 9518          reti
                 .endif
                 .elif AMFORTH_NRWW_SIZE>4000
                 .elif AMFORTH_NRWW_SIZE>2000
                 .else
                 .endif
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000038 ff ff     
                 ; some configs
00003a 75 05     CFG_DP:      .dw DPSTART         ; Dictionary Pointer
00003c c6 01     EE_HERE:     .dw HERESTART       ; Memory Allocation
00003e 94 00     EE_EHERE:    .dw EHERESTART      ; EEProm Memory Allocation
000040 4b 04     CFG_WLSCOPE: .dw XT_GET_CURRENT  ; default wordlist scope
000042 60 00     CFG_FORTHRECOGNIZER: .dw CFG_RECOGNIZERLISTLEN ; Recognizer word set
                 ; LEAVE stack is between data stack and return stack.
000044 b0 10     CFG_LP0:     .dw stackstart+1
000046 f1 04     CFG_TURNKEY: .dw XT_APPLTURNKEY    ; TURNKEY
000048 13 75     CFG_ENVIRONMENT:.dw VE_ENVHEAD     ; environmental queries
00004a 4c 00     CFG_CURRENT: .dw CFG_FORTHWORDLIST ; forth-wordlist
00004c a1 7d     CFG_FORTHWORDLIST:.dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
00004e 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000050 4c 00         .dw CFG_FORTHWORDLIST      ; get/set-order
000052               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
000060 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
000062 1c 7b         .dw XT_REC_FIND
000064 08 7b         .dw XT_REC_NUM
000066               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_STOREI:
00006a 74 73         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
00006c 6c 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
00006e 00 00         .dw 0  ; USER_STATE
000070 00 00         .dw 0  ; USER_FOLLOWER
000072 ff 10         .dw rstackstart  ; USER_RP
000074 af 10         .dw stackstart   ; USER_SP0
000076 af 10         .dw stackstart   ; USER_SP
                     
000078 00 00         .dw 0  ; USER_HANDLER
00007a 0a 00         .dw 10 ; USER_BASE
                     
00007c a7 00         .dw XT_TX  ; USER_EMIT
00007e b5 00         .dw XT_TXQ ; USER_EMITQ
000080 7c 00         .dw XT_RX  ; USER_KEY
000082 97 00         .dw XT_RXQ ; USER_KEYQ
000084 21 7d         .dw XT_SOURCETIB ; USER_SOURCE
000086 00 00         .dw 0            ; USER_G_IN
000088 0e 7d         .dw XT_REFILLTIB ; USER_REFILL  
00008a d5 79         .dw XT_DEFAULT_PROMPTOK
00008c f4 79         .dw XT_DEFAULT_PROMPTERROR
00008e e4 79         .dw XT_DEFAULT_PROMPTREADY
000090 0f 7a         .dw XT_DEFAULT_PROMPTINPUT
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
000092 19 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega644" register use summary:
r0 :  25 r1 :   5 r2 :  11 r3 :  12 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   7 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  89 r17:  61 r18:  61 r19:  37 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 212 r25: 144 r26:  28 r27:  17 r28:   7 r29:   4 r30:  90 r31:  49 
x  :   4 y  : 215 z  :  50 
Registers used: 29 out of 35 (82.9%)

"ATmega644" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  22 add   :  17 adiw  :  17 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   3 brcs  :   1 break :   0 breq  :   7 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  22 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   7 cbr   :   1 
clc   :   2 clh   :   0 cli   :   7 cln   :   0 clr   :  14 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  14 cp    :  11 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :  10 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  25 inc   :   3 jmp   :  19 
ld    : 143 ldd   :   4 ldi   :  41 lds   :   1 lpm   :  16 lsl   :  14 
lsr   :   2 mov   :  16 movw  :  73 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   2 out   :  22 pop   :  49 
push  :  43 rcall :  41 ret   :   7 reti  :   1 rjmp  : 101 rol   :  23 
ror   :   6 sbc   :   9 sbci  :   3 sbi   :   8 sbic  :   3 sbis  :   0 
sbiw  :  16 sbr   :   0 sbrc  :   5 sbrs  :   7 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   4 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  81 std   :   8 sts   :   1 
sub   :   6 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 73 out of 113 (64.6%)

"ATmega644" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00fb6e   2102  14680  16782   65536  25.6%
[.dseg] 0x000100 0x0001c6      0    198    198    4096   4.8%
[.eseg] 0x000000 0x000094      0    148    148    2048   7.2%

Assembly complete, 0 errors, 8 warnings
