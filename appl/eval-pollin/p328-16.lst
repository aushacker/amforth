
AVRASM ver. 2.1.52  p328-16.asm Sun Oct 18 18:22:43 2020

p328-16.asm(5): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega328p\device.asm'
../../avr8/devices/atmega328p\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m328Pdef.inc'
p328-16.asm(14): Including file '../../avr8\drivers/usart_0.asm'
../../avr8\drivers/usart_0.asm(32): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(11): Including file '../../avr8\drivers/usart-rx-buffer.asm'
../../avr8\drivers/usart_common.asm(24): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(29): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(30): Including file '../../avr8\words/usart.asm'
p328-16.asm(19): Including file '../../avr8\drivers/1wire.asm'
p328-16.asm(21): Including file '../../avr8\amforth.asm'
../../avr8\amforth.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth.asm(14): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(7): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/rww.inc(12): Including file '../../avr8\dict/appl_4k.inc'
../../avr8\dict/appl_4k.inc(1): Including file '../../common\words/ver.asm'
../../avr8\dict/appl_4k.inc(5): Including file '../../avr8\words/unused.asm'
../../avr8\dict/appl_4k.inc(6): Including file '../../common\words/to.asm'
../../avr8\dict/appl_4k.inc(7): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/appl_4k.inc(8): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/appl_4k.inc(9): Including file '../../common\words/star.asm'
../../avr8\dict/appl_4k.inc(10): Including file '../../avr8\words/j.asm'
../../avr8\dict/appl_4k.inc(11): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/appl_4k.inc(12): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/appl_4k.inc(13): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/appl_4k.inc(14): Including file '../../common\words/2swap.asm'
../../avr8\dict/appl_4k.inc(15): Including file '../../common\words/tib.asm'
../../avr8\dict/appl_4k.inc(16): Including file '../../avr8\words/init-ram.asm'
../../avr8\dict/appl_4k.inc(20): Including file '../../avr8\words/environment.asm'
../../avr8\dict/appl_4k.inc(21): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/appl_4k.inc(22): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/appl_4k.inc(23): Including file '../../common\words/env-slashhold.asm'
../../avr8\dict/appl_4k.inc(24): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/appl_4k.inc(25): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/appl_4k.inc(26): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/appl_4k.inc(27): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/appl_4k.inc(28): Including file '../../common\words/env-usersize.asm'
../../avr8\dict/appl_4k.inc(30): Including file '../../avr8\words/hld.asm'
../../avr8\dict/appl_4k.inc(31): Including file '../../common\words/hold.asm'
../../avr8\dict/appl_4k.inc(32): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/appl_4k.inc(33): Including file '../../common\words/sharp.asm'
../../avr8\dict/appl_4k.inc(34): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/appl_4k.inc(35): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/appl_4k.inc(36): Including file '../../common\words/sign.asm'
../../avr8\dict/appl_4k.inc(37): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/appl_4k.inc(38): Including file '../../common\words/dot-r.asm'
../../avr8\dict/appl_4k.inc(39): Including file '../../common\words/d-dot.asm'
../../avr8\dict/appl_4k.inc(40): Including file '../../common\words/dot.asm'
../../avr8\dict/appl_4k.inc(41): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/appl_4k.inc(42): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/appl_4k.inc(43): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/appl_4k.inc(44): Including file '../../common\words/digit-q.asm'
../../avr8\dict/appl_4k.inc(46): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/appl_4k.inc(47): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/appl_4k.inc(48): Including file '../../avr8\words/itype.asm'
../../avr8\dict/appl_4k.inc(49): Including file '../../avr8\words/icount.asm'
../../avr8\dict/appl_4k.inc(50): Including file '../../common\words/type.asm'
../../avr8\dict/appl_4k.inc(51): Including file '../../common\words/tick.asm'
../../avr8\dict/appl_4k.inc(53): Including file '../../common\words/cskip.asm'
../../avr8\dict/appl_4k.inc(54): Including file '../../common\words/cscan.asm'
../../avr8\dict/appl_4k.inc(55): Including file '../../common\words/accept.asm'
../../avr8\dict/appl_4k.inc(56): Including file '../../common\words/refill.asm'
../../avr8\dict/appl_4k.inc(57): Including file '../../common\words/char.asm'
../../avr8\dict/appl_4k.inc(58): Including file '../../common\words/number.asm'
../../avr8\dict/appl_4k.inc(59): Including file '../../common\words/q-sign.asm'
../../avr8\dict/appl_4k.inc(60): Including file '../../common\words/set-base.asm'
../../avr8\dict/appl_4k.inc(61): Including file '../../common\words/to-number.asm'
../../avr8\dict/appl_4k.inc(62): Including file '../../common\words/parse.asm'
../../avr8\dict/appl_4k.inc(63): Including file '../../common\words/source.asm'
../../avr8\dict/appl_4k.inc(64): Including file '../../common\words/slash-string.asm'
../../avr8\dict/appl_4k.inc(65): Including file '../../common\words/parse-name.asm'
../../avr8\dict/appl_4k.inc(66): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/appl_4k.inc(67): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/appl_4k.inc(68): Including file '../../common\words/depth.asm'
../../avr8\dict/appl_4k.inc(69): Including file '../../avr8\words/forth-recognizer.asm'
../../avr8\dict/appl_4k.inc(70): Including file '../../common\words/recognize.asm'
../../avr8\dict/appl_4k.inc(71): Including file '../../common\words/interpret.asm'
../../avr8\dict/appl_4k.inc(72): Including file '../../common\words/rec-intnum.asm'
../../avr8\dict/appl_4k.inc(73): Including file '../../common\words/rec-find.asm'
../../avr8\dict/appl_4k.inc(74): Including file '../../common\words/rec-null.asm'
../../avr8\dict/appl_4k.inc(75): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/appl_4k.inc(76): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/appl_4k.inc(77): Including file '../../common\words/name2string.asm'
../../avr8\dict/appl_4k.inc(78): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/appl_4k.inc(79): Including file '../../common\words/find-xt.asm'
../../avr8\dict/appl_4k.inc(81): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/newest.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/do-create.asm'
../../avr8\dict/compiler1.inc(5): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(9): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(10): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(17): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(33): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(38): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../common\words/create.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../common\words/reveal.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(53): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../common\words/recurse.asm'
../../avr8\dict/compiler1.inc(56): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(61): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(67): Including file '../../common\words/cfg-order.asm'
../../avr8\dict/compiler1.inc(68): Including file '../../common\words/cfg-recognizer.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(70): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\dict/appl_4k.inc(82): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/irqcnt.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-num.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(10): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(11): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(12): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(13): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(15): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(16): Including file '../../avr8\words/isr-end.asm'
../../avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(3): Including file '../../common\words/dot-s.asm'
dict_appl.inc(4): Including file '../../avr8\words/spirw.asm'
dict_appl.inc(5): Including file '../../avr8\words/n-spi.asm'
dict_appl.inc(6): Including file 'words/applturnkey.asm'
dict_appl.inc(7): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../common\words/postpone.asm'
dict_appl.inc(8): Including file '../../avr8\words/2r_fetch.asm'
../../avr8\amforth.asm(23): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth.asm(24): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(35): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(36): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(42): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(45): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(46): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(49): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(56): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(63): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../common\words/q-negate.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(89): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(95): Including file '../../avr8\words/store-i_nrww.asm'
../../avr8\dict/nrww.inc(97): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(98): Including file '../../common\words/2literal.asm'
../../avr8\dict/nrww.inc(99): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(100): Including file '../../common\words/num-constants.asm'
../../avr8\dict/nrww.inc(105): Including file '../../avr8\dict/core_4k.inc'
../../avr8\dict/core_4k.inc(3): Including file '../../avr8\words/n_to_r.asm'
../../avr8\dict/core_4k.inc(4): Including file '../../avr8\words/n_r_from.asm'
../../avr8\dict/core_4k.inc(5): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/core_4k.inc(6): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/core_4k.inc(7): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/core_4k.inc(8): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/core_4k.inc(9): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/core_4k.inc(10): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/core_4k.inc(11): Including file '../../common\words/abs.asm'
../../avr8\dict/core_4k.inc(12): Including file '../../common\words/pick.asm'
../../avr8\dict/core_4k.inc(13): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/core_4k.inc(16): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/core_4k.inc(17): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/core_4k.inc(18): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/core_4k.inc(19): Including file '../../common\words/prompt-input.asm'
../../avr8\dict/core_4k.inc(20): Including file '../../common\words/quit.asm'
../../avr8\dict/core_4k.inc(21): Including file '../../avr8\words/pause.asm'
../../avr8\dict/core_4k.inc(22): Including file '../../avr8\words/cold.asm'
../../avr8\dict/core_4k.inc(23): Including file '../../common\words/warm.asm'
../../avr8\dict/core_4k.inc(25): Including file '../../common\words/handler.asm'
../../avr8\dict/core_4k.inc(26): Including file '../../common\words/catch.asm'
../../avr8\dict/core_4k.inc(27): Including file '../../common\words/throw.asm'
../../avr8\dict/core_4k.inc(30): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/core_4k.inc(31): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/core_4k.inc(32): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/core_4k.inc(33): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/core_4k.inc(34): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/core_4k.inc(35): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/core_4k.inc(36): Including file '../../common\words/defer-store.asm'
../../avr8\dict/core_4k.inc(37): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/core_4k.inc(38): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/core_4k.inc(40): Including file '../../common\words/u-dot.asm'
../../avr8\dict/core_4k.inc(41): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/core_4k.inc(44): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/core_4k.inc(45): Including file '../../avr8\words/negate.asm'
../../avr8\dict/core_4k.inc(46): Including file '../../common\words/slash.asm'
../../avr8\dict/core_4k.inc(47): Including file '../../common\words/mod.asm'
../../avr8\dict/core_4k.inc(49): Including file '../../common\words/min.asm'
../../avr8\dict/core_4k.inc(50): Including file '../../common\words/max.asm'
../../avr8\dict/core_4k.inc(51): Including file '../../common\words/within.asm'
../../avr8\dict/core_4k.inc(53): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/core_4k.inc(54): Including file '../../common\words/words.asm'
../../avr8\dict/core_4k.inc(56): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/core_4k.inc(57): Including file '../../common\words/squote.asm'
../../avr8\dict/core_4k.inc(58): Including file '../../avr8\words/fill.asm'
../../avr8\dict/core_4k.inc(60): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/core_4k.inc(61): Including file '../../avr8\words/state.asm'
../../avr8\dict/core_4k.inc(62): Including file '../../common\words/base.asm'
../../avr8\dict/core_4k.inc(64): Including file '../../avr8\words/cells.asm'
../../avr8\dict/core_4k.inc(66): Including file '../../common\words/2dup.asm'
../../avr8\dict/core_4k.inc(67): Including file '../../common\words/2drop.asm'
../../avr8\dict/core_4k.inc(68): Including file '../../common\words/tuck.asm'
../../avr8\dict/core_4k.inc(70): Including file '../../common\words/to-in.asm'
../../avr8\dict/core_4k.inc(71): Including file '../../common\words/pad.asm'
../../avr8\dict/core_4k.inc(72): Including file '../../common\words/emit.asm'
../../avr8\dict/core_4k.inc(73): Including file '../../common\words/emitq.asm'
../../avr8\dict/core_4k.inc(74): Including file '../../common\words/key.asm'
../../avr8\dict/core_4k.inc(75): Including file '../../common\words/keyq.asm'
../../avr8\dict/core_4k.inc(77): Including file '../../avr8\words/dp.asm'
../../avr8\dict/core_4k.inc(78): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/core_4k.inc(79): Including file '../../avr8\words/here.asm'
../../avr8\dict/core_4k.inc(80): Including file '../../avr8\words/allot.asm'
../../avr8\dict/core_4k.inc(82): Including file '../../common\words/bin.asm'
../../avr8\dict/core_4k.inc(83): Including file '../../common\words/decimal.asm'
../../avr8\dict/core_4k.inc(84): Including file '../../common\words/hex.asm'
../../avr8\dict/core_4k.inc(85): Including file '../../common\words/bl.asm'
../../avr8\dict/core_4k.inc(87): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/core_4k.inc(88): Including file '../../common\words/to-upper.asm'
../../avr8\dict/core_4k.inc(89): Including file '../../common\words/to-lower.asm'
../../avr8\dict/core_4k.inc(91): Including file '../../common\words/q-stack.asm'
../../avr8\dict/core_4k.inc(92): Including file '../../common\words/bounds.asm'
../../avr8\dict/core_4k.inc(93): Including file '../../common\words/cr.asm'
../../avr8\dict/core_4k.inc(94): Including file '../../common\words/space.asm'
../../avr8\dict/core_4k.inc(95): Including file '../../common\words/spaces.asm'
../../avr8\dict/core_4k.inc(96): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/core_4k.inc(97): Including file '../../avr8\words/to-body.asm'
../../avr8\dict/core_4k.inc(98): Including file '../../common\words/noop.asm'
../../avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
../../avr8\amforth.asm(36): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; file see ../template/template.asm. You may want to
                 ; copy that file to this one and edit it afterwards.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set USER_P_OK    = 28
                 .set USER_P_ERR   = 30
                 .set USER_P_RDY   = 32
                 .set USER_P_INPUT = 34
                 
                 .set SYSUSERSIZE = 36
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot = r10
                   .def isrflag  = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  256
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 .set WANT_USART0 = 0
                 .set WANT_TWI = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_SPI = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_CPU = 0
                 .set WANT_EEPROM = 0
                 .equ intvecsize = 2 ; please verify; flash size: 32768 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d126      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d124      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d122      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 8
000008 d120      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 10
00000a d11e      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 12
00000c d11c      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 14
00000e d11a      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 16
000010 d118      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 18
000012 d116      	 rcall isr ; Timer/Counter2 Overflow
                 .org 20
000014 d114      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 22
000016 d112      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 24
000018 d110      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 26
00001a d10e      	 rcall isr ; Timer/Counter1 Overflow
                 .org 28
00001c d10c      	 rcall isr ; TimerCounter0 Compare Match A
                 .org 30
00001e d10a      	 rcall isr ; TimerCounter0 Compare Match B
                 .org 32
000020 d108      	 rcall isr ; Timer/Couner0 Overflow
                 .org 34
000022 d106      	 rcall isr ; SPI Serial Transfer Complete
                 .org 36
000024 d104      	 rcall isr ; USART Rx Complete
                 .org 38
000026 d102      	 rcall isr ; USART, Data Register Empty
                 .org 40
000028 d100      	 rcall isr ; USART Tx Complete
                 .org 42
00002a d0fe      	 rcall isr ; ADC Conversion Complete
                 .org 44
00002c d0fc      	 rcall isr ; EEPROM Ready
                 .org 46
00002e d0fa      	 rcall isr ; Analog Comparator
                 .org 48
000030 d0f8      	 rcall isr ; Two-wire Serial Interface
                 .org 50
000032 d0f6      	 rcall isr ; Store Program Memory Read
                 .equ INTVECTORS = 26
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 .equ SPMEN = SELFPRGEN
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000033 0800      	.dw 2048
                 mcu_eepromsize:
000034 0400      	.dw 1024
                 mcu_maxdp:
000035 7000      	.dw 28672 
                 mcu_numints:
000036 001a      	.dw 26
                 mcu_name:
000037 000a      	.dw 10
000038 5441
000039 656d
00003a 6167
00003b 3233
00003c 5038      	.db "ATmega328P"
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 ; enabling Interrupts, disabling them affects
                 ; other settings as well. 
                 .set WANT_INTERRUPTS = 1
                 
                 ; count the number of interrupts individually.
                 ; requires a lot of RAM (one byte per interrupt)
                 ; disabled by default.
                 .set WANT_INTERRUPT_COUNTERS = 1
                 
                 ; receiving is asynchronously, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIB_SIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR+1
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 16000000
                 .set BAUD_MAXERROR = 30
                 .equ TIMER_INT = OVF2addr
                 
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_INTERRUPTS == 0
                   .if WANT_ISR_RX == 1
                   .endif
                 .endif
                 
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-rx-buffer.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100            usart_rx_data: .byte usart_rx_size
000110            usart_rx_in:   .byte 1
000111            usart_rx_out:  .byte 1
                 .cseg
                 
                 VE_TO_RXBUF:
00003d ff07          .dw $ff07
00003e 723e
00003f 2d78
000040 7562
000041 0066          .db ">rx-buf",0
000042 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_RXBUF
                 XT_TO_RXBUF:
000043 0044          .dw PFA_rx_tobuf
                 PFA_rx_tobuf:
000044 2f08          mov temp0, tosl
000045 9110 0110     lds temp1, usart_rx_in
000047 e0e0          ldi zl, low(usart_rx_data)
000048 e0f1          ldi zh, high(usart_rx_data)
000049 0fe1          add zl, temp1
00004a 1df3          adc zh, zeroh
00004b 8300          st Z, temp0
00004c 9513          inc temp1
00004d 701f          andi temp1,usart_rx_mask
00004e 9310 0110     sts usart_rx_in, temp1
000050 9189
000051 9199          loadtos
000052 940c 3805     jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; setup with
                 ; ' isr-rx URXCaddr int!
                 VE_ISR_RX:
000054 ff06          .dw $ff06
000055 7369
000056 2d72
000057 7872          .db "isr-rx"
000058 003d          .dw VE_HEAD
                     .set VE_HEAD = VE_ISR_RX
                 XT_ISR_RX:
000059 3801          .dw DO_COLON
                 usart_rx_isr:
00005a 383d        .dw XT_DOLITERAL
00005b 00c6        .dw usart_data
00005c 3898        .dw XT_CFETCH
00005d 38b1        .dw XT_DUP
00005e 383d        .dw XT_DOLITERAL
00005f 0003        .dw 3
000060 3bd6        .dw XT_EQUAL
000061 3836        .dw XT_DOCONDBRANCH
000062 0064        .dw usart_rx_isr1
000063 3d26        .dw XT_COLD
                 usart_rx_isr1:
000064 0043        .dw XT_TO_RXBUF
000065 3820        .dw XT_EXIT
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RXBUFFER:
                 ;  .dw $ff0x
                 ;  .db "+usart-buffer"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RXBUFFER
                 XT_USART_INIT_RX_BUFFER:
000066 3801        .dw DO_COLON
                 PFA_USART_INIT_RX_BUFFER:          ; ( -- )
000067 383d
000068 0059        .dw XT_DOLITERAL, XT_ISR_RX
000069 383d
00006a 0024        .dw XT_DOLITERAL, URXCaddr
00006b 0a5f        .dw XT_INTSTORE
                 
00006c 383d        .dw XT_DOLITERAL
00006d 0100        .dw usart_rx_data
00006e 383d        .dw XT_DOLITERAL
00006f 0016        .dw usart_rx_size + 6
000070 3954        .dw XT_ZERO
000071 3e83        .dw XT_FILL
000072 3820        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_BUFFER:
000073 ff06          .dw $ff06
000074 7872
000075 622d
000076 6675          .db "rx-buf"
000077 0054          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_BUFFER
                 XT_RX_BUFFER:
000078 3801          .dw DO_COLON
                 PFA_RX_BUFFER:
000079 0093        .dw XT_RXQ_BUFFER
00007a 3836        .dw XT_DOCONDBRANCH
00007b 0079        .dw PFA_RX_BUFFER
00007c 383d        .dw XT_DOLITERAL
00007d 0111        .dw usart_rx_out
00007e 3898        .dw XT_CFETCH
00007f 38b1        .dw XT_DUP
000080 383d        .dw XT_DOLITERAL
000081 0100        .dw usart_rx_data
000082 399d        .dw XT_PLUS
000083 3898        .dw XT_CFETCH
000084 38c4        .dw XT_SWAP
000085 3a2f        .dw XT_1PLUS
000086 383d        .dw XT_DOLITERAL
000087 000f        .dw usart_rx_mask
000088 3a13        .dw XT_AND
000089 383d        .dw XT_DOLITERAL
00008a 0111        .dw usart_rx_out
00008b 388d        .dw XT_CSTORE
00008c 3820        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue
                 VE_RXQ_BUFFER:
00008d ff07          .dw $ff07
00008e 7872
00008f 2d3f
000090 7562
000091 0066          .db "rx?-buf",0
000092 0073          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_BUFFER
                 XT_RXQ_BUFFER:
000093 3801          .dw DO_COLON
                 PFA_RXQ_BUFFER:
000094 3d1e        .dw XT_PAUSE
000095 383d        .dw XT_DOLITERAL
000096 0111        .dw usart_rx_out
000097 3898        .dw XT_CFETCH
000098 383d        .dw XT_DOLITERAL
000099 0110        .dw usart_rx_in
00009a 3898        .dw XT_CFETCH
00009b 3911        .dw XT_NOTEQUAL
00009c 3820        .dw XT_EXIT
                 ;  .include "drivers/timer-usart-isr.asm"
                   .set XT_RX  = XT_RX_BUFFER
                   .set XT_RXQ = XT_RXQ_BUFFER
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_BUFFER
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
00009d ff07          .dw $ff07
00009e 7874
00009f 702d
0000a0 6c6f
0000a1 006c          .db "tx-poll",0
0000a2 008d          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
0000a3 3801          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
0000a4 00b1        .dw XT_TXQ_POLL
0000a5 3836        .dw XT_DOCONDBRANCH
0000a6 00a4        .dw PFA_TX_POLL
                   ; send to usart
0000a7 383d        .dw XT_DOLITERAL
0000a8 00c6        .dw USART_DATA
0000a9 388d        .dw XT_CSTORE
0000aa 3820        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
0000ab ff08          .dw $ff08
0000ac 7874
0000ad 2d3f
0000ae 6f70
0000af 6c6c          .db "tx?-poll"
0000b0 009d          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000b1 3801          .dw DO_COLON
                 PFA_TXQ_POLL:
0000b2 3d1e        .dw XT_PAUSE
0000b3 383d        .dw XT_DOLITERAL
0000b4 00c0        .dw USART_A
0000b5 3898        .dw XT_CFETCH
0000b6 383d        .dw XT_DOLITERAL
0000b7 0020        .dw bm_USART_TXRD
0000b8 3a13        .dw XT_AND
0000b9 3820        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000ba ff04        .dw $ff04
0000bb 6275
0000bc 7272        .db "ubrr"
0000bd 00ab        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000be 386f        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000bf 008e        .dw EE_UBRRVAL
0000c0 3d8b        .dw XT_EDEFERFETCH
0000c1 3d95        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000c2 ff06        .dw $ff06
0000c3 752b
0000c4 6173
0000c5 7472        .db "+usart"
0000c6 00ba        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000c7 3801        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000c8 383d        .dw XT_DOLITERAL
0000c9 0098        .dw USART_B_VALUE
0000ca 383d        .dw XT_DOLITERAL
0000cb 00c1        .dw USART_B
0000cc 388d        .dw XT_CSTORE
                 
0000cd 383d        .dw XT_DOLITERAL
0000ce 0006        .dw USART_C_VALUE
0000cf 383d        .dw XT_DOLITERAL
0000d0 00c2        .dw USART_C | bm_USARTC_en
0000d1 388d        .dw XT_CSTORE
                 
0000d2 00be        .dw XT_UBRR
0000d3 38b1        .dw XT_DUP
0000d4 3af9        .dw XT_BYTESWAP
0000d5 383d        .dw XT_DOLITERAL
0000d6 00c5        .dw BAUDRATE_HIGH
0000d7 388d        .dw XT_CSTORE
0000d8 383d        .dw XT_DOLITERAL
0000d9 00c4        .dw BAUDRATE_LOW
0000da 388d        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
0000db 0066        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
0000dc 3820        .dw XT_EXIT
                 
                 ; settings for 1wire interface
                 .equ OW_PORT=PORTB
                 .EQU OW_BIT=4
                 .include "drivers/1wire.asm"
                 
                 ;   B. J. Rodriguez (MSP 430)
                 ;   Matthias Trute (AVR Atmega)
                 ; COPYRIGHT
                 ;   (c) 2012 Bradford J. Rodriguez for the 430 code and API
                 
                 ;  adapted 430 assembly code to AVR
                 ;  wishlist: 
                 ;     use a configurable pin at runtime, compatible with bitnames.frt
                 ;     no external pull up, no external power supply for devices
                 ;     ???
                 ;
                 ;.EQU OW_BIT=4
                 ;.equ OW_PORT=PORTE
                 .set OW_DDR=(OW_PORT-1)
                 .set OW_PIN=(OW_DDR-1)
                 
                 ;****f* 1W.RESET
                 ; NAME
                 ;   1W.RESET
                 ; SYNOPSIS
                 ;   1W.RESET ( -- f )  Initialize 1-wire devices; return true if present
                 ; DESCRIPTION
                 ;   This configures the port pin used by the 1-wire interface, and then
                 ;   sends an "initialize" sequence to the 1-wire devices.  If any device
                 ;   is present, it will be detected.
                 ;
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" (drive output low) for >480 usec.
                 ;   b) Output "1" (let output float).
                 ;   c) After 15 to 60 usec, device will drive pin low for 60 to 240 usec.
                 ;      So, wait 75 usec and sample input.
                 ;   d) Leave output high (floating) for at least 480 usec.
                 ;******
                 ; ( -- f )
                 ; Hardware
                 ; Initialize 1-wire devices; return true if present
                 VE_OW_RESET:
0000dd ff08          .dw $ff08
0000de 7731
0000df 722e
0000e0 7365
0000e1 7465          .db "1w.reset"
0000e2 00c2          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_RESET
                 XT_OW_RESET:
0000e3 00e4          .dw PFA_OW_RESET
                 PFA_OW_RESET:
0000e4 939a
0000e5 938a          savetos
                     ; setup to output
0000e6 9a24          sbi OW_DDR, OW_BIT
                     ; Pull output low
0000e7 982c          cbi OW_PORT, OW_BIT
                     ; Delay >480 usec        
0000e8 e8e0
0000e9 e0f7
0000ea 9731
0000eb f7f1          DELAY   480
                     ; Critical timing period, disable interrupts.
0000ec b71f          in temp1, SREG
0000ed 94f8          cli
                     ; Pull output high
0000ee 9a2c          sbi OW_PORT, OW_BIT
                     ; make pin input, sends "1"
0000ef 9824          cbi OW_DDR, OW_BIT 
0000f0 e0e0
0000f1 e0f1
0000f2 9731
0000f3 f7f1          DELAY   64 ; delayB
                     ; Sample input pin, set TOS if input is zero
0000f4 b183          in tosl, OW_PIN
0000f5 ff84          sbrs tosl, OW_BIT
0000f6 ef9f          ser  tosh
                     ; End critical timing period, enable interrupts
0000f7 bf1f          out SREG, temp1
                     ; release bus
0000f8 9824          cbi OW_DDR, OW_BIT
0000f9 982c          cbi OW_PORT, OW_BIT
                 
                     ; Delay rest of 480 usec 
0000fa e8e0
0000fb e0f6
0000fc 9731
0000fd f7f1          DELAY   416
                     ; we now have the result flag in TOS        
0000fe 2f89          mov tosl, tosh
0000ff 940c 3805     jmp_ DO_NEXT
                     
                 ;****f* 1W.SLOT
                 ; NAME
                 ;   1W.SLOT
                 ; SYNOPSIS
                 ;   1W.SLOT ( c -- c' ) Write and read one bit to/from 1-wire.
                 ; DESCRIPTION
                 ;   The "touch byte" function is described in Dallas App Note 74.
                 ;   It outputs a byte to the 1-wire pin, LSB first, and reads back
                 ;   the state of the 1-wire pin after a suitable delay.
                 ;   To read a byte, output $FF and read the reply data.
                 ;   To write a byte, output that byte and discard the reply.
                 ;
                 ;   This function performs one bit of the "touch" operation --
                 ;   one read/write "slot" in Dallas jargon.  Perform this eight
                 ;   times in a row to get the "touch byte" function.
                 ;
                 ; PARAMETERS
                 ;   The input parameter is xxxxxxxxbbbbbbbo where
                 ;   'xxxxxxxx' are don't cares,
                 ;   'bbbbbbb' are bits to be shifted down, and
                 ;   'o' is the bit to be output in the slot.  This must be 1
                 ;   to create a read slot.
                 ;
                 ;   The returned value is xxxxxxxxibbbbbbb where
                 ;   'xxxxxxxx' are not known (the input shifted down 1 position),
                 ;   'i' is the bit read during the slot.  This has no meaning
                 ;   if it was a write slot.
                 ;   'bbbbbbb' are the 7 input bits, shifted down one position.
                 ;
                 ;   This peculiar parameter usage allows OWTOUCH to be written as
                 ;     OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT 
                 ;
                 ; NOTES 
                 ;   Interrupts are disabled during each bit.
                 
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" for start period.  (> 1 us, < 15 us, typ. 6 us*)
                 ;   b) Output data bit (0 or 1), open drain 
                 ;   c) After MS from start of cycle, sample input (15 to 60 us, typ. 25 us*)
                 ;   d) After write-0 period from start of cycle, output "1" (>60 us)
                 ;   e) After recovery period, loop or return. (> 1 us)
                 ;   For writes, DS18B20 samples input 15 to 60 usec from start of cycle.
                 ;   * "Typical" values are per App Note 132 for a 300m cable length.
                 
                 ;   ---------        -------------------------------
                 ;            \      /                        /
                 ;             ------------------------------- 
                 ;            a      b          c             d     e
                 ;            |  6us |   19us   |    35us     | 2us |
                 ;******
                 ; ( c -- c' )
                 ; Hardware
                 ; Write and read one bit to/from 1-wire.
                 VE_OW_SLOT:
000101 ff07          .dw $ff07
000102 7731
000103 732e
000104 6f6c
000105 0074          .db "1w.slot",0
000106 00dd          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_SLOT
                 XT_OW_SLOT:
000107 0108          .dw PFA_OW_SLOT
                 PFA_OW_SLOT:
                     ; pull low
000108 982c          cbi OW_PORT, OW_BIT
000109 9a24          sbi OW_DDR, OW_BIT
                     ; disable interrupts
00010a b71f          in temp1, SREG
00010b 94f8          cli
00010c e1e8
00010d e0f0
00010e 9731
00010f f7f1          DELAY   6 ; DELAY A
                     ; check bit
000110 9488          clc
000111 9587          ror tosl
000112 f410          brcc PFA_OW_SLOT0 ; a 0 keeps the bus low
                       ; release bus, a 1 is written
000113 9a2c            sbi OW_PORT, OW_BIT
000114 9824            cbi OW_DDR, OW_BIT
                 PFA_OW_SLOT0:
                     ; sample the input (no action required if zero)
000115 e2e4
000116 e0f0
000117 9731
000118 f7f1          DELAY 9   ; wait DELAY E to sample
000119 b103          in temp0, OW_PIN
00011a fd04          sbrc temp0, OW_BIT
00011b 6880          ori tosl, $80
                 
00011c ecec
00011d e0f0
00011e 9731
00011f f7f1          DELAY   51 ; DELAY B
000120 9a2c          sbi OW_PORT, OW_BIT ; release bus
000121 9824          cbi OW_DDR, OW_BIT
000122 e0e8
000123 e0f0
000124 9731
000125 f7f1          delay 2
                     ; re-enable interrupts
000126 bf1f          out SREG, temp1
000127 940c 3805     jmp_ DO_NEXT
                 
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 
                 .set corepc = pc
                 .org $0000
000000 940c 3d27   jmp_ PFA_COLD
                 
                 .org corepc
                 .include "drivers/generic-isr.asm"
                 
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .if WANT_INTERRUPT_COUNTERS==1
                 .dseg
000112           intcnt: .byte INTVECTORS
                 .endif
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
000129 920a          st -Y, r0
00012a b60f          in r0, SREG
00012b 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
00012c 900f          pop r0
00012d 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
00012e 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
                     ; check whether isrflag is zero. if not,
                     ; there is an still unhandled interrupt pending.
00012f 20bb          tst isrflag
000130 f001          breq isr_clean
                     ; there is a collision. the previous interrupt is not yet
                     ; handled by the forth inner interpreter
                 isr_clean:
000131 2cb0          mov isrflag, r0
                 .if WANT_INTERRUPT_COUNTERS==1
000132 93ff          push zh
000133 93ef          push zl
000134 e1e2          ldi zl, low(intcnt)
000135 e0f1          ldi zh, high(intcnt)
000136 9406          lsr r0 ; we use byte addresses in the counter array, not words
000137 0de0          add zl, r0
000138 1df3          adc zh, zeroh
000139 8000          ld r0, Z
00013a 9403          inc r0
00013b 8200          st Z, r0
00013c 91ef          pop zl
00013d 91ff          pop zh
                 .endif
00013e 9009          ld r0, Y+
00013f be0f          out SREG, r0
000140 9009          ld r0, Y+
000141 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                     ; no reti here, see words/isr-end.asm
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000142 ff02          .dw $ff02
000143 2b6d          .db "m+"
000144 0101          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
000145 3801          .dw DO_COLON
                 PFA_MPLUS:
000146 3fb2          .dw XT_S2D
000147 3c2c          .dw XT_DPLUS
000148 3820          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
000149 ff03          .dw $ff03
00014a 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
00014b 002a          .db "ud*"
00014c 0142          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
00014d 3801          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
00014e 38b1
00014f 38ff
000150 39e0
000151 38d9              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000152 38c4
000153 38f6
000154 39e0
000155 38e1
000156 399d
000157 3820              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
000158 ff04          .dw $ff04
000159 6d75
00015a 7861          .db "umax"
00015b 0149          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
00015c 3801          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
00015d 3eb4
00015e 395c              .DW XT_2DUP,XT_ULESS
00015f 3836      	.dw XT_DOCONDBRANCH
000160 0162      	 DEST(UMAX1)
000161 38c4              .DW XT_SWAP
000162 38d9      UMAX1:  .DW XT_DROP
000163 3820      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
000164 ff04          .dw $ff04
000165 6d75
000166 6e69          .db "umin"
000167 0158          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
000168 3801          .dw DO_COLON
                 PFA_UMIN:
                 .endif
000169 3eb4
00016a 3967              .DW XT_2DUP,XT_UGREATER
00016b 3836      	.dw XT_DOCONDBRANCH
00016c 016e      	DEST(UMIN1)
00016d 38c4              .DW XT_SWAP
00016e 38d9      UMIN1:  .DW XT_DROP
00016f 3820      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; return +1 if immediate, -1 otherwise, flag from name>flags
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
000170 3801          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000171 383d          .dw XT_DOLITERAL
000172 8000          .dw $8000
000173 3a13          .dw XT_AND
000174 3918          .dw XT_ZEROEQUAL
000175 3836          .dw XT_DOCONDBRANCH
000176 0179          DEST(IMMEDIATEQ1)
000177 3bdd           .dw XT_ONE
000178 3820           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
000179 394b          .dw XT_TRUE
00017a 3820          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
00017b ff0a          .dw $ff0a
00017c 616e
00017d 656d
00017e 663e
00017f 616c
000180 7367          .db "name>flags"
000181 0164          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
000182 3801          .dw DO_COLON
                 PFA_NAME2FLAGS:
000183 3bc1          .dw XT_FETCHI ; skip to link field
000184 383d          .dw XT_DOLITERAL
000185 ff00          .dw $ff00
000186 3a13          .dw XT_AND
000187 3820          .dw XT_EXIT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
000188 ff03          .dw $ff03
000189 6d31
00018a 0073          .db "1ms",0
00018b 017b          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
00018c 018d          .dw PFA_1MS
                 PFA_1MS:
00018d eae0
00018e e0ff
00018f 9731
000190 f7f1          delay 1000
000191 940c 3805     jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .include "dict/appl_4k.inc"
                 
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
000193 ff03          .dw $ff03
000194 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
000195 0072          .db "ver"
000196 0188          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
000197 3801          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
000198 02e1          .dw XT_ENV_FORTHNAME
000199 040a          .dw XT_ITYPE
00019a 3f99          .dw XT_SPACE
00019b 3ea8          .dw XT_BASE
00019c 3879          .dw XT_FETCH
                 
00019d 02ef          .dw XT_ENV_FORTHVERSION
00019e 3f2c          .dw XT_DECIMAL
00019f 3fb2          .dw XT_S2D
0001a0 0328          .dw XT_L_SHARP
0001a1 0330          .dw XT_SHARP
0001a2 383d          .dw XT_DOLITERAL
0001a3 002e          .dw '.'
0001a4 0319          .dw XT_HOLD
0001a5 0346          .dw XT_SHARP_S
0001a6 0351          .dw XT_SHARP_G
0001a7 0440          .dw XT_TYPE
0001a8 3ea8          .dw XT_BASE
0001a9 3881          .dw XT_STORE
0001aa 3f99          .dw XT_SPACE
0001ab 02f7          .dw XT_ENV_CPU
0001ac 040a          .dw XT_ITYPE
                 
0001ad 3820          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
0001ae ff06          .dw $ff06
0001af 6e75
0001b0 7375
0001b1 6465          .db "unused"
0001b2 0193          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
0001b3 3801          .dw DO_COLON
                 PFA_UNUSED:
0001b4 3a8d          .dw XT_SP_FETCH
0001b5 3f0e          .dw XT_HERE
0001b6 3993          .dw XT_MINUS
0001b7 3820          .dw XT_EXIT
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
0001b8 0002          .dw $0002
0001b9 6f74          .db "to"
0001ba 01ae          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
0001bb 3801          .dw DO_COLON
                 PFA_TO:
                 .endif
0001bc 044f          .dw XT_TICK
0001bd 3fbb          .dw XT_TO_BODY
0001be 3ea2          .dw XT_STATE
0001bf 3879          .dw XT_FETCH
0001c0 3836          .dw XT_DOCONDBRANCH
0001c1 01cc          DEST(PFA_TO1)
0001c2 077f          .dw XT_COMPILE
0001c3 01c6          .dw XT_DOTO
0001c4 078a          .dw XT_COMMA
0001c5 3820          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
0001c6 3801          .dw DO_COLON
                 PFA_DOTO:
                 .endif
0001c7 38f6          .dw XT_R_FROM
0001c8 38b1          .dw XT_DUP
0001c9 01d8          .dw XT_ICELLPLUS
0001ca 38ff          .dw XT_TO_R
0001cb 3bc1          .dw XT_FETCHI
                 PFA_TO1:
0001cc 38b1          .dw XT_DUP
0001cd 01d8          .dw XT_ICELLPLUS
0001ce 01d8          .dw XT_ICELLPLUS
0001cf 3bc1          .dw XT_FETCHI
0001d0 382a          .dw XT_EXECUTE
0001d1 3820          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
0001d2 ff07          .dw $FF07
0001d3 2d69
0001d4 6563
0001d5 6c6c
0001d6 002b          .db "i-cell+",0
0001d7 01b8          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
0001d8 3801          .dw DO_COLON
                 PFA_ICELLPLUS:
0001d9 3a2f          .dw XT_1PLUS
0001da 3820          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
0001db ff08          .dw $ff08
0001dc 6369
0001dd 6d6f
0001de 6170
0001df 6572          .db "icompare"
0001e0 01d2          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
0001e1 3801          .dw DO_COLON
                 PFA_ICOMPARE:
0001e2 38ff          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
0001e3 38cf          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
0001e4 38f6          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
0001e5 3911          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
0001e6 3836          .dw XT_DOCONDBRANCH
0001e7 01ec          .dw PFA_ICOMPARE_SAMELEN
0001e8 3ebd            .dw XT_2DROP
0001e9 38d9            .dw XT_DROP
0001ea 394b            .dw XT_TRUE
0001eb 3820            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
0001ec 38c4          .dw XT_SWAP ; ( -- r-addr f-addr len )
0001ed 3954          .dw XT_ZERO
0001ee 0849          .dw XT_QDOCHECK
0001ef 3836          .dw XT_DOCONDBRANCH
0001f0 020f          .dw PFA_ICOMPARE_DONE
0001f1 3a9b          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
0001f2 38cf          .dw XT_OVER
0001f3 3879          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
0001f4 38cf          .dw XT_OVER
0001f5 3bc1          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
0001f6 38b1          .dw XT_DUP
                     ;.dw XT_BYTESWAP
0001f7 383d          .dw XT_DOLITERAL
0001f8 0100          .dw $100
0001f9 395c          .dw XT_ULESS
0001fa 3836          .dw XT_DOCONDBRANCH
0001fb 0200          .dw PFA_ICOMPARE_LASTCELL
0001fc 38c4          .dw XT_SWAP
0001fd 383d          .dw XT_DOLITERAL
0001fe 00ff          .dw $00FF
0001ff 3a13          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
000200 3911          .dw XT_NOTEQUAL
000201 3836          .dw XT_DOCONDBRANCH
000202 0207          .dw PFA_ICOMPARE_NEXTLOOP
000203 3ebd          .dw XT_2DROP
000204 394b          .dw XT_TRUE
000205 3ad4          .dw XT_UNLOOP
000206 3820          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
000207 3a2f          .dw XT_1PLUS
000208 38c4          .dw XT_SWAP
000209 3ca7          .dw XT_CELLPLUS
00020a 38c4          .dw XT_SWAP
00020b 383d          .dw XT_DOLITERAL
00020c 0002          .dw 2
00020d 3aba          .dw XT_DOPLUSLOOP
00020e 01f2          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
00020f 3ebd          .dw XT_2DROP
000210 3954          .dw XT_ZERO
000211 3820          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
000212 ff01          .dw $ff01
000213 002a          .db "*",0
000214 01db          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
000215 3801          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
000216 39a6          .dw XT_MSTAR
000217 38d9          .dw XT_DROP
000218 3820          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
000219 ff01          .dw $FF01
00021a 006a          .db "j",0
00021b 0212          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
00021c 3801          .dw DO_COLON
                 PFA_J:
00021d 3a76          .dw XT_RP_FETCH
00021e 383d          .dw XT_DOLITERAL
00021f 0007          .dw 7
000220 399d          .dw XT_PLUS
000221 3879          .dw XT_FETCH
000222 3a76          .dw XT_RP_FETCH
000223 383d          .dw XT_DOLITERAL
000224 0009          .dw 9
000225 399d          .dw XT_PLUS
000226 3879          .dw XT_FETCH
000227 399d          .dw XT_PLUS
000228 3820          .dw XT_EXIT
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
000229 ff04          .dw $ff04
00022a 6164
00022b 7362          .db "dabs"
00022c 0219          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
00022d 3801          .dw DO_COLON
                 PFA_DABS:
00022e 38b1          .dw XT_DUP
00022f 391f          .dw XT_ZEROLESS
000230 3836          .dw XT_DOCONDBRANCH
000231 0233          .dw PFA_DABS1
000232 023a          .dw XT_DNEGATE
                 PFA_DABS1:
000233 3820          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
000234 ff07          .dw $ff07
000235 6e64
000236 6765
000237 7461
000238 0065          .db "dnegate",0
000239 0229          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
00023a 3801          .dw DO_COLON
                 PFA_DNEGATE:
00023b 3c52          .dw XT_DINVERT
00023c 3bdd          .dw XT_ONE
00023d 3954          .dw XT_ZERO
00023e 3c2c          .dw XT_DPLUS
00023f 3820          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
000240 ff05          .dw $ff05
000241 6d63
000242 766f
000243 0065          .db "cmove",0
000244 0234          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
000245 0246          .dw PFA_CMOVE
                 PFA_CMOVE:
000246 93bf          push xh
000247 93af          push xl
000248 91e9          ld zl, Y+
000249 91f9          ld zh, Y+ ; addr-to
00024a 91a9          ld xl, Y+
00024b 91b9          ld xh, Y+ ; addr-from
00024c 2f09          mov temp0, tosh
00024d 2b08          or temp0, tosl
00024e f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
00024f 911d          ld temp1, X+
000250 9311          st Z+, temp1
000251 9701          sbiw tosl, 1
000252 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
000253 91af          pop xl
000254 91bf          pop xh
000255 9189
000256 9199          loadtos
000257 940c 3805     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
000259 ff05          .dw $ff05
00025a 7332
00025b 6177
00025c 0070          .db "2swap",0
00025d 0240          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
00025e 3801          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
00025f 38e1          .dw XT_ROT
000260 38ff          .dw XT_TO_R
000261 38e1          .dw XT_ROT
000262 38f6          .dw XT_R_FROM
000263 3820          .dw XT_EXIT
                 .include "words/tib.asm"
                 
                 ; System
                 ; refills the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILLTIB:
000264 ff0a          .dw $ff0a
000265 6572
000266 6966
000267 6c6c
000268 742d
000269 6269          .db "refill-tib"
00026a 0259          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
00026b 3801          .dw DO_COLON
                 PFA_REFILLTIB:
                 .endif
00026c 0287          .dw XT_TIB
00026d 383d          .dw XT_DOLITERAL
00026e 005a          .dw TIB_SIZE
00026f 049f          .dw XT_ACCEPT
000270 028d          .dw XT_NUMBERTIB
000271 3881          .dw XT_STORE
000272 3954          .dw XT_ZERO
000273 3ecd          .dw XT_TO_IN
000274 3881          .dw XT_STORE
000275 394b          .dw XT_TRUE ; -1
000276 3820          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCETIB:
000277 ff0a          .dw $FF0A
000278 6f73
000279 7275
00027a 6563
00027b 742d
00027c 6269          .db "source-tib"
00027d 0264          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
00027e 3801          .dw DO_COLON
                 PFA_SOURCETIB:
                 .endif
00027f 0287          .dw XT_TIB
000280 028d          .dw XT_NUMBERTIB
000281 3879          .dw XT_FETCH
000282 3820          .dw XT_EXIT
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; terminal input buffer address
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TIB:
000283 ff03          .dw $ff03
000284 6974
000285 0062          .db "tib",0
000286 0277          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
000287 3848          .dw PFA_DOVARIABLE
                 PFA_TIB:
000288 012c          .dw ram_tib
                 .dseg
00012c           ram_tib: .byte TIB_SIZE
                 .cseg
                 .endif
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBERTIB:
000289 ff04          .dw $ff04
00028a 7423
00028b 6269          .db "#tib"
00028c 0283          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
00028d 3848          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
00028e 0186          .dw ram_sharptib
                 .dseg
000186           ram_sharptib: .byte 2
                 .cseg
                 .endif
                 .include "words/init-ram.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
00028f ff06        .dw $ff06
000290 6565
000291 723e
000292 6d61        .db "ee>ram"
000293 0289        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
000294 3801        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
000295 3954          .dw XT_ZERO
000296 3a9b          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
000297 38cf          .dw XT_OVER
000298 3b55          .dw XT_FETCHE
000299 38cf          .dw XT_OVER
00029a 3881          .dw XT_STORE
00029b 3ca7          .dw XT_CELLPLUS
00029c 38c4          .dw XT_SWAP
00029d 3ca7          .dw XT_CELLPLUS
00029e 38c4          .dw XT_SWAP
00029f 3ac9          .dw XT_DOLOOP
0002a0 0297          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
0002a1 3ebd          .dw XT_2DROP
0002a2 3820          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INIT_RAM:
0002a3 ff08        .dw $ff08
0002a4 6e69
0002a5 7469
0002a6 722d
0002a7 6d61        .db "init-ram"
0002a8 028f        .dw VE_HEAD
                   .set VE_HEAD = VE_INIT_RAM
                 XT_INIT_RAM:
0002a9 3801        .dw DO_COLON
                 PFA_INI_RAM:          ; ( -- )
0002aa 383d          .dw XT_DOLITERAL
0002ab 006a          .dw EE_INITUSER
0002ac 3b02          .dw XT_UP_FETCH
0002ad 383d          .dw XT_DOLITERAL
0002ae 0024          .dw SYSUSERSIZE
0002af 3a04          .dw XT_2SLASH
0002b0 0294          .dw XT_EE2RAM
0002b1 3820          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
0002b2 ff0b          .dw $ff0b
0002b3 6e65
0002b4 6976
0002b5 6f72
0002b6 6d6e
0002b7 6e65
0002b8 0074          .db "environment",0
0002b9 02a3          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
0002ba 3848          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
0002bb 0044          .dw CFG_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
0002bc ff09          .dw $ff09
0002bd 6f77
0002be 6472
0002bf 696c
0002c0 7473
0002c1 0073          .db "wordlists",0
0002c2 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
0002c3 3801          .dw DO_COLON
                 PFA_ENVWORDLISTS:
0002c4 383d          .dw XT_DOLITERAL
0002c5 0008          .dw NUMWORDLISTS
0002c6 3820          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
0002c7 ff04          .dw $ff04
0002c8 702f
0002c9 6461          .db "/pad"
0002ca 02bc          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
0002cb 3801          .dw DO_COLON
                 PFA_ENVSLASHPAD:
0002cc 3a8d          .dw XT_SP_FETCH
0002cd 3ed3          .dw XT_PAD
0002ce 3993          .dw XT_MINUS
0002cf 3820          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENVSLASHHOLD:
0002d0 ff05          .dw $ff05
0002d1 682f
0002d2 6c6f
0002d3 0064          .db "/hold",0
0002d4 02c7          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
0002d5 3801          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
                 .endif
0002d6 3ed3          .dw XT_PAD
0002d7 3f0e          .dw XT_HERE
0002d8 3993          .dw XT_MINUS
0002d9 3820          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
0002da ff0a          .dw $ff0a
0002db 6f66
0002dc 7472
0002dd 2d68
0002de 616e
0002df 656d          .db "forth-name"
0002e0 02d0          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
0002e1 3801          .dw DO_COLON
                 PFA_EN_FORTHNAME:
0002e2 03d7          .dw XT_DOSLITERAL
0002e3 0007          .dw 7
                 .endif
0002e4 6d61
0002e5 6f66
0002e6 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
0002e7 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
0002e8 3820          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
0002e9 ff07          .dw $ff07
0002ea 6576
0002eb 7372
0002ec 6f69
0002ed 006e          .db "version",0
0002ee 02da          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
0002ef 3801          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
0002f0 383d          .dw XT_DOLITERAL
0002f1 0045          .dw 69
0002f2 3820          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
0002f3 ff03          .dw $ff03
0002f4 7063
0002f5 0075          .db "cpu",0
0002f6 02e9          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
0002f7 3801          .dw DO_COLON
                 PFA_EN_CPU:
                 .endif
0002f8 383d          .dw XT_DOLITERAL
0002f9 0037          .dw mcu_name
0002fa 0436          .dw XT_ICOUNT
0002fb 3820          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
0002fc ff08          .dw $ff08
0002fd 636d
0002fe 2d75
0002ff 6e69
000300 6f66          .db "mcu-info"
000301 02f3          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
000302 3801          .dw DO_COLON
                 PFA_EN_MCUINFO:
000303 383d          .dw XT_DOLITERAL
000304 0033          .dw mcu_info
000305 3820          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_ENVUSERSIZE:
000306 ff05          .dw $ff05
000307 752f
000308 6573
000309 0072          .db "/user",0
00030a 02fc          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
00030b 3801          .dw DO_COLON
                 PFA_ENVUSERSIZE:
                 .endif
00030c 383d          .dw XT_DOLITERAL
00030d 002e          .dw SYSUSERSIZE + APPUSERSIZE
00030e 3820          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
00030f ff03          .dw $ff03
000310 6c68
000311 0064          .db "hld",0
000312 02b2          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
000313 3848          .dw PFA_DOVARIABLE
                 PFA_HLD:
000314 0188          .dw ram_hld
                 
                 .dseg
000188           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
000315 ff04          .dw $ff04
000316 6f68
000317 646c          .db "hold"
000318 030f          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
000319 3801          .dw DO_COLON
                 PFA_HOLD:
                 .endif
00031a 0313          .dw XT_HLD
00031b 38b1          .dw XT_DUP
00031c 3879          .dw XT_FETCH
00031d 3a35          .dw XT_1MINUS
00031e 38b1          .dw XT_DUP
00031f 38ff          .dw XT_TO_R
000320 38c4          .dw XT_SWAP
000321 3881          .dw XT_STORE
000322 38f6          .dw XT_R_FROM
000323 388d          .dw XT_CSTORE
000324 3820          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
000325 ff02          .dw $ff02
000326 233c          .db "<#"
000327 0315          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
000328 3801          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
000329 3ed3          .dw XT_PAD
00032a 0313          .dw XT_HLD
00032b 3881          .dw XT_STORE
00032c 3820          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
00032d ff01          .dw $ff01
00032e 0023          .db "#",0
00032f 0325          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
000330 3801          .dw DO_COLON
                 PFA_SHARP:
                 .endif
000331 3ea8          .dw XT_BASE
000332 3879          .dw XT_FETCH
000333 03ad          .dw XT_UDSLASHMOD
000334 38e1          .dw XT_ROT
000335 383d          .dw XT_DOLITERAL
000336 0009          .dw 9
000337 38cf          .dw XT_OVER
000338 396e          .dw XT_LESS
000339 3836          .dw XT_DOCONDBRANCH
00033a 033e          DEST(PFA_SHARP1)
00033b 383d          .dw XT_DOLITERAL
00033c 0007          .dw 7
00033d 399d          .dw XT_PLUS
                 PFA_SHARP1:
00033e 383d          .dw XT_DOLITERAL
00033f 0030          .dw 48 ; ASCII 0
000340 399d          .dw XT_PLUS
000341 0319          .dw XT_HOLD
000342 3820          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
000343 ff02          .dw $ff02
000344 7323          .db "#s"
000345 032d          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
000346 3801          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
000347 0330          .dw XT_SHARP
000348 3eb4          .dw XT_2DUP
000349 3a1c          .dw XT_OR
00034a 3918          .dw XT_ZEROEQUAL
00034b 3836          .dw XT_DOCONDBRANCH
00034c 0347          DEST(NUMS1) ; PFA_SHARP_S
00034d 3820          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
00034e ff02          .dw $ff02
00034f 3e23          .db "#>"
000350 0343          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
000351 3801          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
000352 3ebd          .dw XT_2DROP
000353 0313          .dw XT_HLD
000354 3879          .dw XT_FETCH
000355 3ed3          .dw XT_PAD
000356 38cf          .dw XT_OVER
000357 3993          .dw XT_MINUS
000358 3820          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
000359 ff04          .dw $ff04
00035a 6973
00035b 6e67          .db "sign"
00035c 034e          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
00035d 3801          .dw DO_COLON
                 PFA_SIGN:
                 .endif
00035e 391f          .dw XT_ZEROLESS
00035f 3836          .dw XT_DOCONDBRANCH
000360 0364          DEST(PFA_SIGN1)
000361 383d          .dw XT_DOLITERAL
000362 002d          .dw 45 ; ascii -
000363 0319          .dw XT_HOLD
                 PFA_SIGN1:
000364 3820          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
000365 ff03          .dw $ff03
000366 2e64
000367 0072          .db "d.r",0
000368 0359          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
000369 3801          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
00036a 38ff          .dw XT_TO_R
00036b 3ec5          .dw XT_TUCK
00036c 022d          .dw XT_DABS
00036d 0328          .dw XT_L_SHARP
00036e 0346          .dw XT_SHARP_S
00036f 38e1          .dw XT_ROT
000370 035d          .dw XT_SIGN
000371 0351          .dw XT_SHARP_G
000372 38f6          .dw XT_R_FROM
000373 38cf          .dw XT_OVER
000374 3993          .dw XT_MINUS
000375 3fa2          .dw XT_SPACES
000376 0440          .dw XT_TYPE
000377 3820          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
000378 ff02          .dw $ff02
000379 722e          .db ".r"
00037a 0365          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
00037b 3801          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
00037c 38ff          .dw XT_TO_R
00037d 3fb2          .dw XT_S2D
00037e 38f6          .dw XT_R_FROM
00037f 0369          .dw XT_DDOTR
000380 3820          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
000381 ff02          .dw $ff02
000382 2e64          .db "d."
000383 0378          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
000384 3801          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
000385 3954          .dw XT_ZERO
000386 0369          .dw XT_DDOTR
000387 3f99          .dw XT_SPACE
000388 3820          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
000389 ff01          .dw $ff01
00038a 002e          .db ".",0
00038b 0381          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
00038c 3801          .dw DO_COLON
                 PFA_DOT:
                 .endif
00038d 3fb2          .dw XT_S2D
00038e 0384          .dw XT_DDOT
00038f 3820          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
000390 ff03          .dw $ff03
000391 6475
000392 002e          .db "ud.",0
000393 0389          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
000394 3801          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
000395 3954          .dw XT_ZERO
000396 039d          .dw XT_UDDOTR
000397 3f99          .dw XT_SPACE
000398 3820          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
000399 ff04          .dw $ff04
00039a 6475
00039b 722e          .db "ud.r"
00039c 0390          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
00039d 3801          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
00039e 38ff          .dw XT_TO_R
00039f 0328          .dw XT_L_SHARP
0003a0 0346          .dw XT_SHARP_S
0003a1 0351          .dw XT_SHARP_G
0003a2 38f6          .dw XT_R_FROM
0003a3 38cf          .dw XT_OVER
0003a4 3993          .dw XT_MINUS
0003a5 3fa2          .dw XT_SPACES
0003a6 0440          .dw XT_TYPE
0003a7 3820          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
0003a8 ff06          .dw $ff06
0003a9 6475
0003aa 6d2f
0003ab 646f          .db "ud/mod"
0003ac 0399          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
0003ad 3801          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
0003ae 38ff          .dw XT_TO_R
0003af 3954          .dw XT_ZERO
0003b0 3906          .dw XT_R_FETCH
0003b1 39c2          .dw XT_UMSLASHMOD
0003b2 38f6          .dw XT_R_FROM
0003b3 38c4          .dw XT_SWAP
0003b4 38ff          .dw XT_TO_R
0003b5 39c2          .dw XT_UMSLASHMOD
0003b6 38f6          .dw XT_R_FROM
0003b7 3820          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
0003b8 ff06          .dw $ff06 
0003b9 6964
0003ba 6967
0003bb 3f74          .db "digit?"
0003bc 03a8          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
0003bd 3801          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
0003be 3f51          .dw XT_TOUPPER
0003bf 38b1
0003c0 383d
0003c1 0039
0003c2 3978
0003c3 383d
0003c4 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
0003c5 3a13
0003c6 399d
0003c7 38b1
0003c8 383d
0003c9 0140
0003ca 3978          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
0003cb 383d
0003cc 0107
0003cd 3a13
0003ce 3993
0003cf 383d
0003d0 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
0003d1 3993
0003d2 38b1
0003d3 3ea8
0003d4 3879
0003d5 395c          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
0003d6 3820          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
0003d7 3801        .dw DO_COLON
                 PFA_DOSLITERAL:
0003d8 3906        .dw XT_R_FETCH   ; ( -- addr )
0003d9 0436        .dw XT_ICOUNT
0003da 38f6        .dw XT_R_FROM
0003db 38cf        .dw XT_OVER     ; ( -- addr' n addr n)
0003dc 3a2f        .dw XT_1PLUS
0003dd 3a04        .dw XT_2SLASH   ; ( -- addr' n addr k )
0003de 399d        .dw XT_PLUS     ; ( -- addr' n addr'' )
0003df 3a2f        .dw XT_1PLUS
0003e0 38ff        .dw XT_TO_R     ; ( -- )
0003e1 3820        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
0003e2 ff02        .dw $ff02
0003e3 2c73        .db "s",$2c
0003e4 03b8        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
0003e5 3801          .dw DO_COLON
                 PFA_SCOMMA:
0003e6 38b1          .dw XT_DUP
0003e7 03e9          .dw XT_DOSCOMMA
0003e8 3820          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
0003e9 3801          .dw DO_COLON
                 PFA_DOSCOMMA:
0003ea 078a          .dw XT_COMMA
0003eb 38b1          .dw XT_DUP   ; ( --addr len len)
0003ec 3a04          .dw XT_2SLASH ; ( -- addr len len/2
0003ed 3ec5          .dw XT_TUCK   ; ( -- addr len/2 len len/2
0003ee 3a0b          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003ef 3993          .dw XT_MINUS  ; ( -- addr len/2 rem
0003f0 38ff          .dw XT_TO_R
0003f1 3954          .dw XT_ZERO
0003f2 0849          .dw XT_QDOCHECK
0003f3 3836          .dw XT_DOCONDBRANCH
0003f4 03fc          .dw PFA_SCOMMA2
0003f5 3a9b          .dw XT_DODO
                 PFA_SCOMMA1:
0003f6 38b1          .dw XT_DUP         ; ( -- addr addr )
0003f7 3879          .dw XT_FETCH       ; ( -- addr c1c2 )
0003f8 078a          .dw XT_COMMA       ; ( -- addr )
0003f9 3ca7          .dw XT_CELLPLUS    ; ( -- addr+cell )
0003fa 3ac9          .dw XT_DOLOOP
0003fb 03f6          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
0003fc 38f6          .dw XT_R_FROM
0003fd 3926          .dw XT_GREATERZERO
0003fe 3836          .dw XT_DOCONDBRANCH
0003ff 0403          .dw PFA_SCOMMA3
000400 38b1            .dw XT_DUP     ; well, tricky
000401 3898            .dw XT_CFETCH
000402 078a            .dw XT_COMMA
                 PFA_SCOMMA3:
000403 38d9          .dw XT_DROP        ; ( -- )
000404 3820          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
000405 ff05          .dw $ff05
000406 7469
000407 7079
000408 0065          .db "itype",0
000409 03e2          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
00040a 3801          .dw DO_COLON
                 PFA_ITYPE:
00040b 38b1          .dw XT_DUP    ; ( --addr len len)
00040c 3a04          .dw XT_2SLASH ; ( -- addr len len/2
00040d 3ec5          .dw XT_TUCK   ; ( -- addr len/2 len len/2
00040e 3a0b          .dw XT_2STAR  ; ( -- addr len/2 len len'
00040f 3993          .dw XT_MINUS  ; ( -- addr len/2 rem
000410 38ff          .dw XT_TO_R
000411 3954          .dw XT_ZERO
000412 0849          .dw XT_QDOCHECK
000413 3836          .dw XT_DOCONDBRANCH
000414 041e          .dw PFA_ITYPE2
000415 3a9b          .dw XT_DODO
                 PFA_ITYPE1:
000416 38b1          .dw XT_DUP         ; ( -- addr addr )
000417 3bc1          .dw XT_FETCHI      ; ( -- addr c1c2 )
000418 38b1          .dw XT_DUP
000419 042b          .dw XT_LOWEMIT
00041a 0427          .dw XT_HIEMIT
00041b 3a2f          .dw XT_1PLUS    ; ( -- addr+cell )
00041c 3ac9          .dw XT_DOLOOP
00041d 0416          .dw PFA_ITYPE1
                 PFA_ITYPE2:
00041e 38f6          .dw XT_R_FROM
00041f 3926          .dw XT_GREATERZERO
000420 3836          .dw XT_DOCONDBRANCH
000421 0425          .dw PFA_ITYPE3
000422 38b1            .dw XT_DUP     ; make sure the drop below has always something to do
000423 3bc1            .dw XT_FETCHI
000424 042b            .dw XT_LOWEMIT
                 PFA_ITYPE3:
000425 38d9          .dw XT_DROP
000426 3820          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
000427 3801          .dw DO_COLON
                 PFA_HIEMIT:
000428 3af9          .dw XT_BYTESWAP
000429 042b          .dw XT_LOWEMIT
00042a 3820          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
00042b 3801          .dw DO_COLON
                 PFA_LOWEMIT:
00042c 383d          .dw XT_DOLITERAL
00042d 00ff          .dw $00ff
00042e 3a13          .dw XT_AND
00042f 3edd          .dw XT_EMIT
000430 3820          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
000431 ff06          .dw $ff06
000432 6369
000433 756f
000434 746e          .db "icount"
000435 0405          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
000436 3801          .dw DO_COLON
                 PFA_ICOUNT:
000437 38b1          .dw XT_DUP
000438 3a2f          .dw XT_1PLUS
000439 38c4          .dw XT_SWAP
00043a 3bc1          .dw XT_FETCHI
00043b 3820          .dw XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
00043c ff04          .dw $ff04
00043d 7974
00043e 6570          .db "type"
00043f 0431          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
000440 3801          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
000441 3f84          .dw XT_BOUNDS
000442 0849          .dw XT_QDOCHECK
000443 3836          .dw XT_DOCONDBRANCH
000444 044b          DEST(PFA_TYPE2)
000445 3a9b          .dw XT_DODO
                 PFA_TYPE1:
000446 3aac          .dw XT_I
000447 3898          .dw XT_CFETCH
000448 3edd          .dw XT_EMIT
000449 3ac9          .dw XT_DOLOOP
00044a 0446          DEST(PFA_TYPE1)
                 PFA_TYPE2:
00044b 3820          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
00044c ff01          .dw $ff01
00044d 0027          .db "'",0
00044e 043c          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
00044f 3801          .dw DO_COLON
                 PFA_TICK:
                 .endif
000450 05cf          .dw XT_PARSENAME
000451 060d          .dw XT_FORTHRECOGNIZER
000452 0618          .dw XT_RECOGNIZE
                     ; a word is tickable unless RECTYPE-TOKEN is RECTYPE-NULL or 
                     ; the interpret action is a NOOP
000453 38b1          .dw XT_DUP
000454 06ae          .dw XT_RECTYPE_NULL
000455 3bd6          .dw XT_EQUAL
000456 38c4          .dw XT_SWAP
000457 3bc1          .dw XT_FETCHI
000458 383d          .dw XT_DOLITERAL
000459 3fc0          .dw XT_NOOP
00045a 3bd6          .dw XT_EQUAL
00045b 3a1c          .dw XT_OR
00045c 3836          .dw XT_DOCONDBRANCH
00045d 0461          DEST(PFA_TICK1)
00045e 383d            .dw XT_DOLITERAL
00045f fff3            .dw -13
000460 3d74            .dw XT_THROW
                 PFA_TICK1:
000461 38d9          .dw XT_DROP
000462 3820          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
000463 ff05          .dw $ff05
000464 7363
000465 696b
000466 0070          .db "cskip",0
000467 044c          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
000468 3801          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
000469 38ff          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
00046a 38b1          .dw XT_DUP            ; ( -- addr' n' n' )
00046b 3836          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00046c 0477          DEST(PFA_CSKIP2)
00046d 38cf          .dw XT_OVER           ; ( -- addr' n' addr' )
00046e 3898          .dw XT_CFETCH         ; ( -- addr' n' c' )
00046f 3906          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
000470 3bd6          .dw XT_EQUAL          ; ( -- addr' n' f )
000471 3836          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000472 0477          DEST(PFA_CSKIP2)
000473 3bdd          .dw XT_ONE
000474 05c0          .dw XT_SLASHSTRING
000475 382f          .dw XT_DOBRANCH
000476 046a          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
000477 38f6          .dw XT_R_FROM
000478 38d9          .dw XT_DROP           ; ( -- addr2 n2)
000479 3820          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
00047a ff05          .dw $ff05
00047b 7363
00047c 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
00047d 006e          .db "cscan"
00047e 0463          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
00047f 3801          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
000480 38ff          .dw XT_TO_R
000481 38cf          .dw XT_OVER
                 PFA_CSCAN1:
000482 38b1          .dw XT_DUP
000483 3898          .dw XT_CFETCH
000484 3906          .dw XT_R_FETCH
000485 3bd6          .dw XT_EQUAL
000486 3918          .dw XT_ZEROEQUAL
000487 3836          .dw XT_DOCONDBRANCH
000488 0494          DEST(PFA_CSCAN2)
000489 38c4            .dw XT_SWAP
00048a 3a35            .dw XT_1MINUS
00048b 38c4            .dw XT_SWAP
00048c 38cf            .dw XT_OVER
00048d 391f            .dw XT_ZEROLESS ; not negative
00048e 3918            .dw XT_ZEROEQUAL
00048f 3836            .dw XT_DOCONDBRANCH
000490 0494            DEST(PFA_CSCAN2)
000491 3a2f              .dw XT_1PLUS
000492 382f              .dw XT_DOBRANCH
000493 0482              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
000494 38f0          .dw XT_NIP
000495 38cf          .dw XT_OVER
000496 3993          .dw XT_MINUS
000497 38f6          .dw XT_R_FROM
000498 38d9          .dw XT_DROP
000499 3820          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
00049a ff06          .dw $ff06
00049b 6361
00049c 6563
00049d 7470          .db "accept"
00049e 047a          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
00049f 3801          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
0004a0 38cf
0004a1 399d
0004a2 38cf              .DW XT_OVER,XT_PLUS,XT_OVER
0004a3 3eee
0004a4 38b1
0004a5 04e8
0004a6 3918
0004a7 3836      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
0004a8 04db              DEST(ACC5)
0004a9 38b1
0004aa 383d
0004ab 0008
0004ac 3bd6
0004ad 3836              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
0004ae 04c1              DEST(ACC3)
0004af 38d9
0004b0 38e1
0004b1 3eb4
0004b2 3978
0004b3 38ff
0004b4 38e1
0004b5 38e1
0004b6 38f6
0004b7 3836              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
0004b8 04bf      	DEST(ACC6)
0004b9 04e0
0004ba 3a35
0004bb 38ff
0004bc 38cf
0004bd 38f6
0004be 015c      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
0004bf 382f      ACC6:   .DW XT_DOBRANCH
0004c0 04d9              DEST(ACC4)
                     
                 
                 ACC3:    ; check for remaining control characters, replace them with blank
0004c1 38b1      	.dw XT_DUP            ; ( -- addr k k )
0004c2 3f3f              .dw XT_BL
0004c3 396e              .dw XT_LESS
0004c4 3836              .dw XT_DOCONDBRANCH
0004c5 04c8              DEST(PFA_ACCEPT6)
0004c6 38d9              .dw XT_DROP
0004c7 3f3f              .dw XT_BL
                 PFA_ACCEPT6:
0004c8 38ff
0004c9 3eb4
0004ca 3978
0004cb 38f6
0004cc 38c4
0004cd 3836      	.DW XT_TO_R,XT_2DUP,XT_GREATER,XT_R_FROM,XT_SWAP,XT_DOCONDBRANCH
0004ce 04d8              DEST(ACC7)
0004cf 38b1
0004d0 3edd
0004d1 38cf
0004d2 388d
0004d3 3a2f
0004d4 38cf
0004d5 0168                  .DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
0004d6 382f      	    .DW XT_DOBRANCH
0004d7 04d9      	    DEST(ACC4)
0004d8 38d9      ACC7:   .DW XT_DROP
0004d9 382f      ACC4:   .DW XT_DOBRANCH
0004da 04a3              DEST(ACC1)
0004db 38d9
0004dc 38f0
0004dd 38c4
0004de 3993
0004df 3820      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
0004e0 3801          .dw DO_COLON
                 .endif
0004e1 383d          .dw XT_DOLITERAL
0004e2 0008          .dw 8
0004e3 38b1          .dw XT_DUP
0004e4 3edd          .dw XT_EMIT
0004e5 3f99          .dw XT_SPACE
0004e6 3edd          .dw XT_EMIT
0004e7 3820          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
0004e8 3801          .dw DO_COLON
                 .endif
0004e9 38b1          .dw XT_DUP
0004ea 383d          .dw XT_DOLITERAL
0004eb 000d          .dw 13
0004ec 3bd6          .dw XT_EQUAL
0004ed 38c4          .dw XT_SWAP
0004ee 383d          .dw XT_DOLITERAL
0004ef 000a          .dw 10
0004f0 3bd6          .dw XT_EQUAL
0004f1 3a1c          .dw XT_OR
0004f2 3820          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILL:
0004f3 ff06          .dw $ff06
0004f4 6572
0004f5 6966
0004f6 6c6c          .db "refill"
0004f7 049a          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
0004f8 3dea          .dw PFA_DODEFER1
                 PFA_REFILL:
                 .endif
0004f9 001a          .dw USER_REFILL
0004fa 3db3          .dw XT_UDEFERFETCH
0004fb 3dbf          .dw XT_UDEFERSTORE
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
0004fc ff04          .dw $ff04
0004fd 6863
0004fe 7261          .db "char"
0004ff 04f3          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
000500 3801          .dw DO_COLON
                 PFA_CHAR:
                 .endif
000501 05cf          .dw XT_PARSENAME
000502 3918
000503 3836          .dw XT_ZEROEQUAL,XT_DOCONDBRANCH 
000504 0508          DEST(CHAR_1)
000505 383d
000506 fff0
000507 3d74             .dw XT_DOLITERAL, -16, XT_THROW
                 CHAR_1:
                 
000508 3898          .dw XT_CFETCH
000509 3820          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
00050a ff06          .dw $ff06
00050b 756e
00050c 626d
00050d 7265          .db "number"
00050e 04fc          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
00050f 3801          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
000510 3ea8          .dw XT_BASE
000511 3879          .dw XT_FETCH
000512 38ff          .dw XT_TO_R
000513 0553          .dw XT_QSIGN
000514 38ff          .dw XT_TO_R
000515 0566          .dw XT_SET_BASE
000516 0553          .dw XT_QSIGN
000517 38f6          .dw XT_R_FROM
000518 3a1c          .dw XT_OR
000519 38ff          .dw XT_TO_R
                     ; check whether something is left
00051a 38b1          .dw XT_DUP
00051b 3918          .dw XT_ZEROEQUAL
00051c 3836          .dw XT_DOCONDBRANCH
00051d 0526          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
00051e 3ebd            .dw XT_2DROP
00051f 38f6            .dw XT_R_FROM
000520 38d9            .dw XT_DROP
000521 38f6            .dw XT_R_FROM
000522 3ea8            .dw XT_BASE
000523 3881            .dw XT_STORE
000524 3954            .dw XT_ZERO
000525 3820            .dw XT_EXIT
                 PFA_NUMBER0:
000526 3b14          .dw XT_2TO_R
000527 3954          .dw XT_ZERO       ; starting value
000528 3954          .dw XT_ZERO
000529 3b23          .dw XT_2R_FROM
00052a 0584          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
00052b 38b9          .dw XT_QDUP
00052c 3836          .dw XT_DOCONDBRANCH
00052d 0548          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
00052e 3bdd          .dw XT_ONE
00052f 3bd6          .dw XT_EQUAL
000530 3836          .dw XT_DOCONDBRANCH
000531 053f          DEST(PFA_NUMBER2)
                 	; excatly one character is left
000532 3898      	.dw XT_CFETCH
000533 383d      	.dw XT_DOLITERAL
000534 002e      	.dw 46 ; .
000535 3bd6      	.dw XT_EQUAL
000536 3836      	.dw XT_DOCONDBRANCH
000537 0540      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
000538 38f6      	.dw XT_R_FROM
000539 3836              .dw XT_DOCONDBRANCH
00053a 053c      	DEST(PFA_NUMBER3)
00053b 023a              .dw XT_DNEGATE
                 PFA_NUMBER3:
00053c 3be2      	.dw XT_TWO
00053d 382f      	.dw XT_DOBRANCH
00053e 054e      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
00053f 38d9      	.dw XT_DROP
                 PFA_NUMBER6:
000540 3ebd      	.dw XT_2DROP
000541 38f6      	.dw XT_R_FROM
000542 38d9      	.dw XT_DROP
000543 38f6              .dw XT_R_FROM
000544 3ea8              .dw XT_BASE
000545 3881              .dw XT_STORE
000546 3954      	.dw XT_ZERO
000547 3820      	.dw XT_EXIT
                 PFA_NUMBER1:
000548 3ebd          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
000549 38f6          .dw XT_R_FROM
00054a 3836          .dw XT_DOCONDBRANCH
00054b 054d          DEST(PFA_NUMBER4)
00054c 3e12          .dw XT_NEGATE
                 PFA_NUMBER4:
00054d 3bdd          .dw XT_ONE
                 PFA_NUMBER5:
00054e 38f6          .dw XT_R_FROM
00054f 3ea8          .dw XT_BASE
000550 3881          .dw XT_STORE
000551 394b          .dw XT_TRUE
000552 3820          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
000553 3801          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
000554 38cf          .dw XT_OVER    ; ( -- addr len addr )
000555 3898          .dw XT_CFETCH
000556 383d          .dw XT_DOLITERAL
000557 002d          .dw '-'
000558 3bd6          .dw XT_EQUAL  ; ( -- addr len flag )
000559 38b1          .dw XT_DUP
00055a 38ff          .dw XT_TO_R
00055b 3836          .dw XT_DOCONDBRANCH
00055c 055f          DEST(PFA_NUMBERSIGN_DONE)
00055d 3bdd          .dw XT_ONE    ; skip sign character
00055e 05c0          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
00055f 38f6          .dw XT_R_FROM
000560 3820          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
000561 3852          .dw PFA_DOCONSTANT
                 .endif
000562 000a
000563 0010
000564 0002
000565 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
000566 3801          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
000567 38cf          .dw XT_OVER
000568 3898          .dw XT_CFETCH
000569 383d          .dw XT_DOLITERAL
00056a 0023          .dw 35
00056b 3993          .dw XT_MINUS
00056c 38b1          .dw XT_DUP
00056d 3954          .dw XT_ZERO
00056e 383d          .dw XT_DOLITERAL
00056f 0004          .dw 4
000570 3e42          .dw XT_WITHIN
000571 3836          .dw XT_DOCONDBRANCH
000572 057c          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
000573 0561      	.dw XT_BASES
000574 399d      	.dw XT_PLUS
000575 3bc1      	.dw XT_FETCHI
000576 3ea8      	.dw XT_BASE
000577 3881      	.dw XT_STORE
000578 3bdd      	.dw XT_ONE
000579 05c0      	.dw XT_SLASHSTRING
00057a 382f      	.dw XT_DOBRANCH
00057b 057d      	DEST(SET_BASE2)
                 SET_BASE1:
00057c 38d9      	.dw XT_DROP
                 SET_BASE2:
00057d 3820          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
00057e ff07          .dw $ff07
00057f 6e3e
000580 6d75
000581 6562
000582 0072          .db ">number",0
000583 050a          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
000584 3801          .dw DO_COLON
                 
                 .endif
                 
000585 38b1
000586 3836      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
000587 059c              DEST(TONUM3)
000588 38cf
000589 3898
00058a 03bd              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
00058b 3918
00058c 3836              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
00058d 0590              DEST(TONUM2)
00058e 38d9
00058f 3820              .DW XT_DROP,XT_EXIT
000590 38ff
000591 025e
000592 3ea8
000593 3879
000594 014d      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
000595 38f6
000596 0145
000597 025e              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
000598 3bdd
000599 05c0
00059a 382f              .DW XT_ONE,XT_SLASHSTRING,XT_DOBRANCH
00059b 0585              DEST(TONUM1)
00059c 3820      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
00059d ff05          .dw $ff05
00059e 6170
00059f 7372
0005a0 0065          .db "parse",0
0005a1 057e          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
0005a2 3801          .dw DO_COLON
                 PFA_PARSE:
                 .endif
0005a3 38ff          .dw XT_TO_R     ; ( -- )
0005a4 05b6          .dw XT_SOURCE   ; ( -- addr len)
0005a5 3ecd          .dw XT_TO_IN     ; ( -- addr len >in)
0005a6 3879          .dw XT_FETCH
0005a7 05c0          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
0005a8 38f6          .dw XT_R_FROM      ; ( -- addr' len' c)
0005a9 047f          .dw XT_CSCAN       ; ( -- addr' len'')
0005aa 38b1          .dw XT_DUP         ; ( -- addr' len'' len'')
0005ab 3a2f          .dw XT_1PLUS
0005ac 3ecd          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
0005ad 3a65          .dw XT_PLUSSTORE   ; ( -- addr' len')
0005ae 3bdd          .dw XT_ONE
0005af 05c0          .dw XT_SLASHSTRING
0005b0 3820          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCE:
0005b1 ff06          .dw $FF06
0005b2 6f73
0005b3 7275
0005b4 6563          .db "source"
0005b5 059d          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
0005b6 3dea          .dw PFA_DODEFER1
                 PFA_SOURCE:
                 .endif
0005b7 0016          .dw USER_SOURCE
0005b8 3db3          .dw XT_UDEFERFETCH
0005b9 3dbf          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
0005ba ff07          .dw $ff07
0005bb 732f
0005bc 7274
0005bd 6e69
0005be 0067          .db "/string",0
0005bf 05b1          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
0005c0 3801          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
0005c1 38e1          .dw XT_ROT
0005c2 38cf          .dw XT_OVER
0005c3 399d          .dw XT_PLUS
0005c4 38e1          .dw XT_ROT
0005c5 38e1          .dw XT_ROT
0005c6 3993          .dw XT_MINUS
0005c7 3820          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
0005c8 ff0a          .dw $FF0A 
0005c9 6170
0005ca 7372
0005cb 2d65
0005cc 616e
0005cd 656d          .db "parse-name"
0005ce 05ba          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
0005cf 3801          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
0005d0 3f3f          .dw XT_BL
0005d1 05d3          .dw XT_SKIPSCANCHAR
0005d2 3820          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
0005d3 3801          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
0005d4 38ff          .dw XT_TO_R
0005d5 05b6          .dw XT_SOURCE 
0005d6 3ecd          .dw XT_TO_IN 
0005d7 3879          .dw XT_FETCH 
0005d8 05c0          .dw XT_SLASHSTRING 
                 
0005d9 3906          .dw XT_R_FETCH
0005da 0468          .dw XT_CSKIP
0005db 38f6          .dw XT_R_FROM
0005dc 047f          .dw XT_CSCAN
                 
                     ; adjust >IN
0005dd 3eb4          .dw XT_2DUP
0005de 399d          .dw XT_PLUS
0005df 05b6          .dw XT_SOURCE 
0005e0 38d9          .dw XT_DROP
0005e1 3993          .dw XT_MINUS
0005e2 3ecd          .dw XT_TO_IN
0005e3 3881          .dw XT_STORE
0005e4 3820          .dw XT_EXIT
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
0005e5 ff03          .dw $ff03
0005e6 7073
0005e7 0030          .db "sp0",0
0005e8 05c8          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
0005e9 386f          .dw PFA_DOVALUE1
                 PFA_SP0:
0005ea 0006          .dw USER_SP0
0005eb 3db3          .dw XT_UDEFERFETCH
0005ec 3dbf          .dw XT_UDEFERSTORE
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
0005ed ff03          .dw $ff03
0005ee 7072
0005ef 0030          .db "rp0",0
0005f0 05e5          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
0005f1 3801          .dw DO_COLON
                 PFA_RP0:
0005f2 05f5          .dw XT_DORP0
0005f3 3879          .dw XT_FETCH
0005f4 3820          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
0005f5 3858          .dw PFA_DOUSER
                 PFA_DORP0:
0005f6 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
0005f7 ff05          .dw $ff05
0005f8 6564
0005f9 7470
0005fa 0068          .db "depth",0
0005fb 05ed          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
0005fc 3801          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
0005fd 05e9          .dw XT_SP0
0005fe 3a8d          .dw XT_SP_FETCH
0005ff 3993          .dw XT_MINUS
000600 3a04          .dw XT_2SLASH
000601 3a35          .dw XT_1MINUS
000602 3820          .dw XT_EXIT
                 .include "words/forth-recognizer.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_FORTHRECOGNIZER:
000603 ff10          .dw $ff10
000604 6f66
000605 7472
000606 2d68
000607 6572
000608 6f63
000609 6e67
00060a 7a69
00060b 7265          .db "forth-recognizer"
00060c 05f7          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHRECOGNIZER
                 XT_FORTHRECOGNIZER:
00060d 386f          .dw PFA_DOVALUE1
                 PFA_FORTHRECOGNIZER:
00060e 003e          .dw CFG_FORTHRECOGNIZER
00060f 3d8b          .dw XT_EDEFERFETCH
000610 3d95          .dw XT_EDEFERSTORE
                 .include "words/recognize.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECOGNIZE:
000611 ff09          .dw $ff09
000612 6572
000613 6f63
000614 6e67
000615 7a69
000616 0065          .db "recognize",0
000617 0603          .dw VE_HEAD
                     .set VE_HEAD = VE_RECOGNIZE
                 XT_RECOGNIZE:
000618 3801          .dw DO_COLON
                 PFA_RECOGNIZE:
                 .endif
000619 383d          .dw XT_DOLITERAL
00061a 0623          .dw XT_RECOGNIZE_A
00061b 38c4          .dw XT_SWAP
00061c 09ca          .dw XT_MAPSTACK
00061d 3918          .dw XT_ZEROEQUAL
00061e 3836          .dw XT_DOCONDBRANCH
00061f 0622          DEST(PFA_RECOGNIZE1)
000620 3ebd            .dw XT_2DROP
000621 06ae            .dw XT_RECTYPE_NULL
                 PFA_RECOGNIZE1:
000622 3820          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ; ( addr len XT -- addr len [ rectype-* -1 | 0 ] )
                 XT_RECOGNIZE_A:
000623 3801         .dw DO_COLON
                 PFA_RECOGNIZE_A:
                 .endif
000624 38e1         .dw XT_ROT  ; -- len xt addr
000625 38e1         .dw XT_ROT  ; -- xt addr len
000626 3eb4         .dw XT_2DUP 
000627 3b14         .dw XT_2TO_R
000628 38e1         .dw XT_ROT  ; -- addr len xt
000629 382a         .dw XT_EXECUTE ; -- i*x rectype-* | rectype-null
00062a 3b23         .dw XT_2R_FROM
00062b 38e1         .dw XT_ROT
00062c 38b1         .dw XT_DUP
00062d 06ae         .dw XT_RECTYPE_NULL
00062e 3bd6         .dw XT_EQUAL
00062f 3836         .dw XT_DOCONDBRANCH
000630 0634         DEST(PFA_RECOGNIZE_A1)
000631 38d9           .dw XT_DROP
000632 3954           .dw XT_ZERO
000633 3820           .dw XT_EXIT
                 PFA_RECOGNIZE_A1:
000634 38f0         .dw XT_NIP 
000635 38f0         .dw XT_NIP
000636 394b         .dw XT_TRUE
000637 3820         .dw XT_EXIT
                 
                 ; : recognize ( addr len stack-id -- i*x rectype-* | rectype-null )
                 ;   [: ( addr len -- addr len 0 | i*x rectype-* -1 )
                 ;      rot rot 2dup 2>r rot execute 2r> rot 
                 ;      dup rectype-null = ( -- addr len rectype-* f )
                 ;      if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    map-stack ( -- i*x addr len rectype-* f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop rectype-null
                 ;    then ;
                 ;
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
000638 ff09          .dw $ff09
000639 6e69
00063a 6574
00063b 7072
00063c 6572
00063d 0074          .db "interpret",0
00063e 0611          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
00063f 3801          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
000640 05cf          .dw XT_PARSENAME ; ( -- addr len )
000641 38b1          .dw XT_DUP   ; ( -- addr len flag)
000642 3836          .dw XT_DOCONDBRANCH
000643 0650          DEST(PFA_INTERPRET2)
000644 060d            .dw XT_FORTHRECOGNIZER
000645 0618            .dw XT_RECOGNIZE
000646 3ea2            .dw XT_STATE
000647 3879            .dw XT_FETCH
000648 3836            .dw XT_DOCONDBRANCH
000649 064b          DEST(PFA_INTERPRET1)
00064a 01d8            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
00064b 3bc1            .dw XT_FETCHI
00064c 382a            .dw XT_EXECUTE
00064d 3f76            .dw XT_QSTACK
00064e 382f          .dw XT_DOBRANCH
00064f 0640          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
000650 3ebd          .dw XT_2DROP
000651 3820          .dw XT_EXIT
                 .include "words/rec-intnum.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_NUM:
000652 ff0b          .dw $ff0b
000653 6572
000654 7463
000655 7079
000656 2d65
000657 756e
000658 006d          .db "rectype-num",0
000659 0638          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_NUM
                 XT_RECTYPE_NUM:
00065a 3852          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_NUM:
                 .endif
00065b 3fc0          .dw XT_NOOP    ; interpret
00065c 07a0          .dw XT_LITERAL ; compile
00065d 07a0          .dw XT_LITERAL ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_DNUM:
00065e ff0c          .dw $ff0c
00065f 6572
000660 7463
000661 7079
000662 2d65
000663 6e64
000664 6d75          .db "rectype-dnum"
000665 0652          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_DNUM
                 XT_RECTYPE_DNUM:
000666 3852          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_DNUM:
                 .endif
000667 3fc0          .dw XT_NOOP     ; interpret
000668 3bce          .dw XT_2LITERAL ; compile
000669 3bce          .dw XT_2LITERAL ; postpone
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
00066a ff07          .dw $ff07
00066b 6572
00066c 2d63
00066d 756e
00066e 006d          .db "rec-num",0
00066f 065e          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
000670 3801          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
000671 050f          .dw XT_NUMBER
000672 3836          .dw XT_DOCONDBRANCH
000673 067c          DEST(PFA_REC_NONUMBER)
000674 3bdd          .dw XT_ONE
000675 3bd6          .dw XT_EQUAL
000676 3836          .dw XT_DOCONDBRANCH
000677 067a          DEST(PFA_REC_INTNUM2)
000678 065a            .dw XT_RECTYPE_NUM
000679 3820            .dw XT_EXIT
                 PFA_REC_INTNUM2:
00067a 0666            .dw XT_RECTYPE_DNUM
00067b 3820            .dw XT_EXIT
                 PFA_REC_NONUMBER:
00067c 06ae          .dw XT_RECTYPE_NULL
00067d 3820          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_FIND:
00067e ff08          .dw $ff08
00067f 6572
000680 2d63
000681 6966
000682 646e          .db "rec-find"
000683 066a          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
000684 3801          .dw DO_COLON
                 PFA_REC_FIND:
                 .endif
000685 0723          .DW XT_FINDXT
000686 38b1          .dw XT_DUP
000687 3918          .dw XT_ZEROEQUAL
000688 3836          .dw XT_DOCONDBRANCH
000689 068d          DEST(PFA_REC_WORD_FOUND)
00068a 38d9              .dw XT_DROP
00068b 06ae      	.dw XT_RECTYPE_NULL
00068c 3820      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
00068d 0696          .dw XT_RECTYPE_XT
                 
00068e 3820          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_XT:
00068f ff0a          .dw $ff0a
000690 6572
000691 7463
000692 7079
000693 2d65
000694 7478          .db "rectype-xt"
000695 067e          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_XT
                 XT_RECTYPE_XT:
000696 3852          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_XT:
                 .endif
000697 069a          .dw XT_R_WORD_INTERPRET
000698 069e          .dw XT_R_WORD_COMPILE
000699 3bce          .dw XT_2LITERAL
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
00069a 3801          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
00069b 38d9          .dw XT_DROP ; the flags are in the way
00069c 382a          .dw XT_EXECUTE
00069d 3820          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
00069e 3801          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
00069f 391f          .dw XT_ZEROLESS
0006a0 3836          .dw XT_DOCONDBRANCH
0006a1 06a4          DEST(PFA_R_WORD_COMPILE1)
0006a2 078a      	.dw XT_COMMA
0006a3 3820              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
0006a4 382a              .dw XT_EXECUTE
0006a5 3820          .dw XT_EXIT
                 .include "words/rec-null.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_NULL:
0006a6 ff0c          .dw $ff0c
0006a7 6572
0006a8 7463
0006a9 7079
0006aa 2d65
0006ab 756e
0006ac 6c6c          .db "rectype-null"
0006ad 068f          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_NULL
                 XT_RECTYPE_NULL:
0006ae 3852          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_NULL:
                 .endif
0006af 06b2          .dw XT_FAIL  ; interpret
0006b0 06b2          .dw XT_FAIL  ; compile
0006b1 06b2          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
0006b2 3801          .dw DO_COLON
                 PFA_FAIL:
                 .endif
0006b3 383d          .dw XT_DOLITERAL
0006b4 fff3          .dw -13
0006b5 3d74          .dw XT_THROW
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
0006b6 ff0f          .dw $ff0f
0006b7 6573
0006b8 7261
0006b9 6863
0006ba 772d
0006bb 726f
0006bc 6c64
0006bd 7369
0006be 0074          .db "search-wordlist",0
0006bf 06a6          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
0006c0 3801          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
0006c1 38ff          .dw XT_TO_R
0006c2 3954          .dw XT_ZERO
0006c3 383d          .dw XT_DOLITERAL
0006c4 06d5          .dw XT_ISWORD
0006c5 38f6          .dw XT_R_FROM
0006c6 06f2          .dw XT_TRAVERSEWORDLIST
0006c7 38b1          .dw XT_DUP
0006c8 3918          .dw XT_ZEROEQUAL
0006c9 3836          .dw XT_DOCONDBRANCH
0006ca 06cf          DEST(PFA_SEARCH_WORDLIST1)
0006cb 3ebd             .dw XT_2DROP
0006cc 38d9             .dw XT_DROP
0006cd 3954             .dw XT_ZERO
0006ce 3820             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
0006cf 38b1            .dw XT_DUP
0006d0 0719            .dw XT_NFA2CFA
                       ; .. and get the header flag
0006d1 38c4            .dw XT_SWAP
0006d2 0182            .dw XT_NAME2FLAGS
0006d3 0170            .dw XT_IMMEDIATEQ
0006d4 3820          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
0006d5 3801          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
0006d6 38ff          .dw XT_TO_R
0006d7 38d9          .dw XT_DROP
0006d8 3eb4          .dw XT_2DUP
0006d9 3906          .dw XT_R_FETCH  ; -- addr len addr len nt
0006da 070d          .dw XT_NAME2STRING
0006db 01e1          .dw XT_ICOMPARE      ; (-- addr len f )
0006dc 3836          .dw XT_DOCONDBRANCH
0006dd 06e3          DEST(PFA_ISWORD3)
                       ; not now
0006de 38f6            .dw XT_R_FROM
0006df 38d9            .dw XT_DROP
0006e0 3954            .dw XT_ZERO
0006e1 394b            .dw XT_TRUE         ; maybe next word
0006e2 3820            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
0006e3 3ebd            .dw XT_2DROP
0006e4 38f6            .dw XT_R_FROM
0006e5 3954            .dw XT_ZERO       ; finish traverse-wordlist
0006e6 3820            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
0006e7 ff11          .dw $ff11
0006e8 7274
0006e9 7661
0006ea 7265
0006eb 6573
0006ec 772d
0006ed 726f
0006ee 6c64
0006ef 7369
0006f0 0074          .db "traverse-wordlist",0
0006f1 06b6          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
0006f2 3801          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
0006f3 3b55          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
0006f4 38b1          .dw XT_DUP           ; ( -- xt nt nt )
0006f5 3836          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
0006f6 0703          DEST(PFA_TRAVERSEWORDLIST2)
0006f7 3eb4          .dw XT_2DUP
0006f8 3b14          .dw XT_2TO_R
0006f9 38c4          .dw XT_SWAP
0006fa 382a          .dw XT_EXECUTE
0006fb 3b23          .dw XT_2R_FROM
0006fc 38e1          .dw XT_ROT
0006fd 3836          .dw XT_DOCONDBRANCH
0006fe 0703          DEST(PFA_TRAVERSEWORDLIST2)
0006ff 0a35          .dw XT_NFA2LFA
000700 3bc1          .dw XT_FETCHI
000701 382f          .dw XT_DOBRANCH      ; ( -- addr )
000702 06f4          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
000703 3ebd          .dw XT_2DROP
000704 3820          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' )
                 ;        begin @ dup
                 ;        while
                 ;          2dup 2>r
                 ;          swap execute ( i*x nt -- i*x' f )
                 ;          2r> rot
                 ;        while
                 ;          nfa>lfa @i
                 ;        repeat then 2drop ;
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
000705 ff0b          .dw $ff0b
000706 616e
000707 656d
000708 733e
000709 7274
00070a 6e69
00070b 0067          .db "name>string",0
00070c 06e7          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
00070d 3801          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
00070e 0436          .dw XT_ICOUNT   ; ( -- addr n )
00070f 383d          .dw XT_DOLITERAL
000710 00ff          .dw 255
000711 3a13          .dw XT_AND      ; mask immediate bit
000712 3820          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
000713 ff07          .dw $ff07
000714 666e
000715 3e61
000716 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
000717 0061          .db "nfa>cfa"
000718 0705          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
000719 3801          .dw DO_COLON
                 PFA_NFA2CFA:
00071a 0a35          .dw XT_NFA2LFA ; skip to link field
00071b 3a2f          .dw XT_1PLUS   ; next is the execution token
00071c 3820          .dw XT_EXIT
                 .include "words/find-xt.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the xt from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDXT:
00071d ff07          .dw $ff07
00071e 6966
00071f 646e
000720 782d
000721 0074          .db "find-xt",0
000722 0713          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDXT
                 XT_FINDXT:
000723 3801          .dw DO_COLON
                 PFA_FINDXT:
                 .endif
000724 383d          .dw XT_DOLITERAL
000725 072f          .dw XT_FINDXTA
000726 383d          .dw XT_DOLITERAL
000727 004a          .dw CFG_ORDERLISTLEN
000728 09ca          .dw XT_MAPSTACK
000729 3918          .dw XT_ZEROEQUAL
00072a 3836          .dw XT_DOCONDBRANCH
00072b 072e          DEST(PFA_FINDXT1)
00072c 3ebd            .dw XT_2DROP
00072d 3954            .dw XT_ZERO
                 PFA_FINDXT1:
00072e 3820          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDXTA:
00072f 3801          .dw DO_COLON
                 PFA_FINDXTA:
                 .endif
000730 38ff          .dw XT_TO_R
000731 3eb4          .dw XT_2DUP
000732 38f6          .dw XT_R_FROM
000733 06c0          .dw XT_SEARCH_WORDLIST
000734 38b1          .dw XT_DUP
000735 3836          .dw XT_DOCONDBRANCH
000736 073c          DEST(PFA_FINDXTA1)
000737 38ff            .dw XT_TO_R
000738 38f0            .dw XT_NIP
000739 38f0            .dw XT_NIP
00073a 38f6            .dw XT_R_FROM
00073b 394b            .dw XT_TRUE
                 PFA_FINDXTA1:
00073c 3820          .dw XT_EXIT
                 
                 .include "dict/compiler1.inc"
                 
                 .include "words/newest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_NEWEST:
00073d ff06          .dw $ff06
00073e 656e
00073f 6577
000740 7473          .db "newest"
000741 071d          .dw VE_HEAD
                     .set VE_HEAD = VE_NEWEST
                 XT_NEWEST:
000742 3848          .dw PFA_DOVARIABLE
                 PFA_NEWEST:
000743 018a          .dw ram_newest
                 
                 .dseg
00018a           ram_newest: .byte 4
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_LATEST:
000744 ff06          .dw $ff06
000745 616c
000746 6574
000747 7473          .db "latest"
000748 073d          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
000749 3848          .dw PFA_DOVARIABLE
                 PFA_LATEST:
00074a 018e          .dw ram_latest
                 
                 .dseg
00018e           ram_latest: .byte 2
                 .include "words/do-create.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE:
00074b ff08          .dw $ff08
00074c 6328
00074d 6572
00074e 7461
00074f 2965          .db "(create)"
000750 0744          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
000751 3801          .dw DO_COLON
                 PFA_DOCREATE:
                 .endif
000752 05cf
000753 08b3          .DW XT_PARSENAME,XT_WLSCOPE  ; ( -- addr len wid)
000754 075e          .DW XT_DOCREATE_IN           ; ( addr len wid -- )
000755 3820          .DW XT_EXIT
                 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE_IN:
000756 ff0b          .dw $ff0b
000757 6328
000758 6572
000759 7461
00075a 2d65
00075b 6e69
../../common\words/do-create.asm(31): warning: .cseg .db misalignment - padding zero byte
00075c 0029          .db "(create-in)"
00075d 074b          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE_IN
                 XT_DOCREATE_IN:
00075e 3801          .dw DO_COLON
                 PFA_DOCREATE_IN:
                 .endif
00075f 38b1
000760 0742
000761 3ca7
000762 3881          .DW XT_DUP,XT_NEWEST,XT_CELLPLUS,XT_STORE ; save the wid
000763 0898
000764 0742
000765 3881          .DW XT_HEADER,XT_NEWEST,XT_STORE          ; save the nt
000766 3820          .DW XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
000767 0001          .dw $0001
000768 005c          .db $5c,0
000769 0756          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
00076a 3801          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
00076b 05b6          .dw XT_SOURCE
00076c 38f0          .dw XT_NIP
00076d 3ecd          .dw XT_TO_IN
00076e 3881          .dw XT_STORE
00076f 3820          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
000770 0001          .dw $0001
000771 0028          .db "(" ,0
000772 0767          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
000773 3801          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
000774 383d          .dw XT_DOLITERAL
000775 0029          .dw ')'
000776 05a2          .dw XT_PARSE
000777 3ebd          .dw XT_2DROP
000778 3820          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
000779 ff07          .dw $ff07
00077a 6f63
00077b 706d
00077c 6c69
00077d 0065          .db "compile",0
00077e 0770          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
00077f 3801          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
000780 38f6          .dw XT_R_FROM
000781 38b1          .dw XT_DUP
000782 01d8          .dw XT_ICELLPLUS
000783 38ff          .dw XT_TO_R
000784 3bc1          .dw XT_FETCHI
000785 078a          .dw XT_COMMA
000786 3820          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
000787 ff01          .dw $ff01
000788 002c          .db ',',0 ; ,
000789 0779          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
00078a 3801          .dw DO_COLON
                 PFA_COMMA:
00078b 3efd          .dw XT_DP
00078c 3b69          .dw XT_STOREI
00078d 3efd          .dw XT_DP
00078e 3a2f          .dw XT_1PLUS
00078f 01c6          .dw XT_DOTO
000790 3efe          .dw PFA_DP
000791 3820          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
000792 0003          .dw $0003
000793 275b
000794 005d          .db "[']",0
000795 0787          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
000796 3801          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
000797 044f          .dw XT_TICK
000798 07a0          .dw XT_LITERAL
000799 3820          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
00079a 0007          .dw $0007
00079b 696c
00079c 6574
00079d 6172
00079e 006c          .db "literal",0
00079f 0792          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
0007a0 3801          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
0007a1 077f              .DW XT_COMPILE
0007a2 383d              .DW XT_DOLITERAL
0007a3 078a              .DW XT_COMMA
0007a4 3820              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
0007a5 0008        .dw $0008
0007a6 6c73
0007a7 7469
0007a8 7265
0007a9 6c61        .db "sliteral"
0007aa 079a        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
0007ab 3801          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
0007ac 077f          .dw XT_COMPILE
0007ad 03d7          .dw XT_DOSLITERAL    ; ( -- addr n)
0007ae 03e5          .dw XT_SCOMMA
0007af 3820          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
0007b0 3801          .dw DO_COLON
                 PFA_GMARK:
0007b1 3efd          .dw XT_DP
0007b2 077f          .dw XT_COMPILE
0007b3 ffff          .dw -1           ; ffff does not erase flash
0007b4 3820          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
0007b5 3801          .dw DO_COLON
                 PFA_GRESOLVE:
0007b6 3f76          .dw XT_QSTACK
0007b7 3efd          .dw XT_DP
0007b8 38c4          .dw XT_SWAP
0007b9 3b69          .dw XT_STOREI
0007ba 3820          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
0007bb 3801          .dw DO_COLON
                 PFA_LMARK:
0007bc 3efd          .dw XT_DP
0007bd 3820          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
0007be 3801          .dw DO_COLON
                 PFA_LRESOLVE:
0007bf 3f76          .dw XT_QSTACK
0007c0 078a          .dw XT_COMMA
0007c1 3820          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
0007c2 0005          .dw $0005
0007c3 6861
0007c4 6165
0007c5 0064          .db "ahead",0
0007c6 07a5          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
0007c7 3801          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
0007c8 077f          .dw XT_COMPILE
0007c9 382f          .dw XT_DOBRANCH
0007ca 07b0          .dw XT_GMARK
0007cb 3820          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
0007cc 0002          .dw $0002
0007cd 6669          .db "if"
0007ce 07c2          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
0007cf 3801          .dw DO_COLON
                 PFA_IF:
                 .endif
0007d0 077f          .dw XT_COMPILE
0007d1 3836          .dw XT_DOCONDBRANCH
0007d2 07b0          .dw XT_GMARK
0007d3 3820          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
0007d4 0004          .dw $0004
0007d5 6c65
0007d6 6573          .db "else"
0007d7 07cc          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
0007d8 3801          .dw DO_COLON
                 PFA_ELSE:
                 .endif
0007d9 077f          .dw XT_COMPILE
0007da 382f          .dw XT_DOBRANCH
0007db 07b0          .dw XT_GMARK
0007dc 38c4          .dw XT_SWAP
0007dd 07b5          .dw XT_GRESOLVE
0007de 3820          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
0007df 0004          .dw $0004
0007e0 6874
0007e1 6e65          .db "then"
0007e2 07d4          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
0007e3 3801          .dw DO_COLON
                 PFA_THEN:
                 .endif
0007e4 07b5          .dw XT_GRESOLVE
0007e5 3820          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
0007e6 0005          .dw $0005
0007e7 6562
0007e8 6967
0007e9 006e          .db "begin",0
0007ea 07df          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
0007eb 3801          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
0007ec 07bb          .dw XT_LMARK
0007ed 3820          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
0007ee 0005          .dw $0005
0007ef 6877
0007f0 6c69
0007f1 0065          .db "while",0
0007f2 07e6          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
0007f3 3801          .dw DO_COLON
                 PFA_WHILE:
                 .endif
0007f4 07cf          .dw XT_IF
0007f5 38c4          .dw XT_SWAP
0007f6 3820          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
0007f7 0006          .dw $0006
0007f8 6572
0007f9 6570
0007fa 7461          .db "repeat"
0007fb 07ee          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
0007fc 3801          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
0007fd 0810          .dw XT_AGAIN
0007fe 07e3          .dw XT_THEN
0007ff 3820          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
000800 0005          .dw $0005
000801 6e75
000802 6974
000803 006c          .db "until",0
000804 07f7          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
000805 3801          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
000806 383d          .dw XT_DOLITERAL
000807 3836          .dw XT_DOCONDBRANCH
000808 078a          .dw XT_COMMA
                 
000809 07be          .dw XT_LRESOLVE
00080a 3820          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
00080b 0005          .dw $0005
00080c 6761
00080d 6961
00080e 006e          .db "again",0
00080f 0800          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
000810 3801          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
000811 077f          .dw XT_COMPILE
000812 382f          .dw XT_DOBRANCH
000813 07be          .dw XT_LRESOLVE
000814 3820          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
000815 0002          .dw $0002
000816 6f64          .db "do"
000817 080b          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000818 3801          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
000819 077f          .dw XT_COMPILE
00081a 3a9b          .dw XT_DODO
00081b 07bb          .dw XT_LMARK
00081c 3954          .dw XT_ZERO
00081d 0873          .dw XT_TO_L
00081e 3820          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
00081f 0004          .dw $0004
000820 6f6c
000821 706f          .db "loop"
000822 0815          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
000823 3801          .dw DO_COLON
                 PFA_LOOP:
                 .endif
000824 077f          .dw XT_COMPILE
000825 3ac9          .dw XT_DOLOOP
000826 085a          .dw XT_ENDLOOP
000827 3820          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
000828 0005          .dw $0005
000829 6c2b
00082a 6f6f
00082b 0070          .db "+loop",0
00082c 081f          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
00082d 3801          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
00082e 077f          .dw XT_COMPILE
00082f 3aba          .dw XT_DOPLUSLOOP
000830 085a          .dw XT_ENDLOOP
000831 3820          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
000832 0005         .dw $0005
000833 656c
000834 7661
000835 0065         .db "leave",0
000836 0828         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
000837 3801          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
000838 077f
000839 3ad4          .DW XT_COMPILE,XT_UNLOOP
00083a 07c7
00083b 0873
00083c 3820          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
00083d 0003          .dw $0003
00083e 643f
00083f 006f          .db "?do",0
000840 0832          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
000841 3801          .dw DO_COLON
                 PFA_QDO:
                 .endif
000842 077f          .dw XT_COMPILE
000843 0849          .dw XT_QDOCHECK
000844 07cf          .dw XT_IF
000845 0818          .dw XT_DO
000846 38c4          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
000847 0873          .dw XT_TO_L    ; then follows at the end.
000848 3820          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
000849 3801          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
00084a 3eb4          .dw XT_2DUP
00084b 3bd6          .dw XT_EQUAL
00084c 38b1          .dw XT_DUP
00084d 38ff          .dw XT_TO_R
00084e 3836          .dw XT_DOCONDBRANCH
00084f 0851          DEST(PFA_QDOCHECK1)
000850 3ebd          .dw XT_2DROP
                 PFA_QDOCHECK1:
000851 38f6          .dw XT_R_FROM
000852 39fd          .dw XT_INVERT
000853 3820          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
000854 ff07          .dw $ff07
000855 6e65
000856 6c64
000857 6f6f
000858 0070          .db "endloop",0
000859 083d          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
00085a 3801          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
00085b 07be              .DW XT_LRESOLVE
00085c 0867
00085d 38b9
00085e 3836      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
00085f 0863               DEST(LOOP2)
000860 07e3              .DW XT_THEN
000861 382f      	.dw XT_DOBRANCH
000862 085c               DEST(LOOP1)
000863 3820      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
000864 ff02          .dw $ff02
000865 3e6c          .db "l>"
000866 0854          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
000867 3801          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
000868 0886          .dw XT_LP
000869 3879          .dw XT_FETCH
00086a 3879          .dw XT_FETCH
00086b 383d          .dw XT_DOLITERAL
00086c fffe          .dw -2
00086d 0886          .dw XT_LP
00086e 3a65          .dw XT_PLUSSTORE
00086f 3820          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
000870 ff02          .dw $ff02
000871 6c3e          .db ">l"
000872 0864          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
000873 3801          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
000874 3be2              .dw XT_TWO
000875 0886      	.dw XT_LP
000876 3a65      	.dw XT_PLUSSTORE
000877 0886      	.dw XT_LP
000878 3879      	.dw XT_FETCH
000879 3881      	.dw XT_STORE
00087a 3820      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
00087b ff03          .dw $ff03
00087c 706c
00087d 0030          .db "lp0",0
00087e 0870          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
00087f 386f          .dw PFA_DOVALUE1
                 PFA_LP0:
000880 0040          .dw CFG_LP0
000881 3d8b          .dw XT_EDEFERFETCH
000882 3d95          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
000883 ff02          .dw $ff02
000884 706c          .db "lp"
000885 087b          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
000886 3848          .dw PFA_DOVARIABLE
                 PFA_LP:
000887 0190          .dw ram_lp
                 
                 .dseg
000190           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CREATE:
000888 ff06          .dw $ff06
000889 7263
00088a 6165
00088b 6574          .db "create"
00088c 0883          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
00088d 3801          .dw DO_COLON
                 PFA_CREATE:
                 .endif
00088e 0751          .dw XT_DOCREATE
00088f 08bc          .dw XT_REVEAL
000890 077f          .dw XT_COMPILE
000891 3852          .dw PFA_DOCONSTANT
000892 3820          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
000893 ff06          .dw $ff06
000894 6568
000895 6461
000896 7265          .db "header"
000897 0888          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
000898 3801          .dw DO_COLON
                 PFA_HEADER:
000899 3efd          .dw XT_DP           ; the new Name Field
00089a 38ff          .dw XT_TO_R
00089b 38ff          .dw XT_TO_R		; ( R: NFA WID )
00089c 38b1          .dw XT_DUP    
00089d 3926          .dw XT_GREATERZERO 
00089e 3836          .dw XT_DOCONDBRANCH
00089f 08aa          .dw PFA_HEADER1
0008a0 38b1          .dw XT_DUP
0008a1 383d          .dw XT_DOLITERAL
0008a2 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
0008a3 3a1c          .dw XT_OR
0008a4 03e9          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
0008a5 38f6          .dw XT_R_FROM
0008a6 3b55          .dw XT_FETCHE
0008a7 078a          .dw XT_COMMA
0008a8 38f6          .dw XT_R_FROM
0008a9 3820          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
0008aa 383d          .dw XT_DOLITERAL
0008ab fff0          .dw -16
0008ac 3d74          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
0008ad ff07          .dw $ff07
0008ae 6c77
0008af 6373
0008b0 706f
0008b1 0065          .db "wlscope",0
0008b2 0893          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
0008b3 3dea          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
0008b4 003c          .dw CFG_WLSCOPE
0008b5 3d8b          .dw XT_EDEFERFETCH
0008b6 3d95          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REVEAL:
0008b7 ff06          .dw $ff06
0008b8 6572
0008b9 6576
0008ba 6c61          .db "reveal"
0008bb 08ad          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
0008bc 3801          .dw DO_COLON
                 PFA_REVEAL:
                 .endif
0008bd 0742
0008be 3ca7
0008bf 3879          .DW XT_NEWEST,XT_CELLPLUS,XT_FETCH ; only if wordlist is in use
0008c0 38b9
0008c1 3836          .DW XT_QDUP,XT_DOCONDBRANCH
0008c2 08c7          DEST(REVEAL1)
0008c3 0742
0008c4 3879
0008c5 38c4
0008c6 3b31          .DW XT_NEWEST,XT_FETCH,XT_SWAP,XT_STOREE
                 ;    .DW XT_ZERO,XT_NEWEST,XT_CELLPLUS,XT_STORE ; clean wordlist entry
                 REVEAL1:
0008c7 3820          .DW XT_EXIT
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
0008c8 0005          .dw $0005
0008c9 6f64
0008ca 7365
0008cb 003e          .db "does>",0
0008cc 08b7          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
0008cd 3801          .dw DO_COLON
                 PFA_DOES:
0008ce 077f          .dw XT_COMPILE
0008cf 08e0          .dw XT_DODOES
0008d0 077f          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
0008d1 940e          .dw $940e       ; the address of this compiled
0008d2 077f          .dw XT_COMPILE  ; code will replace the XT of the 
0008d3 08d5          .dw DO_DODOES   ; word that CREATE created
0008d4 3820          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
0008d5 939a
0008d6 938a          savetos
0008d7 01cb          movw tosl, wl
0008d8 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
0008d9 917f          pop wh
0008da 916f          pop wl
                 
0008db 93bf          push XH
0008dc 93af          push XL
0008dd 01db          movw XL, wl
0008de 940c 3805     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
0008e0 3801          .dw DO_COLON
                 PFA_DODOES:
0008e1 38f6          .dw XT_R_FROM
0008e2 0742          .dw XT_NEWEST
0008e3 3ca7          .dw XT_CELLPLUS
0008e4 3879          .dw XT_FETCH
0008e5 3b55          .dw XT_FETCHE
0008e6 0719          .dw XT_NFA2CFA
0008e7 3b69          .dw XT_STOREI
0008e8 3820          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
0008e9 ff01          .dw $ff01
0008ea 003a          .db ":",0
0008eb 08c8          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
0008ec 3801          .dw DO_COLON
                 PFA_COLON:
                 .endif
0008ed 0751          .dw XT_DOCREATE
0008ee 08f7          .dw XT_COLONNONAME
0008ef 38d9          .dw XT_DROP
0008f0 3820          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
0008f1 ff07          .dw $ff07
0008f2 6e3a
0008f3 6e6f
0008f4 6d61
0008f5 0065          .db ":noname",0
0008f6 08e9          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
0008f7 3801          .dw DO_COLON
                 PFA_COLONNONAME:
0008f8 3efd          .dw XT_DP
0008f9 38b1          .dw XT_DUP
0008fa 0749          .dw XT_LATEST
0008fb 3881          .dw XT_STORE
                 
0008fc 077f          .dw XT_COMPILE
0008fd 3801          .dw DO_COLON
                 
0008fe 090c          .dw XT_RBRACKET
0008ff 3820          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
000900 0001          .dw $0001
000901 003b          .db $3b,0
000902 08f1          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
000903 3801          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
000904 077f          .dw XT_COMPILE
000905 3820          .dw XT_EXIT
000906 0914          .dw XT_LBRACKET
000907 08bc          .dw XT_REVEAL
000908 3820          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
000909 ff01          .dw $ff01
00090a 005d          .db "]",0
00090b 0900          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
00090c 3801          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
00090d 3bdd          .dw XT_ONE
00090e 3ea2          .dw XT_STATE
00090f 3881          .dw XT_STORE
000910 3820          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
000911 0001          .dw $0001
000912 005b          .db "[",0
000913 0909          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
000914 3801          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
000915 3954          .dw XT_ZERO
000916 3ea2          .dw XT_STATE
000917 3881          .dw XT_STORE
000918 3820          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
000919 ff08          .dw $ff08
00091a 6176
00091b 6972
00091c 6261
00091d 656c          .db "variable"
00091e 0911          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
00091f 3801          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
000920 3f0e          .dw XT_HERE
000921 092b          .dw XT_CONSTANT
000922 3be2          .dw XT_TWO
000923 3f17          .dw XT_ALLOT
000924 3820          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
000925 ff08          .dw $ff08
000926 6f63
000927 736e
000928 6174
000929 746e          .db "constant"
00092a 0919          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
00092b 3801          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
00092c 0751          .dw XT_DOCREATE
00092d 08bc          .dw XT_REVEAL
00092e 077f          .dw XT_COMPILE
00092f 3848          .dw PFA_DOVARIABLE
000930 078a          .dw XT_COMMA
000931 3820          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
000932 ff04          .dw $ff04
000933 7375
000934 7265          .db "user"
000935 0925          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
000936 3801          .dw DO_COLON
                 PFA_USER:
000937 0751          .dw XT_DOCREATE
000938 08bc          .dw XT_REVEAL
                 
000939 077f          .dw XT_COMPILE
00093a 3858          .dw PFA_DOUSER
00093b 078a          .dw XT_COMMA
00093c 3820          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECURSE:
00093d 0007          .dw $0007
00093e 6572
00093f 7563
000940 7372
000941 0065          .db "recurse",0
000942 0932          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
000943 3801          .dw DO_COLON
                 PFA_RECURSE:
                 .endif
000944 0749          .dw XT_LATEST
000945 3879          .dw XT_FETCH
000946 078a          .dw XT_COMMA
000947 3820          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
000948 ff09          .dw $ff09
000949 6d69
00094a 656d
00094b 6964
00094c 7461
00094d 0065          .db "immediate",0
00094e 093d          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
00094f 3801          .dw DO_COLON
                 PFA_IMMEDIATE:
000950 09f1          .dw XT_GET_CURRENT
000951 3b55          .dw XT_FETCHE
000952 38b1          .dw XT_DUP
000953 3bc1          .dw XT_FETCHI
000954 383d          .dw XT_DOLITERAL
000955 7fff          .dw $7fff
000956 3a13          .dw XT_AND
000957 38c4          .dw XT_SWAP
000958 3b69          .dw XT_STOREI
000959 3820          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
00095a 0006          .dw $0006
00095b 635b
00095c 6168
00095d 5d72          .db "[char]"
00095e 0948          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
00095f 3801          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
000960 077f          .dw XT_COMPILE
000961 383d          .dw XT_DOLITERAL
000962 0500          .dw XT_CHAR
000963 078a          .dw XT_COMMA
000964 3820          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
000965 0006          .dw $0006
000966 6261
000967 726f
000968 2274          .db "abort",'"'
000969 095a          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
00096a 3801          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
00096b 3e75          .dw XT_SQUOTE
00096c 077f          .dw XT_COMPILE
00096d 097c          .dw XT_QABORT
00096e 3820          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
00096f ff05          .dw $ff05
000970 6261
000971 726f
000972 0074          .db "abort",0
000973 0965          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
000974 3801          .dw DO_COLON
                 PFA_ABORT:
                 .endif
000975 394b          .dw XT_TRUE
000976 3d74          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
000977 ff06          .dw $ff06
000978 613f
000979 6f62
00097a 7472          .db "?abort"
00097b 096f          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
00097c 3801          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
00097d 38e1
00097e 3836              .DW XT_ROT,XT_DOCONDBRANCH
00097f 0982              DEST(QABO1)
000980 040a
000981 0974              .DW XT_ITYPE,XT_ABORT
000982 3ebd
000983 3820      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
000984 ff09          .dw $ff09
000985 6567
000986 2d74
000987 7473
000988 6361
000989 006b          .db "get-stack",0
00098a 0977          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
00098b 3801          .dw DO_COLON
                 .endif
00098c 38b1          .dw XT_DUP
00098d 3ca7          .dw XT_CELLPLUS
00098e 38c4          .dw XT_SWAP
00098f 3b55          .dw XT_FETCHE
000990 38b1          .dw XT_DUP
000991 38ff          .dw XT_TO_R
000992 3954          .dw XT_ZERO
000993 38c4          .dw XT_SWAP    ; go from bigger to smaller addresses
000994 0849          .dw XT_QDOCHECK
000995 3836          .dw XT_DOCONDBRANCH
000996 09a2          DEST(PFA_N_FETCH_E2)
000997 3a9b          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
000998 3aac          .dw XT_I
000999 3a35          .dw XT_1MINUS
00099a 3eaf          .dw XT_CELLS ; ( -- ee-addr i*2 )
00099b 38cf          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
00099c 399d          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
00099d 3b55          .dw XT_FETCHE ;( -- ee-addr item_i )
00099e 38c4          .dw XT_SWAP   ;( -- item_i ee-addr )
00099f 394b          .dw XT_TRUE  ; shortcut for -1
0009a0 3aba          .dw XT_DOPLUSLOOP
0009a1 0998          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
0009a2 3ebd          .dw XT_2DROP
0009a3 38f6          .dw XT_R_FROM
0009a4 3820          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
0009a5 ff09          .dw $ff09
0009a6 6573
0009a7 2d74
0009a8 7473
0009a9 6361
0009aa 006b          .db "set-stack",0
0009ab 0984          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
0009ac 3801          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
0009ad 38cf          .dw XT_OVER
0009ae 391f          .dw XT_ZEROLESS
0009af 3836          .dw XT_DOCONDBRANCH
0009b0 09b4          DEST(PFA_SET_STACK0)
0009b1 383d          .dw XT_DOLITERAL
0009b2 fffc          .dw -4
0009b3 3d74          .dw XT_THROW
                 PFA_SET_STACK0:
0009b4 3eb4          .dw XT_2DUP
0009b5 3b31          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
0009b6 38c4          .dw XT_SWAP    
0009b7 3954          .dw XT_ZERO
0009b8 0849          .dw XT_QDOCHECK
0009b9 3836          .dw XT_DOCONDBRANCH
0009ba 09c1          DEST(PFA_SET_STACK2)
0009bb 3a9b          .dw XT_DODO
                 PFA_SET_STACK1:
0009bc 3ca7          .dw XT_CELLPLUS ; ( -- i_x e-addr )
0009bd 3ec5          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
0009be 3b31          .dw XT_STOREE
0009bf 3ac9          .dw XT_DOLOOP
0009c0 09bc          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
0009c1 38d9          .dw XT_DROP
0009c2 3820          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
0009c3 ff09          .dw $ff09
0009c4 616d
0009c5 2d70
0009c6 7473
0009c7 6361
0009c8 006b          .db "map-stack",0
0009c9 09a5          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
0009ca 3801          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
0009cb 38b1          .dw XT_DUP
0009cc 3ca7          .dw XT_CELLPLUS
0009cd 38c4          .dw XT_SWAP
0009ce 3b55          .dw XT_FETCHE
0009cf 3eaf          .dw XT_CELLS
0009d0 3f84          .dw XT_BOUNDS
0009d1 0849          .dw XT_QDOCHECK
0009d2 3836          .dw XT_DOCONDBRANCH
0009d3 09e6          DEST(PFA_MAPSTACK3)
0009d4 3a9b          .dw XT_DODO
                 PFA_MAPSTACK1:
0009d5 3aac            .dw XT_I
0009d6 3b55            .dw XT_FETCHE   ; -- i*x XT id
0009d7 38c4            .dw XT_SWAP
0009d8 38ff            .dw XT_TO_R
0009d9 3906            .dw XT_R_FETCH
0009da 382a            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
0009db 38b9            .dw XT_QDUP
0009dc 3836            .dw XT_DOCONDBRANCH
0009dd 09e2            DEST(PFA_MAPSTACK2)
0009de 38f6               .dw XT_R_FROM
0009df 38d9               .dw XT_DROP
0009e0 3ad4               .dw XT_UNLOOP
0009e1 3820               .dw XT_EXIT
                 PFA_MAPSTACK2:
0009e2 38f6            .dw XT_R_FROM
0009e3 3be2            .dw XT_TWO
0009e4 3aba            .dw XT_DOPLUSLOOP
0009e5 09d5            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
0009e6 38d9          .dw XT_DROP
0009e7 3954          .dw XT_ZERO
0009e8 3820          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ; ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
0009e9 ff0b          .dw $ff0b
0009ea 6567
0009eb 2d74
0009ec 7563
0009ed 7272
0009ee 6e65
0009ef 0074          .db "get-current",0
0009f0 09c3          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
0009f1 3801          .dw DO_COLON
                 PFA_GET_CURRENT:
0009f2 383d          .dw XT_DOLITERAL
0009f3 0046          .dw CFG_CURRENT
0009f4 3b55          .dw XT_FETCHE
0009f5 3820          .dw XT_EXIT
                 .include "words/cfg-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CFG_ORDER:
0009f6 ff09          .dw $ff09
0009f7 6663
0009f8 2d67
0009f9 726f
0009fa 6564
0009fb 0072          .db "cfg-order",0
0009fc 09e9          .dw VE_HEAD
                     .set VE_HEAD = VE_CFG_ORDER
                 XT_CFG_ORDER:
0009fd 3848          .dw PFA_DOVARIABLE
                 PFA_CFG_ORDER:
                 .endif
0009fe 004a          .dw CFG_ORDERLISTLEN
                 .include "words/cfg-recognizer.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CFG_RECOGNIZER:
0009ff ff08          .dw $ff08
000a00 6663
000a01 2d67
000a02 6572
000a03 7363          .db "cfg-recs"
000a04 09f6          .dw VE_HEAD
                     .set VE_HEAD = VE_CFG_RECOGNIZER
                 XT_CFG_RECOGNIZER:
000a05 3848          .dw PFA_DOVARIABLE
                 PFA_CFG_RECOGNIZER:
                 .endif
000a06 005c          .dw CFG_RECOGNIZERLISTLEN
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000a07 ff07          .dw $ff07
000a08 6f63
000a09 706d
000a0a 7261
000a0b 0065          .db "compare",0
000a0c 09ff          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
000a0d 0a0e          .dw PFA_COMPARE
                 PFA_COMPARE:
000a0e 93bf          push xh
000a0f 93af          push xl
000a10 018c          movw temp0, tosl
000a11 9189
000a12 9199          loadtos
000a13 01dc          movw xl, tosl
000a14 9189
000a15 9199          loadtos
000a16 019c          movw temp2, tosl
000a17 9189
000a18 9199          loadtos
000a19 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000a1a 90ed          ld temp4, X+
000a1b 90f1          ld temp5, Z+
000a1c 14ef          cp temp4, temp5
000a1d f451          brne PFA_COMPARE_NOTEQUAL
000a1e 950a          dec temp0
000a1f f019          breq PFA_COMPARE_ENDREACHED2
000a20 952a          dec temp2
000a21 f7c1          brne PFA_COMPARE_LOOP
000a22 c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000a23 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000a24 2b02          or temp0, temp2
000a25 f411          brne PFA_COMPARE_CHECKLASTCHAR
000a26 2788          clr tosl
000a27 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000a28 ef8f          ser tosl
000a29 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000a2a 2f98          mov tosh, tosl
000a2b 91af          pop xl
000a2c 91bf          pop xh
000a2d 940c 3805     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
000a2f ff07         .dw $ff07
000a30 666e
000a31 3e61
000a32 666c
000a33 0061         .db "nfa>lfa",0
000a34 0a07         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000a35 3801          .dw DO_COLON
                 PFA_NFA2LFA:
000a36 070d          .dw XT_NAME2STRING
000a37 3a2f          .dw XT_1PLUS
000a38 3a04          .dw XT_2SLASH
000a39 399d          .dw XT_PLUS
000a3a 3820          .dw XT_EXIT
                 .include "dict/interrupt.inc"
                 
                 .if WANT_INTERRUPTS == 1
                 
                 .if WANT_INTERRUPT_COUNTERS == 1
                   .include "words/irqcnt.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_IRQCNTADDR:
000a3b ff06          .dw $ff06
000a3c 7269
000a3d 5b71
000a3e 235d          .db "irq[]#"
000a3f 0a2f          .dw VE_HEAD
                     .set VE_HEAD = VE_IRQCNTADDR
                 XT_IRQCNTADDR:
000a40 3801          .dw DO_COLON
                 PFA_IRQCNTADDR:
000a41 383d          .dw XT_DOLITERAL
000a42 0112          .dw intcnt
000a43 399d          .dw XT_PLUS
000a44 3820          .dw XT_EXIT
                   .include "words/int-num.asm"
                 
                 ; Interrupt
                 ; number of interrupt vectors (0 based)
                 VE_NUMINT:
000a45 ff04          .dw $ff04
000a46 6923
000a47 746e          .db "#int"
000a48 0a3b          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMINT
                 XT_NUMINT:
000a49 3848          .dw PFA_DOVARIABLE
                 PFA_NUMINT:
000a4a 001a          .dw INTVECTORS
                 .endif
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
000a4b ff04          .dw $ff04
000a4c 692b
000a4d 746e          .db "+int"
000a4e 0a45          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
000a4f 0a50          .dw PFA_INTON
                 PFA_INTON:
000a50 9478          sei
000a51 940c 3805     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
000a53 ff04          .dw $ff04
000a54 692d
000a55 746e          .db "-int"
000a56 0a4b          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
000a57 0a58          .dw PFA_INTOFF
                 PFA_INTOFF:
000a58 94f8          cli
000a59 940c 3805     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
000a5b ff04          .dw $ff04
000a5c 6e69
000a5d 2174          .db "int!"
000a5e 0a53          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
000a5f 3801          .dw DO_COLON
                 PFA_INTSTORE:
000a60 383d          .dw XT_DOLITERAL
000a61 0000          .dw intvec
000a62 399d          .dw XT_PLUS
000a63 3b31          .dw XT_STOREE
000a64 3820          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
000a65 ff04          .dw $ff04
000a66 6e69
000a67 4074          .db "int@"
000a68 0a5b          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
000a69 3801          .dw DO_COLON
                 PFA_INTFETCH:
000a6a 383d          .dw XT_DOLITERAL
000a6b 0000          .dw intvec
000a6c 399d          .dw XT_PLUS
000a6d 3b55          .dw XT_FETCHE
000a6e 3820          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
000a6f ff08          .dw $ff08
000a70 6e69
000a71 2d74
000a72 7274
000a73 7061          .db "int-trap"
000a74 0a65          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
000a75 0a76          .dw PFA_INTTRAP
                 PFA_INTTRAP:
000a76 2eb8          mov isrflag, tosl
000a77 9189
000a78 9199          loadtos
000a79 940c 3805     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
000a7b 3801          .dw DO_COLON
                 PFA_ISREXEC:
000a7c 0a69          .dw XT_INTFETCH
000a7d 382a          .dw XT_EXECUTE
000a7e 0a80          .dw XT_ISREND
000a7f 3820          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
000a80 0a81          .dw PFA_ISREND
                 PFA_ISREND:
000a81 d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
000a82 940c 3805     jmp_ DO_NEXT
                 PFA_ISREND1:
000a84 9518          reti
                 .endif
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTS:
000a85 ff02          .dw $ff02
000a86 732e          .db ".s"
000a87 0a6f          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
000a88 3801          .dw DO_COLON
                 PFA_DOTS:
                 .endif
000a89 05fc          .dw XT_DEPTH
000a8a 3df5          .dw XT_UDOT
000a8b 3f99          .dw XT_SPACE
000a8c 05fc          .dw XT_DEPTH
000a8d 3954          .dw XT_ZERO
000a8e 0849          .dw XT_QDOCHECK
000a8f 3836          .dw XT_DOCONDBRANCH
000a90 0a97          DEST(PFA_DOTS2)
000a91 3a9b          .dw XT_DODO
                 PFA_DOTS1:
000a92 3aac          .dw XT_I
000a93 3c9b          .dw XT_PICK
000a94 3df5          .dw XT_UDOT
000a95 3ac9          .dw XT_DOLOOP
000a96 0a92          DEST(PFA_DOTS1)
                 PFA_DOTS2:
000a97 3820          .dw XT_EXIT
                 .include "words/spirw.asm"
                 
                 ; MCU
                 ; SPI exchange of 1 byte
                 VE_SPIRW:
000a98 ff06          .dw $ff06
000a99 2163
000a9a 7340
000a9b 6970          .db "c!@spi"
000a9c 0a85          .dw VE_HEAD
                     .set VE_HEAD  = VE_SPIRW
                 XT_SPIRW:
000a9d 0a9e          .dw PFA_SPIRW
                 PFA_SPIRW:
000a9e d003          rcall do_spirw
000a9f 2799          clr tosh
000aa0 940c 3805     jmp_ DO_NEXT
                 
                 do_spirw:
000aa2 bd8e          out_ SPDR, tosl
                 do_spirw1:
000aa3 b50d          in_ temp0, SPSR
000aa4 7f08          cbr temp0,7
000aa5 bd0d          out_ SPSR, temp0
000aa6 b50d          in_ temp0, SPSR
000aa7 ff07          sbrs temp0, 7
000aa8 cffa          rjmp do_spirw1   ; wait until complete
000aa9 b58e          in_ tosl, SPDR
000aaa 9508          ret
                 .include "words/n-spi.asm"
                 
                 ; MCU
                 ; read len bytes from SPI to addr
                 VE_N_SPIR:
000aab ff05          .dw $ff05
000aac 406e
000aad 7073
000aae 0069          .db "n@spi",0
000aaf 0a98          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIR
                 XT_N_SPIR:
000ab0 0ab1          .dw PFA_N_SPIR
                 PFA_N_SPIR:
000ab1 018c          movw temp0, tosl
000ab2 9189
000ab3 9199          loadtos
000ab4 01fc          movw zl, tosl
000ab5 01c8          movw tosl, temp0
                 PFA_N_SPIR_LOOP:
000ab6 bc2e          out_ SPDR, zerol
                 PFA_N_SPIR_LOOP1:
000ab7 b52d          in_ temp2, SPSR
000ab8 ff27          sbrs temp2, SPIF
000ab9 cffd          rjmp PFA_N_SPIR_LOOP1
000aba b52e          in_ temp2, SPDR
000abb 9321          st Z+, temp2
000abc 9701          sbiw tosl, 1
000abd f7c1          brne PFA_N_SPIR_LOOP
000abe 9189
000abf 9199          loadtos
000ac0 940c 3805     jmp_ DO_NEXT
                 
                 ; ( addr len -- ) 
                 ; MCU
                 ; write len bytes to SPI from addr
                 VE_N_SPIW:
000ac2 ff05          .dw $ff05
000ac3 216e
000ac4 7073
000ac5 0069          .db "n!spi",0
000ac6 0aab          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIW
                 XT_N_SPIW:
000ac7 0ac8          .dw PFA_N_SPIW
                 PFA_N_SPIW:
000ac8 018c          movw temp0, tosl
000ac9 9189
000aca 9199          loadtos
000acb 01fc          movw zl, tosl
000acc 01c8          movw tosl, temp0
                 PFA_N_SPIW_LOOP:
000acd 9121          ld temp2, Z+
000ace bd2e          out_ SPDR, temp2
                 PFA_N_SPIW_LOOP1:
000acf b52d          in_ temp2, SPSR
000ad0 ff27          sbrs temp2, SPIF
000ad1 cffd          rjmp PFA_N_SPIW_LOOP1
000ad2 b52e          in_ temp2, SPDR ; ignore the data
000ad3 9701          sbiw tosl, 1
000ad4 f7c1          brne PFA_N_SPIW_LOOP
000ad5 9189
000ad6 9199          loadtos
000ad7 940c 3805     jmp_ DO_NEXT
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
000ad9 ff0b          .dw $ff0b
000ada 7061
000adb 6c70
000adc 7574
000add 6e72
000ade 656b
000adf 0079          .db "applturnkey",0
000ae0 0ac2          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000ae1 3801          .dw DO_COLON
                 PFA_APPLTURNKEY:
000ae2 00c7          .dw XT_USART
                 
                 .if WANT_INTERRUPTS == 1
000ae3 0a4f          .dw XT_INTON
                 .endif
000ae4 0197          .dw XT_DOT_VER
000ae5 3f99          .dw XT_SPACE
000ae6 3e97          .dw XT_F_CPU
000ae7 383d          .dw XT_DOLITERAL
000ae8 03e8          .dw 1000
000ae9 39c2          .dw XT_UMSLASHMOD
000aea 38f0          .dw XT_NIP
000aeb 3f2c          .dw XT_DECIMAL
000aec 038c          .dw XT_DOT
000aed 03d7          .dw XT_DOSLITERAL
000aee 0004          .dw 4
000aef 486b
000af0 207a          .db "kHz "
000af1 040a          .dw XT_ITYPE
000af2 3820          .dw XT_EXIT
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
000af3 ff0b          .dw $ff0b
000af4 6573
000af5 2d74
000af6 7563
000af7 7272
000af8 6e65
000af9 0074          .db "set-current",0
000afa 0ad9          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
000afb 3801          .dw DO_COLON
                 PFA_SET_CURRENT:
000afc 383d          .dw XT_DOLITERAL
000afd 0046          .dw CFG_CURRENT
000afe 3b31          .dw XT_STOREE
000aff 3820          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
000b00 ff08          .dw $ff08
000b01 6f77
000b02 6472
000b03 696c
000b04 7473          .db "wordlist"
000b05 0af3          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
000b06 3801          .dw DO_COLON
                 PFA_WORDLIST:
000b07 3f06          .dw XT_EHERE
000b08 3954          .dw XT_ZERO
000b09 38cf          .dw XT_OVER
000b0a 3b31          .dw XT_STOREE
000b0b 38b1          .dw XT_DUP
000b0c 3ca7          .dw XT_CELLPLUS
000b0d 01c6          .dw XT_DOTO
000b0e 3f07          .dw PFA_EHERE
000b0f 3820          .dw XT_EXIT
                 
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTHWORDLIST:
000b10 ff0e          .dw $ff0e
000b11 6f66
000b12 7472
000b13 2d68
000b14 6f77
000b15 6472
000b16 696c
000b17 7473          .db "forth-wordlist"
000b18 0b00          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHWORDLIST
                 XT_FORTHWORDLIST:
000b19 3848          .dw PFA_DOVARIABLE
                 PFA_FORTHWORDLIST:
000b1a 0048          .dw CFG_FORTHWORDLIST
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000b1b ff04          .dw $ff04
000b1c 6f63
000b1d 6564          .db "code"
000b1e 0b10          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
000b1f 3801          .dw DO_COLON
                 PFA_CODE:
000b20 0751          .dw XT_DOCREATE
000b21 08bc          .dw XT_REVEAL
000b22 3efd          .dw XT_DP
000b23 01d8          .dw XT_ICELLPLUS
000b24 078a          .dw XT_COMMA
000b25 3820          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000b26 ff08          .dw $ff08
000b27 6e65
000b28 2d64
000b29 6f63
000b2a 6564          .db "end-code"
000b2b 0b1b          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000b2c 3801          .dw DO_COLON
                 PFA_ENDCODE:
000b2d 077f          .dw XT_COMPILE
000b2e 940c          .dw $940c
000b2f 077f          .dw XT_COMPILE
000b30 3805          .dw DO_NEXT
000b31 3820          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
000b32 ff08          .dw $ff08
000b33 6d28
000b34 7261
000b35 656b
000b36 2972          .db "(marker)"
000b37 0b26          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
000b38 386f          .dw PFA_DOVALUE1
                 PFA_MARKER:
000b39 0068          .dw EE_MARKER
000b3a 3d8b          .dw XT_EDEFERFETCH
000b3b 3d95          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
000b3c 0008          .dw $0008
000b3d 6f70
000b3e 7473
000b3f 6f70
000b40 656e          .db "postpone"
000b41 0b32          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
000b42 3801          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
000b43 05cf          .dw XT_PARSENAME
000b44 060d          .dw XT_FORTHRECOGNIZER
000b45 0618          .dw XT_RECOGNIZE
000b46 38b1          .dw XT_DUP
000b47 38ff          .dw XT_TO_R
000b48 01d8          .dw XT_ICELLPLUS
000b49 01d8          .dw XT_ICELLPLUS
000b4a 3bc1          .dw XT_FETCHI
000b4b 382a          .dw XT_EXECUTE
000b4c 38f6          .dw XT_R_FROM
000b4d 01d8          .dw XT_ICELLPLUS
000b4e 3bc1          .dw XT_FETCHI
000b4f 078a          .dw XT_COMMA
000b50 3820          .dw XT_EXIT
                 .endif
                 .include "words/2r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_2R_FETCH:
000b51 ff03          .dw $ff03
000b52 7232
000b53 0040          .db "2r@",0
000b54 0b3c          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FETCH
                 XT_2R_FETCH:
000b55 0b56          .dw PFA_2R_FETCH
                 PFA_2R_FETCH:
000b56 939a
000b57 938a          savetos
000b58 91ef          pop zl
000b59 91ff          pop zh
000b5a 918f          pop tosl
000b5b 919f          pop tosh
000b5c 939f          push tosh
000b5d 938f          push tosl
000b5e 93ff          push zh
000b5f 93ef          push zl
000b60 939a
000b61 938a          savetos
000b62 01cf          movw tosl, zl
000b63 940c 3805     jmp_ DO_NEXT
                 
                 .set DPSTART = pc
                 .if(pc>AMFORTH_RO_SEG)
                 .endif
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
003801 93bf          push XH
003802 93af          push XL          ; PUSH IP
003803 01db          movw XL, wl
003804 9611          adiw xl, 1
                 DO_NEXT:
                 .if WANT_INTERRUPTS == 1
003805 14b2          cp isrflag, zerol
003806 f469          brne DO_INTERRUPT
                 .endif
003807 01fd          movw zl, XL        ; READ IP
003808 0fee
003809 1fff
00380a 9165
00380b 9175          readflashcell wl, wh
00380c 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00380d 01fb          movw zl, wl
00380e 0fee
00380f 1fff
003810 9105
003811 9115          readflashcell temp0,temp1
003812 01f8          movw zl, temp0
003813 9409          ijmp
                 
                 .if WANT_INTERRUPTS == 1
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
003814 939a
003815 938a          savetos
003816 2d8b          mov tosl, isrflag
003817 24bb          clr isrflag
003818 2799          clr tosh
003819 e76b          ldi wl, LOW(XT_ISREXEC)
00381a e07a          ldi wh, HIGH(XT_ISREXEC)
00381b cff1          rjmp DO_EXECUTE
                 .endif
                 .include "dict/nrww.inc"
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
00381c ff04          .dw $ff04
00381d 7865
00381e 7469          .db "exit"
00381f 0b51          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
003820 3821          .dw PFA_EXIT
                 PFA_EXIT:
003821 91af          pop XL
003822 91bf          pop XH
003823 cfe1          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
003824 ff07          .dw $ff07
003825 7865
003826 6365
003827 7475
003828 0065          .db "execute",0
003829 381c          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
00382a 382b          .dw PFA_EXECUTE
                 PFA_EXECUTE:
00382b 01bc          movw wl, tosl
00382c 9189
00382d 9199          loadtos
00382e cfde          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
00382f 3830          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
003830 01fd          movw zl, XL
003831 0fee
003832 1fff
003833 91a5
003834 91b5          readflashcell XL,XH
003835 cfcf          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
003836 3837          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
003837 2b98          or tosh, tosl
003838 9189
003839 9199          loadtos
00383a f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
00383b 9611          adiw XL, 1
00383c cfc8          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
00383d 383e          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
00383e 939a
00383f 938a          savetos
003840 01fd          movw zl, xl
003841 0fee
003842 1fff
003843 9185
003844 9195          readflashcell tosl,tosh
003845 9611          adiw xl, 1
003846 cfbe          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
003847 3848          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
003848 939a
003849 938a          savetos
00384a 01fb          movw zl, wl
00384b 9631          adiw zl,1
00384c 0fee
00384d 1fff
00384e 9185
00384f 9195          readflashcell tosl,tosh
003850 cfb4          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
003851 3852          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
003852 939a
003853 938a          savetos
003854 01cb          movw tosl, wl
003855 9601          adiw tosl, 1
003856 cfae          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
003857 3858          .dw PFA_DOUSER
                 PFA_DOUSER:
003858 939a
003859 938a          savetos
00385a 01fb          movw zl, wl
00385b 9631          adiw zl, 1
00385c 0fee
00385d 1fff
00385e 9185
00385f 9195          readflashcell tosl,tosh
003860 0d84          add tosl, upl
003861 1d95          adc tosh, uph
003862 cfa2          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
003863 ff07          .dw $ff07
003864 7628
003865 6c61
003866 6575
003867 0029          .db "(value)", 0
003868 3824          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
003869 3801          .dw DO_COLON
                 PFA_DOVALUE:
00386a 0751          .dw XT_DOCREATE
00386b 08bc          .dw XT_REVEAL
00386c 077f          .dw XT_COMPILE
00386d 386f          .dw PFA_DOVALUE1
00386e 3820          .dw XT_EXIT
                 PFA_DOVALUE1:
00386f 940e 08d5     call_ DO_DODOES
003871 38b1          .dw XT_DUP
003872 01d8          .dw XT_ICELLPLUS
003873 3bc1          .dw XT_FETCHI
003874 382a          .dw XT_EXECUTE
003875 3820          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
003876 ff01          .dw $ff01
003877 0040          .db "@",0
003878 3863          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
003879 387a          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
00387a 01fc          movw zl, tosl
                     ; low byte is read before the high byte
00387b 9181          ld tosl, z+
00387c 9191          ld tosh, z+
00387d cf87          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
00387e ff01          .dw $ff01
00387f 0021          .db "!",0
003880 3876          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
003881 3882          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
003882 01fc          movw zl, tosl
003883 9189
003884 9199          loadtos
                     ; the high byte is written before the low byte
003885 8391          std Z+1, tosh
003886 8380          std Z+0, tosl
003887 9189
003888 9199          loadtos
003889 cf7b          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
00388a ff02          .dw $ff02
00388b 2163          .db "c!"
00388c 387e          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
00388d 388e          .dw PFA_CSTORE
                 PFA_CSTORE:
00388e 01fc          movw zl, tosl
00388f 9189
003890 9199          loadtos
003891 8380          st Z, tosl
003892 9189
003893 9199          loadtos
003894 cf70          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
003895 ff02          .dw $ff02
003896 4063          .db "c@"
003897 388a          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
003898 3899          .dw PFA_CFETCH
                 PFA_CFETCH:
003899 01fc          movw zl, tosl
00389a 2799          clr tosh
00389b 8180          ld tosl, Z
00389c cf68          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
00389d ff02          .dw $ff02
00389e 7540          .db "@u"
00389f 3895          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
0038a0 3801          .dw DO_COLON
                 PFA_FETCHU:
0038a1 3b02          .dw XT_UP_FETCH
0038a2 399d          .dw XT_PLUS
0038a3 3879          .dw XT_FETCH
0038a4 3820          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
0038a5 ff02          .dw $ff02
0038a6 7521          .db "!u"
0038a7 389d          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
0038a8 3801          .dw DO_COLON
                 PFA_STOREU:
0038a9 3b02          .dw XT_UP_FETCH
0038aa 399d          .dw XT_PLUS
0038ab 3881          .dw XT_STORE
0038ac 3820          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
0038ad ff03          .dw $ff03
0038ae 7564
0038af 0070          .db "dup",0
0038b0 38a5          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
0038b1 38b2          .dw PFA_DUP
                 PFA_DUP:
0038b2 939a
0038b3 938a          savetos
0038b4 cf50          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
0038b5 ff04          .dw $ff04
0038b6 643f
0038b7 7075          .db "?dup"
0038b8 38ad          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
0038b9 38ba          .dw PFA_QDUP
                 PFA_QDUP:
0038ba 2f08          mov temp0, tosl
0038bb 2b09          or temp0, tosh
0038bc f011          breq PFA_QDUP1
0038bd 939a
0038be 938a          savetos
                 PFA_QDUP1:
0038bf cf45          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
0038c0 ff04          .dw $ff04
0038c1 7773
0038c2 7061          .db "swap"
0038c3 38b5          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
0038c4 38c5          .dw PFA_SWAP
                 PFA_SWAP:
0038c5 018c          movw temp0, tosl
0038c6 9189
0038c7 9199          loadtos
0038c8 931a          st -Y, temp1
0038c9 930a          st -Y, temp0
0038ca cf3a          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
0038cb ff04          .dw $ff04
0038cc 766f
0038cd 7265          .db "over"
0038ce 38c0          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
0038cf 38d0          .dw PFA_OVER
                 PFA_OVER:
0038d0 939a
0038d1 938a          savetos
0038d2 818a          ldd tosl, Y+2
0038d3 819b          ldd tosh, Y+3
                 
0038d4 cf30          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
0038d5 ff04          .dw $ff04
0038d6 7264
0038d7 706f          .db "drop"
0038d8 38cb          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
0038d9 38da          .dw PFA_DROP
                 PFA_DROP:
0038da 9189
0038db 9199          loadtos
0038dc cf28          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
0038dd ff03          .dw $ff03
0038de 6f72
0038df 0074          .db "rot",0
0038e0 38d5          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
0038e1 38e2          .dw PFA_ROT
                 PFA_ROT:
0038e2 018c          movw temp0, tosl
0038e3 9129          ld temp2, Y+
0038e4 9139          ld temp3, Y+ 
0038e5 9189
0038e6 9199          loadtos
                         
0038e7 933a          st -Y, temp3
0038e8 932a          st -Y, temp2
0038e9 931a          st -Y, temp1
0038ea 930a          st -Y, temp0
                 
0038eb cf19          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
0038ec ff03          .dw $ff03
0038ed 696e
0038ee 0070          .db "nip",0
0038ef 38dd          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
0038f0 38f1          .dw PFA_NIP
                 PFA_NIP:
0038f1 9622          adiw yl, 2
0038f2 cf12          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
0038f3 ff02          .dw $ff02
0038f4 3e72          .db "r>"
0038f5 38ec          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
0038f6 38f7          .dw PFA_R_FROM
                 PFA_R_FROM:
0038f7 939a
0038f8 938a          savetos
0038f9 918f          pop tosl
0038fa 919f          pop tosh
0038fb cf09          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
0038fc ff02          .dw $ff02
0038fd 723e          .db ">r"
0038fe 38f3          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
0038ff 3900          .dw PFA_TO_R
                 PFA_TO_R:
003900 939f          push tosh
003901 938f          push tosl
003902 cfd7          jmp_ PFA_DROP
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
003903 ff02          .dw $ff02
003904 4072          .db "r@"
003905 38fc          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
003906 3907          .dw PFA_R_FETCH
                 PFA_R_FETCH:
003907 939a
003908 938a          savetos
003909 918f          pop tosl
00390a 919f          pop tosh
00390b 939f          push tosh
00390c 938f          push tosl
00390d cef7          jmp_ DO_NEXT
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
00390e ff02          .dw $ff02
00390f 3e3c          .db "<>"
003910 3903          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
003911 3801          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
003912 3bd6
003913 3918
003914 3820          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
003915 ff02          .dw $ff02
003916 3d30          .db "0="
003917 390e          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
003918 3919          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
003919 2b98          or tosh, tosl
00391a f5e1          brne PFA_ZERO1
00391b c032          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
00391c ff02          .dw $ff02
00391d 3c30          .db "0<"
00391e 3915          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
00391f 3920          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
003920 fd97          sbrc tosh,7
003921 c02c          rjmp PFA_TRUE1
003922 c034          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
003923 ff02          .dw $ff02
003924 3e30          .db "0>"
003925 391c          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
003926 3927          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
003927 1582          cp tosl, zerol
003928 0593          cpc tosh, zeroh
003929 f16c          brlt PFA_ZERO1
00392a f161          brbs 1, PFA_ZERO1
00392b c022          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
00392c ff03          .dw $ff03
00392d 3064
00392e 003e          .db "d0>",0
00392f 3923          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
003930 3931          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
003931 1593          cp tosh, zeroh
003932 f03c          brlt PFA_DGREATERZERO_FALSE ; if MSBit is set, d:arg is negative, we are done (false).
003933 0582          cpc tosl, zerol
003934 9189
003935 9199          loadtos
003936 0582          cpc tosl, zerol
003937 0593          cpc tosh, zeroh
003938 f0f1          brbs 1, PFA_ZERO1           ; if all 4 Bytes of d:arg are zero, we are done (false).
003939 c014          rjmp PFA_TRUE1              ; if we get this far, d:arg was positive! (true)
                 PFA_DGREATERZERO_FALSE:
00393a 01c1          movw tosl, zerol            ; ZERO
00393b cfb5          rjmp PFA_NIP                ; NIP
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
00393c ff03          .dw $ff03
00393d 3064
00393e 003c          .db "d0<",0
00393f 392c          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
003940 3941          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
003941 9622          adiw Y,2
003942 fd97          sbrc tosh,7
003943 940c 394e     jmp PFA_TRUE1
003945 940c 3957     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
003947 ff04          .dw $ff04
003948 7274
003949 6575          .db "true"
00394a 393c          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
00394b 394c          .dw PFA_TRUE
                 PFA_TRUE:
00394c 939a
00394d 938a          savetos
                 PFA_TRUE1:
00394e ef8f          ser tosl
00394f ef9f          ser tosh
003950 ceb4          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
003951 ff01          .dw $ff01
003952 0030          .db "0",0
003953 3947          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
003954 3955          .dw PFA_ZERO
                 PFA_ZERO:
003955 939a
003956 938a          savetos
                 PFA_ZERO1:
003957 01c1          movw tosl, zerol
003958 ceac          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
003959 ff02          .dw $ff02
00395a 3c75          .db "u<"
00395b 3951          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
00395c 395d          .dw PFA_ULESS
                 PFA_ULESS:
00395d 9129          ld temp2, Y+
00395e 9139          ld temp3, Y+
00395f 1782          cp tosl, temp2
003960 0793          cpc tosh, temp3
003961 f3a8          brlo PFA_ZERO1
003962 f3a1          brbs 1, PFA_ZERO1
003963 cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
003964 ff02          .dw $ff02
003965 3e75          .db "u>"
003966 3959          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
003967 3801          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
003968 38c4          .DW XT_SWAP
003969 395c          .dw XT_ULESS
00396a 3820          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
00396b ff01          .dw $ff01
00396c 003c          .db "<",0
00396d 3964          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
00396e 396f          .dw PFA_LESS
                 PFA_LESS:
00396f 9129          ld temp2, Y+
003970 9139          ld temp3, Y+
003971 1728          cp temp2, tosl
003972 0739          cpc temp3, tosh
                 PFA_LESSDONE:
003973 f71c          brge PFA_ZERO1
003974 cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
003975 ff01          .dw $ff01
003976 003e          .db ">",0
003977 396b          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
003978 3979          .dw PFA_GREATER
                 PFA_GREATER:
003979 9129          ld temp2, Y+
00397a 9139          ld temp3, Y+
00397b 1728          cp temp2, tosl
00397c 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
00397d f2cc          brlt PFA_ZERO1
00397e f2c1          brbs 1, PFA_ZERO1
00397f cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
003980 ff04          .dw $ff04
003981 6f6c
003982 3267          .db "log2"
003983 3975          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
003984 3985          .dw PFA_LOG2
                 PFA_LOG2:
003985 01fc          movw zl, tosl
003986 2799          clr tosh
003987 e180          ldi tosl, 16
                 PFA_LOG2_1:
003988 958a          dec tosl
003989 f022          brmi PFA_LOG2_2 ; wrong data
00398a 0fee          lsl  zl
00398b 1fff          rol  zh
00398c f7d8          brcc PFA_LOG2_1
00398d ce77          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
00398e 959a          dec tosh
00398f ce75          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
003990 ff01          .dw $ff01
003991 002d          .db "-",0
003992 3980          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
003993 3994          .dw PFA_MINUS
                 PFA_MINUS:
003994 9109          ld temp0, Y+
003995 9119          ld temp1, Y+
003996 1b08          sub temp0, tosl
003997 0b19          sbc temp1, tosh
003998 01c8          movw tosl, temp0
003999 ce6b          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
00399a ff01          .dw $ff01
00399b 002b          .db "+",0
00399c 3990          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
00399d 399e          .dw PFA_PLUS
                 PFA_PLUS:
00399e 9109          ld temp0, Y+
00399f 9119          ld temp1, Y+
0039a0 0f80          add tosl, temp0
0039a1 1f91          adc tosh, temp1
0039a2 ce62          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
0039a3 ff02          .dw $ff02
0039a4 2a6d          .db "m*"
0039a5 399a          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
0039a6 39a7          .dw PFA_MSTAR
                 PFA_MSTAR:
0039a7 018c          movw temp0, tosl
0039a8 9189
0039a9 9199          loadtos
0039aa 019c          movw temp2, tosl
                     ; high cell ah*bh
0039ab 0231          muls temp3, temp1
0039ac 0170          movw temp4, r0
                     ; low cell  al*bl
0039ad 9f20          mul  temp2, temp0
0039ae 01c0          movw tosl, r0
                     ; signed ah*bl
0039af 0330          mulsu temp3, temp0
0039b0 08f3          sbc   temp5, zeroh
0039b1 0d90          add   tosh,  r0
0039b2 1ce1          adc   temp4, r1
0039b3 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
0039b4 0312          mulsu temp1, temp2
0039b5 08f3          sbc   temp5, zeroh
0039b6 0d90          add   tosh,  r0
0039b7 1ce1          adc   temp4, r1
0039b8 1cf3          adc   temp5, zeroh
                 
0039b9 939a
0039ba 938a          savetos
0039bb 01c7          movw tosl, temp4
0039bc ce48          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
0039bd ff06          .dw $ff06
0039be 6d75
0039bf 6d2f
0039c0 646f          .db "um/mod"
0039c1 39a3          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
0039c2 39c3          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
0039c3 017c          movw temp4, tosl
                 
0039c4 9129          ld temp2, Y+
0039c5 9139          ld temp3, Y+
                   
0039c6 9109          ld temp0, Y+
0039c7 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
0039c8 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
0039c9 2755          clr temp7
0039ca 0f00          lsl temp0
0039cb 1f11          rol temp1
0039cc 1f22          rol temp2
0039cd 1f33          rol temp3
0039ce 1f55          rol temp7
                 
                   ; try subtracting divisor
0039cf 152e          cp temp2, temp4
0039d0 053f          cpc temp3, temp5
0039d1 0552          cpc temp7,zerol
                 
0039d2 f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
0039d3 9503          inc temp0
0039d4 192e          sub temp2, temp4
0039d5 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
0039d6 954a          dec  temp6
0039d7 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
0039d8 933a          st -Y,temp3
0039d9 932a          st -Y,temp2
                 
                     ; put quotient on stack
0039da 01c8          movw tosl, temp0
0039db ce29          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
0039dc ff03          .dw $ff03
0039dd 6d75
0039de 002a          .db "um*",0
0039df 39bd          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
0039e0 39e1          .dw PFA_UMSTAR
                 PFA_UMSTAR:
0039e1 018c          movw temp0, tosl
0039e2 9189
0039e3 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
0039e4 9f80          mul tosl,temp0
0039e5 01f0          movw zl, r0
0039e6 2722          clr temp2
0039e7 2733          clr temp3
                     ; middle bytes
0039e8 9f90          mul tosh, temp0
0039e9 0df0          add zh, r0
0039ea 1d21          adc temp2, r1
0039eb 1d33          adc temp3, zeroh
                         
0039ec 9f81          mul tosl, temp1
0039ed 0df0          add zh, r0
0039ee 1d21          adc temp2, r1
0039ef 1d33          adc temp3, zeroh
                     
0039f0 9f91          mul tosh, temp1
0039f1 0d20          add temp2, r0
0039f2 1d31          adc temp3, r1
0039f3 01cf          movw tosl, zl
0039f4 939a
0039f5 938a          savetos
0039f6 01c9          movw tosl, temp2
0039f7 ce0d          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
0039f8 ff06          .dw $ff06
0039f9 6e69
0039fa 6576
0039fb 7472          .db "invert"
0039fc 39dc          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
0039fd 39fe          .dw PFA_INVERT
                 PFA_INVERT:
0039fe 9580          com tosl
0039ff 9590          com tosh
003a00 ce04          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
003a01 ff02          .dw $ff02
003a02 2f32          .db "2/"
003a03 39f8          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
003a04 3a05          .dw PFA_2SLASH
                 PFA_2SLASH:
003a05 9595          asr tosh
003a06 9587          ror tosl
003a07 cdfd          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
003a08 ff02          .dw $ff02
003a09 2a32          .db "2*"
003a0a 3a01          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
003a0b 3a0c          .dw PFA_2STAR
                 PFA_2STAR:
003a0c 0f88          lsl tosl
003a0d 1f99          rol tosh
003a0e cdf6          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
003a0f ff03          .dw $ff03
003a10 6e61
003a11 0064          .db "and",0
003a12 3a08          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
003a13 3a14          .dw PFA_AND
                 PFA_AND:
003a14 9109          ld temp0, Y+
003a15 9119          ld temp1, Y+
003a16 2380          and tosl, temp0
003a17 2391          and tosh, temp1
003a18 cdec          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
003a19 ff02          .dw $ff02
003a1a 726f          .db "or"
003a1b 3a0f          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
003a1c 3a1d          .dw PFA_OR
                 PFA_OR:
003a1d 9109          ld temp0, Y+
003a1e 9119          ld temp1, Y+
003a1f 2b80          or tosl, temp0
003a20 2b91          or tosh, temp1
003a21 cde3          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
003a22 ff03          .dw $ff03
003a23 6f78
003a24 0072          .db "xor",0
003a25 3a19          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
003a26 3a27          .dw PFA_XOR
                 PFA_XOR:
003a27 9109          ld temp0, Y+
003a28 9119          ld temp1, Y+
003a29 2780          eor tosl, temp0
003a2a 2791          eor tosh, temp1
003a2b cdd9          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
003a2c ff02          .dw $ff02
003a2d 2b31          .db "1+"
003a2e 3a22          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
003a2f 3a30          .dw PFA_1PLUS
                 PFA_1PLUS:
003a30 9601          adiw tosl,1
003a31 cdd3          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
003a32 ff02          .dw $ff02 
003a33 2d31          .db "1-"
003a34 3a2c          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
003a35 3a36          .dw PFA_1MINUS
                 PFA_1MINUS:
003a36 9701          sbiw tosl, 1
003a37 cdcd          jmp_ DO_NEXT
                 .include "words/q-negate.asm"
                 
                 ;   0< IF NEGATE THEN ;        ...a common factor
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QNEGATE:
003a38 ff07          .dw $ff07
003a39 6e3f
003a3a 6765
003a3b 7461
../../common\words/q-negate.asm(11): warning: .cseg .db misalignment - padding zero byte
003a3c 0065          .db "?negate"
003a3d 3a32          .dw VE_HEAD
                     .set VE_HEAD = VE_QNEGATE
                 XT_QNEGATE:
003a3e 3801          .dw DO_COLON
                 PFA_QNEGATE:
                 
                 .endif
003a3f 391f
003a40 3836              .DW XT_ZEROLESS,XT_DOCONDBRANCH
003a41 3a43              DEST(QNEG1)
003a42 3e12              .DW XT_NEGATE
003a43 3820      QNEG1:  .DW XT_EXIT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
003a44 ff06          .dw $ff06
003a45 736c
003a46 6968
003a47 7466          .db "lshift"
003a48 3a38          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
003a49 3a4a          .dw PFA_LSHIFT
                 PFA_LSHIFT:
003a4a 01fc          movw zl, tosl
003a4b 9189
003a4c 9199          loadtos
                 PFA_LSHIFT1:
003a4d 9731          sbiw zl, 1
003a4e f01a          brmi PFA_LSHIFT2
003a4f 0f88          lsl tosl
003a50 1f99          rol tosh
003a51 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
003a52 cdb2          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
003a53 ff06          .dw $ff06
003a54 7372
003a55 6968
003a56 7466          .db "rshift"
003a57 3a44          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
003a58 3a59          .dw PFA_RSHIFT
                 PFA_RSHIFT:
003a59 01fc          movw zl, tosl
003a5a 9189
003a5b 9199          loadtos
                 PFA_RSHIFT1:
003a5c 9731          sbiw zl, 1
003a5d f01a          brmi PFA_RSHIFT2
003a5e 9596          lsr tosh
003a5f 9587          ror tosl
003a60 cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
003a61 cda3          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
003a62 ff02          .dw $ff02
003a63 212b          .db "+!"
003a64 3a53          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
003a65 3a66          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
003a66 01fc          movw zl, tosl
003a67 9189
003a68 9199          loadtos
003a69 8120          ldd temp2, Z+0
003a6a 8131          ldd temp3, Z+1
003a6b 0f82          add tosl, temp2
003a6c 1f93          adc tosh, temp3
003a6d 8380          std Z+0, tosl
003a6e 8391          std Z+1, tosh
003a6f 9189
003a70 9199          loadtos
003a71 cd93          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
003a72 ff03          .dw $ff03
003a73 7072
003a74 0040          .db "rp@",0
003a75 3a62          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
003a76 3a77          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
003a77 939a
003a78 938a          savetos
003a79 b78d          in tosl, SPL
003a7a b79e          in tosh, SPH
003a7b cd89          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
003a7c ff03          .dw $ff03
003a7d 7072
003a7e 0021          .db "rp!",0
003a7f 3a72          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
003a80 3a81          .dw PFA_RP_STORE
                 PFA_RP_STORE:
003a81 b72f          in temp2, SREG
003a82 94f8          cli
003a83 bf8d          out SPL, tosl
003a84 bf9e          out SPH, tosh
003a85 bf2f          out SREG, temp2
003a86 9189
003a87 9199          loadtos
003a88 cd7c          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
003a89 ff03          .dw $ff03
003a8a 7073
003a8b 0040          .db "sp@",0
003a8c 3a7c          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
003a8d 3a8e          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
003a8e 939a
003a8f 938a          savetos
003a90 01ce          movw tosl, yl
003a91 cd73          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
003a92 ff03          .dw $ff03
003a93 7073
003a94 0021          .db "sp!",0
003a95 3a89          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
003a96 3a97          .dw PFA_SP_STORE
                 PFA_SP_STORE:
003a97 01ec          movw yl, tosl
003a98 9189
003a99 9199          loadtos
003a9a cd6a          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
003a9b 3a9c          .dw PFA_DODO
                 PFA_DODO:
003a9c 9129          ld temp2, Y+
003a9d 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
003a9e e8e0          ldi zl, $80
003a9f 0f3e          add temp3, zl
003aa0 1b82          sub  tosl, temp2
003aa1 0b93          sbc  tosh, temp3
                 
003aa2 933f          push temp3
003aa3 932f          push temp2    ; limit  ( --> limit + $8000)
003aa4 939f          push tosh
003aa5 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
003aa6 9189
003aa7 9199          loadtos
003aa8 cd5c          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
003aa9 ff01          .dw $FF01
003aaa 0069          .db "i",0
003aab 3a92          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
003aac 3aad          .dw PFA_I
                 PFA_I:
003aad 939a
003aae 938a          savetos
003aaf 918f          pop tosl
003ab0 919f          pop tosh  ; index
003ab1 91ef          pop zl
003ab2 91ff          pop zh    ; limit
003ab3 93ff          push zh
003ab4 93ef          push zl
003ab5 939f          push tosh
003ab6 938f          push tosl
003ab7 0f8e          add tosl, zl
003ab8 1f9f          adc tosh, zh
003ab9 cd4b          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
003aba 3abb          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
003abb 91ef          pop zl
003abc 91ff          pop zh
003abd 0fe8          add zl, tosl
003abe 1ff9          adc zh, tosh
003abf 9189
003ac0 9199          loadtos
003ac1 f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
003ac2 93ff          push zh
003ac3 93ef          push zl
003ac4 cd6b          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
003ac5 910f          pop  temp0
003ac6 911f          pop  temp1  ; remove limit
003ac7 9611          adiw xl, 1  ; skip branch-back address
003ac8 cd3c          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
003ac9 3aca          .dw PFA_DOLOOP
                 PFA_DOLOOP:
003aca 91ef          pop zl
003acb 91ff          pop zh
003acc 9631          adiw zl,1
003acd f3bb          brvs PFA_DOPLUSLOOP_LEAVE
003ace cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
003acf ff06          .dw $ff06
003ad0 6e75
003ad1 6f6c
003ad2 706f          .db "unloop"
003ad3 3aa9          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
003ad4 3ad5          .dw PFA_UNLOOP
                 PFA_UNLOOP:
003ad5 911f          pop temp1
003ad6 910f          pop temp0
003ad7 911f          pop temp1
003ad8 910f          pop temp0
003ad9 cd2b          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
003ada ff06          .dw $ff06
003adb 6d63
003adc 766f
003add 3e65          .db "cmove>"
003ade 3acf          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
003adf 3ae0          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
003ae0 93bf          push xh
003ae1 93af          push xl
003ae2 91e9          ld zl, Y+
003ae3 91f9          ld zh, Y+ ; addr-to
003ae4 91a9          ld xl, Y+
003ae5 91b9          ld xh, Y+ ; addr-from
003ae6 2f09          mov temp0, tosh
003ae7 2b08          or temp0, tosl
003ae8 f041          brbs 1, PFA_CMOVE_G1
003ae9 0fe8          add zl, tosl
003aea 1ff9          adc zh, tosh
003aeb 0fa8          add xl, tosl
003aec 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
003aed 911e          ld temp1, -X
003aee 9312          st -Z, temp1
003aef 9701          sbiw tosl, 1
003af0 f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
003af1 91af          pop xl
003af2 91bf          pop xh
003af3 9189
003af4 9199          loadtos
003af5 cd0f          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
003af6 ff02          .dw $ff02
003af7 3c3e          .db "><"
003af8 3ada          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
003af9 3afa          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
003afa 2f09          mov temp0, tosh
003afb 2f98          mov tosh, tosl
003afc 2f80          mov tosl, temp0
003afd cd07          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
003afe ff03          .dw $ff03
003aff 7075
003b00 0040          .db "up@",0
003b01 3af6          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
003b02 3b03          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
003b03 939a
003b04 938a          savetos
003b05 01c2          movw tosl, upl
003b06 ccfe          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
003b07 ff03          .dw $ff03
003b08 7075
003b09 0021          .db "up!",0
003b0a 3afe          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
003b0b 3b0c          .dw PFA_UP_STORE
                 PFA_UP_STORE:
003b0c 012c          movw upl, tosl
003b0d 9189
003b0e 9199          loadtos
003b0f ccf5          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
003b10 ff03          .dw $ff03
003b11 3e32
003b12 0072          .db "2>r",0
003b13 3b07          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
003b14 3b15          .dw PFA_2TO_R
                 PFA_2TO_R:
003b15 01fc          movw zl, tosl
003b16 9189
003b17 9199          loadtos
003b18 939f          push tosh
003b19 938f          push tosl
003b1a 93ff          push zh
003b1b 93ef          push zl
003b1c 9189
003b1d 9199          loadtos
003b1e cce6          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
003b1f ff03          .dw $ff03
003b20 7232
003b21 003e          .db "2r>",0
003b22 3b10          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
003b23 3b24          .dw PFA_2R_FROM
                 PFA_2R_FROM:
003b24 939a
003b25 938a          savetos
003b26 91ef          pop zl
003b27 91ff          pop zh
003b28 918f          pop tosl
003b29 919f          pop tosh
003b2a 939a
003b2b 938a          savetos
003b2c 01cf          movw tosl, zl
003b2d ccd7          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
003b2e ff02          .dw $ff02
003b2f 6521          .db "!e"
003b30 3b1f          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
003b31 3b32          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
003b32 01fc          movw zl, tosl
003b33 9189
003b34 9199          loadtos
003b35 b72f          in_ temp2, SREG
003b36 94f8          cli
003b37 d028          rcall PFA_FETCHE2
003b38 b500          in_  temp0, EEDR
003b39 1708          cp temp0,tosl
003b3a f009          breq PFA_STOREE3
003b3b d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
003b3c 9631          adiw zl,1
003b3d d022          rcall PFA_FETCHE2
003b3e b500          in_  temp0, EEDR
003b3f 1709          cp temp0,tosh
003b40 f011          breq PFA_STOREE4
003b41 2f89          mov tosl, tosh
003b42 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
003b43 bf2f          out_ SREG, temp2
003b44 9189
003b45 9199          loadtos
003b46 ccbe          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
003b47 99f9          sbic EECR, EEPE
003b48 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
003b49 b707          in_ temp0, SPMCSR
003b4a fd00          sbrc temp0,SPMEN
003b4b cffd          rjmp PFA_STOREE2
                 
003b4c bdf2          out_ EEARH,zh
003b4d bde1          out_ EEARL,zl
003b4e bd80          out_ EEDR, tosl
003b4f 9afa          sbi EECR,EEMPE
003b50 9af9          sbi EECR,EEPE
                 
003b51 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
003b52 ff02          .dw $ff02
003b53 6540          .db "@e"
003b54 3b2e          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
003b55 3b56          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
003b56 b72f          in_ temp2, SREG
003b57 94f8          cli
003b58 01fc          movw zl, tosl
003b59 d006          rcall PFA_FETCHE2
003b5a b580          in_ tosl, EEDR
                 
003b5b 9631          adiw zl,1
                 
003b5c d003          rcall PFA_FETCHE2
003b5d b590          in_  tosh, EEDR
003b5e bf2f          out_ SREG, temp2
003b5f cca5          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
003b60 99f9          sbic EECR, EEPE
003b61 cffe          rjmp PFA_FETCHE2
                 
003b62 bdf2          out_ EEARH,zh
003b63 bde1          out_ EEARL,zl
                 
003b64 9af8          sbi EECR,EERE
003b65 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
003b66 ff02          .dw $ff02
003b67 6921          .db "!i"
003b68 3b52          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
003b69 3dea          .dw PFA_DODEFER1
                 PFA_STOREI:
003b6a 0066          .dw EE_STOREI
003b6b 3d8b          .dw XT_EDEFERFETCH
003b6c 3d95          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                 .else
                   .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
003b6d ff09          .dw $ff09
003b6e 2128
003b6f 2d69
003b70 726e
003b71 7777
003b72 0029          .db "(!i-nrww)",0
003b73 3b66          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
003b74 3b75          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
003b75 b71f        in temp1,SREG
003b76 931f        push temp1
003b77 94f8        cli
                 
003b78 019c        movw temp2, tosl ; save the (word) address
003b79 9189
003b7a 9199        loadtos          ; get the new value for the flash cell
003b7b 93af        push xl
003b7c 93bf        push xh
003b7d 93cf        push yl
003b7e 93df        push yh
003b7f d009        rcall DO_STOREI_atmega
003b80 91df        pop yh
003b81 91cf        pop yl
003b82 91bf        pop xh
003b83 91af        pop xl
                   ; finally clear the stack
003b84 9189
003b85 9199        loadtos
003b86 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
003b87 bf1f        out SREG,temp1
                 
003b88 cc7c        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
003b89 d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
003b8a 94e0        com temp4
003b8b 94f0        com temp5
003b8c 218e        and tosl, temp4
003b8d 219f        and tosh, temp5
003b8e 2b98        or tosh, tosl
003b8f f019        breq DO_STOREI_writepage 
003b90 01f9          movw zl, temp2
003b91 e002          ldi temp0,(1<<PGERS)
003b92 d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
003b93 01f9        movw zl, temp2
003b94 e004        ldi temp0,(1<<PGWRT)
003b95 d01d        rcall dospm
                 
                   ; reenable RWW section
003b96 01f9        movw zl, temp2
003b97 e100        ldi temp0,(1<<RWWSRE)
003b98 d01a        rcall dospm
003b99 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
003b9a 01f9        movw zl, temp2
                   ; get the beginning of page
003b9b 7ce0        andi zl,low(pagemask)
003b9c 7fff        andi zh,high(pagemask)
003b9d 01ef        movw y, z
                   ; loop counter (in words)
003b9e e4a0        ldi xl,low(pagesize)
003b9f e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
003ba0 01fe        movw z, y
003ba1 0fee
003ba2 1fff
003ba3 9145
003ba4 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
003ba5 01fe        movw z, y
003ba6 17e2        cp zl, temp2
003ba7 07f3        cpc zh, temp3
003ba8 f011        breq pageload_newdata
003ba9 010a          movw r0, temp6
003baa c002          rjmp pageload_cont
                 pageload_newdata:
003bab 017a          movw temp4, temp6
003bac 010c          movw r0, tosl
                 pageload_cont:
003bad 2700        clr temp0
003bae d004        rcall dospm
003baf 9621        adiw y, 1
003bb0 9711        sbiw x, 1
003bb1 f771        brne pageload_loop
                 
                 pageload_done:
003bb2 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
003bb3 99f9        sbic EECR, EEPE
003bb4 cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
003bb5 b717        in_  temp1, SPMCSR
003bb6 fd10        sbrc temp1, SPMEN
003bb7 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
003bb8 0fee
003bb9 1fff        writeflashcell
                   ; execute spm
003bba 6001        ori temp0, (1<<SPMEN)
003bbb bf07        out_ SPMCSR,temp0
003bbc 95e8        spm
003bbd 9508        ret
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
003bbe ff02          .dw $ff02
003bbf 6940          .db "@i"
003bc0 3b6d          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
003bc1 3bc2          .dw PFA_FETCHI
                 PFA_FETCHI:
003bc2 01fc          movw zl, tosl
003bc3 0fee
003bc4 1fff
003bc5 9185
003bc6 9195          readflashcell tosl,tosh
003bc7 cc3d          jmp_ DO_NEXT
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2LITERAL:
003bc8 0008          .dw $0008
003bc9 6c32
003bca 7469
003bcb 7265
003bcc 6c61          .db "2literal"
003bcd 3bbe          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
003bce 3801          .dw DO_COLON
                 PFA_2LITERAL:
                 .endif
003bcf 38c4          .dw XT_SWAP
003bd0 07a0          .dw XT_LITERAL
003bd1 07a0          .dw XT_LITERAL
003bd2 3820          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
003bd3 ff01          .dw $ff01
003bd4 003d          .db "=",0
003bd5 3bc8          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
003bd6 3801          .dw DO_COLON
                 PFA_EQUAL:
003bd7 3993          .dw XT_MINUS
003bd8 3918          .dw XT_ZEROEQUAL
003bd9 3820          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
003bda ff01          .dw $ff01
003bdb 0031          .db "1",0
003bdc 3bd3          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
003bdd 3848          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
003bde 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
003bdf ff01          .dw $ff01
003be0 0032          .db "2",0
003be1 3bda          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
003be2 3848          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
003be3 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
003be4 ff02          .dw $ff02
003be5 312d          .db "-1"
003be6 3bdf          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
003be7 3848          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
003be8 ffff              .DW -1
                 
                 .if AMFORTH_NRWW_SIZE>8000
                 .elif AMFORTH_NRWW_SIZE>4000
                   .include "dict/core_4k.inc"
                 
                 ; in a short distance to DO_NEXT
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
003be9 ff03          .dw $ff03
003bea 3e6e
003beb 0072          .db "n>r",0
003bec 3be4          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
003bed 3bee          .dw PFA_N_TO_R
                 PFA_N_TO_R:
003bee 01fc          movw zl, tosl
003bef 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
003bf0 9189
003bf1 9199          loadtos
003bf2 939f          push tosh
003bf3 938f          push tosl
003bf4 950a          dec temp0
003bf5 f7d1          brne PFA_N_TO_R1
003bf6 93ef          push zl
003bf7 93ff          push zh
003bf8 9189
003bf9 9199          loadtos
003bfa cc0a          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
003bfb ff03          .dw $ff03
003bfc 726e
003bfd 003e          .db "nr>",0
003bfe 3be9          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
003bff 3c00          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
003c00 939a
003c01 938a          savetos
003c02 91ff          pop zh
003c03 91ef          pop zl
003c04 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
003c05 918f          pop tosl
003c06 919f          pop tosh
003c07 939a
003c08 938a          savetos
003c09 950a          dec temp0
003c0a f7d1          brne PFA_N_R_FROM1
003c0b 01cf          movw tosl, zl
003c0c cbf8          jmp_ DO_NEXT
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
003c0d ff03          .dw $ff03
003c0e 3264
003c0f 002a          .db "d2*",0
003c10 3bfb          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
003c11 3c12          .dw PFA_D2STAR
                 PFA_D2STAR:
003c12 9109          ld temp0, Y+
003c13 9119          ld temp1, Y+
003c14 0f00          lsl temp0
003c15 1f11          rol temp1
003c16 1f88          rol tosl
003c17 1f99          rol tosh
003c18 931a          st -Y, temp1
003c19 930a          st -Y, temp0
003c1a cbea          jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
003c1b ff03          .dw $ff03
003c1c 3264
003c1d 002f          .db "d2/",0
003c1e 3c0d          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
003c1f 3c20          .dw PFA_D2SLASH
                 PFA_D2SLASH:
003c20 9109          ld temp0, Y+
003c21 9119          ld temp1, Y+
003c22 9595          asr tosh
003c23 9587          ror tosl
003c24 9517          ror temp1
003c25 9507          ror temp0
003c26 931a          st -Y, temp1
003c27 930a          st -Y, temp0
003c28 cbdc          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
003c29 ff02          .dw $ff02
003c2a 2b64          .db "d+"
003c2b 3c1b          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
003c2c 3c2d          .dw PFA_DPLUS
                 PFA_DPLUS:
003c2d 9129          ld temp2, Y+
003c2e 9139          ld temp3, Y+
                 
003c2f 90e9          ld temp4, Y+
003c30 90f9          ld temp5, Y+
003c31 9149          ld temp6, Y+
003c32 9159          ld temp7, Y+
                 
003c33 0f24          add temp2, temp6
003c34 1f35          adc temp3, temp7
003c35 1d8e          adc tosl, temp4
003c36 1d9f          adc tosh, temp5
                     
003c37 933a          st -Y, temp3
003c38 932a          st -Y, temp2
003c39 cbcb          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
003c3a ff02          .dw $ff02
003c3b 2d64          .db "d-"
003c3c 3c29          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
003c3d 3c3e          .dw PFA_DMINUS
                 PFA_DMINUS:
003c3e 9129          ld temp2, Y+
003c3f 9139          ld temp3, Y+
                 
003c40 90e9          ld temp4, Y+
003c41 90f9          ld temp5, Y+
003c42 9149          ld temp6, Y+
003c43 9159          ld temp7, Y+
                 
003c44 1b42          sub temp6, temp2
003c45 0b53          sbc temp7, temp3
003c46 0ae8          sbc temp4, tosl
003c47 0af9          sbc temp5, tosh
                 
003c48 935a          st -Y, temp7
003c49 934a          st -Y, temp6
003c4a 01c7          movw tosl, temp4
003c4b cbb9          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
003c4c ff07          .dw $ff07
003c4d 6964
003c4e 766e
003c4f 7265
003c50 0074          .db "dinvert",0
003c51 3c3a          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
003c52 3c53          .dw PFA_DINVERT
                 PFA_DINVERT:
003c53 9109          ld temp0, Y+
003c54 9119          ld temp1, Y+
003c55 9580          com tosl
003c56 9590          com tosh
003c57 9500          com temp0
003c58 9510          com temp1
003c59 931a          st -Y, temp1
003c5a 930a          st -Y, temp0
003c5b cba9          jmp_ DO_NEXT
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
003c5c ff04          .dw $ff04
003c5d 6d2f
003c5e 646f          .db "/mod"
003c5f 3c4c          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
003c60 3c61          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
003c61 019c          movw temp2, tosl
                     
003c62 9109          ld temp0, Y+
003c63 9119          ld temp1, Y+
                 
003c64 2f41          mov	temp6,temp1	;move dividend High to sign register
003c65 2743          eor	temp6,temp3	;xor divisor High with sign register
003c66 ff17          sbrs	temp1,7	;if MSB in dividend set
003c67 c004          rjmp	PFA_SLASHMOD_1
003c68 9510          com	temp1		;    change sign of dividend
003c69 9500          com	temp0		
003c6a 5f0f          subi	temp0,low(-1)
003c6b 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
003c6c ff37          sbrs	temp3,7	;if MSB in divisor set
003c6d c004          rjmp	PFA_SLASHMOD_2
003c6e 9530          com	temp3		;    change sign of divisor
003c6f 9520          com	temp2		
003c70 5f2f          subi	temp2,low(-1)
003c71 4f3f          sbci	temp3,high(-1)
003c72 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
003c73 18ff          sub	temp5,temp5;clear remainder High byte and carry
003c74 e151          ldi	temp7,17	;init loop counter
                 
003c75 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
003c76 1f11          rol	temp1
003c77 955a          dec	temp7		;decrement counter
003c78 f439          brne	PFA_SLASHMOD_5		;if done
003c79 ff47          sbrs	temp6,7		;    if MSB in sign register set
003c7a c004          rjmp	PFA_SLASHMOD_4
003c7b 9510          com	temp1	;        change sign of result
003c7c 9500          com	temp0
003c7d 5f0f          subi	temp0,low(-1)
003c7e 4f1f          sbci	temp1,high(-1)
003c7f c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
003c80 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
003c81 1cff          rol	temp5
003c82 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
003c83 0af3          sbc	temp5,temp3	;
003c84 f420          brcc	PFA_SLASHMOD_6		;if result negative
003c85 0ee2          add	temp4,temp2	;    restore remainder
003c86 1ef3          adc	temp5,temp3
003c87 9488          clc			;    clear carry to be shifted into result
003c88 cfec          rjmp	PFA_SLASHMOD_3		;else
003c89 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
003c8a cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
003c8b 92fa          st -Y,temp5
003c8c 92ea          st -Y,temp4
                 
                     ; put quotient on stack
003c8d 01c8          movw tosl, temp0
003c8e cb76          jmp_ DO_NEXT
                 .include "words/abs.asm"
                 
                 ;   DUP ?NEGATE ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABS:
003c8f ff03          .dw $ff03
003c90 6261
003c91 0073          .db "abs",0
003c92 3c5c          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
003c93 3801          .dw DO_COLON
                 PFA_ABS:
                 
                 .endif
                 
003c94 38b1
003c95 3a3e
003c96 3820          .DW XT_DUP,XT_QNEGATE,XT_EXIT
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
003c97 ff04          .dw $ff04
003c98 6970
003c99 6b63          .db "pick"
003c9a 3c8f          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
003c9b 3801          .dw DO_COLON
                 PFA_PICK:
                 .endif
003c9c 3a2f          .dw XT_1PLUS
003c9d 3eaf          .dw XT_CELLS
003c9e 3a8d          .dw XT_SP_FETCH
003c9f 399d          .dw XT_PLUS
003ca0 3879          .dw XT_FETCH
003ca1 3820          .dw XT_EXIT
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
003ca2 ff05          .dw $ff05
003ca3 6563
003ca4 6c6c
003ca5 002b          .db "cell+",0
003ca6 3c97          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
003ca7 3ca8          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
003ca8 9602          adiw tosl, CELLSIZE
003ca9 cb5b          jmp_ DO_NEXT
                 
                 ; now the relocatable colon words
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_DEFAULT_PROMPTOK:
003caa 3801          .dw DO_COLON
                 PFA_DEFAULT_PROMPTOK:
003cab 03d7          .dw XT_DOSLITERAL
003cac 0003          .dw 3
003cad 6f20
003cae 006b          .db " ok",0
                 .endif
003caf 040a          .dw XT_ITYPE
003cb0 3820          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTOK:
003cb1 ff03          .dw $FF03
003cb2 6f2e
../../common\words/prompt-ok.asm(43): warning: .cseg .db misalignment - padding zero byte
003cb3 006b          .db ".ok"
003cb4 3ca2          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
003cb5 3dea          .dw PFA_DODEFER1
                 PFA_PROMPTOK:
                 .endif
003cb6 001c          .dw USER_P_OK
003cb7 3db3          .dw XT_UDEFERFETCH
003cb8 3dbf          .dw XT_UDEFERSTORE
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_DEFAULT_PROMPTREADY:
003cb9 3801          .dw DO_COLON
                 PFA_DEFAULT_PROMPTREADY:
003cba 03d7          .dw XT_DOSLITERAL
003cbb 0002          .dw 2
003cbc 203e          .db "> "
                 .endif
003cbd 3f8c          .dw XT_CR
003cbe 040a          .dw XT_ITYPE
003cbf 3820          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTREADY:
003cc0 ff06          .dw $FF06
003cc1 722e
003cc2 6165
003cc3 7964          .db ".ready"
003cc4 3cb1          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTREADY
                 XT_PROMPTREADY:
003cc5 3dea          .dw PFA_DODEFER1
                 PFA_PROMPTREADY:
                 .endif
003cc6 0020          .dw USER_P_RDY
003cc7 3db3          .dw XT_UDEFERFETCH
003cc8 3dbf          .dw XT_UDEFERSTORE
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_DEFAULT_PROMPTERROR:
003cc9 3801          .dw DO_COLON
                 PFA_DEFAULT_PROMPTERROR:
003cca 03d7      	.dw XT_DOSLITERAL
003ccb 0004          .dw 4
003ccc 3f20
003ccd 203f          .db " ?? "
                 .endif
003cce 040a          .dw XT_ITYPE
003ccf 3ea8          .dw XT_BASE
003cd0 3879          .dw XT_FETCH
003cd1 38ff          .dw XT_TO_R
003cd2 3f2c          .dw XT_DECIMAL
003cd3 038c          .dw XT_DOT
003cd4 3ecd          .dw XT_TO_IN
003cd5 3879          .dw XT_FETCH
003cd6 038c          .dw XT_DOT
003cd7 38f6          .dw XT_R_FROM
003cd8 3ea8          .dw XT_BASE
003cd9 3881          .dw XT_STORE
003cda 3820          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTERROR:
003cdb ff06          .dw $FF06
003cdc 652e
003cdd 7272
003cde 726f          .db ".error"
003cdf 3cc0          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
003ce0 3dea          .dw PFA_DODEFER1
                 PFA_PROMPTERROR:
                 .endif
003ce1 001e          .dw USER_P_ERR
003ce2 3db3          .dw XT_UDEFERFETCH
003ce3 3dbf          .dw XT_UDEFERSTORE
                 .include "words/prompt-input.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_DEFAULT_PROMPTINPUT:
003ce4 3801          .dw DO_COLON
                 PFA_DEFAULT_PROMPTINPUT:
                 .endif
003ce5 3f8c          .dw XT_CR
003ce6 3820          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTINPUT:
003ce7 ff06          .dw $FF06
003ce8 692e
003ce9 706e
003cea 7475          .db ".input"
003ceb 3cdb          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTINPUT
                 XT_PROMPTINPUT:
003cec 3dea          .dw PFA_DODEFER1
                 PFA_PROMPTINPUT:
                 .endif
003ced 0022          .dw USER_P_INPUT
003cee 3db3          .dw XT_UDEFERFETCH
003cef 3dbf          .dw XT_UDEFERSTORE
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
003cf0 ff04          .dw $ff04
003cf1 7571
003cf2 7469          .db "quit"
003cf3 3ce7          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
003cf4 3801          .dw DO_COLON
                 .endif
                 PFA_QUIT:
003cf5 087f
003cf6 0886
003cf7 3881          .dw XT_LP0,XT_LP,XT_STORE
003cf8 05e9          .dw XT_SP0
003cf9 3a96          .dw XT_SP_STORE
003cfa 05f1          .dw XT_RP0
003cfb 3a80          .dw XT_RP_STORE
003cfc 0914          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
003cfd 3ea2          .dw XT_STATE
003cfe 3879          .dw XT_FETCH
003cff 3918          .dw XT_ZEROEQUAL
003d00 3836          .dw XT_DOCONDBRANCH
003d01 3d03          DEST(PFA_QUIT4)
003d02 3cc5          .dw XT_PROMPTREADY
                 PFA_QUIT4:
003d03 04f8          .dw XT_REFILL
003d04 3cec          .dw XT_PROMPTINPUT
003d05 3836          .dw XT_DOCONDBRANCH
003d06 3d16          DEST(PFA_QUIT3)
003d07 383d          .dw XT_DOLITERAL
003d08 063f          .dw XT_INTERPRET
003d09 3d5e          .dw XT_CATCH
003d0a 38b9          .dw XT_QDUP
003d0b 3836          .dw XT_DOCONDBRANCH
003d0c 3d16          DEST(PFA_QUIT3)
003d0d 38b1      	.dw XT_DUP
003d0e 383d      	.dw XT_DOLITERAL
003d0f fffe      	.dw -2
003d10 396e      	.dw XT_LESS
003d11 3836      	.dw XT_DOCONDBRANCH
003d12 3d14      	DEST(PFA_QUIT5)
003d13 3ce0      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
003d14 382f      	.dw XT_DOBRANCH
003d15 3cf5      	DEST(PFA_QUIT)
                 PFA_QUIT3:
003d16 3cb5          .dw XT_PROMPTOK
003d17 382f          .dw XT_DOBRANCH
003d18 3cfd          DEST(PFA_QUIT2)
                 ;    .dw XT_EXIT ; never reached
                 
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
003d19 ff05          .dw $ff05
003d1a 6170
003d1b 7375
003d1c 0065          .db "pause",0
003d1d 3cf0          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
003d1e 3dea          .dw PFA_DODEFER1
                 PFA_PAUSE:
003d1f 0192          .dw ram_pause
003d20 3d9f          .dw XT_RDEFERFETCH
003d21 3da9          .dw XT_RDEFERSTORE
                 
                 .dseg
000192           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
003d22 ff04          .dw $ff04
003d23 6f63
003d24 646c          .db "cold"
003d25 3d19          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
003d26 3d27          .dw PFA_COLD
                 PFA_COLD:
003d27 b6a4          in_ mcu_boot, MCUSR
003d28 2422          clr zerol
003d29 2433          clr zeroh
003d2a 24bb          clr isrflag
003d2b be24          out_ MCUSR, zerol
                     ; clear RAM
003d2c e0e0          ldi zl, low(ramstart)
003d2d e0f1          ldi zh, high(ramstart)
                 clearloop:
003d2e 9221          st Z+, zerol
003d2f 30e0          cpi zl, low(sram_size+ramstart)
003d30 f7e9          brne clearloop
003d31 30f9          cpi zh, high(sram_size+ramstart)
003d32 f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000194           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
003d33 e9e4          ldi zl, low(ram_user1)
003d34 e0f1          ldi zh, high(ram_user1)
003d35 012f          movw upl, zl
                     ; init return stack pointer
003d36 ef0f          ldi temp0,low(rstackstart)
003d37 bf0d          out_ SPL,temp0
003d38 8304          std Z+4, temp0
003d39 e018          ldi temp1,high(rstackstart)
003d3a bf1e          out_ SPH,temp1
003d3b 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
003d3c eacf          ldi yl,low(stackstart)
003d3d 83c6          std Z+6, yl
003d3e e0d8          ldi yh,high(stackstart)
003d3f 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
003d40 e4a8          ldi XL, low(PFA_WARM)
003d41 e3bd          ldi XH, high(PFA_WARM)
                     ; its a far jump...
003d42 cac2          jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WARM:
003d43 ff04          .dw $ff04
003d44 6177
003d45 6d72          .db "warm"
003d46 3d22          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
003d47 3801          .dw DO_COLON
                 PFA_WARM:
                 .endif
003d48 02a9          .dw XT_INIT_RAM
003d49 383d          .dw XT_DOLITERAL
003d4a 3fc0          .dw XT_NOOP
003d4b 383d          .dw XT_DOLITERAL
003d4c 3d1e          .dw XT_PAUSE
003d4d 3dca          .dw XT_DEFERSTORE
003d4e 0914          .dw XT_LBRACKET
003d4f 3f47          .dw XT_TURNKEY
003d50 3cf4          .dw XT_QUIT     ; never returns
                 
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
003d51 ff07          .dw $ff07
003d52 6168
003d53 646e
003d54 656c
003d55 0072          .db "handler",0
003d56 3d43          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
003d57 3858          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
003d58 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
003d59 ff05          .dw $ff05
003d5a 6163
003d5b 6374
003d5c 0068          .db "catch",0
003d5d 3d51          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
003d5e 3801          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
003d5f 3a8d          .dw XT_SP_FETCH
003d60 38ff          .dw XT_TO_R
                     ; handler @ >r
003d61 3d57          .dw XT_HANDLER
003d62 3879          .dw XT_FETCH
003d63 38ff          .dw XT_TO_R
                     ; rp@ handler !
003d64 3a76          .dw XT_RP_FETCH
003d65 3d57          .dw XT_HANDLER
003d66 3881          .dw XT_STORE
003d67 382a          .dw XT_EXECUTE
                     ; r> handler !
003d68 38f6          .dw XT_R_FROM
003d69 3d57          .dw XT_HANDLER
003d6a 3881          .dw XT_STORE
003d6b 38f6          .dw XT_R_FROM
003d6c 38d9          .dw XT_DROP
003d6d 3954          .dw XT_ZERO
003d6e 3820          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
003d6f ff05          .dw $ff05
003d70 6874
003d71 6f72
003d72 0077          .db "throw",0
003d73 3d59          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
003d74 3801          .dw DO_COLON
                 PFA_THROW:
                 .endif
003d75 38b9          .dw XT_QDUP
003d76 3836          .dw XT_DOCONDBRANCH
003d77 3d84          DEST(PFA_THROW1)
003d78 3d57            .dw XT_HANDLER
003d79 3879            .dw XT_FETCH
003d7a 3a80            .dw XT_RP_STORE
003d7b 38f6            .dw XT_R_FROM
003d7c 3d57            .dw XT_HANDLER
003d7d 3881            .dw XT_STORE
003d7e 38f6            .dw XT_R_FROM
003d7f 38c4            .dw XT_SWAP
003d80 38ff            .dw XT_TO_R
003d81 3a96            .dw XT_SP_STORE
003d82 38d9            .dw XT_DROP
003d83 38f6            .dw XT_R_FROM    
                 PFA_THROW1:
003d84 3820          .dw XT_EXIT
                 
                 
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
003d85 ff07          .dw $ff07
003d86 6445
003d87 6665
003d88 7265
003d89 0040          .db "Edefer@",0
003d8a 3d6f          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
003d8b 3801          .dw DO_COLON
                 PFA_EDEFERFETCH:
003d8c 3bc1          .dw XT_FETCHI
003d8d 3b55          .dw XT_FETCHE
003d8e 3820          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
003d8f ff07          .dw $ff07
003d90 6445
003d91 6665
003d92 7265
003d93 0021          .db "Edefer!",0
003d94 3d85          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
003d95 3801          .dw DO_COLON
                 PFA_EDEFERSTORE:
003d96 3bc1          .dw XT_FETCHI
003d97 3b31          .dw XT_STOREE
003d98 3820          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
003d99 ff07          .dw $ff07
003d9a 6452
003d9b 6665
003d9c 7265
003d9d 0040          .db "Rdefer@",0
003d9e 3d8f          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
003d9f 3801          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
003da0 3bc1          .dw XT_FETCHI
003da1 3879          .dw XT_FETCH
003da2 3820          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
003da3 ff07          .dw $ff07
003da4 6452
003da5 6665
003da6 7265
003da7 0021          .db "Rdefer!",0
003da8 3d99          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
003da9 3801          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
003daa 3bc1          .dw XT_FETCHI
003dab 3881          .dw XT_STORE
003dac 3820          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
003dad ff07          .dw $ff07
003dae 6455
003daf 6665
003db0 7265
003db1 0040          .db "Udefer@",0
003db2 3da3          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
003db3 3801          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
003db4 3bc1          .dw XT_FETCHI
003db5 3b02          .dw XT_UP_FETCH
003db6 399d          .dw XT_PLUS
003db7 3879          .dw XT_FETCH
003db8 3820          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
003db9 ff07          .dw $ff07
003dba 6455
003dbb 6665
003dbc 7265
003dbd 0021          .db "Udefer!",0
003dbe 3dad          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
003dbf 3801          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
003dc0 3bc1          .dw XT_FETCHI
003dc1 3b02          .dw XT_UP_FETCH
003dc2 399d          .dw XT_PLUS
003dc3 3881          .dw XT_STORE
003dc4 3820          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
003dc5 ff06          .dw $ff06
003dc6 6564
003dc7 6566
003dc8 2172          .db "defer!"
003dc9 3db9          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
003dca 3801          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
003dcb 3fbb          .dw XT_TO_BODY
003dcc 38b1          .dw XT_DUP
003dcd 01d8          .dw XT_ICELLPLUS
003dce 01d8          .dw XT_ICELLPLUS
003dcf 3bc1          .dw XT_FETCHI
003dd0 382a          .dw XT_EXECUTE
003dd1 3820          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
003dd2 ff06          .dw $ff06
003dd3 6564
003dd4 6566
003dd5 4072          .db "defer@"
003dd6 3dc5          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
003dd7 3801          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
003dd8 3fbb          .dw XT_TO_BODY 
003dd9 38b1          .dw XT_DUP
003dda 01d8          .dw XT_ICELLPLUS
003ddb 3bc1          .dw XT_FETCHI
003ddc 382a          .dw XT_EXECUTE
003ddd 3820          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
003dde ff07          .dw $ff07
003ddf 6428
003de0 6665
003de1 7265
003de2 0029          .db "(defer)", 0
003de3 3dd2          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
003de4 3801          .dw DO_COLON
                 PFA_DODEFER:
003de5 0751          .dw XT_DOCREATE
003de6 08bc          .dw XT_REVEAL
003de7 077f          .dw XT_COMPILE
003de8 3dea          .dw PFA_DODEFER1
003de9 3820          .dw XT_EXIT
                 PFA_DODEFER1:
003dea 940e 08d5     call_ DO_DODOES
003dec 38b1          .dw XT_DUP
003ded 01d8          .dw XT_ICELLPLUS
003dee 3bc1          .dw XT_FETCHI
003def 382a          .dw XT_EXECUTE 
003df0 382a          .dw XT_EXECUTE
003df1 3820          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
003df2 ff02          .dw $ff02
003df3 2e75          .db "u."
003df4 3dde          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
003df5 3801          .dw DO_COLON
                 PFA_UDOT:
                 .endif
003df6 3954          .dw XT_ZERO
003df7 0394          .dw XT_UDDOT
003df8 3820          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
003df9 ff03          .dw $ff03
003dfa 2e75
003dfb 0072          .db "u.r",0
003dfc 3df2          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
003dfd 3801          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
003dfe 3954          .dw XT_ZERO
003dff 38c4          .dw XT_SWAP
003e00 039d          .dw XT_UDDOTR
003e01 3820          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
003e02 ff05          .dw $ff05
003e03 2f75
003e04 6f6d
003e05 0064          .db "u/mod",0
003e06 3df9          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
003e07 3801          .dw DO_COLON
                 PFA_USLASHMOD:
003e08 38ff          .dw XT_TO_R
003e09 3954          .dw XT_ZERO
003e0a 38f6          .dw XT_R_FROM
003e0b 39c2          .dw XT_UMSLASHMOD
003e0c 3820          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
003e0d ff06          .dw $ff06
003e0e 656e
003e0f 6167
003e10 6574          .db "negate"
003e11 3e02          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
003e12 3801          .dw DO_COLON
                 PFA_NEGATE:
003e13 39fd          .dw XT_INVERT
003e14 3a2f          .dw XT_1PLUS
003e15 3820          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
003e16 ff01          .dw $ff01
003e17 002f          .db "/",0
003e18 3e0d          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
003e19 3801          .dw DO_COLON
                 PFA_SLASH:
                 .endif
003e1a 3c60          .dw XT_SLASHMOD
003e1b 38f0          .dw XT_NIP
003e1c 3820          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
003e1d ff03          .dw $ff03
003e1e 6f6d
003e1f 0064          .db "mod",0
003e20 3e16          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
003e21 3801          .dw DO_COLON
                 PFA_MOD:
                 .endif
003e22 3c60          .dw XT_SLASHMOD
003e23 38d9          .dw XT_DROP
003e24 3820          .dw XT_EXIT
                 
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
003e25 ff03          .dw $ff03
003e26 696d
003e27 006e          .db "min",0
003e28 3e1d          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
003e29 3801          .dw DO_COLON
                 PFA_MIN:
                 .endif
003e2a 3eb4          .dw XT_2DUP
003e2b 3978          .dw XT_GREATER
003e2c 3836          .dw XT_DOCONDBRANCH
003e2d 3e2f          DEST(PFA_MIN1)
003e2e 38c4          .dw XT_SWAP
                 PFA_MIN1:
003e2f 38d9          .dw XT_DROP
003e30 3820          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
003e31 ff03          .dw $ff03
003e32 616d
003e33 0078          .db "max",0
003e34 3e25          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
003e35 3801          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
003e36 3eb4          .dw XT_2DUP
003e37 396e          .dw XT_LESS
003e38 3836          .dw XT_DOCONDBRANCH
003e39 3e3b          DEST(PFA_MAX1)
003e3a 38c4          .dw XT_SWAP
                 PFA_MAX1:
003e3b 38d9          .dw XT_DROP
003e3c 3820          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
003e3d ff06          .dw $ff06
003e3e 6977
003e3f 6874
003e40 6e69          .db "within"
003e41 3e31          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
003e42 3801          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
003e43 38cf          .dw XT_OVER
003e44 3993          .dw XT_MINUS
003e45 38ff          .dw XT_TO_R
003e46 3993          .dw XT_MINUS
003e47 38f6          .dw XT_R_FROM
003e48 395c          .dw XT_ULESS
003e49 3820          .dw XT_EXIT
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
003e4a ff0d          .dw $ff0d
003e4b 6873
003e4c 776f
003e4d 772d
003e4e 726f
003e4f 6c64
003e50 7369
003e51 0074          .db "show-wordlist",0
003e52 3e3d          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
003e53 3801          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
003e54 383d          .dw XT_DOLITERAL
003e55 3e59          .dw XT_SHOWWORD
003e56 38c4          .dw XT_SWAP
003e57 06f2          .dw XT_TRAVERSEWORDLIST
003e58 3820          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
003e59 3801          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
003e5a 070d          .dw XT_NAME2STRING
003e5b 040a          .dw XT_ITYPE
003e5c 3f99          .dw XT_SPACE         ; ( -- addr n)
003e5d 394b          .dw XT_TRUE
003e5e 3820          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_WORDS:
003e5f ff05          .dw $ff05
003e60 6f77
003e61 6472
003e62 0073          .db "words",0
003e63 3e4a          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
003e64 3801          .dw DO_COLON
                 PFA_WORDS:
                 .endif
003e65 383d          .dw XT_DOLITERAL
003e66 004c          .dw CFG_ORDERLISTLEN+2
003e67 3b55          .dw XT_FETCHE
003e68 3e53          .dw XT_SHOWWORDLIST
003e69 3820          .dw XT_EXIT
                 
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
003e6a 0002          .dw $0002
003e6b 222e          .db ".",$22
003e6c 3e5f          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
003e6d 3801          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
003e6e 3e75          .dw XT_SQUOTE
003e6f 077f          .dw XT_COMPILE
003e70 040a          .dw XT_ITYPE
003e71 3820          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
003e72 0002        .dw $0002
003e73 2273        .db "s",$22
003e74 3e6a        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
003e75 3801          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
003e76 383d          .dw XT_DOLITERAL
003e77 0022          .dw 34   ; 0x22 
003e78 05a2          .dw XT_PARSE       ; ( -- addr n)
003e79 3ea2          .dw XT_STATE
003e7a 3879          .dw XT_FETCH
003e7b 3836          .dw XT_DOCONDBRANCH
003e7c 3e7e          DEST(PFA_SQUOTE1)
003e7d 07ab            .dw XT_SLITERAL
                 PFA_SQUOTE1:
003e7e 3820          .dw XT_EXIT
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
003e7f ff04          .dw $ff04
003e80 6966
003e81 6c6c          .db "fill"
003e82 3e72          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
003e83 3801          .dw DO_COLON
                 PFA_FILL:
003e84 38e1          .dw XT_ROT
003e85 38e1          .dw XT_ROT
003e86 38b9
003e87 3836          .dw XT_QDUP,XT_DOCONDBRANCH
003e88 3e90          DEST(PFA_FILL2)
003e89 3f84          .dw XT_BOUNDS
003e8a 3a9b          .dw XT_DODO
                 PFA_FILL1:
003e8b 38b1          .dw XT_DUP
003e8c 3aac          .dw XT_I
003e8d 388d          .dw XT_CSTORE  ; ( -- c c-addr)
003e8e 3ac9          .dw XT_DOLOOP
003e8f 3e8b          .dw PFA_FILL1
                 PFA_FILL2:
003e90 38d9          .dw XT_DROP
003e91 3820          .dw XT_EXIT
                 
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
003e92 ff05          .dw $ff05
003e93 5f66
003e94 7063
003e95 0075          .db "f_cpu",0
003e96 3e7f          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
003e97 3801          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
003e98 383d          .dw XT_DOLITERAL
003e99 2400          .dw (F_CPU % 65536)
003e9a 383d          .dw XT_DOLITERAL
003e9b 00f4          .dw (F_CPU / 65536)
003e9c 3820          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
003e9d ff05          .dw $ff05
003e9e 7473
003e9f 7461
003ea0 0065          .db "state",0
003ea1 3e92          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
003ea2 3848          .dw PFA_DOVARIABLE
                 PFA_STATE:
003ea3 01c2          .dw ram_state
                 
                 .dseg
0001c2           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
003ea4 ff04          .dw $ff04
003ea5 6162
003ea6 6573          .db "base"
003ea7 3e9d          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
003ea8 3858          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
003ea9 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
003eaa ff05          .dw $ff05
003eab 6563
003eac 6c6c
003ead 0073          .db "cells",0
003eae 3ea4          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
003eaf 3a0c          .dw PFA_2STAR
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
003eb0 ff04          .dw $ff04
003eb1 6432
003eb2 7075          .db "2dup"
003eb3 3eaa          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
003eb4 3801          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
003eb5 38cf          .dw XT_OVER
003eb6 38cf          .dw XT_OVER
003eb7 3820          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
003eb8 ff05          .dw $ff05
003eb9 6432
003eba 6f72
003ebb 0070          .db "2drop",0
003ebc 3eb0          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
003ebd 3801          .dw DO_COLON
                 PFA_2DROP:
                 .endif
003ebe 38d9          .dw XT_DROP
003ebf 38d9          .dw XT_DROP
003ec0 3820          .dw XT_EXIT
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
003ec1 ff04          .dw $ff04
003ec2 7574
003ec3 6b63          .db "tuck"
003ec4 3eb8          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
003ec5 3801          .dw DO_COLON
                 PFA_TUCK:
                 .endif
003ec6 38c4          .dw XT_SWAP
003ec7 38cf          .dw XT_OVER
003ec8 3820          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
003ec9 ff03          .dw $ff03
003eca 693e
003ecb 006e          .db ">in",0
003ecc 3ec1          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
003ecd 3858          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
003ece 0018          .dw USER_TO_IN
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PAD:
003ecf ff03          .dw $ff03
003ed0 6170
003ed1 0064          .db "pad",0
003ed2 3ec9          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
003ed3 3801          .dw DO_COLON
                 PFA_PAD:
                 .endif
003ed4 3f0e          .dw XT_HERE
003ed5 383d          .dw XT_DOLITERAL
003ed6 0028          .dw 40
003ed7 399d          .dw XT_PLUS
003ed8 3820          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMIT:
003ed9 ff04          .dw $ff04
003eda 6d65
003edb 7469          .db "emit"
003edc 3ecf          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
003edd 3dea          .dw PFA_DODEFER1
                 PFA_EMIT:
                 .endif
003ede 000e          .dw USER_EMIT
003edf 3db3          .dw XT_UDEFERFETCH
003ee0 3dbf          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMITQ:
003ee1 ff05          .dw $ff05
003ee2 6d65
003ee3 7469
003ee4 003f          .db "emit?",0
003ee5 3ed9          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
003ee6 3dea          .dw PFA_DODEFER1
                 PFA_EMITQ:
                 .endif
003ee7 0010          .dw USER_EMITQ
003ee8 3db3          .dw XT_UDEFERFETCH
003ee9 3dbf          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEY:
003eea ff03          .dw $ff03
003eeb 656b
003eec 0079          .db "key",0
003eed 3ee1          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
003eee 3dea          .dw PFA_DODEFER1
                 PFA_KEY:
                 .endif
003eef 0012          .dw USER_KEY
003ef0 3db3          .dw XT_UDEFERFETCH
003ef1 3dbf          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEYQ:
003ef2 ff04          .dw $ff04
003ef3 656b
003ef4 3f79          .db "key?"
003ef5 3eea          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
003ef6 3dea          .dw PFA_DODEFER1
                 PFA_KEYQ:
                 .endif
003ef7 0014          .dw USER_KEYQ
003ef8 3db3          .dw XT_UDEFERFETCH
003ef9 3dbf          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
003efa ff02          .dw $ff02
003efb 7064          .db "dp"
003efc 3ef2          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
003efd 386f          .dw PFA_DOVALUE1
                 PFA_DP:
003efe 0036          .dw CFG_DP
003eff 3d8b          .dw XT_EDEFERFETCH
003f00 3d95          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
003f01 ff05          .dw $ff05
003f02 6865
003f03 7265
003f04 0065          .db "ehere",0
003f05 3efa          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
003f06 386f          .dw PFA_DOVALUE1
                 PFA_EHERE:
003f07 003a          .dw EE_EHERE
003f08 3d8b          .dw XT_EDEFERFETCH
003f09 3d95          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
003f0a ff04          .dw $ff04
003f0b 6568
003f0c 6572          .db "here"
003f0d 3f01          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
003f0e 386f          .dw PFA_DOVALUE1
                 PFA_HERE:
003f0f 0038          .dw EE_HERE
003f10 3d8b          .dw XT_EDEFERFETCH
003f11 3d95          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
003f12 ff05          .dw $ff05
003f13 6c61
003f14 6f6c
003f15 0074          .db "allot",0
003f16 3f0a          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
003f17 3801          .dw DO_COLON
                 PFA_ALLOT:
003f18 3f0e          .dw XT_HERE
003f19 399d          .dw XT_PLUS
003f1a 01c6          .dw XT_DOTO
003f1b 3f0f          .dw PFA_HERE
003f1c 3820          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
003f1d ff03          .dw $ff03
003f1e 6962
003f1f 006e          .db "bin",0
003f20 3f12          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
003f21 3801          .dw DO_COLON
                 PFA_BIN:
                 .endif
003f22 3be2          .dw XT_TWO
003f23 3ea8          .dw XT_BASE
003f24 3881          .dw XT_STORE
003f25 3820          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
003f26 ff07          .dw $ff07
003f27 6564
003f28 6963
003f29 616d
003f2a 006c          .db "decimal",0
003f2b 3f1d          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
003f2c 3801          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
003f2d 383d          .dw XT_DOLITERAL
003f2e 000a          .dw 10
003f2f 3ea8          .dw XT_BASE
003f30 3881          .dw XT_STORE
003f31 3820          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
003f32 ff03          .dw $ff03
003f33 6568
003f34 0078          .db "hex",0
003f35 3f26          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
003f36 3801          .dw DO_COLON
                 PFA_HEX:
                 .endif
003f37 383d          .dw XT_DOLITERAL
003f38 0010          .dw 16
003f39 3ea8          .dw XT_BASE
003f3a 3881          .dw XT_STORE
003f3b 3820          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
003f3c ff02          .dw $ff02
003f3d 6c62          .db "bl"
003f3e 3f32          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
003f3f 3848          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
003f40 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
003f41 ff07          .dw $ff07
003f42 7574
003f43 6e72
003f44 656b
003f45 0079          .db "turnkey",0
003f46 3f3c          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
003f47 3dea          .dw PFA_DODEFER1
                 PFA_TURNKEY:
003f48 0042          .dw CFG_TURNKEY
003f49 3d8b          .dw XT_EDEFERFETCH
003f4a 3d95          .dw XT_EDEFERSTORE
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
003f4b ff07          .dw $ff07 
003f4c 6f74
003f4d 7075
003f4e 6570
003f4f 0072          .db "toupper",0
003f50 3f41          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
003f51 3801          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
003f52 38b1          .dw XT_DUP 
003f53 383d          .dw XT_DOLITERAL 
003f54 0061          .dw 'a' 
003f55 383d          .dw XT_DOLITERAL 
003f56 007b          .dw 'z'+1
003f57 3e42          .dw XT_WITHIN 
003f58 3836          .dw XT_DOCONDBRANCH
003f59 3f5d          DEST(PFA_TOUPPER0)
003f5a 383d          .dw XT_DOLITERAL
003f5b 00df          .dw 223 ; inverse of 0x20: 0xdf
003f5c 3a13          .dw XT_AND 
                 PFA_TOUPPER0:
003f5d 3820          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
003f5e ff07          .dw $ff07
003f5f 6f74
003f60 6f6c
003f61 6577
003f62 0072          .db "tolower",0
003f63 3f4b          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
003f64 3801          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
003f65 38b1          .dw XT_DUP
003f66 383d          .dw XT_DOLITERAL
003f67 0041          .dw 'A'
003f68 383d          .dw XT_DOLITERAL
003f69 005b          .dw 'Z'+1
003f6a 3e42          .dw XT_WITHIN
003f6b 3836          .dw XT_DOCONDBRANCH
003f6c 3f70          DEST(PFA_TOLOWER0)
003f6d 383d          .dw XT_DOLITERAL
003f6e 0020          .dw 32
003f6f 3a1c          .dw XT_OR 
                 PFA_TOLOWER0:
003f70 3820          .dw XT_EXIT 
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
003f71 ff06          .dw $ff06
003f72 733f
003f73 6174
003f74 6b63          .db "?stack"
003f75 3f5e          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
003f76 3801          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
003f77 05fc          .dw XT_DEPTH
003f78 391f          .dw XT_ZEROLESS
003f79 3836          .dw XT_DOCONDBRANCH
003f7a 3f7e          DEST(PFA_QSTACK1)
003f7b 383d            .dw XT_DOLITERAL
003f7c fffc            .dw -4
003f7d 3d74            .dw XT_THROW
                 PFA_QSTACK1:
003f7e 3820          .dw XT_EXIT
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
003f7f ff06          .dw $ff06
003f80 6f62
003f81 6e75
003f82 7364          .db "bounds"
003f83 3f71          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
003f84 3801          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
003f85 38cf          .dw XT_OVER
003f86 399d          .dw XT_PLUS
003f87 38c4          .dw XT_SWAP
003f88 3820          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
003f89 ff02          .dw 0xff02
003f8a 7263          .db "cr"
003f8b 3f7f          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
003f8c 3801          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
003f8d 383d          .dw XT_DOLITERAL
003f8e 000d          .dw 13
003f8f 3edd          .dw XT_EMIT
003f90 383d          .dw XT_DOLITERAL
003f91 000a          .dw 10
003f92 3edd          .dw XT_EMIT
003f93 3820          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
003f94 ff05          .dw $ff05
003f95 7073
003f96 6361
003f97 0065          .db "space",0
003f98 3f89          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
003f99 3801          .dw DO_COLON
                 PFA_SPACE:
                 .endif
003f9a 3f3f          .dw XT_BL
003f9b 3edd          .dw XT_EMIT
003f9c 3820          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
003f9d ff06          .dw $ff06
003f9e 7073
003f9f 6361
003fa0 7365          .db "spaces"
003fa1 3f94          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
003fa2 3801          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
003fa3 3954
003fa4 3e35      	.DW XT_ZERO, XT_MAX
003fa5 38b1
003fa6 3836      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
003fa7 3fac              DEST(SPCS2)
003fa8 3f99
003fa9 3a35
003faa 382f              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
003fab 3fa5              DEST(SPCS1)
003fac 38d9
003fad 3820      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
003fae ff03          .dw $ff03
003faf 3e73
003fb0 0064          .db "s>d",0
003fb1 3f9d          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
003fb2 3801          .dw DO_COLON
                 PFA_S2D:
                 .endif
003fb3 38b1          .dw XT_DUP
003fb4 391f          .dw XT_ZEROLESS
003fb5 3820          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
003fb6 ff05          .dw $ff05
003fb7 623e
003fb8 646f
003fb9 0079          .db ">body",0
003fba 3fae          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
003fbb 3a30          .dw PFA_1PLUS
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOOP:
003fbc ff04          .dw $ff04
003fbd 6f6e
003fbe 706f          .db "noop"
003fbf 3fb6          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
003fc0 3801          .dw DO_COLON
                 PFA_NOOP:
                 .endif
003fc1 3820         .DW XT_EXIT
                 .elif AMFORTH_NRWW_SIZE>2000
                 .else
                 .endif
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000034 ff ff     
                 ; some configs
000036 65 0b     CFG_DP:      .dw DPSTART         ; Dictionary Pointer
000038 c4 01     EE_HERE:     .dw HERESTART       ; Memory Allocation
00003a 90 00     EE_EHERE:    .dw EHERESTART      ; EEProm Memory Allocation
00003c f1 09     CFG_WLSCOPE: .dw XT_GET_CURRENT  ; default wordlist scope
00003e 5c 00     CFG_FORTHRECOGNIZER: .dw CFG_RECOGNIZERLISTLEN ; Recognizer word set
                 ; LEAVE stack is between data stack and return stack.
000040 b0 08     CFG_LP0:     .dw stackstart+1
000042 e1 0a     CFG_TURNKEY: .dw XT_APPLTURNKEY    ; TURNKEY
000044 06 03     CFG_ENVIRONMENT:.dw VE_ENVHEAD     ; environmental queries
000046 48 00     CFG_CURRENT: .dw CFG_FORTHWORDLIST ; forth-wordlist
000048 bc 3f     CFG_FORTHWORDLIST:.dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
00004a 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
00004c 48 00         .dw CFG_FORTHWORDLIST      ; get/set-order
00004e               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
00005c 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
00005e 84 06         .dw XT_REC_FIND
000060 70 06         .dw XT_REC_NUM
000062               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_STOREI:
000066 74 3b         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
000068 68 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
00006a 00 00         .dw 0  ; USER_STATE
00006c 00 00         .dw 0  ; USER_FOLLOWER
00006e ff 08         .dw rstackstart  ; USER_RP
000070 af 08         .dw stackstart   ; USER_SP0
000072 af 08         .dw stackstart   ; USER_SP
                     
000074 00 00         .dw 0  ; USER_HANDLER
000076 0a 00         .dw 10 ; USER_BASE
                     
000078 a3 00         .dw XT_TX  ; USER_EMIT
00007a b1 00         .dw XT_TXQ ; USER_EMITQ
00007c 78 00         .dw XT_RX  ; USER_KEY
00007e 93 00         .dw XT_RXQ ; USER_KEYQ
000080 7e 02         .dw XT_SOURCETIB ; USER_SOURCE
000082 00 00         .dw 0            ; USER_G_IN
000084 6b 02         .dw XT_REFILLTIB ; USER_REFILL  
000086 aa 3c         .dw XT_DEFAULT_PROMPTOK
000088 c9 3c         .dw XT_DEFAULT_PROMPTERROR
00008a b9 3c         .dw XT_DEFAULT_PROMPTREADY
00008c e4 3c         .dw XT_DEFAULT_PROMPTINPUT
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
00008e 19 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega328P" register use summary:
r0 :  25 r1 :   5 r2 :  11 r3 :  12 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   7 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  89 r17:  61 r18:  61 r19:  37 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 212 r25: 144 r26:  28 r27:  17 r28:   7 r29:   4 r30:  90 r31:  49 
x  :   4 y  : 215 z  :  50 
Registers used: 29 out of 35 (82.9%)

"ATmega328P" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  22 add   :  17 adiw  :  17 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   3 brcs  :   1 break :   0 breq  :   7 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  22 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   7 cbr   :   1 
clc   :   2 clh   :   0 cli   :   7 cln   :   0 clr   :  14 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  14 cp    :  11 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :  10 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  25 inc   :   3 jmp   :  18 
ld    : 143 ldd   :   4 ldi   :  41 lds   :   1 lpm   :  16 lsl   :  14 
lsr   :   2 mov   :  16 movw  :  73 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   2 out   :  22 pop   :  49 
push  :  43 rcall :  39 ret   :   7 reti  :   1 rjmp  : 102 rol   :  23 
ror   :   6 sbc   :   9 sbci  :   3 sbi   :   8 sbic  :   3 sbis  :   0 
sbiw  :  16 sbr   :   0 sbrc  :   5 sbrs  :   7 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   4 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  81 std   :   8 sts   :   1 
sub   :   6 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 73 out of 113 (64.6%)

"ATmega328P" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x007f84   2096  11630  13726   32768  41.9%
[.dseg] 0x000100 0x0001c4      0    196    196    2048   9.6%
[.eseg] 0x000000 0x000090      0    144    144    1024  14.1%

Assembly complete, 0 errors, 8 warnings
