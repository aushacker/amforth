
AVRASM ver. 2.1.52  p16-8.asm Sun Oct 18 18:22:43 2020

p16-8.asm(5): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega16\device.asm'
../../avr8/devices/atmega16\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m16def.inc'
p16-8.asm(14): Including file '../../avr8\drivers/usart.asm'
../../avr8\drivers/usart.asm(30): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(11): Including file '../../avr8\drivers/usart-rx-buffer.asm'
../../avr8\drivers/usart_common.asm(24): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(29): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(30): Including file '../../avr8\words/usart.asm'
p16-8.asm(19): Including file '../../avr8\drivers/1wire.asm'
p16-8.asm(21): Including file '../../avr8\amforth.asm'
../../avr8\amforth.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth.asm(14): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(7): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/rww.inc(14): Including file '../../avr8\dict/appl_2k.inc'
../../avr8\dict/appl_2k.inc(1): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/appl_2k.inc(2): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/appl_2k.inc(3): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/appl_2k.inc(4): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/appl_2k.inc(5): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/appl_2k.inc(6): Including file '../../common\words/u-dot.asm'
../../avr8\dict/appl_2k.inc(7): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/appl_2k.inc(9): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/appl_2k.inc(10): Including file '../../common\words/words.asm'
../../avr8\dict/appl_2k.inc(11): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/irqcnt.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-num.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(10): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(11): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(12): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(13): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(15): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(16): Including file '../../avr8\words/isr-end.asm'
../../avr8\dict/appl_2k.inc(13): Including file '../../common\words/pick.asm'
../../avr8\dict/appl_2k.inc(14): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/appl_2k.inc(15): Including file '../../common\words/squote.asm'
../../avr8\dict/appl_2k.inc(17): Including file '../../avr8\words/fill.asm'
../../avr8\dict/appl_2k.inc(18): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/newest.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/do-create.asm'
../../avr8\dict/compiler1.inc(5): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(9): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(10): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(17): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(33): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(38): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../common\words/create.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../common\words/reveal.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(53): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../common\words/recurse.asm'
../../avr8\dict/compiler1.inc(56): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(61): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(67): Including file '../../common\words/cfg-order.asm'
../../avr8\dict/compiler1.inc(68): Including file '../../common\words/cfg-recognizer.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(70): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\dict/appl_2k.inc(20): Including file '../../avr8\words/environment.asm'
../../avr8\dict/appl_2k.inc(21): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/appl_2k.inc(22): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/appl_2k.inc(23): Including file '../../common\words/env-slashhold.asm'
../../avr8\dict/appl_2k.inc(24): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/appl_2k.inc(25): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/appl_2k.inc(26): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/appl_2k.inc(27): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/appl_2k.inc(28): Including file '../../common\words/env-usersize.asm'
../../avr8\dict/appl_2k.inc(30): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/appl_2k.inc(31): Including file '../../avr8\words/state.asm'
../../avr8\dict/appl_2k.inc(32): Including file '../../common\words/base.asm'
../../avr8\dict/appl_2k.inc(34): Including file '../../avr8\words/cells.asm'
../../avr8\dict/appl_2k.inc(35): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/appl_2k.inc(37): Including file '../../common\words/2dup.asm'
../../avr8\dict/appl_2k.inc(38): Including file '../../common\words/2drop.asm'
../../avr8\dict/appl_2k.inc(40): Including file '../../common\words/tuck.asm'
../../avr8\dict/appl_2k.inc(42): Including file '../../common\words/to-in.asm'
../../avr8\dict/appl_2k.inc(43): Including file '../../common\words/pad.asm'
../../avr8\dict/appl_2k.inc(44): Including file '../../common\words/emit.asm'
../../avr8\dict/appl_2k.inc(45): Including file '../../common\words/emitq.asm'
../../avr8\dict/appl_2k.inc(46): Including file '../../common\words/key.asm'
../../avr8\dict/appl_2k.inc(47): Including file '../../common\words/keyq.asm'
../../avr8\dict/appl_2k.inc(49): Including file '../../avr8\words/dp.asm'
../../avr8\dict/appl_2k.inc(50): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/appl_2k.inc(51): Including file '../../avr8\words/here.asm'
../../avr8\dict/appl_2k.inc(52): Including file '../../avr8\words/allot.asm'
../../avr8\dict/appl_2k.inc(54): Including file '../../common\words/bin.asm'
../../avr8\dict/appl_2k.inc(55): Including file '../../common\words/decimal.asm'
../../avr8\dict/appl_2k.inc(56): Including file '../../common\words/hex.asm'
../../avr8\dict/appl_2k.inc(57): Including file '../../common\words/bl.asm'
../../avr8\dict/appl_2k.inc(59): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/appl_2k.inc(61): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/appl_2k.inc(62): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/appl_2k.inc(63): Including file '../../avr8\words/negate.asm'
../../avr8\dict/appl_2k.inc(64): Including file '../../common\words/slash.asm'
../../avr8\dict/appl_2k.inc(65): Including file '../../common\words/mod.asm'
../../avr8\dict/appl_2k.inc(66): Including file '../../common\words/abs.asm'
../../avr8\dict/appl_2k.inc(67): Including file '../../common\words/min.asm'
../../avr8\dict/appl_2k.inc(68): Including file '../../common\words/max.asm'
../../avr8\dict/appl_2k.inc(69): Including file '../../common\words/within.asm'
../../avr8\dict/appl_2k.inc(71): Including file '../../common\words/to-upper.asm'
../../avr8\dict/appl_2k.inc(72): Including file '../../common\words/to-lower.asm'
../../avr8\dict/appl_2k.inc(74): Including file '../../avr8\words/hld.asm'
../../avr8\dict/appl_2k.inc(75): Including file '../../common\words/hold.asm'
../../avr8\dict/appl_2k.inc(76): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/appl_2k.inc(77): Including file '../../common\words/sharp.asm'
../../avr8\dict/appl_2k.inc(78): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/appl_2k.inc(79): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/appl_2k.inc(80): Including file '../../common\words/sign.asm'
../../avr8\dict/appl_2k.inc(81): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/appl_2k.inc(82): Including file '../../common\words/dot-r.asm'
../../avr8\dict/appl_2k.inc(83): Including file '../../common\words/d-dot.asm'
../../avr8\dict/appl_2k.inc(84): Including file '../../common\words/dot.asm'
../../avr8\dict/appl_2k.inc(85): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/appl_2k.inc(86): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/appl_2k.inc(87): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/appl_2k.inc(88): Including file '../../common\words/digit-q.asm'
../../avr8\dict/appl_2k.inc(90): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/appl_2k.inc(91): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/appl_2k.inc(92): Including file '../../avr8\words/itype.asm'
../../avr8\dict/appl_2k.inc(93): Including file '../../avr8\words/icount.asm'
../../avr8\dict/appl_2k.inc(94): Including file '../../common\words/cr.asm'
../../avr8\dict/appl_2k.inc(95): Including file '../../common\words/space.asm'
../../avr8\dict/appl_2k.inc(96): Including file '../../common\words/spaces.asm'
../../avr8\dict/appl_2k.inc(97): Including file '../../common\words/type.asm'
../../avr8\dict/appl_2k.inc(98): Including file '../../common\words/tick.asm'
../../avr8\dict/appl_2k.inc(100): Including file '../../common\words/handler.asm'
../../avr8\dict/appl_2k.inc(101): Including file '../../common\words/catch.asm'
../../avr8\dict/appl_2k.inc(102): Including file '../../common\words/throw.asm'
../../avr8\dict/appl_2k.inc(104): Including file '../../common\words/cskip.asm'
../../avr8\dict/appl_2k.inc(105): Including file '../../common\words/cscan.asm'
../../avr8\dict/appl_2k.inc(106): Including file '../../common\words/accept.asm'
../../avr8\dict/appl_2k.inc(107): Including file '../../common\words/refill.asm'
../../avr8\dict/appl_2k.inc(108): Including file '../../common\words/char.asm'
../../avr8\dict/appl_2k.inc(109): Including file '../../common\words/number.asm'
../../avr8\dict/appl_2k.inc(110): Including file '../../common\words/q-sign.asm'
../../avr8\dict/appl_2k.inc(111): Including file '../../common\words/set-base.asm'
../../avr8\dict/appl_2k.inc(112): Including file '../../common\words/to-number.asm'
../../avr8\dict/appl_2k.inc(113): Including file '../../common\words/parse.asm'
../../avr8\dict/appl_2k.inc(114): Including file '../../common\words/source.asm'
../../avr8\dict/appl_2k.inc(115): Including file '../../common\words/slash-string.asm'
../../avr8\dict/appl_2k.inc(116): Including file '../../common\words/parse-name.asm'
../../avr8\dict/appl_2k.inc(117): Including file '../../common\words/find-xt.asm'
../../avr8\dict/appl_2k.inc(119): Including file '../../common\words/quit.asm'
../../avr8\dict/appl_2k.inc(120): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/appl_2k.inc(121): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/appl_2k.inc(122): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/appl_2k.inc(123): Including file '../../common\words/prompt-input.asm'
../../avr8\dict/appl_2k.inc(124): Including file '../../avr8\words/pause.asm'
../../avr8\dict/appl_2k.inc(125): Including file '../../avr8\words/cold.asm'
../../avr8\dict/appl_2k.inc(126): Including file '../../common\words/warm.asm'
../../avr8\dict/appl_2k.inc(128): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/appl_2k.inc(129): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/appl_2k.inc(130): Including file '../../common\words/depth.asm'
../../avr8\dict/appl_2k.inc(131): Including file '../../common\words/recognize.asm'
../../avr8\dict/appl_2k.inc(132): Including file '../../avr8\words/forth-recognizer.asm'
../../avr8\dict/appl_2k.inc(133): Including file '../../common\words/interpret.asm'
../../avr8\dict/appl_2k.inc(134): Including file '../../common\words/rec-intnum.asm'
../../avr8\dict/appl_2k.inc(135): Including file '../../common\words/rec-find.asm'
../../avr8\dict/appl_2k.inc(136): Including file '../../common\words/rec-null.asm'
../../avr8\dict/appl_2k.inc(138): Including file '../../common\words/q-stack.asm'
../../avr8\dict/appl_2k.inc(139): Including file '../../common\words/ver.asm'
../../avr8\dict/appl_2k.inc(141): Including file '../../common\words/noop.asm'
../../avr8\dict/appl_2k.inc(142): Including file '../../avr8\words/unused.asm'
../../avr8\dict/appl_2k.inc(144): Including file '../../common\words/to.asm'
../../avr8\dict/appl_2k.inc(145): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/appl_2k.inc(147): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/appl_2k.inc(148): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/appl_2k.inc(149): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/appl_2k.inc(150): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/appl_2k.inc(151): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/appl_2k.inc(152): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/appl_2k.inc(153): Including file '../../common\words/defer-store.asm'
../../avr8\dict/appl_2k.inc(154): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/appl_2k.inc(155): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/appl_2k.inc(157): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/appl_2k.inc(158): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/appl_2k.inc(159): Including file '../../common\words/name2string.asm'
../../avr8\dict/appl_2k.inc(160): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/appl_2k.inc(161): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/appl_2k.inc(163): Including file '../../common\words/star.asm'
../../avr8\dict/appl_2k.inc(164): Including file '../../avr8\words/j.asm'
../../avr8\dict/appl_2k.inc(166): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/appl_2k.inc(167): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/appl_2k.inc(168): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/appl_2k.inc(169): Including file '../../common\words/2swap.asm'
../../avr8\dict/appl_2k.inc(171): Including file '../../common\words/tib.asm'
../../avr8\dict/appl_2k.inc(173): Including file '../../avr8\words/init-ram.asm'
../../avr8\dict/appl_2k.inc(174): Including file '../../common\words/bounds.asm'
../../avr8\dict/appl_2k.inc(175): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/appl_2k.inc(176): Including file '../../avr8\words/to-body.asm'
../../avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(3): Including file '../../common\words/dot-s.asm'
dict_appl.inc(4): Including file '../../avr8\words/spirw.asm'
dict_appl.inc(5): Including file '../../avr8\words/n-spi.asm'
dict_appl.inc(6): Including file 'words/applturnkey.asm'
dict_appl.inc(7): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../common\words/postpone.asm'
dict_appl.inc(8): Including file '../../avr8\words/2r_fetch.asm'
../../avr8\amforth.asm(23): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth.asm(24): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(35): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(36): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(42): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(45): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(46): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(49): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(56): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(63): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../common\words/q-negate.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(89): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(95): Including file '../../avr8\words/store-i_nrww.asm'
../../avr8\dict/nrww.inc(97): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(98): Including file '../../common\words/2literal.asm'
../../avr8\dict/nrww.inc(99): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(100): Including file '../../common\words/num-constants.asm'
../../avr8\dict/nrww.inc(107): Including file '../../avr8\dict/core_2k.inc'
../../avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
../../avr8\amforth.asm(36): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; file see ../template/template.asm. You may want to
                 ; copy that file to this one and edit it afterwards.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set USER_P_OK    = 28
                 .set USER_P_ERR   = 30
                 .set USER_P_RDY   = 32
                 .set USER_P_INPUT = 34
                 
                 .set SYSUSERSIZE = 36
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot = r10
                   .def isrflag  = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  96
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_EEPROM = 0
                 .set WANT_CPU = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_SPI = 0
                 .set WANT_USART = 0
                 .set WANT_TWI = 0
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_JTAG = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_WATCHDOG = 0
                 .equ intvecsize = 2 ; please verify; flash size: 16384 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d11b      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d119      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d117      	 rcall isr ; Timer/Counter2 Compare Match
                 .org 8
000008 d115      	 rcall isr ; Timer/Counter2 Overflow
                 .org 10
00000a d113      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 12
00000c d111      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 14
00000e d10f      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 16
000010 d10d      	 rcall isr ; Timer/Counter1 Overflow
                 .org 18
000012 d10b      	 rcall isr ; Timer/Counter0 Overflow
                 .org 20
000014 d109      	 rcall isr ; Serial Transfer Complete
                 .org 22
000016 d107      	 rcall isr ; USART, Rx Complete
                 .org 24
000018 d105      	 rcall isr ; USART Data Register Empty
                 .org 26
00001a d103      	 rcall isr ; USART, Tx Complete
                 .org 28
00001c d101      	 rcall isr ; ADC Conversion Complete
                 .org 30
00001e d0ff      	 rcall isr ; EEPROM Ready
                 .org 32
000020 d0fd      	 rcall isr ; Analog Comparator
                 .org 34
000022 d0fb      	 rcall isr ; 2-wire Serial Interface
                 .org 36
000024 d0f9      	 rcall isr ; External Interrupt Request 2
                 .org 38
000026 d0f7      	 rcall isr ; Timer/Counter0 Compare Match
                 .org 40
000028 d0f5      	 rcall isr ; Store Program Memory Ready
                 .equ INTVECTORS = 21
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 .equ EEPE = EEWE
                 .equ EEMPE = EEMWE
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000029 0400      	.dw 1024
                 mcu_eepromsize:
00002a 0200      	.dw 512
                 mcu_maxdp:
00002b 3800      	.dw 14336 
                 mcu_numints:
00002c 0015      	.dw 21
                 mcu_name:
00002d 0008      	.dw  8
00002e 5441
00002f 656d
000030 6167
000031 3631      	.db "ATmega16"
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 ; enabling Interrupts, disabling them affects
                 ; other settings as well. 
                 .set WANT_INTERRUPTS = 1
                 
                 ; count the number of interrupts individually.
                 ; requires a lot of RAM (one byte per interrupt)
                 ; disabled by default.
                 .set WANT_INTERRUPT_COUNTERS = 1
                 
                 ; receiving is asynchronously, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIB_SIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 .set AMFORTH_RO_SEG = NRWW_START_ADDR+1
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 8000000
                 .set BAUD_MAXERROR = 30
                 .equ TIMER_INT = OVF2addr
                 
                 .include "drivers/usart.asm"
                 
                 .equ BAUDRATE_LOW = UBRRL+$20
                 .equ BAUDRATE_HIGH = UBRRH+$20
                 .equ USART_C = UCSRC+$20
                 .equ USART_B = UCSRB+$20
                 .equ USART_A = UCSRA+$20
                 .equ USART_DATA = UDR+$20
                 .equ bm_USARTC_en   = 1 << 7
                 
                 ; some generic constants
                 .equ bm_USART_RXRD = 1 << RXC
                 .equ bm_USART_TXRD = 1 << UDRE
                 .equ bm_ENABLE_TX  = 1 << TXEN
                 .equ bm_ENABLE_RX  = 1 << RXEN
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE
                 .equ bm_ENABLE_INT_TX = 1<<UDRE
                 
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_INTERRUPTS == 0
                   .if WANT_ISR_RX == 1
                   .endif
                 .endif
                 
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-rx-buffer.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000060            usart_rx_data: .byte usart_rx_size
000070            usart_rx_in:   .byte 1
000071            usart_rx_out:  .byte 1
                 .cseg
                 
                 VE_TO_RXBUF:
000032 ff07          .dw $ff07
000033 723e
000034 2d78
000035 7562
000036 0066          .db ">rx-buf",0
000037 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_RXBUF
                 XT_TO_RXBUF:
000038 0039          .dw PFA_rx_tobuf
                 PFA_rx_tobuf:
000039 2f08          mov temp0, tosl
00003a 9110 0070     lds temp1, usart_rx_in
00003c e6e0          ldi zl, low(usart_rx_data)
00003d e0f0          ldi zh, high(usart_rx_data)
00003e 0fe1          add zl, temp1
00003f 1df3          adc zh, zeroh
000040 8300          st Z, temp0
000041 9513          inc temp1
000042 701f          andi temp1,usart_rx_mask
000043 9310 0070     sts usart_rx_in, temp1
000045 9189
000046 9199          loadtos
000047 940c 1c05     jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; setup with
                 ; ' isr-rx URXCaddr int!
                 VE_ISR_RX:
000049 ff06          .dw $ff06
00004a 7369
00004b 2d72
00004c 7872          .db "isr-rx"
00004d 0032          .dw VE_HEAD
                     .set VE_HEAD = VE_ISR_RX
                 XT_ISR_RX:
00004e 1c01          .dw DO_COLON
                 usart_rx_isr:
00004f 1c3d        .dw XT_DOLITERAL
000050 002c        .dw usart_data
000051 1c98        .dw XT_CFETCH
000052 1cb1        .dw XT_DUP
000053 1c3d        .dw XT_DOLITERAL
000054 0003        .dw 3
000055 1fd6        .dw XT_EQUAL
000056 1c36        .dw XT_DOCONDBRANCH
000057 0059        .dw usart_rx_isr1
000058 0b1b        .dw XT_COLD
                 usart_rx_isr1:
000059 0038        .dw XT_TO_RXBUF
00005a 1c20        .dw XT_EXIT
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RXBUFFER:
                 ;  .dw $ff0x
                 ;  .db "+usart-buffer"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RXBUFFER
                 XT_USART_INIT_RX_BUFFER:
00005b 1c01        .dw DO_COLON
                 PFA_USART_INIT_RX_BUFFER:          ; ( -- )
00005c 1c3d
00005d 004e        .dw XT_DOLITERAL, XT_ISR_RX
00005e 1c3d
00005f 0016        .dw XT_DOLITERAL, URXCaddr
000060 0230        .dw XT_INTSTORE
                 
000061 1c3d        .dw XT_DOLITERAL
000062 0060        .dw usart_rx_data
000063 1c3d        .dw XT_DOLITERAL
000064 0016        .dw usart_rx_size + 6
000065 1d54        .dw XT_ZERO
000066 027a        .dw XT_FILL
000067 1c20        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_BUFFER:
000068 ff06          .dw $ff06
000069 7872
00006a 622d
00006b 6675          .db "rx-buf"
00006c 0049          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_BUFFER
                 XT_RX_BUFFER:
00006d 1c01          .dw DO_COLON
                 PFA_RX_BUFFER:
00006e 0088        .dw XT_RXQ_BUFFER
00006f 1c36        .dw XT_DOCONDBRANCH
000070 006e        .dw PFA_RX_BUFFER
000071 1c3d        .dw XT_DOLITERAL
000072 0071        .dw usart_rx_out
000073 1c98        .dw XT_CFETCH
000074 1cb1        .dw XT_DUP
000075 1c3d        .dw XT_DOLITERAL
000076 0060        .dw usart_rx_data
000077 1d9d        .dw XT_PLUS
000078 1c98        .dw XT_CFETCH
000079 1cc4        .dw XT_SWAP
00007a 1e2f        .dw XT_1PLUS
00007b 1c3d        .dw XT_DOLITERAL
00007c 000f        .dw usart_rx_mask
00007d 1e13        .dw XT_AND
00007e 1c3d        .dw XT_DOLITERAL
00007f 0071        .dw usart_rx_out
000080 1c8d        .dw XT_CSTORE
000081 1c20        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue
                 VE_RXQ_BUFFER:
000082 ff07          .dw $ff07
000083 7872
000084 2d3f
000085 7562
000086 0066          .db "rx?-buf",0
000087 0068          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_BUFFER
                 XT_RXQ_BUFFER:
000088 1c01          .dw DO_COLON
                 PFA_RXQ_BUFFER:
000089 0b13        .dw XT_PAUSE
00008a 1c3d        .dw XT_DOLITERAL
00008b 0071        .dw usart_rx_out
00008c 1c98        .dw XT_CFETCH
00008d 1c3d        .dw XT_DOLITERAL
00008e 0070        .dw usart_rx_in
00008f 1c98        .dw XT_CFETCH
000090 1d11        .dw XT_NOTEQUAL
000091 1c20        .dw XT_EXIT
                 ;  .include "drivers/timer-usart-isr.asm"
                   .set XT_RX  = XT_RX_BUFFER
                   .set XT_RXQ = XT_RXQ_BUFFER
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_BUFFER
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
000092 ff07          .dw $ff07
000093 7874
000094 702d
000095 6c6f
000096 006c          .db "tx-poll",0
000097 0082          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
000098 1c01          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
000099 00a6        .dw XT_TXQ_POLL
00009a 1c36        .dw XT_DOCONDBRANCH
00009b 0099        .dw PFA_TX_POLL
                   ; send to usart
00009c 1c3d        .dw XT_DOLITERAL
00009d 002c        .dw USART_DATA
00009e 1c8d        .dw XT_CSTORE
00009f 1c20        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
0000a0 ff08          .dw $ff08
0000a1 7874
0000a2 2d3f
0000a3 6f70
0000a4 6c6c          .db "tx?-poll"
0000a5 0092          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000a6 1c01          .dw DO_COLON
                 PFA_TXQ_POLL:
0000a7 0b13        .dw XT_PAUSE
0000a8 1c3d        .dw XT_DOLITERAL
0000a9 002b        .dw USART_A
0000aa 1c98        .dw XT_CFETCH
0000ab 1c3d        .dw XT_DOLITERAL
0000ac 0020        .dw bm_USART_TXRD
0000ad 1e13        .dw XT_AND
0000ae 1c20        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000af ff04        .dw $ff04
0000b0 6275
0000b1 7272        .db "ubrr"
0000b2 00a0        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000b3 1c6f        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000b4 0084        .dw EE_UBRRVAL
0000b5 0c7a        .dw XT_EDEFERFETCH
0000b6 0c84        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000b7 ff06        .dw $ff06
0000b8 752b
0000b9 6173
0000ba 7472        .db "+usart"
0000bb 00af        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000bc 1c01        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000bd 1c3d        .dw XT_DOLITERAL
0000be 0098        .dw USART_B_VALUE
0000bf 1c3d        .dw XT_DOLITERAL
0000c0 002a        .dw USART_B
0000c1 1c8d        .dw XT_CSTORE
                 
0000c2 1c3d        .dw XT_DOLITERAL
0000c3 0006        .dw USART_C_VALUE
0000c4 1c3d        .dw XT_DOLITERAL
0000c5 00c0        .dw USART_C | bm_USARTC_en
0000c6 1c8d        .dw XT_CSTORE
                 
0000c7 00b3        .dw XT_UBRR
0000c8 1cb1        .dw XT_DUP
0000c9 1ef9        .dw XT_BYTESWAP
0000ca 1c3d        .dw XT_DOLITERAL
0000cb 0040        .dw BAUDRATE_HIGH
0000cc 1c8d        .dw XT_CSTORE
0000cd 1c3d        .dw XT_DOLITERAL
0000ce 0029        .dw BAUDRATE_LOW
0000cf 1c8d        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
0000d0 005b        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
0000d1 1c20        .dw XT_EXIT
                 
                 ; settings for 1wire interface
                 .equ OW_PORT=PORTB
                 .EQU OW_BIT=4
                 .include "drivers/1wire.asm"
                 
                 ;   B. J. Rodriguez (MSP 430)
                 ;   Matthias Trute (AVR Atmega)
                 ; COPYRIGHT
                 ;   (c) 2012 Bradford J. Rodriguez for the 430 code and API
                 
                 ;  adapted 430 assembly code to AVR
                 ;  wishlist: 
                 ;     use a configurable pin at runtime, compatible with bitnames.frt
                 ;     no external pull up, no external power supply for devices
                 ;     ???
                 ;
                 ;.EQU OW_BIT=4
                 ;.equ OW_PORT=PORTE
                 .set OW_DDR=(OW_PORT-1)
                 .set OW_PIN=(OW_DDR-1)
                 
                 ;****f* 1W.RESET
                 ; NAME
                 ;   1W.RESET
                 ; SYNOPSIS
                 ;   1W.RESET ( -- f )  Initialize 1-wire devices; return true if present
                 ; DESCRIPTION
                 ;   This configures the port pin used by the 1-wire interface, and then
                 ;   sends an "initialize" sequence to the 1-wire devices.  If any device
                 ;   is present, it will be detected.
                 ;
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" (drive output low) for >480 usec.
                 ;   b) Output "1" (let output float).
                 ;   c) After 15 to 60 usec, device will drive pin low for 60 to 240 usec.
                 ;      So, wait 75 usec and sample input.
                 ;   d) Leave output high (floating) for at least 480 usec.
                 ;******
                 ; ( -- f )
                 ; Hardware
                 ; Initialize 1-wire devices; return true if present
                 VE_OW_RESET:
0000d2 ff08          .dw $ff08
0000d3 7731
0000d4 722e
0000d5 7365
0000d6 7465          .db "1w.reset"
0000d7 00b7          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_RESET
                 XT_OW_RESET:
0000d8 00d9          .dw PFA_OW_RESET
                 PFA_OW_RESET:
0000d9 939a
0000da 938a          savetos
                     ; setup to output
0000db 9abc          sbi OW_DDR, OW_BIT
                     ; Pull output low
0000dc 98c4          cbi OW_PORT, OW_BIT
                     ; Delay >480 usec        
0000dd ece0
0000de e0f3
0000df 9731
0000e0 f7f1          DELAY   480
                     ; Critical timing period, disable interrupts.
0000e1 b71f          in temp1, SREG
0000e2 94f8          cli
                     ; Pull output high
0000e3 9ac4          sbi OW_PORT, OW_BIT
                     ; make pin input, sends "1"
0000e4 98bc          cbi OW_DDR, OW_BIT 
0000e5 e8e0
0000e6 e0f0
0000e7 9731
0000e8 f7f1          DELAY   64 ; delayB
                     ; Sample input pin, set TOS if input is zero
0000e9 b386          in tosl, OW_PIN
0000ea ff84          sbrs tosl, OW_BIT
0000eb ef9f          ser  tosh
                     ; End critical timing period, enable interrupts
0000ec bf1f          out SREG, temp1
                     ; release bus
0000ed 98bc          cbi OW_DDR, OW_BIT
0000ee 98c4          cbi OW_PORT, OW_BIT
                 
                     ; Delay rest of 480 usec 
0000ef e4e0
0000f0 e0f3
0000f1 9731
0000f2 f7f1          DELAY   416
                     ; we now have the result flag in TOS        
0000f3 2f89          mov tosl, tosh
0000f4 940c 1c05     jmp_ DO_NEXT
                     
                 ;****f* 1W.SLOT
                 ; NAME
                 ;   1W.SLOT
                 ; SYNOPSIS
                 ;   1W.SLOT ( c -- c' ) Write and read one bit to/from 1-wire.
                 ; DESCRIPTION
                 ;   The "touch byte" function is described in Dallas App Note 74.
                 ;   It outputs a byte to the 1-wire pin, LSB first, and reads back
                 ;   the state of the 1-wire pin after a suitable delay.
                 ;   To read a byte, output $FF and read the reply data.
                 ;   To write a byte, output that byte and discard the reply.
                 ;
                 ;   This function performs one bit of the "touch" operation --
                 ;   one read/write "slot" in Dallas jargon.  Perform this eight
                 ;   times in a row to get the "touch byte" function.
                 ;
                 ; PARAMETERS
                 ;   The input parameter is xxxxxxxxbbbbbbbo where
                 ;   'xxxxxxxx' are don't cares,
                 ;   'bbbbbbb' are bits to be shifted down, and
                 ;   'o' is the bit to be output in the slot.  This must be 1
                 ;   to create a read slot.
                 ;
                 ;   The returned value is xxxxxxxxibbbbbbb where
                 ;   'xxxxxxxx' are not known (the input shifted down 1 position),
                 ;   'i' is the bit read during the slot.  This has no meaning
                 ;   if it was a write slot.
                 ;   'bbbbbbb' are the 7 input bits, shifted down one position.
                 ;
                 ;   This peculiar parameter usage allows OWTOUCH to be written as
                 ;     OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT 
                 ;
                 ; NOTES 
                 ;   Interrupts are disabled during each bit.
                 
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" for start period.  (> 1 us, < 15 us, typ. 6 us*)
                 ;   b) Output data bit (0 or 1), open drain 
                 ;   c) After MS from start of cycle, sample input (15 to 60 us, typ. 25 us*)
                 ;   d) After write-0 period from start of cycle, output "1" (>60 us)
                 ;   e) After recovery period, loop or return. (> 1 us)
                 ;   For writes, DS18B20 samples input 15 to 60 usec from start of cycle.
                 ;   * "Typical" values are per App Note 132 for a 300m cable length.
                 
                 ;   ---------        -------------------------------
                 ;            \      /                        /
                 ;             ------------------------------- 
                 ;            a      b          c             d     e
                 ;            |  6us |   19us   |    35us     | 2us |
                 ;******
                 ; ( c -- c' )
                 ; Hardware
                 ; Write and read one bit to/from 1-wire.
                 VE_OW_SLOT:
0000f6 ff07          .dw $ff07
0000f7 7731
0000f8 732e
0000f9 6f6c
0000fa 0074          .db "1w.slot",0
0000fb 00d2          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_SLOT
                 XT_OW_SLOT:
0000fc 00fd          .dw PFA_OW_SLOT
                 PFA_OW_SLOT:
                     ; pull low
0000fd 98c4          cbi OW_PORT, OW_BIT
0000fe 9abc          sbi OW_DDR, OW_BIT
                     ; disable interrupts
0000ff b71f          in temp1, SREG
000100 94f8          cli
000101 e0ec
000102 e0f0
000103 9731
000104 f7f1          DELAY   6 ; DELAY A
                     ; check bit
000105 9488          clc
000106 9587          ror tosl
000107 f410          brcc PFA_OW_SLOT0 ; a 0 keeps the bus low
                       ; release bus, a 1 is written
000108 9ac4            sbi OW_PORT, OW_BIT
000109 98bc            cbi OW_DDR, OW_BIT
                 PFA_OW_SLOT0:
                     ; sample the input (no action required if zero)
00010a e1e2
00010b e0f0
00010c 9731
00010d f7f1          DELAY 9   ; wait DELAY E to sample
00010e b306          in temp0, OW_PIN
00010f fd04          sbrc temp0, OW_BIT
000110 6880          ori tosl, $80
                 
000111 e6e6
000112 e0f0
000113 9731
000114 f7f1          DELAY   51 ; DELAY B
000115 9ac4          sbi OW_PORT, OW_BIT ; release bus
000116 98bc          cbi OW_DDR, OW_BIT
000117 e0e4
000118 e0f0
000119 9731
00011a f7f1          delay 2
                     ; re-enable interrupts
00011b bf1f          out SREG, temp1
00011c 940c 1c05     jmp_ DO_NEXT
                 
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 
                 .set corepc = pc
                 .org $0000
000000 940c 0b1c   jmp_ PFA_COLD
                 
                 .org corepc
                 .include "drivers/generic-isr.asm"
                 
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .if WANT_INTERRUPT_COUNTERS==1
                 .dseg
000072           intcnt: .byte INTVECTORS
                 .endif
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
00011e 920a          st -Y, r0
00011f b60f          in r0, SREG
000120 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
000121 900f          pop r0
000122 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
000123 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
                     ; check whether isrflag is zero. if not,
                     ; there is an still unhandled interrupt pending.
000124 20bb          tst isrflag
000125 f001          breq isr_clean
                     ; there is a collision. the previous interrupt is not yet
                     ; handled by the forth inner interpreter
                 isr_clean:
000126 2cb0          mov isrflag, r0
                 .if WANT_INTERRUPT_COUNTERS==1
000127 93ff          push zh
000128 93ef          push zl
000129 e7e2          ldi zl, low(intcnt)
00012a e0f0          ldi zh, high(intcnt)
00012b 9406          lsr r0 ; we use byte addresses in the counter array, not words
00012c 0de0          add zl, r0
00012d 1df3          adc zh, zeroh
00012e 8000          ld r0, Z
00012f 9403          inc r0
000130 8200          st Z, r0
000131 91ef          pop zl
000132 91ff          pop zh
                 .endif
000133 9009          ld r0, Y+
000134 be0f          out SREG, r0
000135 9009          ld r0, Y+
000136 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                     ; no reti here, see words/isr-end.asm
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000137 ff02          .dw $ff02
000138 2b6d          .db "m+"
000139 00f6          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
00013a 1c01          .dw DO_COLON
                 PFA_MPLUS:
00013b 0e2d          .dw XT_S2D
00013c 01a9          .dw XT_DPLUS
00013d 1c20          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
00013e ff03          .dw $ff03
00013f 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
000140 002a          .db "ud*"
000141 0137          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
000142 1c01          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
000143 1cb1
000144 1cff
000145 1de0
000146 1cd9              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000147 1cc4
000148 1cf6
000149 1de0
00014a 1ce1
00014b 1d9d
00014c 1c20              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
00014d ff04          .dw $ff04
00014e 6d75
00014f 7861          .db "umax"
000150 013e          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
000151 1c01          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
000152 060f
000153 1d5c              .DW XT_2DUP,XT_ULESS
000154 1c36      	.dw XT_DOCONDBRANCH
000155 0157      	 DEST(UMAX1)
000156 1cc4              .DW XT_SWAP
000157 1cd9      UMAX1:  .DW XT_DROP
000158 1c20      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
000159 ff04          .dw $ff04
00015a 6d75
00015b 6e69          .db "umin"
00015c 014d          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
00015d 1c01          .dw DO_COLON
                 PFA_UMIN:
                 .endif
00015e 060f
00015f 1d67              .DW XT_2DUP,XT_UGREATER
000160 1c36      	.dw XT_DOCONDBRANCH
000161 0163      	DEST(UMIN1)
000162 1cc4              .DW XT_SWAP
000163 1cd9      UMIN1:  .DW XT_DROP
000164 1c20      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; return +1 if immediate, -1 otherwise, flag from name>flags
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
000165 1c01          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000166 1c3d          .dw XT_DOLITERAL
000167 8000          .dw $8000
000168 1e13          .dw XT_AND
000169 1d18          .dw XT_ZEROEQUAL
00016a 1c36          .dw XT_DOCONDBRANCH
00016b 016e          DEST(IMMEDIATEQ1)
00016c 1fdd           .dw XT_ONE
00016d 1c20           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
00016e 1d4b          .dw XT_TRUE
00016f 1c20          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
000170 ff0a          .dw $ff0a
000171 616e
000172 656d
000173 663e
000174 616c
000175 7367          .db "name>flags"
000176 0159          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
000177 1c01          .dw DO_COLON
                 PFA_NAME2FLAGS:
000178 1fc1          .dw XT_FETCHI ; skip to link field
000179 1c3d          .dw XT_DOLITERAL
00017a ff00          .dw $ff00
00017b 1e13          .dw XT_AND
00017c 1c20          .dw XT_EXIT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
00017d ff03          .dw $ff03
00017e 6d31
00017f 0073          .db "1ms",0
000180 0170          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
000181 0182          .dw PFA_1MS
                 PFA_1MS:
000182 ede0
000183 e0f7
000184 9731
000185 f7f1          delay 1000
000186 940c 1c05     jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .include "dict/appl_2k.inc"
                 
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
000188 ff03          .dw $ff03
000189 3264
00018a 002a          .db "d2*",0
00018b 017d          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
00018c 018d          .dw PFA_D2STAR
                 PFA_D2STAR:
00018d 9109          ld temp0, Y+
00018e 9119          ld temp1, Y+
00018f 0f00          lsl temp0
000190 1f11          rol temp1
000191 1f88          rol tosl
000192 1f99          rol tosh
000193 931a          st -Y, temp1
000194 930a          st -Y, temp0
000195 940c 1c05     jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
000197 ff03          .dw $ff03
000198 3264
000199 002f          .db "d2/",0
00019a 0188          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
00019b 019c          .dw PFA_D2SLASH
                 PFA_D2SLASH:
00019c 9109          ld temp0, Y+
00019d 9119          ld temp1, Y+
00019e 9595          asr tosh
00019f 9587          ror tosl
0001a0 9517          ror temp1
0001a1 9507          ror temp0
0001a2 931a          st -Y, temp1
0001a3 930a          st -Y, temp0
0001a4 940c 1c05     jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
0001a6 ff02          .dw $ff02
0001a7 2b64          .db "d+"
0001a8 0197          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
0001a9 01aa          .dw PFA_DPLUS
                 PFA_DPLUS:
0001aa 9129          ld temp2, Y+
0001ab 9139          ld temp3, Y+
                 
0001ac 90e9          ld temp4, Y+
0001ad 90f9          ld temp5, Y+
0001ae 9149          ld temp6, Y+
0001af 9159          ld temp7, Y+
                 
0001b0 0f24          add temp2, temp6
0001b1 1f35          adc temp3, temp7
0001b2 1d8e          adc tosl, temp4
0001b3 1d9f          adc tosh, temp5
                     
0001b4 933a          st -Y, temp3
0001b5 932a          st -Y, temp2
0001b6 940c 1c05     jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
0001b8 ff02          .dw $ff02
0001b9 2d64          .db "d-"
0001ba 01a6          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
0001bb 01bc          .dw PFA_DMINUS
                 PFA_DMINUS:
0001bc 9129          ld temp2, Y+
0001bd 9139          ld temp3, Y+
                 
0001be 90e9          ld temp4, Y+
0001bf 90f9          ld temp5, Y+
0001c0 9149          ld temp6, Y+
0001c1 9159          ld temp7, Y+
                 
0001c2 1b42          sub temp6, temp2
0001c3 0b53          sbc temp7, temp3
0001c4 0ae8          sbc temp4, tosl
0001c5 0af9          sbc temp5, tosh
                 
0001c6 935a          st -Y, temp7
0001c7 934a          st -Y, temp6
0001c8 01c7          movw tosl, temp4
0001c9 940c 1c05     jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
0001cb ff07          .dw $ff07
0001cc 6964
0001cd 766e
0001ce 7265
0001cf 0074          .db "dinvert",0
0001d0 01b8          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
0001d1 01d2          .dw PFA_DINVERT
                 PFA_DINVERT:
0001d2 9109          ld temp0, Y+
0001d3 9119          ld temp1, Y+
0001d4 9580          com tosl
0001d5 9590          com tosh
0001d6 9500          com temp0
0001d7 9510          com temp1
0001d8 931a          st -Y, temp1
0001d9 930a          st -Y, temp0
0001da 940c 1c05     jmp_ DO_NEXT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
0001dc ff02          .dw $ff02
0001dd 2e75          .db "u."
0001de 01cb          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
0001df 1c01          .dw DO_COLON
                 PFA_UDOT:
                 .endif
0001e0 1d54          .dw XT_ZERO
0001e1 07d5          .dw XT_UDDOT
0001e2 1c20          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
0001e3 ff03          .dw $ff03
0001e4 2e75
0001e5 0072          .db "u.r",0
0001e6 01dc          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
0001e7 1c01          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
0001e8 1d54          .dw XT_ZERO
0001e9 1cc4          .dw XT_SWAP
0001ea 07de          .dw XT_UDDOTR
0001eb 1c20          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
0001ec ff0d          .dw $ff0d
0001ed 6873
0001ee 776f
0001ef 772d
0001f0 726f
0001f1 6c64
0001f2 7369
0001f3 0074          .db "show-wordlist",0
0001f4 01e3          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
0001f5 1c01          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
0001f6 1c3d          .dw XT_DOLITERAL
0001f7 01fb          .dw XT_SHOWWORD
0001f8 1cc4          .dw XT_SWAP
0001f9 0d1d          .dw XT_TRAVERSEWORDLIST
0001fa 1c20          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
0001fb 1c01          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
0001fc 0d38          .dw XT_NAME2STRING
0001fd 084b          .dw XT_ITYPE
0001fe 088d          .dw XT_SPACE         ; ( -- addr n)
0001ff 1d4b          .dw XT_TRUE
000200 1c20          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_WORDS:
000201 ff05          .dw $ff05
000202 6f77
000203 6472
000204 0073          .db "words",0
000205 01ec          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
000206 1c01          .dw DO_COLON
                 PFA_WORDS:
                 .endif
000207 1c3d          .dw XT_DOLITERAL
000208 0042          .dw CFG_ORDERLISTLEN+2
000209 1f55          .dw XT_FETCHE
00020a 01f5          .dw XT_SHOWWORDLIST
00020b 1c20          .dw XT_EXIT
                 .include "dict/interrupt.inc"
                 
                 .if WANT_INTERRUPTS == 1
                 
                 .if WANT_INTERRUPT_COUNTERS == 1
                   .include "words/irqcnt.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_IRQCNTADDR:
00020c ff06          .dw $ff06
00020d 7269
00020e 5b71
00020f 235d          .db "irq[]#"
000210 0201          .dw VE_HEAD
                     .set VE_HEAD = VE_IRQCNTADDR
                 XT_IRQCNTADDR:
000211 1c01          .dw DO_COLON
                 PFA_IRQCNTADDR:
000212 1c3d          .dw XT_DOLITERAL
000213 0072          .dw intcnt
000214 1d9d          .dw XT_PLUS
000215 1c20          .dw XT_EXIT
                   .include "words/int-num.asm"
                 
                 ; Interrupt
                 ; number of interrupt vectors (0 based)
                 VE_NUMINT:
000216 ff04          .dw $ff04
000217 6923
000218 746e          .db "#int"
000219 020c          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMINT
                 XT_NUMINT:
00021a 1c48          .dw PFA_DOVARIABLE
                 PFA_NUMINT:
00021b 0015          .dw INTVECTORS
                 .endif
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
00021c ff04          .dw $ff04
00021d 692b
00021e 746e          .db "+int"
00021f 0216          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
000220 0221          .dw PFA_INTON
                 PFA_INTON:
000221 9478          sei
000222 940c 1c05     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
000224 ff04          .dw $ff04
000225 692d
000226 746e          .db "-int"
000227 021c          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
000228 0229          .dw PFA_INTOFF
                 PFA_INTOFF:
000229 94f8          cli
00022a 940c 1c05     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
00022c ff04          .dw $ff04
00022d 6e69
00022e 2174          .db "int!"
00022f 0224          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
000230 1c01          .dw DO_COLON
                 PFA_INTSTORE:
000231 1c3d          .dw XT_DOLITERAL
000232 0000          .dw intvec
000233 1d9d          .dw XT_PLUS
000234 1f31          .dw XT_STOREE
000235 1c20          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
000236 ff04          .dw $ff04
000237 6e69
000238 4074          .db "int@"
000239 022c          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
00023a 1c01          .dw DO_COLON
                 PFA_INTFETCH:
00023b 1c3d          .dw XT_DOLITERAL
00023c 0000          .dw intvec
00023d 1d9d          .dw XT_PLUS
00023e 1f55          .dw XT_FETCHE
00023f 1c20          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
000240 ff08          .dw $ff08
000241 6e69
000242 2d74
000243 7274
000244 7061          .db "int-trap"
000245 0236          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
000246 0247          .dw PFA_INTTRAP
                 PFA_INTTRAP:
000247 2eb8          mov isrflag, tosl
000248 9189
000249 9199          loadtos
00024a 940c 1c05     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
00024c 1c01          .dw DO_COLON
                 PFA_ISREXEC:
00024d 023a          .dw XT_INTFETCH
00024e 1c2a          .dw XT_EXECUTE
00024f 0251          .dw XT_ISREND
000250 1c20          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
000251 0252          .dw PFA_ISREND
                 PFA_ISREND:
000252 d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
000253 940c 1c05     jmp_ DO_NEXT
                 PFA_ISREND1:
000255 9518          reti
                 .endif
                 
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
000256 ff04          .dw $ff04
000257 6970
000258 6b63          .db "pick"
000259 0240          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
00025a 1c01          .dw DO_COLON
                 PFA_PICK:
                 .endif
00025b 1e2f          .dw XT_1PLUS
00025c 0601          .dw XT_CELLS
00025d 1e8d          .dw XT_SP_FETCH
00025e 1d9d          .dw XT_PLUS
00025f 1c79          .dw XT_FETCH
000260 1c20          .dw XT_EXIT
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
000261 0002          .dw $0002
000262 222e          .db ".",$22
000263 0256          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
000264 1c01          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
000265 026c          .dw XT_SQUOTE
000266 02cb          .dw XT_COMPILE
000267 084b          .dw XT_ITYPE
000268 1c20          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
000269 0002        .dw $0002
00026a 2273        .db "s",$22
00026b 0261        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
00026c 1c01          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
00026d 1c3d          .dw XT_DOLITERAL
00026e 0022          .dw 34   ; 0x22 
00026f 0a3c          .dw XT_PARSE       ; ( -- addr n)
000270 05f4          .dw XT_STATE
000271 1c79          .dw XT_FETCH
000272 1c36          .dw XT_DOCONDBRANCH
000273 0275          DEST(PFA_SQUOTE1)
000274 02f7            .dw XT_SLITERAL
                 PFA_SQUOTE1:
000275 1c20          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
000276 ff04          .dw $ff04
000277 6966
000278 6c6c          .db "fill"
000279 0269          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
00027a 1c01          .dw DO_COLON
                 PFA_FILL:
00027b 1ce1          .dw XT_ROT
00027c 1ce1          .dw XT_ROT
00027d 1cb9
00027e 1c36          .dw XT_QDUP,XT_DOCONDBRANCH
00027f 0287          DEST(PFA_FILL2)
000280 0e24          .dw XT_BOUNDS
000281 1e9b          .dw XT_DODO
                 PFA_FILL1:
000282 1cb1          .dw XT_DUP
000283 1eac          .dw XT_I
000284 1c8d          .dw XT_CSTORE  ; ( -- c c-addr)
000285 1ec9          .dw XT_DOLOOP
000286 0282          .dw PFA_FILL1
                 PFA_FILL2:
000287 1cd9          .dw XT_DROP
000288 1c20          .dw XT_EXIT
                 .include "dict/compiler1.inc"
                 
                 .include "words/newest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_NEWEST:
000289 ff06          .dw $ff06
00028a 656e
00028b 6577
00028c 7473          .db "newest"
00028d 0276          .dw VE_HEAD
                     .set VE_HEAD = VE_NEWEST
                 XT_NEWEST:
00028e 1c48          .dw PFA_DOVARIABLE
                 PFA_NEWEST:
00028f 0087          .dw ram_newest
                 
                 .dseg
000087           ram_newest: .byte 4
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_LATEST:
000290 ff06          .dw $ff06
000291 616c
000292 6574
000293 7473          .db "latest"
000294 0289          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
000295 1c48          .dw PFA_DOVARIABLE
                 PFA_LATEST:
000296 008b          .dw ram_latest
                 
                 .dseg
00008b           ram_latest: .byte 2
                 .include "words/do-create.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE:
000297 ff08          .dw $ff08
000298 6328
000299 6572
00029a 7461
00029b 2965          .db "(create)"
00029c 0290          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
00029d 1c01          .dw DO_COLON
                 PFA_DOCREATE:
                 .endif
00029e 0a69
00029f 03ff          .DW XT_PARSENAME,XT_WLSCOPE  ; ( -- addr len wid)
0002a0 02aa          .DW XT_DOCREATE_IN           ; ( addr len wid -- )
0002a1 1c20          .DW XT_EXIT
                 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE_IN:
0002a2 ff0b          .dw $ff0b
0002a3 6328
0002a4 6572
0002a5 7461
0002a6 2d65
0002a7 6e69
../../common\words/do-create.asm(31): warning: .cseg .db misalignment - padding zero byte
0002a8 0029          .db "(create-in)"
0002a9 0297          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE_IN
                 XT_DOCREATE_IN:
0002aa 1c01          .dw DO_COLON
                 PFA_DOCREATE_IN:
                 .endif
0002ab 1cb1
0002ac 028e
0002ad 0607
0002ae 1c81          .DW XT_DUP,XT_NEWEST,XT_CELLPLUS,XT_STORE ; save the wid
0002af 03e4
0002b0 028e
0002b1 1c81          .DW XT_HEADER,XT_NEWEST,XT_STORE          ; save the nt
0002b2 1c20          .DW XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
0002b3 0001          .dw $0001
0002b4 005c          .db $5c,0
0002b5 02a2          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
0002b6 1c01          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
0002b7 0a50          .dw XT_SOURCE
0002b8 1cf0          .dw XT_NIP
0002b9 0628          .dw XT_TO_IN
0002ba 1c81          .dw XT_STORE
0002bb 1c20          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
0002bc 0001          .dw $0001
0002bd 0028          .db "(" ,0
0002be 02b3          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
0002bf 1c01          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
0002c0 1c3d          .dw XT_DOLITERAL
0002c1 0029          .dw ')'
0002c2 0a3c          .dw XT_PARSE
0002c3 0618          .dw XT_2DROP
0002c4 1c20          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
0002c5 ff07          .dw $ff07
0002c6 6f63
0002c7 706d
0002c8 6c69
0002c9 0065          .db "compile",0
0002ca 02bc          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
0002cb 1c01          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
0002cc 1cf6          .dw XT_R_FROM
0002cd 1cb1          .dw XT_DUP
0002ce 0c71          .dw XT_ICELLPLUS
0002cf 1cff          .dw XT_TO_R
0002d0 1fc1          .dw XT_FETCHI
0002d1 02d6          .dw XT_COMMA
0002d2 1c20          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0002d3 ff01          .dw $ff01
0002d4 002c          .db ',',0 ; ,
0002d5 02c5          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0002d6 1c01          .dw DO_COLON
                 PFA_COMMA:
0002d7 0658          .dw XT_DP
0002d8 1f69          .dw XT_STOREI
0002d9 0658          .dw XT_DP
0002da 1e2f          .dw XT_1PLUS
0002db 0c5f          .dw XT_DOTO
0002dc 0659          .dw PFA_DP
0002dd 1c20          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
0002de 0003          .dw $0003
0002df 275b
0002e0 005d          .db "[']",0
0002e1 02d3          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
0002e2 1c01          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
0002e3 08b5          .dw XT_TICK
0002e4 02ec          .dw XT_LITERAL
0002e5 1c20          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
0002e6 0007          .dw $0007
0002e7 696c
0002e8 6574
0002e9 6172
0002ea 006c          .db "literal",0
0002eb 02de          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
0002ec 1c01          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
0002ed 02cb              .DW XT_COMPILE
0002ee 1c3d              .DW XT_DOLITERAL
0002ef 02d6              .DW XT_COMMA
0002f0 1c20              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
0002f1 0008        .dw $0008
0002f2 6c73
0002f3 7469
0002f4 7265
0002f5 6c61        .db "sliteral"
0002f6 02e6        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
0002f7 1c01          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
0002f8 02cb          .dw XT_COMPILE
0002f9 0818          .dw XT_DOSLITERAL    ; ( -- addr n)
0002fa 0826          .dw XT_SCOMMA
0002fb 1c20          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
0002fc 1c01          .dw DO_COLON
                 PFA_GMARK:
0002fd 0658          .dw XT_DP
0002fe 02cb          .dw XT_COMPILE
0002ff ffff          .dw -1           ; ffff does not erase flash
000300 1c20          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
000301 1c01          .dw DO_COLON
                 PFA_GRESOLVE:
000302 0c1d          .dw XT_QSTACK
000303 0658          .dw XT_DP
000304 1cc4          .dw XT_SWAP
000305 1f69          .dw XT_STOREI
000306 1c20          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
000307 1c01          .dw DO_COLON
                 PFA_LMARK:
000308 0658          .dw XT_DP
000309 1c20          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
00030a 1c01          .dw DO_COLON
                 PFA_LRESOLVE:
00030b 0c1d          .dw XT_QSTACK
00030c 02d6          .dw XT_COMMA
00030d 1c20          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
00030e 0005          .dw $0005
00030f 6861
000310 6165
000311 0064          .db "ahead",0
000312 02f1          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
000313 1c01          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
000314 02cb          .dw XT_COMPILE
000315 1c2f          .dw XT_DOBRANCH
000316 02fc          .dw XT_GMARK
000317 1c20          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
000318 0002          .dw $0002
000319 6669          .db "if"
00031a 030e          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
00031b 1c01          .dw DO_COLON
                 PFA_IF:
                 .endif
00031c 02cb          .dw XT_COMPILE
00031d 1c36          .dw XT_DOCONDBRANCH
00031e 02fc          .dw XT_GMARK
00031f 1c20          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
000320 0004          .dw $0004
000321 6c65
000322 6573          .db "else"
000323 0318          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
000324 1c01          .dw DO_COLON
                 PFA_ELSE:
                 .endif
000325 02cb          .dw XT_COMPILE
000326 1c2f          .dw XT_DOBRANCH
000327 02fc          .dw XT_GMARK
000328 1cc4          .dw XT_SWAP
000329 0301          .dw XT_GRESOLVE
00032a 1c20          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
00032b 0004          .dw $0004
00032c 6874
00032d 6e65          .db "then"
00032e 0320          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
00032f 1c01          .dw DO_COLON
                 PFA_THEN:
                 .endif
000330 0301          .dw XT_GRESOLVE
000331 1c20          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
000332 0005          .dw $0005
000333 6562
000334 6967
000335 006e          .db "begin",0
000336 032b          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
000337 1c01          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
000338 0307          .dw XT_LMARK
000339 1c20          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
00033a 0005          .dw $0005
00033b 6877
00033c 6c69
00033d 0065          .db "while",0
00033e 0332          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
00033f 1c01          .dw DO_COLON
                 PFA_WHILE:
                 .endif
000340 031b          .dw XT_IF
000341 1cc4          .dw XT_SWAP
000342 1c20          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
000343 0006          .dw $0006
000344 6572
000345 6570
000346 7461          .db "repeat"
000347 033a          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
000348 1c01          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
000349 035c          .dw XT_AGAIN
00034a 032f          .dw XT_THEN
00034b 1c20          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
00034c 0005          .dw $0005
00034d 6e75
00034e 6974
00034f 006c          .db "until",0
000350 0343          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
000351 1c01          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
000352 1c3d          .dw XT_DOLITERAL
000353 1c36          .dw XT_DOCONDBRANCH
000354 02d6          .dw XT_COMMA
                 
000355 030a          .dw XT_LRESOLVE
000356 1c20          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
000357 0005          .dw $0005
000358 6761
000359 6961
00035a 006e          .db "again",0
00035b 034c          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
00035c 1c01          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
00035d 02cb          .dw XT_COMPILE
00035e 1c2f          .dw XT_DOBRANCH
00035f 030a          .dw XT_LRESOLVE
000360 1c20          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
000361 0002          .dw $0002
000362 6f64          .db "do"
000363 0357          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000364 1c01          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
000365 02cb          .dw XT_COMPILE
000366 1e9b          .dw XT_DODO
000367 0307          .dw XT_LMARK
000368 1d54          .dw XT_ZERO
000369 03bf          .dw XT_TO_L
00036a 1c20          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
00036b 0004          .dw $0004
00036c 6f6c
00036d 706f          .db "loop"
00036e 0361          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
00036f 1c01          .dw DO_COLON
                 PFA_LOOP:
                 .endif
000370 02cb          .dw XT_COMPILE
000371 1ec9          .dw XT_DOLOOP
000372 03a6          .dw XT_ENDLOOP
000373 1c20          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
000374 0005          .dw $0005
000375 6c2b
000376 6f6f
000377 0070          .db "+loop",0
000378 036b          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
000379 1c01          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
00037a 02cb          .dw XT_COMPILE
00037b 1eba          .dw XT_DOPLUSLOOP
00037c 03a6          .dw XT_ENDLOOP
00037d 1c20          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
00037e 0005         .dw $0005
00037f 656c
000380 7661
000381 0065         .db "leave",0
000382 0374         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
000383 1c01          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
000384 02cb
000385 1ed4          .DW XT_COMPILE,XT_UNLOOP
000386 0313
000387 03bf
000388 1c20          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
000389 0003          .dw $0003
00038a 643f
00038b 006f          .db "?do",0
00038c 037e          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
00038d 1c01          .dw DO_COLON
                 PFA_QDO:
                 .endif
00038e 02cb          .dw XT_COMPILE
00038f 0395          .dw XT_QDOCHECK
000390 031b          .dw XT_IF
000391 0364          .dw XT_DO
000392 1cc4          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
000393 03bf          .dw XT_TO_L    ; then follows at the end.
000394 1c20          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
000395 1c01          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
000396 060f          .dw XT_2DUP
000397 1fd6          .dw XT_EQUAL
000398 1cb1          .dw XT_DUP
000399 1cff          .dw XT_TO_R
00039a 1c36          .dw XT_DOCONDBRANCH
00039b 039d          DEST(PFA_QDOCHECK1)
00039c 0618          .dw XT_2DROP
                 PFA_QDOCHECK1:
00039d 1cf6          .dw XT_R_FROM
00039e 1dfd          .dw XT_INVERT
00039f 1c20          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
0003a0 ff07          .dw $ff07
0003a1 6e65
0003a2 6c64
0003a3 6f6f
0003a4 0070          .db "endloop",0
0003a5 0389          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
0003a6 1c01          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
0003a7 030a              .DW XT_LRESOLVE
0003a8 03b3
0003a9 1cb9
0003aa 1c36      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
0003ab 03af               DEST(LOOP2)
0003ac 032f              .DW XT_THEN
0003ad 1c2f      	.dw XT_DOBRANCH
0003ae 03a8               DEST(LOOP1)
0003af 1c20      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
0003b0 ff02          .dw $ff02
0003b1 3e6c          .db "l>"
0003b2 03a0          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
0003b3 1c01          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
0003b4 03d2          .dw XT_LP
0003b5 1c79          .dw XT_FETCH
0003b6 1c79          .dw XT_FETCH
0003b7 1c3d          .dw XT_DOLITERAL
0003b8 fffe          .dw -2
0003b9 03d2          .dw XT_LP
0003ba 1e65          .dw XT_PLUSSTORE
0003bb 1c20          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
0003bc ff02          .dw $ff02
0003bd 6c3e          .db ">l"
0003be 03b0          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
0003bf 1c01          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
0003c0 1fe2              .dw XT_TWO
0003c1 03d2      	.dw XT_LP
0003c2 1e65      	.dw XT_PLUSSTORE
0003c3 03d2      	.dw XT_LP
0003c4 1c79      	.dw XT_FETCH
0003c5 1c81      	.dw XT_STORE
0003c6 1c20      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
0003c7 ff03          .dw $ff03
0003c8 706c
0003c9 0030          .db "lp0",0
0003ca 03bc          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
0003cb 1c6f          .dw PFA_DOVALUE1
                 PFA_LP0:
0003cc 0036          .dw CFG_LP0
0003cd 0c7a          .dw XT_EDEFERFETCH
0003ce 0c84          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
0003cf ff02          .dw $ff02
0003d0 706c          .db "lp"
0003d1 03c7          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
0003d2 1c48          .dw PFA_DOVARIABLE
                 PFA_LP:
0003d3 008d          .dw ram_lp
                 
                 .dseg
00008d           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CREATE:
0003d4 ff06          .dw $ff06
0003d5 7263
0003d6 6165
0003d7 6574          .db "create"
0003d8 03cf          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
0003d9 1c01          .dw DO_COLON
                 PFA_CREATE:
                 .endif
0003da 029d          .dw XT_DOCREATE
0003db 0408          .dw XT_REVEAL
0003dc 02cb          .dw XT_COMPILE
0003dd 1c52          .dw PFA_DOCONSTANT
0003de 1c20          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
0003df ff06          .dw $ff06
0003e0 6568
0003e1 6461
0003e2 7265          .db "header"
0003e3 03d4          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
0003e4 1c01          .dw DO_COLON
                 PFA_HEADER:
0003e5 0658          .dw XT_DP           ; the new Name Field
0003e6 1cff          .dw XT_TO_R
0003e7 1cff          .dw XT_TO_R		; ( R: NFA WID )
0003e8 1cb1          .dw XT_DUP    
0003e9 1d26          .dw XT_GREATERZERO 
0003ea 1c36          .dw XT_DOCONDBRANCH
0003eb 03f6          .dw PFA_HEADER1
0003ec 1cb1          .dw XT_DUP
0003ed 1c3d          .dw XT_DOLITERAL
0003ee ff00          .dw $ff00           ; all flags are off (e.g. immediate)
0003ef 1e1c          .dw XT_OR
0003f0 082a          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
0003f1 1cf6          .dw XT_R_FROM
0003f2 1f55          .dw XT_FETCHE
0003f3 02d6          .dw XT_COMMA
0003f4 1cf6          .dw XT_R_FROM
0003f5 1c20          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
0003f6 1c3d          .dw XT_DOLITERAL
0003f7 fff0          .dw -16
0003f8 08ec          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
0003f9 ff07          .dw $ff07
0003fa 6c77
0003fb 6373
0003fc 706f
0003fd 0065          .db "wlscope",0
0003fe 03df          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
0003ff 0cd9          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
000400 0032          .dw CFG_WLSCOPE
000401 0c7a          .dw XT_EDEFERFETCH
000402 0c84          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REVEAL:
000403 ff06          .dw $ff06
000404 6572
000405 6576
000406 6c61          .db "reveal"
000407 03f9          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
000408 1c01          .dw DO_COLON
                 PFA_REVEAL:
                 .endif
000409 028e
00040a 0607
00040b 1c79          .DW XT_NEWEST,XT_CELLPLUS,XT_FETCH ; only if wordlist is in use
00040c 1cb9
00040d 1c36          .DW XT_QDUP,XT_DOCONDBRANCH
00040e 0413          DEST(REVEAL1)
00040f 028e
000410 1c79
000411 1cc4
000412 1f31          .DW XT_NEWEST,XT_FETCH,XT_SWAP,XT_STOREE
                 ;    .DW XT_ZERO,XT_NEWEST,XT_CELLPLUS,XT_STORE ; clean wordlist entry
                 REVEAL1:
000413 1c20          .DW XT_EXIT
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
000414 0005          .dw $0005
000415 6f64
000416 7365
000417 003e          .db "does>",0
000418 0403          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000419 1c01          .dw DO_COLON
                 PFA_DOES:
00041a 02cb          .dw XT_COMPILE
00041b 042c          .dw XT_DODOES
00041c 02cb          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
00041d 940e          .dw $940e       ; the address of this compiled
00041e 02cb          .dw XT_COMPILE  ; code will replace the XT of the 
00041f 0421          .dw DO_DODOES   ; word that CREATE created
000420 1c20          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
000421 939a
000422 938a          savetos
000423 01cb          movw tosl, wl
000424 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
000425 917f          pop wh
000426 916f          pop wl
                 
000427 93bf          push XH
000428 93af          push XL
000429 01db          movw XL, wl
00042a 940c 1c05     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
00042c 1c01          .dw DO_COLON
                 PFA_DODOES:
00042d 1cf6          .dw XT_R_FROM
00042e 028e          .dw XT_NEWEST
00042f 0607          .dw XT_CELLPLUS
000430 1c79          .dw XT_FETCH
000431 1f55          .dw XT_FETCHE
000432 0d44          .dw XT_NFA2CFA
000433 1f69          .dw XT_STOREI
000434 1c20          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
000435 ff01          .dw $ff01
000436 003a          .db ":",0
000437 0414          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000438 1c01          .dw DO_COLON
                 PFA_COLON:
                 .endif
000439 029d          .dw XT_DOCREATE
00043a 0443          .dw XT_COLONNONAME
00043b 1cd9          .dw XT_DROP
00043c 1c20          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
00043d ff07          .dw $ff07
00043e 6e3a
00043f 6e6f
000440 6d61
000441 0065          .db ":noname",0
000442 0435          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000443 1c01          .dw DO_COLON
                 PFA_COLONNONAME:
000444 0658          .dw XT_DP
000445 1cb1          .dw XT_DUP
000446 0295          .dw XT_LATEST
000447 1c81          .dw XT_STORE
                 
000448 02cb          .dw XT_COMPILE
000449 1c01          .dw DO_COLON
                 
00044a 0458          .dw XT_RBRACKET
00044b 1c20          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
00044c 0001          .dw $0001
00044d 003b          .db $3b,0
00044e 043d          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
00044f 1c01          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
000450 02cb          .dw XT_COMPILE
000451 1c20          .dw XT_EXIT
000452 0460          .dw XT_LBRACKET
000453 0408          .dw XT_REVEAL
000454 1c20          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
000455 ff01          .dw $ff01
000456 005d          .db "]",0
000457 044c          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000458 1c01          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
000459 1fdd          .dw XT_ONE
00045a 05f4          .dw XT_STATE
00045b 1c81          .dw XT_STORE
00045c 1c20          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
00045d 0001          .dw $0001
00045e 005b          .db "[",0
00045f 0455          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
000460 1c01          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
000461 1d54          .dw XT_ZERO
000462 05f4          .dw XT_STATE
000463 1c81          .dw XT_STORE
000464 1c20          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
000465 ff08          .dw $ff08
000466 6176
000467 6972
000468 6261
000469 656c          .db "variable"
00046a 045d          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
00046b 1c01          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
00046c 0669          .dw XT_HERE
00046d 0477          .dw XT_CONSTANT
00046e 1fe2          .dw XT_TWO
00046f 0672          .dw XT_ALLOT
000470 1c20          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
000471 ff08          .dw $ff08
000472 6f63
000473 736e
000474 6174
000475 746e          .db "constant"
000476 0465          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000477 1c01          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
000478 029d          .dw XT_DOCREATE
000479 0408          .dw XT_REVEAL
00047a 02cb          .dw XT_COMPILE
00047b 1c48          .dw PFA_DOVARIABLE
00047c 02d6          .dw XT_COMMA
00047d 1c20          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
00047e ff04          .dw $ff04
00047f 7375
000480 7265          .db "user"
000481 0471          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
000482 1c01          .dw DO_COLON
                 PFA_USER:
000483 029d          .dw XT_DOCREATE
000484 0408          .dw XT_REVEAL
                 
000485 02cb          .dw XT_COMPILE
000486 1c58          .dw PFA_DOUSER
000487 02d6          .dw XT_COMMA
000488 1c20          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECURSE:
000489 0007          .dw $0007
00048a 6572
00048b 7563
00048c 7372
00048d 0065          .db "recurse",0
00048e 047e          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
00048f 1c01          .dw DO_COLON
                 PFA_RECURSE:
                 .endif
000490 0295          .dw XT_LATEST
000491 1c79          .dw XT_FETCH
000492 02d6          .dw XT_COMMA
000493 1c20          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
000494 ff09          .dw $ff09
000495 6d69
000496 656d
000497 6964
000498 7461
000499 0065          .db "immediate",0
00049a 0489          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
00049b 1c01          .dw DO_COLON
                 PFA_IMMEDIATE:
00049c 053d          .dw XT_GET_CURRENT
00049d 1f55          .dw XT_FETCHE
00049e 1cb1          .dw XT_DUP
00049f 1fc1          .dw XT_FETCHI
0004a0 1c3d          .dw XT_DOLITERAL
0004a1 7fff          .dw $7fff
0004a2 1e13          .dw XT_AND
0004a3 1cc4          .dw XT_SWAP
0004a4 1f69          .dw XT_STOREI
0004a5 1c20          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
0004a6 0006          .dw $0006
0004a7 635b
0004a8 6168
0004a9 5d72          .db "[char]"
0004aa 0494          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
0004ab 1c01          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
0004ac 02cb          .dw XT_COMPILE
0004ad 1c3d          .dw XT_DOLITERAL
0004ae 099a          .dw XT_CHAR
0004af 02d6          .dw XT_COMMA
0004b0 1c20          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
0004b1 0006          .dw $0006
0004b2 6261
0004b3 726f
0004b4 2274          .db "abort",'"'
0004b5 04a6          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
0004b6 1c01          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
0004b7 026c          .dw XT_SQUOTE
0004b8 02cb          .dw XT_COMPILE
0004b9 04c8          .dw XT_QABORT
0004ba 1c20          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
0004bb ff05          .dw $ff05
0004bc 6261
0004bd 726f
0004be 0074          .db "abort",0
0004bf 04b1          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
0004c0 1c01          .dw DO_COLON
                 PFA_ABORT:
                 .endif
0004c1 1d4b          .dw XT_TRUE
0004c2 08ec          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
0004c3 ff06          .dw $ff06
0004c4 613f
0004c5 6f62
0004c6 7472          .db "?abort"
0004c7 04bb          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
0004c8 1c01          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
0004c9 1ce1
0004ca 1c36              .DW XT_ROT,XT_DOCONDBRANCH
0004cb 04ce              DEST(QABO1)
0004cc 084b
0004cd 04c0              .DW XT_ITYPE,XT_ABORT
0004ce 0618
0004cf 1c20      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
0004d0 ff09          .dw $ff09
0004d1 6567
0004d2 2d74
0004d3 7473
0004d4 6361
0004d5 006b          .db "get-stack",0
0004d6 04c3          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
0004d7 1c01          .dw DO_COLON
                 .endif
0004d8 1cb1          .dw XT_DUP
0004d9 0607          .dw XT_CELLPLUS
0004da 1cc4          .dw XT_SWAP
0004db 1f55          .dw XT_FETCHE
0004dc 1cb1          .dw XT_DUP
0004dd 1cff          .dw XT_TO_R
0004de 1d54          .dw XT_ZERO
0004df 1cc4          .dw XT_SWAP    ; go from bigger to smaller addresses
0004e0 0395          .dw XT_QDOCHECK
0004e1 1c36          .dw XT_DOCONDBRANCH
0004e2 04ee          DEST(PFA_N_FETCH_E2)
0004e3 1e9b          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
0004e4 1eac          .dw XT_I
0004e5 1e35          .dw XT_1MINUS
0004e6 0601          .dw XT_CELLS ; ( -- ee-addr i*2 )
0004e7 1ccf          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
0004e8 1d9d          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
0004e9 1f55          .dw XT_FETCHE ;( -- ee-addr item_i )
0004ea 1cc4          .dw XT_SWAP   ;( -- item_i ee-addr )
0004eb 1d4b          .dw XT_TRUE  ; shortcut for -1
0004ec 1eba          .dw XT_DOPLUSLOOP
0004ed 04e4          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
0004ee 0618          .dw XT_2DROP
0004ef 1cf6          .dw XT_R_FROM
0004f0 1c20          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
0004f1 ff09          .dw $ff09
0004f2 6573
0004f3 2d74
0004f4 7473
0004f5 6361
0004f6 006b          .db "set-stack",0
0004f7 04d0          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
0004f8 1c01          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
0004f9 1ccf          .dw XT_OVER
0004fa 1d1f          .dw XT_ZEROLESS
0004fb 1c36          .dw XT_DOCONDBRANCH
0004fc 0500          DEST(PFA_SET_STACK0)
0004fd 1c3d          .dw XT_DOLITERAL
0004fe fffc          .dw -4
0004ff 08ec          .dw XT_THROW
                 PFA_SET_STACK0:
000500 060f          .dw XT_2DUP
000501 1f31          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
000502 1cc4          .dw XT_SWAP    
000503 1d54          .dw XT_ZERO
000504 0395          .dw XT_QDOCHECK
000505 1c36          .dw XT_DOCONDBRANCH
000506 050d          DEST(PFA_SET_STACK2)
000507 1e9b          .dw XT_DODO
                 PFA_SET_STACK1:
000508 0607          .dw XT_CELLPLUS ; ( -- i_x e-addr )
000509 0620          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
00050a 1f31          .dw XT_STOREE
00050b 1ec9          .dw XT_DOLOOP
00050c 0508          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
00050d 1cd9          .dw XT_DROP
00050e 1c20          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
00050f ff09          .dw $ff09
000510 616d
000511 2d70
000512 7473
000513 6361
000514 006b          .db "map-stack",0
000515 04f1          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
000516 1c01          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
000517 1cb1          .dw XT_DUP
000518 0607          .dw XT_CELLPLUS
000519 1cc4          .dw XT_SWAP
00051a 1f55          .dw XT_FETCHE
00051b 0601          .dw XT_CELLS
00051c 0e24          .dw XT_BOUNDS
00051d 0395          .dw XT_QDOCHECK
00051e 1c36          .dw XT_DOCONDBRANCH
00051f 0532          DEST(PFA_MAPSTACK3)
000520 1e9b          .dw XT_DODO
                 PFA_MAPSTACK1:
000521 1eac            .dw XT_I
000522 1f55            .dw XT_FETCHE   ; -- i*x XT id
000523 1cc4            .dw XT_SWAP
000524 1cff            .dw XT_TO_R
000525 1d06            .dw XT_R_FETCH
000526 1c2a            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
000527 1cb9            .dw XT_QDUP
000528 1c36            .dw XT_DOCONDBRANCH
000529 052e            DEST(PFA_MAPSTACK2)
00052a 1cf6               .dw XT_R_FROM
00052b 1cd9               .dw XT_DROP
00052c 1ed4               .dw XT_UNLOOP
00052d 1c20               .dw XT_EXIT
                 PFA_MAPSTACK2:
00052e 1cf6            .dw XT_R_FROM
00052f 1fe2            .dw XT_TWO
000530 1eba            .dw XT_DOPLUSLOOP
000531 0521            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
000532 1cd9          .dw XT_DROP
000533 1d54          .dw XT_ZERO
000534 1c20          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ; ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000535 ff0b          .dw $ff0b
000536 6567
000537 2d74
000538 7563
000539 7272
00053a 6e65
00053b 0074          .db "get-current",0
00053c 050f          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
00053d 1c01          .dw DO_COLON
                 PFA_GET_CURRENT:
00053e 1c3d          .dw XT_DOLITERAL
00053f 003c          .dw CFG_CURRENT
000540 1f55          .dw XT_FETCHE
000541 1c20          .dw XT_EXIT
                 .include "words/cfg-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CFG_ORDER:
000542 ff09          .dw $ff09
000543 6663
000544 2d67
000545 726f
000546 6564
000547 0072          .db "cfg-order",0
000548 0535          .dw VE_HEAD
                     .set VE_HEAD = VE_CFG_ORDER
                 XT_CFG_ORDER:
000549 1c48          .dw PFA_DOVARIABLE
                 PFA_CFG_ORDER:
                 .endif
00054a 0040          .dw CFG_ORDERLISTLEN
                 .include "words/cfg-recognizer.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CFG_RECOGNIZER:
00054b ff08          .dw $ff08
00054c 6663
00054d 2d67
00054e 6572
00054f 7363          .db "cfg-recs"
000550 0542          .dw VE_HEAD
                     .set VE_HEAD = VE_CFG_RECOGNIZER
                 XT_CFG_RECOGNIZER:
000551 1c48          .dw PFA_DOVARIABLE
                 PFA_CFG_RECOGNIZER:
                 .endif
000552 0052          .dw CFG_RECOGNIZERLISTLEN
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000553 ff07          .dw $ff07
000554 6f63
000555 706d
000556 7261
000557 0065          .db "compare",0
000558 054b          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
000559 055a          .dw PFA_COMPARE
                 PFA_COMPARE:
00055a 93bf          push xh
00055b 93af          push xl
00055c 018c          movw temp0, tosl
00055d 9189
00055e 9199          loadtos
00055f 01dc          movw xl, tosl
000560 9189
000561 9199          loadtos
000562 019c          movw temp2, tosl
000563 9189
000564 9199          loadtos
000565 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000566 90ed          ld temp4, X+
000567 90f1          ld temp5, Z+
000568 14ef          cp temp4, temp5
000569 f451          brne PFA_COMPARE_NOTEQUAL
00056a 950a          dec temp0
00056b f019          breq PFA_COMPARE_ENDREACHED2
00056c 952a          dec temp2
00056d f7c1          brne PFA_COMPARE_LOOP
00056e c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
00056f 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000570 2b02          or temp0, temp2
000571 f411          brne PFA_COMPARE_CHECKLASTCHAR
000572 2788          clr tosl
000573 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000574 ef8f          ser tosl
000575 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000576 2f98          mov tosh, tosl
000577 91af          pop xl
000578 91bf          pop xh
000579 940c 1c05     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
00057b ff07         .dw $ff07
00057c 666e
00057d 3e61
00057e 666c
00057f 0061         .db "nfa>lfa",0
000580 0553         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000581 1c01          .dw DO_COLON
                 PFA_NFA2LFA:
000582 0d38          .dw XT_NAME2STRING
000583 1e2f          .dw XT_1PLUS
000584 1e04          .dw XT_2SLASH
000585 1d9d          .dw XT_PLUS
000586 1c20          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
000587 ff0b          .dw $ff0b
000588 6e65
000589 6976
00058a 6f72
00058b 6d6e
00058c 6e65
00058d 0074          .db "environment",0
00058e 057b          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
00058f 1c48          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
000590 003a          .dw CFG_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
000591 ff09          .dw $ff09
000592 6f77
000593 6472
000594 696c
000595 7473
000596 0073          .db "wordlists",0
000597 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
000598 1c01          .dw DO_COLON
                 PFA_ENVWORDLISTS:
000599 1c3d          .dw XT_DOLITERAL
00059a 0008          .dw NUMWORDLISTS
00059b 1c20          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
00059c ff04          .dw $ff04
00059d 702f
00059e 6461          .db "/pad"
00059f 0591          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
0005a0 1c01          .dw DO_COLON
                 PFA_ENVSLASHPAD:
0005a1 1e8d          .dw XT_SP_FETCH
0005a2 062e          .dw XT_PAD
0005a3 1d93          .dw XT_MINUS
0005a4 1c20          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENVSLASHHOLD:
0005a5 ff05          .dw $ff05
0005a6 682f
0005a7 6c6f
0005a8 0064          .db "/hold",0
0005a9 059c          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
0005aa 1c01          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
                 .endif
0005ab 062e          .dw XT_PAD
0005ac 0669          .dw XT_HERE
0005ad 1d93          .dw XT_MINUS
0005ae 1c20          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
0005af ff0a          .dw $ff0a
0005b0 6f66
0005b1 7472
0005b2 2d68
0005b3 616e
0005b4 656d          .db "forth-name"
0005b5 05a5          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
0005b6 1c01          .dw DO_COLON
                 PFA_EN_FORTHNAME:
0005b7 0818          .dw XT_DOSLITERAL
0005b8 0007          .dw 7
                 .endif
0005b9 6d61
0005ba 6f66
0005bb 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
0005bc 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
0005bd 1c20          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
0005be ff07          .dw $ff07
0005bf 6576
0005c0 7372
0005c1 6f69
0005c2 006e          .db "version",0
0005c3 05af          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
0005c4 1c01          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
0005c5 1c3d          .dw XT_DOLITERAL
0005c6 0045          .dw 69
0005c7 1c20          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
0005c8 ff03          .dw $ff03
0005c9 7063
0005ca 0075          .db "cpu",0
0005cb 05be          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
0005cc 1c01          .dw DO_COLON
                 PFA_EN_CPU:
                 .endif
0005cd 1c3d          .dw XT_DOLITERAL
0005ce 002d          .dw mcu_name
0005cf 0877          .dw XT_ICOUNT
0005d0 1c20          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
0005d1 ff08          .dw $ff08
0005d2 636d
0005d3 2d75
0005d4 6e69
0005d5 6f66          .db "mcu-info"
0005d6 05c8          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
0005d7 1c01          .dw DO_COLON
                 PFA_EN_MCUINFO:
0005d8 1c3d          .dw XT_DOLITERAL
0005d9 0029          .dw mcu_info
0005da 1c20          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_ENVUSERSIZE:
0005db ff05          .dw $ff05
0005dc 752f
0005dd 6573
0005de 0072          .db "/user",0
0005df 05d1          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
0005e0 1c01          .dw DO_COLON
                 PFA_ENVUSERSIZE:
                 .endif
0005e1 1c3d          .dw XT_DOLITERAL
0005e2 002e          .dw SYSUSERSIZE + APPUSERSIZE
0005e3 1c20          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
0005e4 ff05          .dw $ff05
0005e5 5f66
0005e6 7063
0005e7 0075          .db "f_cpu",0
0005e8 0587          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
0005e9 1c01          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
0005ea 1c3d          .dw XT_DOLITERAL
0005eb 1200          .dw (F_CPU % 65536)
0005ec 1c3d          .dw XT_DOLITERAL
0005ed 007a          .dw (F_CPU / 65536)
0005ee 1c20          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
0005ef ff05          .dw $ff05
0005f0 7473
0005f1 7461
0005f2 0065          .db "state",0
0005f3 05e4          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
0005f4 1c48          .dw PFA_DOVARIABLE
                 PFA_STATE:
0005f5 008f          .dw ram_state
                 
                 .dseg
00008f           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
0005f6 ff04          .dw $ff04
0005f7 6162
0005f8 6573          .db "base"
0005f9 05ef          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
0005fa 1c58          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
0005fb 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
0005fc ff05          .dw $ff05
0005fd 6563
0005fe 6c6c
0005ff 0073          .db "cells",0
000600 05f6          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
000601 1e0c          .dw PFA_2STAR
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
000602 ff05          .dw $ff05
000603 6563
000604 6c6c
000605 002b          .db "cell+",0
000606 05fc          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
000607 0608          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
000608 9602          adiw tosl, CELLSIZE
000609 940c 1c05     jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
00060b ff04          .dw $ff04
00060c 6432
00060d 7075          .db "2dup"
00060e 0602          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
00060f 1c01          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
000610 1ccf          .dw XT_OVER
000611 1ccf          .dw XT_OVER
000612 1c20          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
000613 ff05          .dw $ff05
000614 6432
000615 6f72
000616 0070          .db "2drop",0
000617 060b          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
000618 1c01          .dw DO_COLON
                 PFA_2DROP:
                 .endif
000619 1cd9          .dw XT_DROP
00061a 1cd9          .dw XT_DROP
00061b 1c20          .dw XT_EXIT
                 
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
00061c ff04          .dw $ff04
00061d 7574
00061e 6b63          .db "tuck"
00061f 0613          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
000620 1c01          .dw DO_COLON
                 PFA_TUCK:
                 .endif
000621 1cc4          .dw XT_SWAP
000622 1ccf          .dw XT_OVER
000623 1c20          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
000624 ff03          .dw $ff03
000625 693e
000626 006e          .db ">in",0
000627 061c          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
000628 1c58          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
000629 0018          .dw USER_TO_IN
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PAD:
00062a ff03          .dw $ff03
00062b 6170
00062c 0064          .db "pad",0
00062d 0624          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
00062e 1c01          .dw DO_COLON
                 PFA_PAD:
                 .endif
00062f 0669          .dw XT_HERE
000630 1c3d          .dw XT_DOLITERAL
000631 0028          .dw 40
000632 1d9d          .dw XT_PLUS
000633 1c20          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMIT:
000634 ff04          .dw $ff04
000635 6d65
000636 7469          .db "emit"
000637 062a          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
000638 0cd9          .dw PFA_DODEFER1
                 PFA_EMIT:
                 .endif
000639 000e          .dw USER_EMIT
00063a 0ca2          .dw XT_UDEFERFETCH
00063b 0cae          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMITQ:
00063c ff05          .dw $ff05
00063d 6d65
00063e 7469
00063f 003f          .db "emit?",0
000640 0634          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
000641 0cd9          .dw PFA_DODEFER1
                 PFA_EMITQ:
                 .endif
000642 0010          .dw USER_EMITQ
000643 0ca2          .dw XT_UDEFERFETCH
000644 0cae          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEY:
000645 ff03          .dw $ff03
000646 656b
000647 0079          .db "key",0
000648 063c          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
000649 0cd9          .dw PFA_DODEFER1
                 PFA_KEY:
                 .endif
00064a 0012          .dw USER_KEY
00064b 0ca2          .dw XT_UDEFERFETCH
00064c 0cae          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEYQ:
00064d ff04          .dw $ff04
00064e 656b
00064f 3f79          .db "key?"
000650 0645          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
000651 0cd9          .dw PFA_DODEFER1
                 PFA_KEYQ:
                 .endif
000652 0014          .dw USER_KEYQ
000653 0ca2          .dw XT_UDEFERFETCH
000654 0cae          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
000655 ff02          .dw $ff02
000656 7064          .db "dp"
000657 064d          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
000658 1c6f          .dw PFA_DOVALUE1
                 PFA_DP:
000659 002c          .dw CFG_DP
00065a 0c7a          .dw XT_EDEFERFETCH
00065b 0c84          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
00065c ff05          .dw $ff05
00065d 6865
00065e 7265
00065f 0065          .db "ehere",0
000660 0655          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
000661 1c6f          .dw PFA_DOVALUE1
                 PFA_EHERE:
000662 0030          .dw EE_EHERE
000663 0c7a          .dw XT_EDEFERFETCH
000664 0c84          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
000665 ff04          .dw $ff04
000666 6568
000667 6572          .db "here"
000668 065c          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
000669 1c6f          .dw PFA_DOVALUE1
                 PFA_HERE:
00066a 002e          .dw EE_HERE
00066b 0c7a          .dw XT_EDEFERFETCH
00066c 0c84          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
00066d ff05          .dw $ff05
00066e 6c61
00066f 6f6c
000670 0074          .db "allot",0
000671 0665          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
000672 1c01          .dw DO_COLON
                 PFA_ALLOT:
000673 0669          .dw XT_HERE
000674 1d9d          .dw XT_PLUS
000675 0c5f          .dw XT_DOTO
000676 066a          .dw PFA_HERE
000677 1c20          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
000678 ff03          .dw $ff03
000679 6962
00067a 006e          .db "bin",0
00067b 066d          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
00067c 1c01          .dw DO_COLON
                 PFA_BIN:
                 .endif
00067d 1fe2          .dw XT_TWO
00067e 05fa          .dw XT_BASE
00067f 1c81          .dw XT_STORE
000680 1c20          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
000681 ff07          .dw $ff07
000682 6564
000683 6963
000684 616d
000685 006c          .db "decimal",0
000686 0678          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
000687 1c01          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
000688 1c3d          .dw XT_DOLITERAL
000689 000a          .dw 10
00068a 05fa          .dw XT_BASE
00068b 1c81          .dw XT_STORE
00068c 1c20          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
00068d ff03          .dw $ff03
00068e 6568
00068f 0078          .db "hex",0
000690 0681          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
000691 1c01          .dw DO_COLON
                 PFA_HEX:
                 .endif
000692 1c3d          .dw XT_DOLITERAL
000693 0010          .dw 16
000694 05fa          .dw XT_BASE
000695 1c81          .dw XT_STORE
000696 1c20          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
000697 ff02          .dw $ff02
000698 6c62          .db "bl"
000699 068d          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
00069a 1c48          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
00069b 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
00069c ff07          .dw $ff07
00069d 7574
00069e 6e72
00069f 656b
0006a0 0079          .db "turnkey",0
0006a1 0697          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
0006a2 0cd9          .dw PFA_DODEFER1
                 PFA_TURNKEY:
0006a3 0038          .dw CFG_TURNKEY
0006a4 0c7a          .dw XT_EDEFERFETCH
0006a5 0c84          .dw XT_EDEFERSTORE
                 
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
0006a6 ff04          .dw $ff04
0006a7 6d2f
0006a8 646f          .db "/mod"
0006a9 069c          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
0006aa 06ab          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
0006ab 019c          movw temp2, tosl
                     
0006ac 9109          ld temp0, Y+
0006ad 9119          ld temp1, Y+
                 
0006ae 2f41          mov	temp6,temp1	;move dividend High to sign register
0006af 2743          eor	temp6,temp3	;xor divisor High with sign register
0006b0 ff17          sbrs	temp1,7	;if MSB in dividend set
0006b1 c004          rjmp	PFA_SLASHMOD_1
0006b2 9510          com	temp1		;    change sign of dividend
0006b3 9500          com	temp0		
0006b4 5f0f          subi	temp0,low(-1)
0006b5 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
0006b6 ff37          sbrs	temp3,7	;if MSB in divisor set
0006b7 c004          rjmp	PFA_SLASHMOD_2
0006b8 9530          com	temp3		;    change sign of divisor
0006b9 9520          com	temp2		
0006ba 5f2f          subi	temp2,low(-1)
0006bb 4f3f          sbci	temp3,high(-1)
0006bc 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
0006bd 18ff          sub	temp5,temp5;clear remainder High byte and carry
0006be e151          ldi	temp7,17	;init loop counter
                 
0006bf 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
0006c0 1f11          rol	temp1
0006c1 955a          dec	temp7		;decrement counter
0006c2 f439          brne	PFA_SLASHMOD_5		;if done
0006c3 ff47          sbrs	temp6,7		;    if MSB in sign register set
0006c4 c004          rjmp	PFA_SLASHMOD_4
0006c5 9510          com	temp1	;        change sign of result
0006c6 9500          com	temp0
0006c7 5f0f          subi	temp0,low(-1)
0006c8 4f1f          sbci	temp1,high(-1)
0006c9 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
0006ca 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
0006cb 1cff          rol	temp5
0006cc 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
0006cd 0af3          sbc	temp5,temp3	;
0006ce f420          brcc	PFA_SLASHMOD_6		;if result negative
0006cf 0ee2          add	temp4,temp2	;    restore remainder
0006d0 1ef3          adc	temp5,temp3
0006d1 9488          clc			;    clear carry to be shifted into result
0006d2 cfec          rjmp	PFA_SLASHMOD_3		;else
0006d3 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
0006d4 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
0006d5 92fa          st -Y,temp5
0006d6 92ea          st -Y,temp4
                 
                     ; put quotient on stack
0006d7 01c8          movw tosl, temp0
0006d8 940c 1c05     jmp_ DO_NEXT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
0006da ff05          .dw $ff05
0006db 2f75
0006dc 6f6d
0006dd 0064          .db "u/mod",0
0006de 06a6          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
0006df 1c01          .dw DO_COLON
                 PFA_USLASHMOD:
0006e0 1cff          .dw XT_TO_R
0006e1 1d54          .dw XT_ZERO
0006e2 1cf6          .dw XT_R_FROM
0006e3 1dc2          .dw XT_UMSLASHMOD
0006e4 1c20          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
0006e5 ff06          .dw $ff06
0006e6 656e
0006e7 6167
0006e8 6574          .db "negate"
0006e9 06da          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
0006ea 1c01          .dw DO_COLON
                 PFA_NEGATE:
0006eb 1dfd          .dw XT_INVERT
0006ec 1e2f          .dw XT_1PLUS
0006ed 1c20          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
0006ee ff01          .dw $ff01
0006ef 002f          .db "/",0
0006f0 06e5          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
0006f1 1c01          .dw DO_COLON
                 PFA_SLASH:
                 .endif
0006f2 06aa          .dw XT_SLASHMOD
0006f3 1cf0          .dw XT_NIP
0006f4 1c20          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
0006f5 ff03          .dw $ff03
0006f6 6f6d
0006f7 0064          .db "mod",0
0006f8 06ee          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
0006f9 1c01          .dw DO_COLON
                 PFA_MOD:
                 .endif
0006fa 06aa          .dw XT_SLASHMOD
0006fb 1cd9          .dw XT_DROP
0006fc 1c20          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ;   DUP ?NEGATE ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABS:
0006fd ff03          .dw $ff03
0006fe 6261
0006ff 0073          .db "abs",0
000700 06f5          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
000701 1c01          .dw DO_COLON
                 PFA_ABS:
                 
                 .endif
                 
000702 1cb1
000703 1e3e
000704 1c20          .DW XT_DUP,XT_QNEGATE,XT_EXIT
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
000705 ff03          .dw $ff03
000706 696d
000707 006e          .db "min",0
000708 06fd          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
000709 1c01          .dw DO_COLON
                 PFA_MIN:
                 .endif
00070a 060f          .dw XT_2DUP
00070b 1d78          .dw XT_GREATER
00070c 1c36          .dw XT_DOCONDBRANCH
00070d 070f          DEST(PFA_MIN1)
00070e 1cc4          .dw XT_SWAP
                 PFA_MIN1:
00070f 1cd9          .dw XT_DROP
000710 1c20          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
000711 ff03          .dw $ff03
000712 616d
000713 0078          .db "max",0
000714 0705          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
000715 1c01          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
000716 060f          .dw XT_2DUP
000717 1d6e          .dw XT_LESS
000718 1c36          .dw XT_DOCONDBRANCH
000719 071b          DEST(PFA_MAX1)
00071a 1cc4          .dw XT_SWAP
                 PFA_MAX1:
00071b 1cd9          .dw XT_DROP
00071c 1c20          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
00071d ff06          .dw $ff06
00071e 6977
00071f 6874
000720 6e69          .db "within"
000721 0711          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
000722 1c01          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
000723 1ccf          .dw XT_OVER
000724 1d93          .dw XT_MINUS
000725 1cff          .dw XT_TO_R
000726 1d93          .dw XT_MINUS
000727 1cf6          .dw XT_R_FROM
000728 1d5c          .dw XT_ULESS
000729 1c20          .dw XT_EXIT
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
00072a ff07          .dw $ff07 
00072b 6f74
00072c 7075
00072d 6570
00072e 0072          .db "toupper",0
00072f 071d          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
000730 1c01          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
000731 1cb1          .dw XT_DUP 
000732 1c3d          .dw XT_DOLITERAL 
000733 0061          .dw 'a' 
000734 1c3d          .dw XT_DOLITERAL 
000735 007b          .dw 'z'+1
000736 0722          .dw XT_WITHIN 
000737 1c36          .dw XT_DOCONDBRANCH
000738 073c          DEST(PFA_TOUPPER0)
000739 1c3d          .dw XT_DOLITERAL
00073a 00df          .dw 223 ; inverse of 0x20: 0xdf
00073b 1e13          .dw XT_AND 
                 PFA_TOUPPER0:
00073c 1c20          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
00073d ff07          .dw $ff07
00073e 6f74
00073f 6f6c
000740 6577
000741 0072          .db "tolower",0
000742 072a          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
000743 1c01          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
000744 1cb1          .dw XT_DUP
000745 1c3d          .dw XT_DOLITERAL
000746 0041          .dw 'A'
000747 1c3d          .dw XT_DOLITERAL
000748 005b          .dw 'Z'+1
000749 0722          .dw XT_WITHIN
00074a 1c36          .dw XT_DOCONDBRANCH
00074b 074f          DEST(PFA_TOLOWER0)
00074c 1c3d          .dw XT_DOLITERAL
00074d 0020          .dw 32
00074e 1e1c          .dw XT_OR 
                 PFA_TOLOWER0:
00074f 1c20          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
000750 ff03          .dw $ff03
000751 6c68
000752 0064          .db "hld",0
000753 073d          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
000754 1c48          .dw PFA_DOVARIABLE
                 PFA_HLD:
000755 0091          .dw ram_hld
                 
                 .dseg
000091           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
000756 ff04          .dw $ff04
000757 6f68
000758 646c          .db "hold"
000759 0750          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
00075a 1c01          .dw DO_COLON
                 PFA_HOLD:
                 .endif
00075b 0754          .dw XT_HLD
00075c 1cb1          .dw XT_DUP
00075d 1c79          .dw XT_FETCH
00075e 1e35          .dw XT_1MINUS
00075f 1cb1          .dw XT_DUP
000760 1cff          .dw XT_TO_R
000761 1cc4          .dw XT_SWAP
000762 1c81          .dw XT_STORE
000763 1cf6          .dw XT_R_FROM
000764 1c8d          .dw XT_CSTORE
000765 1c20          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
000766 ff02          .dw $ff02
000767 233c          .db "<#"
000768 0756          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
000769 1c01          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
00076a 062e          .dw XT_PAD
00076b 0754          .dw XT_HLD
00076c 1c81          .dw XT_STORE
00076d 1c20          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
00076e ff01          .dw $ff01
00076f 0023          .db "#",0
000770 0766          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
000771 1c01          .dw DO_COLON
                 PFA_SHARP:
                 .endif
000772 05fa          .dw XT_BASE
000773 1c79          .dw XT_FETCH
000774 07ee          .dw XT_UDSLASHMOD
000775 1ce1          .dw XT_ROT
000776 1c3d          .dw XT_DOLITERAL
000777 0009          .dw 9
000778 1ccf          .dw XT_OVER
000779 1d6e          .dw XT_LESS
00077a 1c36          .dw XT_DOCONDBRANCH
00077b 077f          DEST(PFA_SHARP1)
00077c 1c3d          .dw XT_DOLITERAL
00077d 0007          .dw 7
00077e 1d9d          .dw XT_PLUS
                 PFA_SHARP1:
00077f 1c3d          .dw XT_DOLITERAL
000780 0030          .dw 48 ; ASCII 0
000781 1d9d          .dw XT_PLUS
000782 075a          .dw XT_HOLD
000783 1c20          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
000784 ff02          .dw $ff02
000785 7323          .db "#s"
000786 076e          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
000787 1c01          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
000788 0771          .dw XT_SHARP
000789 060f          .dw XT_2DUP
00078a 1e1c          .dw XT_OR
00078b 1d18          .dw XT_ZEROEQUAL
00078c 1c36          .dw XT_DOCONDBRANCH
00078d 0788          DEST(NUMS1) ; PFA_SHARP_S
00078e 1c20          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
00078f ff02          .dw $ff02
000790 3e23          .db "#>"
000791 0784          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
000792 1c01          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
000793 0618          .dw XT_2DROP
000794 0754          .dw XT_HLD
000795 1c79          .dw XT_FETCH
000796 062e          .dw XT_PAD
000797 1ccf          .dw XT_OVER
000798 1d93          .dw XT_MINUS
000799 1c20          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
00079a ff04          .dw $ff04
00079b 6973
00079c 6e67          .db "sign"
00079d 078f          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
00079e 1c01          .dw DO_COLON
                 PFA_SIGN:
                 .endif
00079f 1d1f          .dw XT_ZEROLESS
0007a0 1c36          .dw XT_DOCONDBRANCH
0007a1 07a5          DEST(PFA_SIGN1)
0007a2 1c3d          .dw XT_DOLITERAL
0007a3 002d          .dw 45 ; ascii -
0007a4 075a          .dw XT_HOLD
                 PFA_SIGN1:
0007a5 1c20          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
0007a6 ff03          .dw $ff03
0007a7 2e64
0007a8 0072          .db "d.r",0
0007a9 079a          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
0007aa 1c01          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
0007ab 1cff          .dw XT_TO_R
0007ac 0620          .dw XT_TUCK
0007ad 0d9a          .dw XT_DABS
0007ae 0769          .dw XT_L_SHARP
0007af 0787          .dw XT_SHARP_S
0007b0 1ce1          .dw XT_ROT
0007b1 079e          .dw XT_SIGN
0007b2 0792          .dw XT_SHARP_G
0007b3 1cf6          .dw XT_R_FROM
0007b4 1ccf          .dw XT_OVER
0007b5 1d93          .dw XT_MINUS
0007b6 0896          .dw XT_SPACES
0007b7 08a6          .dw XT_TYPE
0007b8 1c20          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
0007b9 ff02          .dw $ff02
0007ba 722e          .db ".r"
0007bb 07a6          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
0007bc 1c01          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
0007bd 1cff          .dw XT_TO_R
0007be 0e2d          .dw XT_S2D
0007bf 1cf6          .dw XT_R_FROM
0007c0 07aa          .dw XT_DDOTR
0007c1 1c20          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
0007c2 ff02          .dw $ff02
0007c3 2e64          .db "d."
0007c4 07b9          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
0007c5 1c01          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
0007c6 1d54          .dw XT_ZERO
0007c7 07aa          .dw XT_DDOTR
0007c8 088d          .dw XT_SPACE
0007c9 1c20          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
0007ca ff01          .dw $ff01
0007cb 002e          .db ".",0
0007cc 07c2          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
0007cd 1c01          .dw DO_COLON
                 PFA_DOT:
                 .endif
0007ce 0e2d          .dw XT_S2D
0007cf 07c5          .dw XT_DDOT
0007d0 1c20          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
0007d1 ff03          .dw $ff03
0007d2 6475
0007d3 002e          .db "ud.",0
0007d4 07ca          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
0007d5 1c01          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
0007d6 1d54          .dw XT_ZERO
0007d7 07de          .dw XT_UDDOTR
0007d8 088d          .dw XT_SPACE
0007d9 1c20          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
0007da ff04          .dw $ff04
0007db 6475
0007dc 722e          .db "ud.r"
0007dd 07d1          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
0007de 1c01          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
0007df 1cff          .dw XT_TO_R
0007e0 0769          .dw XT_L_SHARP
0007e1 0787          .dw XT_SHARP_S
0007e2 0792          .dw XT_SHARP_G
0007e3 1cf6          .dw XT_R_FROM
0007e4 1ccf          .dw XT_OVER
0007e5 1d93          .dw XT_MINUS
0007e6 0896          .dw XT_SPACES
0007e7 08a6          .dw XT_TYPE
0007e8 1c20          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
0007e9 ff06          .dw $ff06
0007ea 6475
0007eb 6d2f
0007ec 646f          .db "ud/mod"
0007ed 07da          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
0007ee 1c01          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
0007ef 1cff          .dw XT_TO_R
0007f0 1d54          .dw XT_ZERO
0007f1 1d06          .dw XT_R_FETCH
0007f2 1dc2          .dw XT_UMSLASHMOD
0007f3 1cf6          .dw XT_R_FROM
0007f4 1cc4          .dw XT_SWAP
0007f5 1cff          .dw XT_TO_R
0007f6 1dc2          .dw XT_UMSLASHMOD
0007f7 1cf6          .dw XT_R_FROM
0007f8 1c20          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
0007f9 ff06          .dw $ff06 
0007fa 6964
0007fb 6967
0007fc 3f74          .db "digit?"
0007fd 07e9          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
0007fe 1c01          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
0007ff 0730          .dw XT_TOUPPER
000800 1cb1
000801 1c3d
000802 0039
000803 1d78
000804 1c3d
000805 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
000806 1e13
000807 1d9d
000808 1cb1
000809 1c3d
00080a 0140
00080b 1d78          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
00080c 1c3d
00080d 0107
00080e 1e13
00080f 1d93
000810 1c3d
000811 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
000812 1d93
000813 1cb1
000814 05fa
000815 1c79
000816 1d5c          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
000817 1c20          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
000818 1c01        .dw DO_COLON
                 PFA_DOSLITERAL:
000819 1d06        .dw XT_R_FETCH   ; ( -- addr )
00081a 0877        .dw XT_ICOUNT
00081b 1cf6        .dw XT_R_FROM
00081c 1ccf        .dw XT_OVER     ; ( -- addr' n addr n)
00081d 1e2f        .dw XT_1PLUS
00081e 1e04        .dw XT_2SLASH   ; ( -- addr' n addr k )
00081f 1d9d        .dw XT_PLUS     ; ( -- addr' n addr'' )
000820 1e2f        .dw XT_1PLUS
000821 1cff        .dw XT_TO_R     ; ( -- )
000822 1c20        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
000823 ff02        .dw $ff02
000824 2c73        .db "s",$2c
000825 07f9        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
000826 1c01          .dw DO_COLON
                 PFA_SCOMMA:
000827 1cb1          .dw XT_DUP
000828 082a          .dw XT_DOSCOMMA
000829 1c20          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
00082a 1c01          .dw DO_COLON
                 PFA_DOSCOMMA:
00082b 02d6          .dw XT_COMMA
00082c 1cb1          .dw XT_DUP   ; ( --addr len len)
00082d 1e04          .dw XT_2SLASH ; ( -- addr len len/2
00082e 0620          .dw XT_TUCK   ; ( -- addr len/2 len len/2
00082f 1e0b          .dw XT_2STAR  ; ( -- addr len/2 len len'
000830 1d93          .dw XT_MINUS  ; ( -- addr len/2 rem
000831 1cff          .dw XT_TO_R
000832 1d54          .dw XT_ZERO
000833 0395          .dw XT_QDOCHECK
000834 1c36          .dw XT_DOCONDBRANCH
000835 083d          .dw PFA_SCOMMA2
000836 1e9b          .dw XT_DODO
                 PFA_SCOMMA1:
000837 1cb1          .dw XT_DUP         ; ( -- addr addr )
000838 1c79          .dw XT_FETCH       ; ( -- addr c1c2 )
000839 02d6          .dw XT_COMMA       ; ( -- addr )
00083a 0607          .dw XT_CELLPLUS    ; ( -- addr+cell )
00083b 1ec9          .dw XT_DOLOOP
00083c 0837          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
00083d 1cf6          .dw XT_R_FROM
00083e 1d26          .dw XT_GREATERZERO
00083f 1c36          .dw XT_DOCONDBRANCH
000840 0844          .dw PFA_SCOMMA3
000841 1cb1            .dw XT_DUP     ; well, tricky
000842 1c98            .dw XT_CFETCH
000843 02d6            .dw XT_COMMA
                 PFA_SCOMMA3:
000844 1cd9          .dw XT_DROP        ; ( -- )
000845 1c20          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
000846 ff05          .dw $ff05
000847 7469
000848 7079
000849 0065          .db "itype",0
00084a 0823          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
00084b 1c01          .dw DO_COLON
                 PFA_ITYPE:
00084c 1cb1          .dw XT_DUP    ; ( --addr len len)
00084d 1e04          .dw XT_2SLASH ; ( -- addr len len/2
00084e 0620          .dw XT_TUCK   ; ( -- addr len/2 len len/2
00084f 1e0b          .dw XT_2STAR  ; ( -- addr len/2 len len'
000850 1d93          .dw XT_MINUS  ; ( -- addr len/2 rem
000851 1cff          .dw XT_TO_R
000852 1d54          .dw XT_ZERO
000853 0395          .dw XT_QDOCHECK
000854 1c36          .dw XT_DOCONDBRANCH
000855 085f          .dw PFA_ITYPE2
000856 1e9b          .dw XT_DODO
                 PFA_ITYPE1:
000857 1cb1          .dw XT_DUP         ; ( -- addr addr )
000858 1fc1          .dw XT_FETCHI      ; ( -- addr c1c2 )
000859 1cb1          .dw XT_DUP
00085a 086c          .dw XT_LOWEMIT
00085b 0868          .dw XT_HIEMIT
00085c 1e2f          .dw XT_1PLUS    ; ( -- addr+cell )
00085d 1ec9          .dw XT_DOLOOP
00085e 0857          .dw PFA_ITYPE1
                 PFA_ITYPE2:
00085f 1cf6          .dw XT_R_FROM
000860 1d26          .dw XT_GREATERZERO
000861 1c36          .dw XT_DOCONDBRANCH
000862 0866          .dw PFA_ITYPE3
000863 1cb1            .dw XT_DUP     ; make sure the drop below has always something to do
000864 1fc1            .dw XT_FETCHI
000865 086c            .dw XT_LOWEMIT
                 PFA_ITYPE3:
000866 1cd9          .dw XT_DROP
000867 1c20          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
000868 1c01          .dw DO_COLON
                 PFA_HIEMIT:
000869 1ef9          .dw XT_BYTESWAP
00086a 086c          .dw XT_LOWEMIT
00086b 1c20          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
00086c 1c01          .dw DO_COLON
                 PFA_LOWEMIT:
00086d 1c3d          .dw XT_DOLITERAL
00086e 00ff          .dw $00ff
00086f 1e13          .dw XT_AND
000870 0638          .dw XT_EMIT
000871 1c20          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
000872 ff06          .dw $ff06
000873 6369
000874 756f
000875 746e          .db "icount"
000876 0846          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
000877 1c01          .dw DO_COLON
                 PFA_ICOUNT:
000878 1cb1          .dw XT_DUP
000879 1e2f          .dw XT_1PLUS
00087a 1cc4          .dw XT_SWAP
00087b 1fc1          .dw XT_FETCHI
00087c 1c20          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
00087d ff02          .dw 0xff02
00087e 7263          .db "cr"
00087f 0872          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
000880 1c01          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
000881 1c3d          .dw XT_DOLITERAL
000882 000d          .dw 13
000883 0638          .dw XT_EMIT
000884 1c3d          .dw XT_DOLITERAL
000885 000a          .dw 10
000886 0638          .dw XT_EMIT
000887 1c20          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
000888 ff05          .dw $ff05
000889 7073
00088a 6361
00088b 0065          .db "space",0
00088c 087d          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
00088d 1c01          .dw DO_COLON
                 PFA_SPACE:
                 .endif
00088e 069a          .dw XT_BL
00088f 0638          .dw XT_EMIT
000890 1c20          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
000891 ff06          .dw $ff06
000892 7073
000893 6361
000894 7365          .db "spaces"
000895 0888          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
000896 1c01          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
000897 1d54
000898 0715      	.DW XT_ZERO, XT_MAX
000899 1cb1
00089a 1c36      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
00089b 08a0              DEST(SPCS2)
00089c 088d
00089d 1e35
00089e 1c2f              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
00089f 0899              DEST(SPCS1)
0008a0 1cd9
0008a1 1c20      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
0008a2 ff04          .dw $ff04
0008a3 7974
0008a4 6570          .db "type"
0008a5 0891          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
0008a6 1c01          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
0008a7 0e24          .dw XT_BOUNDS
0008a8 0395          .dw XT_QDOCHECK
0008a9 1c36          .dw XT_DOCONDBRANCH
0008aa 08b1          DEST(PFA_TYPE2)
0008ab 1e9b          .dw XT_DODO
                 PFA_TYPE1:
0008ac 1eac          .dw XT_I
0008ad 1c98          .dw XT_CFETCH
0008ae 0638          .dw XT_EMIT
0008af 1ec9          .dw XT_DOLOOP
0008b0 08ac          DEST(PFA_TYPE1)
                 PFA_TYPE2:
0008b1 1c20          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
0008b2 ff01          .dw $ff01
0008b3 0027          .db "'",0
0008b4 08a2          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
0008b5 1c01          .dw DO_COLON
                 PFA_TICK:
                 .endif
0008b6 0a69          .dw XT_PARSENAME
0008b7 0b96          .dw XT_FORTHRECOGNIZER
0008b8 0b6c          .dw XT_RECOGNIZE
                     ; a word is tickable unless RECTYPE-TOKEN is RECTYPE-NULL or 
                     ; the interpret action is a NOOP
0008b9 1cb1          .dw XT_DUP
0008ba 0c10          .dw XT_RECTYPE_NULL
0008bb 1fd6          .dw XT_EQUAL
0008bc 1cc4          .dw XT_SWAP
0008bd 1fc1          .dw XT_FETCHI
0008be 1c3d          .dw XT_DOLITERAL
0008bf 0c45          .dw XT_NOOP
0008c0 1fd6          .dw XT_EQUAL
0008c1 1e1c          .dw XT_OR
0008c2 1c36          .dw XT_DOCONDBRANCH
0008c3 08c7          DEST(PFA_TICK1)
0008c4 1c3d            .dw XT_DOLITERAL
0008c5 fff3            .dw -13
0008c6 08ec            .dw XT_THROW
                 PFA_TICK1:
0008c7 1cd9          .dw XT_DROP
0008c8 1c20          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
0008c9 ff07          .dw $ff07
0008ca 6168
0008cb 646e
0008cc 656c
0008cd 0072          .db "handler",0
0008ce 08b2          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
0008cf 1c58          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
0008d0 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
0008d1 ff05          .dw $ff05
0008d2 6163
0008d3 6374
0008d4 0068          .db "catch",0
0008d5 08c9          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
0008d6 1c01          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
0008d7 1e8d          .dw XT_SP_FETCH
0008d8 1cff          .dw XT_TO_R
                     ; handler @ >r
0008d9 08cf          .dw XT_HANDLER
0008da 1c79          .dw XT_FETCH
0008db 1cff          .dw XT_TO_R
                     ; rp@ handler !
0008dc 1e76          .dw XT_RP_FETCH
0008dd 08cf          .dw XT_HANDLER
0008de 1c81          .dw XT_STORE
0008df 1c2a          .dw XT_EXECUTE
                     ; r> handler !
0008e0 1cf6          .dw XT_R_FROM
0008e1 08cf          .dw XT_HANDLER
0008e2 1c81          .dw XT_STORE
0008e3 1cf6          .dw XT_R_FROM
0008e4 1cd9          .dw XT_DROP
0008e5 1d54          .dw XT_ZERO
0008e6 1c20          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
0008e7 ff05          .dw $ff05
0008e8 6874
0008e9 6f72
0008ea 0077          .db "throw",0
0008eb 08d1          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
0008ec 1c01          .dw DO_COLON
                 PFA_THROW:
                 .endif
0008ed 1cb9          .dw XT_QDUP
0008ee 1c36          .dw XT_DOCONDBRANCH
0008ef 08fc          DEST(PFA_THROW1)
0008f0 08cf            .dw XT_HANDLER
0008f1 1c79            .dw XT_FETCH
0008f2 1e80            .dw XT_RP_STORE
0008f3 1cf6            .dw XT_R_FROM
0008f4 08cf            .dw XT_HANDLER
0008f5 1c81            .dw XT_STORE
0008f6 1cf6            .dw XT_R_FROM
0008f7 1cc4            .dw XT_SWAP
0008f8 1cff            .dw XT_TO_R
0008f9 1e96            .dw XT_SP_STORE
0008fa 1cd9            .dw XT_DROP
0008fb 1cf6            .dw XT_R_FROM    
                 PFA_THROW1:
0008fc 1c20          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
0008fd ff05          .dw $ff05
0008fe 7363
0008ff 696b
000900 0070          .db "cskip",0
000901 08e7          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
000902 1c01          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
000903 1cff          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
000904 1cb1          .dw XT_DUP            ; ( -- addr' n' n' )
000905 1c36          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000906 0911          DEST(PFA_CSKIP2)
000907 1ccf          .dw XT_OVER           ; ( -- addr' n' addr' )
000908 1c98          .dw XT_CFETCH         ; ( -- addr' n' c' )
000909 1d06          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
00090a 1fd6          .dw XT_EQUAL          ; ( -- addr' n' f )
00090b 1c36          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00090c 0911          DEST(PFA_CSKIP2)
00090d 1fdd          .dw XT_ONE
00090e 0a5a          .dw XT_SLASHSTRING
00090f 1c2f          .dw XT_DOBRANCH
000910 0904          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
000911 1cf6          .dw XT_R_FROM
000912 1cd9          .dw XT_DROP           ; ( -- addr2 n2)
000913 1c20          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
000914 ff05          .dw $ff05
000915 7363
000916 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
000917 006e          .db "cscan"
000918 08fd          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
000919 1c01          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
00091a 1cff          .dw XT_TO_R
00091b 1ccf          .dw XT_OVER
                 PFA_CSCAN1:
00091c 1cb1          .dw XT_DUP
00091d 1c98          .dw XT_CFETCH
00091e 1d06          .dw XT_R_FETCH
00091f 1fd6          .dw XT_EQUAL
000920 1d18          .dw XT_ZEROEQUAL
000921 1c36          .dw XT_DOCONDBRANCH
000922 092e          DEST(PFA_CSCAN2)
000923 1cc4            .dw XT_SWAP
000924 1e35            .dw XT_1MINUS
000925 1cc4            .dw XT_SWAP
000926 1ccf            .dw XT_OVER
000927 1d1f            .dw XT_ZEROLESS ; not negative
000928 1d18            .dw XT_ZEROEQUAL
000929 1c36            .dw XT_DOCONDBRANCH
00092a 092e            DEST(PFA_CSCAN2)
00092b 1e2f              .dw XT_1PLUS
00092c 1c2f              .dw XT_DOBRANCH
00092d 091c              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
00092e 1cf0          .dw XT_NIP
00092f 1ccf          .dw XT_OVER
000930 1d93          .dw XT_MINUS
000931 1cf6          .dw XT_R_FROM
000932 1cd9          .dw XT_DROP
000933 1c20          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
000934 ff06          .dw $ff06
000935 6361
000936 6563
000937 7470          .db "accept"
000938 0914          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
000939 1c01          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
00093a 1ccf
00093b 1d9d
00093c 1ccf              .DW XT_OVER,XT_PLUS,XT_OVER
00093d 0649
00093e 1cb1
00093f 0982
000940 1d18
000941 1c36      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
000942 0975              DEST(ACC5)
000943 1cb1
000944 1c3d
000945 0008
000946 1fd6
000947 1c36              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
000948 095b              DEST(ACC3)
000949 1cd9
00094a 1ce1
00094b 060f
00094c 1d78
00094d 1cff
00094e 1ce1
00094f 1ce1
000950 1cf6
000951 1c36              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
000952 0959      	DEST(ACC6)
000953 097a
000954 1e35
000955 1cff
000956 1ccf
000957 1cf6
000958 0151      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
000959 1c2f      ACC6:   .DW XT_DOBRANCH
00095a 0973              DEST(ACC4)
                     
                 
                 ACC3:    ; check for remaining control characters, replace them with blank
00095b 1cb1      	.dw XT_DUP            ; ( -- addr k k )
00095c 069a              .dw XT_BL
00095d 1d6e              .dw XT_LESS
00095e 1c36              .dw XT_DOCONDBRANCH
00095f 0962              DEST(PFA_ACCEPT6)
000960 1cd9              .dw XT_DROP
000961 069a              .dw XT_BL
                 PFA_ACCEPT6:
000962 1cff
000963 060f
000964 1d78
000965 1cf6
000966 1cc4
000967 1c36      	.DW XT_TO_R,XT_2DUP,XT_GREATER,XT_R_FROM,XT_SWAP,XT_DOCONDBRANCH
000968 0972              DEST(ACC7)
000969 1cb1
00096a 0638
00096b 1ccf
00096c 1c8d
00096d 1e2f
00096e 1ccf
00096f 015d                  .DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
000970 1c2f      	    .DW XT_DOBRANCH
000971 0973      	    DEST(ACC4)
000972 1cd9      ACC7:   .DW XT_DROP
000973 1c2f      ACC4:   .DW XT_DOBRANCH
000974 093d              DEST(ACC1)
000975 1cd9
000976 1cf0
000977 1cc4
000978 1d93
000979 1c20      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
00097a 1c01          .dw DO_COLON
                 .endif
00097b 1c3d          .dw XT_DOLITERAL
00097c 0008          .dw 8
00097d 1cb1          .dw XT_DUP
00097e 0638          .dw XT_EMIT
00097f 088d          .dw XT_SPACE
000980 0638          .dw XT_EMIT
000981 1c20          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
000982 1c01          .dw DO_COLON
                 .endif
000983 1cb1          .dw XT_DUP
000984 1c3d          .dw XT_DOLITERAL
000985 000d          .dw 13
000986 1fd6          .dw XT_EQUAL
000987 1cc4          .dw XT_SWAP
000988 1c3d          .dw XT_DOLITERAL
000989 000a          .dw 10
00098a 1fd6          .dw XT_EQUAL
00098b 1e1c          .dw XT_OR
00098c 1c20          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILL:
00098d ff06          .dw $ff06
00098e 6572
00098f 6966
000990 6c6c          .db "refill"
000991 0934          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
000992 0cd9          .dw PFA_DODEFER1
                 PFA_REFILL:
                 .endif
000993 001a          .dw USER_REFILL
000994 0ca2          .dw XT_UDEFERFETCH
000995 0cae          .dw XT_UDEFERSTORE
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
000996 ff04          .dw $ff04
000997 6863
000998 7261          .db "char"
000999 098d          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
00099a 1c01          .dw DO_COLON
                 PFA_CHAR:
                 .endif
00099b 0a69          .dw XT_PARSENAME
00099c 1d18
00099d 1c36          .dw XT_ZEROEQUAL,XT_DOCONDBRANCH 
00099e 09a2          DEST(CHAR_1)
00099f 1c3d
0009a0 fff0
0009a1 08ec             .dw XT_DOLITERAL, -16, XT_THROW
                 CHAR_1:
                 
0009a2 1c98          .dw XT_CFETCH
0009a3 1c20          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
0009a4 ff06          .dw $ff06
0009a5 756e
0009a6 626d
0009a7 7265          .db "number"
0009a8 0996          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
0009a9 1c01          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
0009aa 05fa          .dw XT_BASE
0009ab 1c79          .dw XT_FETCH
0009ac 1cff          .dw XT_TO_R
0009ad 09ed          .dw XT_QSIGN
0009ae 1cff          .dw XT_TO_R
0009af 0a00          .dw XT_SET_BASE
0009b0 09ed          .dw XT_QSIGN
0009b1 1cf6          .dw XT_R_FROM
0009b2 1e1c          .dw XT_OR
0009b3 1cff          .dw XT_TO_R
                     ; check whether something is left
0009b4 1cb1          .dw XT_DUP
0009b5 1d18          .dw XT_ZEROEQUAL
0009b6 1c36          .dw XT_DOCONDBRANCH
0009b7 09c0          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
0009b8 0618            .dw XT_2DROP
0009b9 1cf6            .dw XT_R_FROM
0009ba 1cd9            .dw XT_DROP
0009bb 1cf6            .dw XT_R_FROM
0009bc 05fa            .dw XT_BASE
0009bd 1c81            .dw XT_STORE
0009be 1d54            .dw XT_ZERO
0009bf 1c20            .dw XT_EXIT
                 PFA_NUMBER0:
0009c0 1f14          .dw XT_2TO_R
0009c1 1d54          .dw XT_ZERO       ; starting value
0009c2 1d54          .dw XT_ZERO
0009c3 1f23          .dw XT_2R_FROM
0009c4 0a1e          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
0009c5 1cb9          .dw XT_QDUP
0009c6 1c36          .dw XT_DOCONDBRANCH
0009c7 09e2          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
0009c8 1fdd          .dw XT_ONE
0009c9 1fd6          .dw XT_EQUAL
0009ca 1c36          .dw XT_DOCONDBRANCH
0009cb 09d9          DEST(PFA_NUMBER2)
                 	; excatly one character is left
0009cc 1c98      	.dw XT_CFETCH
0009cd 1c3d      	.dw XT_DOLITERAL
0009ce 002e      	.dw 46 ; .
0009cf 1fd6      	.dw XT_EQUAL
0009d0 1c36      	.dw XT_DOCONDBRANCH
0009d1 09da      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
0009d2 1cf6      	.dw XT_R_FROM
0009d3 1c36              .dw XT_DOCONDBRANCH
0009d4 09d6      	DEST(PFA_NUMBER3)
0009d5 0da7              .dw XT_DNEGATE
                 PFA_NUMBER3:
0009d6 1fe2      	.dw XT_TWO
0009d7 1c2f      	.dw XT_DOBRANCH
0009d8 09e8      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
0009d9 1cd9      	.dw XT_DROP
                 PFA_NUMBER6:
0009da 0618      	.dw XT_2DROP
0009db 1cf6      	.dw XT_R_FROM
0009dc 1cd9      	.dw XT_DROP
0009dd 1cf6              .dw XT_R_FROM
0009de 05fa              .dw XT_BASE
0009df 1c81              .dw XT_STORE
0009e0 1d54      	.dw XT_ZERO
0009e1 1c20      	.dw XT_EXIT
                 PFA_NUMBER1:
0009e2 0618          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
0009e3 1cf6          .dw XT_R_FROM
0009e4 1c36          .dw XT_DOCONDBRANCH
0009e5 09e7          DEST(PFA_NUMBER4)
0009e6 06ea          .dw XT_NEGATE
                 PFA_NUMBER4:
0009e7 1fdd          .dw XT_ONE
                 PFA_NUMBER5:
0009e8 1cf6          .dw XT_R_FROM
0009e9 05fa          .dw XT_BASE
0009ea 1c81          .dw XT_STORE
0009eb 1d4b          .dw XT_TRUE
0009ec 1c20          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
0009ed 1c01          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
0009ee 1ccf          .dw XT_OVER    ; ( -- addr len addr )
0009ef 1c98          .dw XT_CFETCH
0009f0 1c3d          .dw XT_DOLITERAL
0009f1 002d          .dw '-'
0009f2 1fd6          .dw XT_EQUAL  ; ( -- addr len flag )
0009f3 1cb1          .dw XT_DUP
0009f4 1cff          .dw XT_TO_R
0009f5 1c36          .dw XT_DOCONDBRANCH
0009f6 09f9          DEST(PFA_NUMBERSIGN_DONE)
0009f7 1fdd          .dw XT_ONE    ; skip sign character
0009f8 0a5a          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
0009f9 1cf6          .dw XT_R_FROM
0009fa 1c20          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
0009fb 1c52          .dw PFA_DOCONSTANT
                 .endif
0009fc 000a
0009fd 0010
0009fe 0002
0009ff 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
000a00 1c01          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
000a01 1ccf          .dw XT_OVER
000a02 1c98          .dw XT_CFETCH
000a03 1c3d          .dw XT_DOLITERAL
000a04 0023          .dw 35
000a05 1d93          .dw XT_MINUS
000a06 1cb1          .dw XT_DUP
000a07 1d54          .dw XT_ZERO
000a08 1c3d          .dw XT_DOLITERAL
000a09 0004          .dw 4
000a0a 0722          .dw XT_WITHIN
000a0b 1c36          .dw XT_DOCONDBRANCH
000a0c 0a16          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
000a0d 09fb      	.dw XT_BASES
000a0e 1d9d      	.dw XT_PLUS
000a0f 1fc1      	.dw XT_FETCHI
000a10 05fa      	.dw XT_BASE
000a11 1c81      	.dw XT_STORE
000a12 1fdd      	.dw XT_ONE
000a13 0a5a      	.dw XT_SLASHSTRING
000a14 1c2f      	.dw XT_DOBRANCH
000a15 0a17      	DEST(SET_BASE2)
                 SET_BASE1:
000a16 1cd9      	.dw XT_DROP
                 SET_BASE2:
000a17 1c20          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
000a18 ff07          .dw $ff07
000a19 6e3e
000a1a 6d75
000a1b 6562
000a1c 0072          .db ">number",0
000a1d 09a4          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
000a1e 1c01          .dw DO_COLON
                 
                 .endif
                 
000a1f 1cb1
000a20 1c36      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
000a21 0a36              DEST(TONUM3)
000a22 1ccf
000a23 1c98
000a24 07fe              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
000a25 1d18
000a26 1c36              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
000a27 0a2a              DEST(TONUM2)
000a28 1cd9
000a29 1c20              .DW XT_DROP,XT_EXIT
000a2a 1cff
000a2b 0dcb
000a2c 05fa
000a2d 1c79
000a2e 0142      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
000a2f 1cf6
000a30 013a
000a31 0dcb              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
000a32 1fdd
000a33 0a5a
000a34 1c2f              .DW XT_ONE,XT_SLASHSTRING,XT_DOBRANCH
000a35 0a1f              DEST(TONUM1)
000a36 1c20      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
000a37 ff05          .dw $ff05
000a38 6170
000a39 7372
000a3a 0065          .db "parse",0
000a3b 0a18          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
000a3c 1c01          .dw DO_COLON
                 PFA_PARSE:
                 .endif
000a3d 1cff          .dw XT_TO_R     ; ( -- )
000a3e 0a50          .dw XT_SOURCE   ; ( -- addr len)
000a3f 0628          .dw XT_TO_IN     ; ( -- addr len >in)
000a40 1c79          .dw XT_FETCH
000a41 0a5a          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
000a42 1cf6          .dw XT_R_FROM      ; ( -- addr' len' c)
000a43 0919          .dw XT_CSCAN       ; ( -- addr' len'')
000a44 1cb1          .dw XT_DUP         ; ( -- addr' len'' len'')
000a45 1e2f          .dw XT_1PLUS
000a46 0628          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
000a47 1e65          .dw XT_PLUSSTORE   ; ( -- addr' len')
000a48 1fdd          .dw XT_ONE
000a49 0a5a          .dw XT_SLASHSTRING
000a4a 1c20          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCE:
000a4b ff06          .dw $FF06
000a4c 6f73
000a4d 7275
000a4e 6563          .db "source"
000a4f 0a37          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
000a50 0cd9          .dw PFA_DODEFER1
                 PFA_SOURCE:
                 .endif
000a51 0016          .dw USER_SOURCE
000a52 0ca2          .dw XT_UDEFERFETCH
000a53 0cae          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
000a54 ff07          .dw $ff07
000a55 732f
000a56 7274
000a57 6e69
000a58 0067          .db "/string",0
000a59 0a4b          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
000a5a 1c01          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
000a5b 1ce1          .dw XT_ROT
000a5c 1ccf          .dw XT_OVER
000a5d 1d9d          .dw XT_PLUS
000a5e 1ce1          .dw XT_ROT
000a5f 1ce1          .dw XT_ROT
000a60 1d93          .dw XT_MINUS
000a61 1c20          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
000a62 ff0a          .dw $FF0A 
000a63 6170
000a64 7372
000a65 2d65
000a66 616e
000a67 656d          .db "parse-name"
000a68 0a54          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
000a69 1c01          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
000a6a 069a          .dw XT_BL
000a6b 0a6d          .dw XT_SKIPSCANCHAR
000a6c 1c20          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
000a6d 1c01          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
000a6e 1cff          .dw XT_TO_R
000a6f 0a50          .dw XT_SOURCE 
000a70 0628          .dw XT_TO_IN 
000a71 1c79          .dw XT_FETCH 
000a72 0a5a          .dw XT_SLASHSTRING 
                 
000a73 1d06          .dw XT_R_FETCH
000a74 0902          .dw XT_CSKIP
000a75 1cf6          .dw XT_R_FROM
000a76 0919          .dw XT_CSCAN
                 
                     ; adjust >IN
000a77 060f          .dw XT_2DUP
000a78 1d9d          .dw XT_PLUS
000a79 0a50          .dw XT_SOURCE 
000a7a 1cd9          .dw XT_DROP
000a7b 1d93          .dw XT_MINUS
000a7c 0628          .dw XT_TO_IN
000a7d 1c81          .dw XT_STORE
000a7e 1c20          .dw XT_EXIT
                 .include "words/find-xt.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the xt from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDXT:
000a7f ff07          .dw $ff07
000a80 6966
000a81 646e
000a82 782d
000a83 0074          .db "find-xt",0
000a84 0a62          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDXT
                 XT_FINDXT:
000a85 1c01          .dw DO_COLON
                 PFA_FINDXT:
                 .endif
000a86 1c3d          .dw XT_DOLITERAL
000a87 0a91          .dw XT_FINDXTA
000a88 1c3d          .dw XT_DOLITERAL
000a89 0040          .dw CFG_ORDERLISTLEN
000a8a 0516          .dw XT_MAPSTACK
000a8b 1d18          .dw XT_ZEROEQUAL
000a8c 1c36          .dw XT_DOCONDBRANCH
000a8d 0a90          DEST(PFA_FINDXT1)
000a8e 0618            .dw XT_2DROP
000a8f 1d54            .dw XT_ZERO
                 PFA_FINDXT1:
000a90 1c20          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDXTA:
000a91 1c01          .dw DO_COLON
                 PFA_FINDXTA:
                 .endif
000a92 1cff          .dw XT_TO_R
000a93 060f          .dw XT_2DUP
000a94 1cf6          .dw XT_R_FROM
000a95 0ceb          .dw XT_SEARCH_WORDLIST
000a96 1cb1          .dw XT_DUP
000a97 1c36          .dw XT_DOCONDBRANCH
000a98 0a9e          DEST(PFA_FINDXTA1)
000a99 1cff            .dw XT_TO_R
000a9a 1cf0            .dw XT_NIP
000a9b 1cf0            .dw XT_NIP
000a9c 1cf6            .dw XT_R_FROM
000a9d 1d4b            .dw XT_TRUE
                 PFA_FINDXTA1:
000a9e 1c20          .dw XT_EXIT
                 
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
000a9f ff04          .dw $ff04
000aa0 7571
000aa1 7469          .db "quit"
000aa2 0a7f          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
000aa3 1c01          .dw DO_COLON
                 .endif
                 PFA_QUIT:
000aa4 03cb
000aa5 03d2
000aa6 1c81          .dw XT_LP0,XT_LP,XT_STORE
000aa7 0b4b          .dw XT_SP0
000aa8 1e96          .dw XT_SP_STORE
000aa9 0b53          .dw XT_RP0
000aaa 1e80          .dw XT_RP_STORE
000aab 0460          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
000aac 05f4          .dw XT_STATE
000aad 1c79          .dw XT_FETCH
000aae 1d18          .dw XT_ZEROEQUAL
000aaf 1c36          .dw XT_DOCONDBRANCH
000ab0 0ab2          DEST(PFA_QUIT4)
000ab1 0ae3          .dw XT_PROMPTREADY
                 PFA_QUIT4:
000ab2 0992          .dw XT_REFILL
000ab3 0b0a          .dw XT_PROMPTINPUT
000ab4 1c36          .dw XT_DOCONDBRANCH
000ab5 0ac5          DEST(PFA_QUIT3)
000ab6 1c3d          .dw XT_DOLITERAL
000ab7 0ba1          .dw XT_INTERPRET
000ab8 08d6          .dw XT_CATCH
000ab9 1cb9          .dw XT_QDUP
000aba 1c36          .dw XT_DOCONDBRANCH
000abb 0ac5          DEST(PFA_QUIT3)
000abc 1cb1      	.dw XT_DUP
000abd 1c3d      	.dw XT_DOLITERAL
000abe fffe      	.dw -2
000abf 1d6e      	.dw XT_LESS
000ac0 1c36      	.dw XT_DOCONDBRANCH
000ac1 0ac3      	DEST(PFA_QUIT5)
000ac2 0afe      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
000ac3 1c2f      	.dw XT_DOBRANCH
000ac4 0aa4      	DEST(PFA_QUIT)
                 PFA_QUIT3:
000ac5 0ad3          .dw XT_PROMPTOK
000ac6 1c2f          .dw XT_DOBRANCH
000ac7 0aac          DEST(PFA_QUIT2)
                 ;    .dw XT_EXIT ; never reached
                 
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_DEFAULT_PROMPTOK:
000ac8 1c01          .dw DO_COLON
                 PFA_DEFAULT_PROMPTOK:
000ac9 0818          .dw XT_DOSLITERAL
000aca 0003          .dw 3
000acb 6f20
000acc 006b          .db " ok",0
                 .endif
000acd 084b          .dw XT_ITYPE
000ace 1c20          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTOK:
000acf ff03          .dw $FF03
000ad0 6f2e
../../common\words/prompt-ok.asm(43): warning: .cseg .db misalignment - padding zero byte
000ad1 006b          .db ".ok"
000ad2 0a9f          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
000ad3 0cd9          .dw PFA_DODEFER1
                 PFA_PROMPTOK:
                 .endif
000ad4 001c          .dw USER_P_OK
000ad5 0ca2          .dw XT_UDEFERFETCH
000ad6 0cae          .dw XT_UDEFERSTORE
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_DEFAULT_PROMPTREADY:
000ad7 1c01          .dw DO_COLON
                 PFA_DEFAULT_PROMPTREADY:
000ad8 0818          .dw XT_DOSLITERAL
000ad9 0002          .dw 2
000ada 203e          .db "> "
                 .endif
000adb 0880          .dw XT_CR
000adc 084b          .dw XT_ITYPE
000add 1c20          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTREADY:
000ade ff06          .dw $FF06
000adf 722e
000ae0 6165
000ae1 7964          .db ".ready"
000ae2 0acf          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTREADY
                 XT_PROMPTREADY:
000ae3 0cd9          .dw PFA_DODEFER1
                 PFA_PROMPTREADY:
                 .endif
000ae4 0020          .dw USER_P_RDY
000ae5 0ca2          .dw XT_UDEFERFETCH
000ae6 0cae          .dw XT_UDEFERSTORE
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_DEFAULT_PROMPTERROR:
000ae7 1c01          .dw DO_COLON
                 PFA_DEFAULT_PROMPTERROR:
000ae8 0818      	.dw XT_DOSLITERAL
000ae9 0004          .dw 4
000aea 3f20
000aeb 203f          .db " ?? "
                 .endif
000aec 084b          .dw XT_ITYPE
000aed 05fa          .dw XT_BASE
000aee 1c79          .dw XT_FETCH
000aef 1cff          .dw XT_TO_R
000af0 0687          .dw XT_DECIMAL
000af1 07cd          .dw XT_DOT
000af2 0628          .dw XT_TO_IN
000af3 1c79          .dw XT_FETCH
000af4 07cd          .dw XT_DOT
000af5 1cf6          .dw XT_R_FROM
000af6 05fa          .dw XT_BASE
000af7 1c81          .dw XT_STORE
000af8 1c20          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTERROR:
000af9 ff06          .dw $FF06
000afa 652e
000afb 7272
000afc 726f          .db ".error"
000afd 0ade          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
000afe 0cd9          .dw PFA_DODEFER1
                 PFA_PROMPTERROR:
                 .endif
000aff 001e          .dw USER_P_ERR
000b00 0ca2          .dw XT_UDEFERFETCH
000b01 0cae          .dw XT_UDEFERSTORE
                 .include "words/prompt-input.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_DEFAULT_PROMPTINPUT:
000b02 1c01          .dw DO_COLON
                 PFA_DEFAULT_PROMPTINPUT:
                 .endif
000b03 0880          .dw XT_CR
000b04 1c20          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTINPUT:
000b05 ff06          .dw $FF06
000b06 692e
000b07 706e
000b08 7475          .db ".input"
000b09 0af9          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTINPUT
                 XT_PROMPTINPUT:
000b0a 0cd9          .dw PFA_DODEFER1
                 PFA_PROMPTINPUT:
                 .endif
000b0b 0022          .dw USER_P_INPUT
000b0c 0ca2          .dw XT_UDEFERFETCH
000b0d 0cae          .dw XT_UDEFERSTORE
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
000b0e ff05          .dw $ff05
000b0f 6170
000b10 7375
000b11 0065          .db "pause",0
000b12 0b05          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
000b13 0cd9          .dw PFA_DODEFER1
                 PFA_PAUSE:
000b14 0093          .dw ram_pause
000b15 0c8e          .dw XT_RDEFERFETCH
000b16 0c98          .dw XT_RDEFERSTORE
                 
                 .dseg
000093           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
000b17 ff04          .dw $ff04
000b18 6f63
000b19 646c          .db "cold"
000b1a 0b0e          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
000b1b 0b1c          .dw PFA_COLD
                 PFA_COLD:
000b1c b6a4          in_ mcu_boot, MCUSR
000b1d 2422          clr zerol
000b1e 2433          clr zeroh
000b1f 24bb          clr isrflag
000b20 be24          out_ MCUSR, zerol
                     ; clear RAM
000b21 e6e0          ldi zl, low(ramstart)
000b22 e0f0          ldi zh, high(ramstart)
                 clearloop:
000b23 9221          st Z+, zerol
000b24 36e0          cpi zl, low(sram_size+ramstart)
000b25 f7e9          brne clearloop
000b26 30f4          cpi zh, high(sram_size+ramstart)
000b27 f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000095           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
000b28 e9e5          ldi zl, low(ram_user1)
000b29 e0f0          ldi zh, high(ram_user1)
000b2a 012f          movw upl, zl
                     ; init return stack pointer
000b2b e50f          ldi temp0,low(rstackstart)
000b2c bf0d          out_ SPL,temp0
000b2d 8304          std Z+4, temp0
000b2e e014          ldi temp1,high(rstackstart)
000b2f bf1e          out_ SPH,temp1
000b30 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
000b31 e0cf          ldi yl,low(stackstart)
000b32 83c6          std Z+6, yl
000b33 e0d4          ldi yh,high(stackstart)
000b34 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
000b35 e3ae          ldi XL, low(PFA_WARM)
000b36 e0bb          ldi XH, high(PFA_WARM)
                     ; its a far jump...
000b37 940c 1c05     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WARM:
000b39 ff04          .dw $ff04
000b3a 6177
000b3b 6d72          .db "warm"
000b3c 0b17          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
000b3d 1c01          .dw DO_COLON
                 PFA_WARM:
                 .endif
000b3e 0e16          .dw XT_INIT_RAM
000b3f 1c3d          .dw XT_DOLITERAL
000b40 0c45          .dw XT_NOOP
000b41 1c3d          .dw XT_DOLITERAL
000b42 0b13          .dw XT_PAUSE
000b43 0cb9          .dw XT_DEFERSTORE
000b44 0460          .dw XT_LBRACKET
000b45 06a2          .dw XT_TURNKEY
000b46 0aa3          .dw XT_QUIT     ; never returns
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
000b47 ff03          .dw $ff03
000b48 7073
000b49 0030          .db "sp0",0
000b4a 0b39          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
000b4b 1c6f          .dw PFA_DOVALUE1
                 PFA_SP0:
000b4c 0006          .dw USER_SP0
000b4d 0ca2          .dw XT_UDEFERFETCH
000b4e 0cae          .dw XT_UDEFERSTORE
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
000b4f ff03          .dw $ff03
000b50 7072
000b51 0030          .db "rp0",0
000b52 0b47          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
000b53 1c01          .dw DO_COLON
                 PFA_RP0:
000b54 0b57          .dw XT_DORP0
000b55 1c79          .dw XT_FETCH
000b56 1c20          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
000b57 1c58          .dw PFA_DOUSER
                 PFA_DORP0:
000b58 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
000b59 ff05          .dw $ff05
000b5a 6564
000b5b 7470
000b5c 0068          .db "depth",0
000b5d 0b4f          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
000b5e 1c01          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
000b5f 0b4b          .dw XT_SP0
000b60 1e8d          .dw XT_SP_FETCH
000b61 1d93          .dw XT_MINUS
000b62 1e04          .dw XT_2SLASH
000b63 1e35          .dw XT_1MINUS
000b64 1c20          .dw XT_EXIT
                 .include "words/recognize.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECOGNIZE:
000b65 ff09          .dw $ff09
000b66 6572
000b67 6f63
000b68 6e67
000b69 7a69
000b6a 0065          .db "recognize",0
000b6b 0b59          .dw VE_HEAD
                     .set VE_HEAD = VE_RECOGNIZE
                 XT_RECOGNIZE:
000b6c 1c01          .dw DO_COLON
                 PFA_RECOGNIZE:
                 .endif
000b6d 1c3d          .dw XT_DOLITERAL
000b6e 0b77          .dw XT_RECOGNIZE_A
000b6f 1cc4          .dw XT_SWAP
000b70 0516          .dw XT_MAPSTACK
000b71 1d18          .dw XT_ZEROEQUAL
000b72 1c36          .dw XT_DOCONDBRANCH
000b73 0b76          DEST(PFA_RECOGNIZE1)
000b74 0618            .dw XT_2DROP
000b75 0c10            .dw XT_RECTYPE_NULL
                 PFA_RECOGNIZE1:
000b76 1c20          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ; ( addr len XT -- addr len [ rectype-* -1 | 0 ] )
                 XT_RECOGNIZE_A:
000b77 1c01         .dw DO_COLON
                 PFA_RECOGNIZE_A:
                 .endif
000b78 1ce1         .dw XT_ROT  ; -- len xt addr
000b79 1ce1         .dw XT_ROT  ; -- xt addr len
000b7a 060f         .dw XT_2DUP 
000b7b 1f14         .dw XT_2TO_R
000b7c 1ce1         .dw XT_ROT  ; -- addr len xt
000b7d 1c2a         .dw XT_EXECUTE ; -- i*x rectype-* | rectype-null
000b7e 1f23         .dw XT_2R_FROM
000b7f 1ce1         .dw XT_ROT
000b80 1cb1         .dw XT_DUP
000b81 0c10         .dw XT_RECTYPE_NULL
000b82 1fd6         .dw XT_EQUAL
000b83 1c36         .dw XT_DOCONDBRANCH
000b84 0b88         DEST(PFA_RECOGNIZE_A1)
000b85 1cd9           .dw XT_DROP
000b86 1d54           .dw XT_ZERO
000b87 1c20           .dw XT_EXIT
                 PFA_RECOGNIZE_A1:
000b88 1cf0         .dw XT_NIP 
000b89 1cf0         .dw XT_NIP
000b8a 1d4b         .dw XT_TRUE
000b8b 1c20         .dw XT_EXIT
                 
                 ; : recognize ( addr len stack-id -- i*x rectype-* | rectype-null )
                 ;   [: ( addr len -- addr len 0 | i*x rectype-* -1 )
                 ;      rot rot 2dup 2>r rot execute 2r> rot 
                 ;      dup rectype-null = ( -- addr len rectype-* f )
                 ;      if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    map-stack ( -- i*x addr len rectype-* f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop rectype-null
                 ;    then ;
                 ;
                 .include "words/forth-recognizer.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_FORTHRECOGNIZER:
000b8c ff10          .dw $ff10
000b8d 6f66
000b8e 7472
000b8f 2d68
000b90 6572
000b91 6f63
000b92 6e67
000b93 7a69
000b94 7265          .db "forth-recognizer"
000b95 0b65          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHRECOGNIZER
                 XT_FORTHRECOGNIZER:
000b96 1c6f          .dw PFA_DOVALUE1
                 PFA_FORTHRECOGNIZER:
000b97 0034          .dw CFG_FORTHRECOGNIZER
000b98 0c7a          .dw XT_EDEFERFETCH
000b99 0c84          .dw XT_EDEFERSTORE
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
000b9a ff09          .dw $ff09
000b9b 6e69
000b9c 6574
000b9d 7072
000b9e 6572
000b9f 0074          .db "interpret",0
000ba0 0b8c          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
000ba1 1c01          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
000ba2 0a69          .dw XT_PARSENAME ; ( -- addr len )
000ba3 1cb1          .dw XT_DUP   ; ( -- addr len flag)
000ba4 1c36          .dw XT_DOCONDBRANCH
000ba5 0bb2          DEST(PFA_INTERPRET2)
000ba6 0b96            .dw XT_FORTHRECOGNIZER
000ba7 0b6c            .dw XT_RECOGNIZE
000ba8 05f4            .dw XT_STATE
000ba9 1c79            .dw XT_FETCH
000baa 1c36            .dw XT_DOCONDBRANCH
000bab 0bad          DEST(PFA_INTERPRET1)
000bac 0c71            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
000bad 1fc1            .dw XT_FETCHI
000bae 1c2a            .dw XT_EXECUTE
000baf 0c1d            .dw XT_QSTACK
000bb0 1c2f          .dw XT_DOBRANCH
000bb1 0ba2          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
000bb2 0618          .dw XT_2DROP
000bb3 1c20          .dw XT_EXIT
                 .include "words/rec-intnum.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_NUM:
000bb4 ff0b          .dw $ff0b
000bb5 6572
000bb6 7463
000bb7 7079
000bb8 2d65
000bb9 756e
000bba 006d          .db "rectype-num",0
000bbb 0b9a          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_NUM
                 XT_RECTYPE_NUM:
000bbc 1c52          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_NUM:
                 .endif
000bbd 0c45          .dw XT_NOOP    ; interpret
000bbe 02ec          .dw XT_LITERAL ; compile
000bbf 02ec          .dw XT_LITERAL ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_DNUM:
000bc0 ff0c          .dw $ff0c
000bc1 6572
000bc2 7463
000bc3 7079
000bc4 2d65
000bc5 6e64
000bc6 6d75          .db "rectype-dnum"
000bc7 0bb4          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_DNUM
                 XT_RECTYPE_DNUM:
000bc8 1c52          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_DNUM:
                 .endif
000bc9 0c45          .dw XT_NOOP     ; interpret
000bca 1fce          .dw XT_2LITERAL ; compile
000bcb 1fce          .dw XT_2LITERAL ; postpone
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
000bcc ff07          .dw $ff07
000bcd 6572
000bce 2d63
000bcf 756e
000bd0 006d          .db "rec-num",0
000bd1 0bc0          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
000bd2 1c01          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
000bd3 09a9          .dw XT_NUMBER
000bd4 1c36          .dw XT_DOCONDBRANCH
000bd5 0bde          DEST(PFA_REC_NONUMBER)
000bd6 1fdd          .dw XT_ONE
000bd7 1fd6          .dw XT_EQUAL
000bd8 1c36          .dw XT_DOCONDBRANCH
000bd9 0bdc          DEST(PFA_REC_INTNUM2)
000bda 0bbc            .dw XT_RECTYPE_NUM
000bdb 1c20            .dw XT_EXIT
                 PFA_REC_INTNUM2:
000bdc 0bc8            .dw XT_RECTYPE_DNUM
000bdd 1c20            .dw XT_EXIT
                 PFA_REC_NONUMBER:
000bde 0c10          .dw XT_RECTYPE_NULL
000bdf 1c20          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_FIND:
000be0 ff08          .dw $ff08
000be1 6572
000be2 2d63
000be3 6966
000be4 646e          .db "rec-find"
000be5 0bcc          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
000be6 1c01          .dw DO_COLON
                 PFA_REC_FIND:
                 .endif
000be7 0a85          .DW XT_FINDXT
000be8 1cb1          .dw XT_DUP
000be9 1d18          .dw XT_ZEROEQUAL
000bea 1c36          .dw XT_DOCONDBRANCH
000beb 0bef          DEST(PFA_REC_WORD_FOUND)
000bec 1cd9              .dw XT_DROP
000bed 0c10      	.dw XT_RECTYPE_NULL
000bee 1c20      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
000bef 0bf8          .dw XT_RECTYPE_XT
                 
000bf0 1c20          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_XT:
000bf1 ff0a          .dw $ff0a
000bf2 6572
000bf3 7463
000bf4 7079
000bf5 2d65
000bf6 7478          .db "rectype-xt"
000bf7 0be0          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_XT
                 XT_RECTYPE_XT:
000bf8 1c52          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_XT:
                 .endif
000bf9 0bfc          .dw XT_R_WORD_INTERPRET
000bfa 0c00          .dw XT_R_WORD_COMPILE
000bfb 1fce          .dw XT_2LITERAL
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
000bfc 1c01          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
000bfd 1cd9          .dw XT_DROP ; the flags are in the way
000bfe 1c2a          .dw XT_EXECUTE
000bff 1c20          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
000c00 1c01          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
000c01 1d1f          .dw XT_ZEROLESS
000c02 1c36          .dw XT_DOCONDBRANCH
000c03 0c06          DEST(PFA_R_WORD_COMPILE1)
000c04 02d6      	.dw XT_COMMA
000c05 1c20              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
000c06 1c2a              .dw XT_EXECUTE
000c07 1c20          .dw XT_EXIT
                 .include "words/rec-null.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_NULL:
000c08 ff0c          .dw $ff0c
000c09 6572
000c0a 7463
000c0b 7079
000c0c 2d65
000c0d 756e
000c0e 6c6c          .db "rectype-null"
000c0f 0bf1          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_NULL
                 XT_RECTYPE_NULL:
000c10 1c52          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_NULL:
                 .endif
000c11 0c14          .dw XT_FAIL  ; interpret
000c12 0c14          .dw XT_FAIL  ; compile
000c13 0c14          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
000c14 1c01          .dw DO_COLON
                 PFA_FAIL:
                 .endif
000c15 1c3d          .dw XT_DOLITERAL
000c16 fff3          .dw -13
000c17 08ec          .dw XT_THROW
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
000c18 ff06          .dw $ff06
000c19 733f
000c1a 6174
000c1b 6b63          .db "?stack"
000c1c 0c08          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
000c1d 1c01          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
000c1e 0b5e          .dw XT_DEPTH
000c1f 1d1f          .dw XT_ZEROLESS
000c20 1c36          .dw XT_DOCONDBRANCH
000c21 0c25          DEST(PFA_QSTACK1)
000c22 1c3d            .dw XT_DOLITERAL
000c23 fffc            .dw -4
000c24 08ec            .dw XT_THROW
                 PFA_QSTACK1:
000c25 1c20          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
000c26 ff03          .dw $ff03
000c27 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
000c28 0072          .db "ver"
000c29 0c18          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
000c2a 1c01          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
000c2b 05b6          .dw XT_ENV_FORTHNAME
000c2c 084b          .dw XT_ITYPE
000c2d 088d          .dw XT_SPACE
000c2e 05fa          .dw XT_BASE
000c2f 1c79          .dw XT_FETCH
                 
000c30 05c4          .dw XT_ENV_FORTHVERSION
000c31 0687          .dw XT_DECIMAL
000c32 0e2d          .dw XT_S2D
000c33 0769          .dw XT_L_SHARP
000c34 0771          .dw XT_SHARP
000c35 1c3d          .dw XT_DOLITERAL
000c36 002e          .dw '.'
000c37 075a          .dw XT_HOLD
000c38 0787          .dw XT_SHARP_S
000c39 0792          .dw XT_SHARP_G
000c3a 08a6          .dw XT_TYPE
000c3b 05fa          .dw XT_BASE
000c3c 1c81          .dw XT_STORE
000c3d 088d          .dw XT_SPACE
000c3e 05cc          .dw XT_ENV_CPU
000c3f 084b          .dw XT_ITYPE
                 
000c40 1c20          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOOP:
000c41 ff04          .dw $ff04
000c42 6f6e
000c43 706f          .db "noop"
000c44 0c26          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
000c45 1c01          .dw DO_COLON
                 PFA_NOOP:
                 .endif
000c46 1c20         .DW XT_EXIT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
000c47 ff06          .dw $ff06
000c48 6e75
000c49 7375
000c4a 6465          .db "unused"
000c4b 0c41          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
000c4c 1c01          .dw DO_COLON
                 PFA_UNUSED:
000c4d 1e8d          .dw XT_SP_FETCH
000c4e 0669          .dw XT_HERE
000c4f 1d93          .dw XT_MINUS
000c50 1c20          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
000c51 0002          .dw $0002
000c52 6f74          .db "to"
000c53 0c47          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
000c54 1c01          .dw DO_COLON
                 PFA_TO:
                 .endif
000c55 08b5          .dw XT_TICK
000c56 0e36          .dw XT_TO_BODY
000c57 05f4          .dw XT_STATE
000c58 1c79          .dw XT_FETCH
000c59 1c36          .dw XT_DOCONDBRANCH
000c5a 0c65          DEST(PFA_TO1)
000c5b 02cb          .dw XT_COMPILE
000c5c 0c5f          .dw XT_DOTO
000c5d 02d6          .dw XT_COMMA
000c5e 1c20          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
000c5f 1c01          .dw DO_COLON
                 PFA_DOTO:
                 .endif
000c60 1cf6          .dw XT_R_FROM
000c61 1cb1          .dw XT_DUP
000c62 0c71          .dw XT_ICELLPLUS
000c63 1cff          .dw XT_TO_R
000c64 1fc1          .dw XT_FETCHI
                 PFA_TO1:
000c65 1cb1          .dw XT_DUP
000c66 0c71          .dw XT_ICELLPLUS
000c67 0c71          .dw XT_ICELLPLUS
000c68 1fc1          .dw XT_FETCHI
000c69 1c2a          .dw XT_EXECUTE
000c6a 1c20          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
000c6b ff07          .dw $FF07
000c6c 2d69
000c6d 6563
000c6e 6c6c
000c6f 002b          .db "i-cell+",0
000c70 0c51          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
000c71 1c01          .dw DO_COLON
                 PFA_ICELLPLUS:
000c72 1e2f          .dw XT_1PLUS
000c73 1c20          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
000c74 ff07          .dw $ff07
000c75 6445
000c76 6665
000c77 7265
000c78 0040          .db "Edefer@",0
000c79 0c6b          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
000c7a 1c01          .dw DO_COLON
                 PFA_EDEFERFETCH:
000c7b 1fc1          .dw XT_FETCHI
000c7c 1f55          .dw XT_FETCHE
000c7d 1c20          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
000c7e ff07          .dw $ff07
000c7f 6445
000c80 6665
000c81 7265
000c82 0021          .db "Edefer!",0
000c83 0c74          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
000c84 1c01          .dw DO_COLON
                 PFA_EDEFERSTORE:
000c85 1fc1          .dw XT_FETCHI
000c86 1f31          .dw XT_STOREE
000c87 1c20          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
000c88 ff07          .dw $ff07
000c89 6452
000c8a 6665
000c8b 7265
000c8c 0040          .db "Rdefer@",0
000c8d 0c7e          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
000c8e 1c01          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
000c8f 1fc1          .dw XT_FETCHI
000c90 1c79          .dw XT_FETCH
000c91 1c20          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
000c92 ff07          .dw $ff07
000c93 6452
000c94 6665
000c95 7265
000c96 0021          .db "Rdefer!",0
000c97 0c88          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
000c98 1c01          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
000c99 1fc1          .dw XT_FETCHI
000c9a 1c81          .dw XT_STORE
000c9b 1c20          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
000c9c ff07          .dw $ff07
000c9d 6455
000c9e 6665
000c9f 7265
000ca0 0040          .db "Udefer@",0
000ca1 0c92          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
000ca2 1c01          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
000ca3 1fc1          .dw XT_FETCHI
000ca4 1f02          .dw XT_UP_FETCH
000ca5 1d9d          .dw XT_PLUS
000ca6 1c79          .dw XT_FETCH
000ca7 1c20          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
000ca8 ff07          .dw $ff07
000ca9 6455
000caa 6665
000cab 7265
000cac 0021          .db "Udefer!",0
000cad 0c9c          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
000cae 1c01          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
000caf 1fc1          .dw XT_FETCHI
000cb0 1f02          .dw XT_UP_FETCH
000cb1 1d9d          .dw XT_PLUS
000cb2 1c81          .dw XT_STORE
000cb3 1c20          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
000cb4 ff06          .dw $ff06
000cb5 6564
000cb6 6566
000cb7 2172          .db "defer!"
000cb8 0ca8          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
000cb9 1c01          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
000cba 0e36          .dw XT_TO_BODY
000cbb 1cb1          .dw XT_DUP
000cbc 0c71          .dw XT_ICELLPLUS
000cbd 0c71          .dw XT_ICELLPLUS
000cbe 1fc1          .dw XT_FETCHI
000cbf 1c2a          .dw XT_EXECUTE
000cc0 1c20          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
000cc1 ff06          .dw $ff06
000cc2 6564
000cc3 6566
000cc4 4072          .db "defer@"
000cc5 0cb4          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
000cc6 1c01          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
000cc7 0e36          .dw XT_TO_BODY 
000cc8 1cb1          .dw XT_DUP
000cc9 0c71          .dw XT_ICELLPLUS
000cca 1fc1          .dw XT_FETCHI
000ccb 1c2a          .dw XT_EXECUTE
000ccc 1c20          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
000ccd ff07          .dw $ff07
000cce 6428
000ccf 6665
000cd0 7265
000cd1 0029          .db "(defer)", 0
000cd2 0cc1          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
000cd3 1c01          .dw DO_COLON
                 PFA_DODEFER:
000cd4 029d          .dw XT_DOCREATE
000cd5 0408          .dw XT_REVEAL
000cd6 02cb          .dw XT_COMPILE
000cd7 0cd9          .dw PFA_DODEFER1
000cd8 1c20          .dw XT_EXIT
                 PFA_DODEFER1:
000cd9 940e 0421     call_ DO_DODOES
000cdb 1cb1          .dw XT_DUP
000cdc 0c71          .dw XT_ICELLPLUS
000cdd 1fc1          .dw XT_FETCHI
000cde 1c2a          .dw XT_EXECUTE 
000cdf 1c2a          .dw XT_EXECUTE
000ce0 1c20          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
000ce1 ff0f          .dw $ff0f
000ce2 6573
000ce3 7261
000ce4 6863
000ce5 772d
000ce6 726f
000ce7 6c64
000ce8 7369
000ce9 0074          .db "search-wordlist",0
000cea 0ccd          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
000ceb 1c01          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
000cec 1cff          .dw XT_TO_R
000ced 1d54          .dw XT_ZERO
000cee 1c3d          .dw XT_DOLITERAL
000cef 0d00          .dw XT_ISWORD
000cf0 1cf6          .dw XT_R_FROM
000cf1 0d1d          .dw XT_TRAVERSEWORDLIST
000cf2 1cb1          .dw XT_DUP
000cf3 1d18          .dw XT_ZEROEQUAL
000cf4 1c36          .dw XT_DOCONDBRANCH
000cf5 0cfa          DEST(PFA_SEARCH_WORDLIST1)
000cf6 0618             .dw XT_2DROP
000cf7 1cd9             .dw XT_DROP
000cf8 1d54             .dw XT_ZERO
000cf9 1c20             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
000cfa 1cb1            .dw XT_DUP
000cfb 0d44            .dw XT_NFA2CFA
                       ; .. and get the header flag
000cfc 1cc4            .dw XT_SWAP
000cfd 0177            .dw XT_NAME2FLAGS
000cfe 0165            .dw XT_IMMEDIATEQ
000cff 1c20          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
000d00 1c01          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
000d01 1cff          .dw XT_TO_R
000d02 1cd9          .dw XT_DROP
000d03 060f          .dw XT_2DUP
000d04 1d06          .dw XT_R_FETCH  ; -- addr len addr len nt
000d05 0d38          .dw XT_NAME2STRING
000d06 0d4e          .dw XT_ICOMPARE      ; (-- addr len f )
000d07 1c36          .dw XT_DOCONDBRANCH
000d08 0d0e          DEST(PFA_ISWORD3)
                       ; not now
000d09 1cf6            .dw XT_R_FROM
000d0a 1cd9            .dw XT_DROP
000d0b 1d54            .dw XT_ZERO
000d0c 1d4b            .dw XT_TRUE         ; maybe next word
000d0d 1c20            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
000d0e 0618            .dw XT_2DROP
000d0f 1cf6            .dw XT_R_FROM
000d10 1d54            .dw XT_ZERO       ; finish traverse-wordlist
000d11 1c20            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
000d12 ff11          .dw $ff11
000d13 7274
000d14 7661
000d15 7265
000d16 6573
000d17 772d
000d18 726f
000d19 6c64
000d1a 7369
000d1b 0074          .db "traverse-wordlist",0
000d1c 0ce1          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
000d1d 1c01          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
000d1e 1f55          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
000d1f 1cb1          .dw XT_DUP           ; ( -- xt nt nt )
000d20 1c36          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
000d21 0d2e          DEST(PFA_TRAVERSEWORDLIST2)
000d22 060f          .dw XT_2DUP
000d23 1f14          .dw XT_2TO_R
000d24 1cc4          .dw XT_SWAP
000d25 1c2a          .dw XT_EXECUTE
000d26 1f23          .dw XT_2R_FROM
000d27 1ce1          .dw XT_ROT
000d28 1c36          .dw XT_DOCONDBRANCH
000d29 0d2e          DEST(PFA_TRAVERSEWORDLIST2)
000d2a 0581          .dw XT_NFA2LFA
000d2b 1fc1          .dw XT_FETCHI
000d2c 1c2f          .dw XT_DOBRANCH      ; ( -- addr )
000d2d 0d1f          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
000d2e 0618          .dw XT_2DROP
000d2f 1c20          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' )
                 ;        begin @ dup
                 ;        while
                 ;          2dup 2>r
                 ;          swap execute ( i*x nt -- i*x' f )
                 ;          2r> rot
                 ;        while
                 ;          nfa>lfa @i
                 ;        repeat then 2drop ;
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
000d30 ff0b          .dw $ff0b
000d31 616e
000d32 656d
000d33 733e
000d34 7274
000d35 6e69
000d36 0067          .db "name>string",0
000d37 0d12          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
000d38 1c01          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
000d39 0877          .dw XT_ICOUNT   ; ( -- addr n )
000d3a 1c3d          .dw XT_DOLITERAL
000d3b 00ff          .dw 255
000d3c 1e13          .dw XT_AND      ; mask immediate bit
000d3d 1c20          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
000d3e ff07          .dw $ff07
000d3f 666e
000d40 3e61
000d41 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
000d42 0061          .db "nfa>cfa"
000d43 0d30          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
000d44 1c01          .dw DO_COLON
                 PFA_NFA2CFA:
000d45 0581          .dw XT_NFA2LFA ; skip to link field
000d46 1e2f          .dw XT_1PLUS   ; next is the execution token
000d47 1c20          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
000d48 ff08          .dw $ff08
000d49 6369
000d4a 6d6f
000d4b 6170
000d4c 6572          .db "icompare"
000d4d 0d3e          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
000d4e 1c01          .dw DO_COLON
                 PFA_ICOMPARE:
000d4f 1cff          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
000d50 1ccf          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
000d51 1cf6          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
000d52 1d11          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
000d53 1c36          .dw XT_DOCONDBRANCH
000d54 0d59          .dw PFA_ICOMPARE_SAMELEN
000d55 0618            .dw XT_2DROP
000d56 1cd9            .dw XT_DROP
000d57 1d4b            .dw XT_TRUE
000d58 1c20            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
000d59 1cc4          .dw XT_SWAP ; ( -- r-addr f-addr len )
000d5a 1d54          .dw XT_ZERO
000d5b 0395          .dw XT_QDOCHECK
000d5c 1c36          .dw XT_DOCONDBRANCH
000d5d 0d7c          .dw PFA_ICOMPARE_DONE
000d5e 1e9b          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
000d5f 1ccf          .dw XT_OVER
000d60 1c79          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
000d61 1ccf          .dw XT_OVER
000d62 1fc1          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
000d63 1cb1          .dw XT_DUP
                     ;.dw XT_BYTESWAP
000d64 1c3d          .dw XT_DOLITERAL
000d65 0100          .dw $100
000d66 1d5c          .dw XT_ULESS
000d67 1c36          .dw XT_DOCONDBRANCH
000d68 0d6d          .dw PFA_ICOMPARE_LASTCELL
000d69 1cc4          .dw XT_SWAP
000d6a 1c3d          .dw XT_DOLITERAL
000d6b 00ff          .dw $00FF
000d6c 1e13          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
000d6d 1d11          .dw XT_NOTEQUAL
000d6e 1c36          .dw XT_DOCONDBRANCH
000d6f 0d74          .dw PFA_ICOMPARE_NEXTLOOP
000d70 0618          .dw XT_2DROP
000d71 1d4b          .dw XT_TRUE
000d72 1ed4          .dw XT_UNLOOP
000d73 1c20          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
000d74 1e2f          .dw XT_1PLUS
000d75 1cc4          .dw XT_SWAP
000d76 0607          .dw XT_CELLPLUS
000d77 1cc4          .dw XT_SWAP
000d78 1c3d          .dw XT_DOLITERAL
000d79 0002          .dw 2
000d7a 1eba          .dw XT_DOPLUSLOOP
000d7b 0d5f          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
000d7c 0618          .dw XT_2DROP
000d7d 1d54          .dw XT_ZERO
000d7e 1c20          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
000d7f ff01          .dw $ff01
000d80 002a          .db "*",0
000d81 0d48          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
000d82 1c01          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
000d83 1da6          .dw XT_MSTAR
000d84 1cd9          .dw XT_DROP
000d85 1c20          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
000d86 ff01          .dw $FF01
000d87 006a          .db "j",0
000d88 0d7f          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
000d89 1c01          .dw DO_COLON
                 PFA_J:
000d8a 1e76          .dw XT_RP_FETCH
000d8b 1c3d          .dw XT_DOLITERAL
000d8c 0007          .dw 7
000d8d 1d9d          .dw XT_PLUS
000d8e 1c79          .dw XT_FETCH
000d8f 1e76          .dw XT_RP_FETCH
000d90 1c3d          .dw XT_DOLITERAL
000d91 0009          .dw 9
000d92 1d9d          .dw XT_PLUS
000d93 1c79          .dw XT_FETCH
000d94 1d9d          .dw XT_PLUS
000d95 1c20          .dw XT_EXIT
                 
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
000d96 ff04          .dw $ff04
000d97 6164
000d98 7362          .db "dabs"
000d99 0d86          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
000d9a 1c01          .dw DO_COLON
                 PFA_DABS:
000d9b 1cb1          .dw XT_DUP
000d9c 1d1f          .dw XT_ZEROLESS
000d9d 1c36          .dw XT_DOCONDBRANCH
000d9e 0da0          .dw PFA_DABS1
000d9f 0da7          .dw XT_DNEGATE
                 PFA_DABS1:
000da0 1c20          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
000da1 ff07          .dw $ff07
000da2 6e64
000da3 6765
000da4 7461
000da5 0065          .db "dnegate",0
000da6 0d96          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
000da7 1c01          .dw DO_COLON
                 PFA_DNEGATE:
000da8 01d1          .dw XT_DINVERT
000da9 1fdd          .dw XT_ONE
000daa 1d54          .dw XT_ZERO
000dab 01a9          .dw XT_DPLUS
000dac 1c20          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
000dad ff05          .dw $ff05
000dae 6d63
000daf 766f
000db0 0065          .db "cmove",0
000db1 0da1          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
000db2 0db3          .dw PFA_CMOVE
                 PFA_CMOVE:
000db3 93bf          push xh
000db4 93af          push xl
000db5 91e9          ld zl, Y+
000db6 91f9          ld zh, Y+ ; addr-to
000db7 91a9          ld xl, Y+
000db8 91b9          ld xh, Y+ ; addr-from
000db9 2f09          mov temp0, tosh
000dba 2b08          or temp0, tosl
000dbb f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
000dbc 911d          ld temp1, X+
000dbd 9311          st Z+, temp1
000dbe 9701          sbiw tosl, 1
000dbf f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
000dc0 91af          pop xl
000dc1 91bf          pop xh
000dc2 9189
000dc3 9199          loadtos
000dc4 940c 1c05     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
000dc6 ff05          .dw $ff05
000dc7 7332
000dc8 6177
000dc9 0070          .db "2swap",0
000dca 0dad          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
000dcb 1c01          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
000dcc 1ce1          .dw XT_ROT
000dcd 1cff          .dw XT_TO_R
000dce 1ce1          .dw XT_ROT
000dcf 1cf6          .dw XT_R_FROM
000dd0 1c20          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System
                 ; refills the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILLTIB:
000dd1 ff0a          .dw $ff0a
000dd2 6572
000dd3 6966
000dd4 6c6c
000dd5 742d
000dd6 6269          .db "refill-tib"
000dd7 0dc6          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
000dd8 1c01          .dw DO_COLON
                 PFA_REFILLTIB:
                 .endif
000dd9 0df4          .dw XT_TIB
000dda 1c3d          .dw XT_DOLITERAL
000ddb 005a          .dw TIB_SIZE
000ddc 0939          .dw XT_ACCEPT
000ddd 0dfa          .dw XT_NUMBERTIB
000dde 1c81          .dw XT_STORE
000ddf 1d54          .dw XT_ZERO
000de0 0628          .dw XT_TO_IN
000de1 1c81          .dw XT_STORE
000de2 1d4b          .dw XT_TRUE ; -1
000de3 1c20          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCETIB:
000de4 ff0a          .dw $FF0A
000de5 6f73
000de6 7275
000de7 6563
000de8 742d
000de9 6269          .db "source-tib"
000dea 0dd1          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
000deb 1c01          .dw DO_COLON
                 PFA_SOURCETIB:
                 .endif
000dec 0df4          .dw XT_TIB
000ded 0dfa          .dw XT_NUMBERTIB
000dee 1c79          .dw XT_FETCH
000def 1c20          .dw XT_EXIT
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; terminal input buffer address
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TIB:
000df0 ff03          .dw $ff03
000df1 6974
000df2 0062          .db "tib",0
000df3 0de4          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
000df4 1c48          .dw PFA_DOVARIABLE
                 PFA_TIB:
000df5 00c3          .dw ram_tib
                 .dseg
0000c3           ram_tib: .byte TIB_SIZE
                 .cseg
                 .endif
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBERTIB:
000df6 ff04          .dw $ff04
000df7 7423
000df8 6269          .db "#tib"
000df9 0df0          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
000dfa 1c48          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
000dfb 011d          .dw ram_sharptib
                 .dseg
00011d           ram_sharptib: .byte 2
                 .cseg
                 .endif
                 
                 .include "words/init-ram.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
000dfc ff06        .dw $ff06
000dfd 6565
000dfe 723e
000dff 6d61        .db "ee>ram"
000e00 0df6        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
000e01 1c01        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
000e02 1d54          .dw XT_ZERO
000e03 1e9b          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
000e04 1ccf          .dw XT_OVER
000e05 1f55          .dw XT_FETCHE
000e06 1ccf          .dw XT_OVER
000e07 1c81          .dw XT_STORE
000e08 0607          .dw XT_CELLPLUS
000e09 1cc4          .dw XT_SWAP
000e0a 0607          .dw XT_CELLPLUS
000e0b 1cc4          .dw XT_SWAP
000e0c 1ec9          .dw XT_DOLOOP
000e0d 0e04          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
000e0e 0618          .dw XT_2DROP
000e0f 1c20          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INIT_RAM:
000e10 ff08        .dw $ff08
000e11 6e69
000e12 7469
000e13 722d
000e14 6d61        .db "init-ram"
000e15 0dfc        .dw VE_HEAD
                   .set VE_HEAD = VE_INIT_RAM
                 XT_INIT_RAM:
000e16 1c01        .dw DO_COLON
                 PFA_INI_RAM:          ; ( -- )
000e17 1c3d          .dw XT_DOLITERAL
000e18 0060          .dw EE_INITUSER
000e19 1f02          .dw XT_UP_FETCH
000e1a 1c3d          .dw XT_DOLITERAL
000e1b 0024          .dw SYSUSERSIZE
000e1c 1e04          .dw XT_2SLASH
000e1d 0e01          .dw XT_EE2RAM
000e1e 1c20          .dw XT_EXIT
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
000e1f ff06          .dw $ff06
000e20 6f62
000e21 6e75
000e22 7364          .db "bounds"
000e23 0e10          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
000e24 1c01          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
000e25 1ccf          .dw XT_OVER
000e26 1d9d          .dw XT_PLUS
000e27 1cc4          .dw XT_SWAP
000e28 1c20          .dw XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
000e29 ff03          .dw $ff03
000e2a 3e73
000e2b 0064          .db "s>d",0
000e2c 0e1f          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
000e2d 1c01          .dw DO_COLON
                 PFA_S2D:
                 .endif
000e2e 1cb1          .dw XT_DUP
000e2f 1d1f          .dw XT_ZEROLESS
000e30 1c20          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
000e31 ff05          .dw $ff05
000e32 623e
000e33 646f
000e34 0079          .db ">body",0
000e35 0e29          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
000e36 1e30          .dw PFA_1PLUS
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 .include "words/dot-s.asm"
                 
                 ; Tools
                 ; stack dump
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTS:
000e37 ff02          .dw $ff02
000e38 732e          .db ".s"
000e39 0e31          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTS
                 XT_DOTS:
000e3a 1c01          .dw DO_COLON
                 PFA_DOTS:
                 .endif
000e3b 0b5e          .dw XT_DEPTH
000e3c 01df          .dw XT_UDOT
000e3d 088d          .dw XT_SPACE
000e3e 0b5e          .dw XT_DEPTH
000e3f 1d54          .dw XT_ZERO
000e40 0395          .dw XT_QDOCHECK
000e41 1c36          .dw XT_DOCONDBRANCH
000e42 0e49          DEST(PFA_DOTS2)
000e43 1e9b          .dw XT_DODO
                 PFA_DOTS1:
000e44 1eac          .dw XT_I
000e45 025a          .dw XT_PICK
000e46 01df          .dw XT_UDOT
000e47 1ec9          .dw XT_DOLOOP
000e48 0e44          DEST(PFA_DOTS1)
                 PFA_DOTS2:
000e49 1c20          .dw XT_EXIT
                 .include "words/spirw.asm"
                 
                 ; MCU
                 ; SPI exchange of 1 byte
                 VE_SPIRW:
000e4a ff06          .dw $ff06
000e4b 2163
000e4c 7340
000e4d 6970          .db "c!@spi"
000e4e 0e37          .dw VE_HEAD
                     .set VE_HEAD  = VE_SPIRW
                 XT_SPIRW:
000e4f 0e50          .dw PFA_SPIRW
                 PFA_SPIRW:
000e50 d003          rcall do_spirw
000e51 2799          clr tosh
000e52 940c 1c05     jmp_ DO_NEXT
                 
                 do_spirw:
000e54 b98f          out_ SPDR, tosl
                 do_spirw1:
000e55 b10e          in_ temp0, SPSR
000e56 7f08          cbr temp0,7
000e57 b90e          out_ SPSR, temp0
000e58 b10e          in_ temp0, SPSR
000e59 ff07          sbrs temp0, 7
000e5a cffa          rjmp do_spirw1   ; wait until complete
000e5b b18f          in_ tosl, SPDR
000e5c 9508          ret
                 .include "words/n-spi.asm"
                 
                 ; MCU
                 ; read len bytes from SPI to addr
                 VE_N_SPIR:
000e5d ff05          .dw $ff05
000e5e 406e
000e5f 7073
000e60 0069          .db "n@spi",0
000e61 0e4a          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIR
                 XT_N_SPIR:
000e62 0e63          .dw PFA_N_SPIR
                 PFA_N_SPIR:
000e63 018c          movw temp0, tosl
000e64 9189
000e65 9199          loadtos
000e66 01fc          movw zl, tosl
000e67 01c8          movw tosl, temp0
                 PFA_N_SPIR_LOOP:
000e68 b82f          out_ SPDR, zerol
                 PFA_N_SPIR_LOOP1:
000e69 b12e          in_ temp2, SPSR
000e6a ff27          sbrs temp2, SPIF
000e6b cffd          rjmp PFA_N_SPIR_LOOP1
000e6c b12f          in_ temp2, SPDR
000e6d 9321          st Z+, temp2
000e6e 9701          sbiw tosl, 1
000e6f f7c1          brne PFA_N_SPIR_LOOP
000e70 9189
000e71 9199          loadtos
000e72 940c 1c05     jmp_ DO_NEXT
                 
                 ; ( addr len -- ) 
                 ; MCU
                 ; write len bytes to SPI from addr
                 VE_N_SPIW:
000e74 ff05          .dw $ff05
000e75 216e
000e76 7073
000e77 0069          .db "n!spi",0
000e78 0e5d          .dw VE_HEAD
                     .set VE_HEAD  = VE_N_SPIW
                 XT_N_SPIW:
000e79 0e7a          .dw PFA_N_SPIW
                 PFA_N_SPIW:
000e7a 018c          movw temp0, tosl
000e7b 9189
000e7c 9199          loadtos
000e7d 01fc          movw zl, tosl
000e7e 01c8          movw tosl, temp0
                 PFA_N_SPIW_LOOP:
000e7f 9121          ld temp2, Z+
000e80 b92f          out_ SPDR, temp2
                 PFA_N_SPIW_LOOP1:
000e81 b12e          in_ temp2, SPSR
000e82 ff27          sbrs temp2, SPIF
000e83 cffd          rjmp PFA_N_SPIW_LOOP1
000e84 b12f          in_ temp2, SPDR ; ignore the data
000e85 9701          sbiw tosl, 1
000e86 f7c1          brne PFA_N_SPIW_LOOP
000e87 9189
000e88 9199          loadtos
000e89 940c 1c05     jmp_ DO_NEXT
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
000e8b ff0b          .dw $ff0b
000e8c 7061
000e8d 6c70
000e8e 7574
000e8f 6e72
000e90 656b
000e91 0079          .db "applturnkey",0
000e92 0e74          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000e93 1c01          .dw DO_COLON
                 PFA_APPLTURNKEY:
000e94 00bc          .dw XT_USART
                 
                 .if WANT_INTERRUPTS == 1
000e95 0220          .dw XT_INTON
                 .endif
000e96 0c2a          .dw XT_DOT_VER
000e97 088d          .dw XT_SPACE
000e98 05e9          .dw XT_F_CPU
000e99 1c3d          .dw XT_DOLITERAL
000e9a 03e8          .dw 1000
000e9b 1dc2          .dw XT_UMSLASHMOD
000e9c 1cf0          .dw XT_NIP
000e9d 0687          .dw XT_DECIMAL
000e9e 07cd          .dw XT_DOT
000e9f 0818          .dw XT_DOSLITERAL
000ea0 0004          .dw 4
000ea1 486b
000ea2 207a          .db "kHz "
000ea3 084b          .dw XT_ITYPE
000ea4 1c20          .dw XT_EXIT
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
000ea5 ff0b          .dw $ff0b
000ea6 6573
000ea7 2d74
000ea8 7563
000ea9 7272
000eaa 6e65
000eab 0074          .db "set-current",0
000eac 0e8b          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
000ead 1c01          .dw DO_COLON
                 PFA_SET_CURRENT:
000eae 1c3d          .dw XT_DOLITERAL
000eaf 003c          .dw CFG_CURRENT
000eb0 1f31          .dw XT_STOREE
000eb1 1c20          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
000eb2 ff08          .dw $ff08
000eb3 6f77
000eb4 6472
000eb5 696c
000eb6 7473          .db "wordlist"
000eb7 0ea5          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
000eb8 1c01          .dw DO_COLON
                 PFA_WORDLIST:
000eb9 0661          .dw XT_EHERE
000eba 1d54          .dw XT_ZERO
000ebb 1ccf          .dw XT_OVER
000ebc 1f31          .dw XT_STOREE
000ebd 1cb1          .dw XT_DUP
000ebe 0607          .dw XT_CELLPLUS
000ebf 0c5f          .dw XT_DOTO
000ec0 0662          .dw PFA_EHERE
000ec1 1c20          .dw XT_EXIT
                 
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTHWORDLIST:
000ec2 ff0e          .dw $ff0e
000ec3 6f66
000ec4 7472
000ec5 2d68
000ec6 6f77
000ec7 6472
000ec8 696c
000ec9 7473          .db "forth-wordlist"
000eca 0eb2          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHWORDLIST
                 XT_FORTHWORDLIST:
000ecb 1c48          .dw PFA_DOVARIABLE
                 PFA_FORTHWORDLIST:
000ecc 003e          .dw CFG_FORTHWORDLIST
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000ecd ff04          .dw $ff04
000ece 6f63
000ecf 6564          .db "code"
000ed0 0ec2          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
000ed1 1c01          .dw DO_COLON
                 PFA_CODE:
000ed2 029d          .dw XT_DOCREATE
000ed3 0408          .dw XT_REVEAL
000ed4 0658          .dw XT_DP
000ed5 0c71          .dw XT_ICELLPLUS
000ed6 02d6          .dw XT_COMMA
000ed7 1c20          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000ed8 ff08          .dw $ff08
000ed9 6e65
000eda 2d64
000edb 6f63
000edc 6564          .db "end-code"
000edd 0ecd          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000ede 1c01          .dw DO_COLON
                 PFA_ENDCODE:
000edf 02cb          .dw XT_COMPILE
000ee0 940c          .dw $940c
000ee1 02cb          .dw XT_COMPILE
000ee2 1c05          .dw DO_NEXT
000ee3 1c20          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
000ee4 ff08          .dw $ff08
000ee5 6d28
000ee6 7261
000ee7 656b
000ee8 2972          .db "(marker)"
000ee9 0ed8          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
000eea 1c6f          .dw PFA_DOVALUE1
                 PFA_MARKER:
000eeb 005e          .dw EE_MARKER
000eec 0c7a          .dw XT_EDEFERFETCH
000eed 0c84          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
000eee 0008          .dw $0008
000eef 6f70
000ef0 7473
000ef1 6f70
000ef2 656e          .db "postpone"
000ef3 0ee4          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
000ef4 1c01          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
000ef5 0a69          .dw XT_PARSENAME
000ef6 0b96          .dw XT_FORTHRECOGNIZER
000ef7 0b6c          .dw XT_RECOGNIZE
000ef8 1cb1          .dw XT_DUP
000ef9 1cff          .dw XT_TO_R
000efa 0c71          .dw XT_ICELLPLUS
000efb 0c71          .dw XT_ICELLPLUS
000efc 1fc1          .dw XT_FETCHI
000efd 1c2a          .dw XT_EXECUTE
000efe 1cf6          .dw XT_R_FROM
000eff 0c71          .dw XT_ICELLPLUS
000f00 1fc1          .dw XT_FETCHI
000f01 02d6          .dw XT_COMMA
000f02 1c20          .dw XT_EXIT
                 .endif
                 .include "words/2r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_2R_FETCH:
000f03 ff03          .dw $ff03
000f04 7232
000f05 0040          .db "2r@",0
000f06 0eee          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FETCH
                 XT_2R_FETCH:
000f07 0f08          .dw PFA_2R_FETCH
                 PFA_2R_FETCH:
000f08 939a
000f09 938a          savetos
000f0a 91ef          pop zl
000f0b 91ff          pop zh
000f0c 918f          pop tosl
000f0d 919f          pop tosh
000f0e 939f          push tosh
000f0f 938f          push tosl
000f10 93ff          push zh
000f11 93ef          push zl
000f12 939a
000f13 938a          savetos
000f14 01cf          movw tosl, zl
000f15 940c 1c05     jmp_ DO_NEXT
                 
                 .set DPSTART = pc
                 .if(pc>AMFORTH_RO_SEG)
                 .endif
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
001c01 93bf          push XH
001c02 93af          push XL          ; PUSH IP
001c03 01db          movw XL, wl
001c04 9611          adiw xl, 1
                 DO_NEXT:
                 .if WANT_INTERRUPTS == 1
001c05 14b2          cp isrflag, zerol
001c06 f469          brne DO_INTERRUPT
                 .endif
001c07 01fd          movw zl, XL        ; READ IP
001c08 0fee
001c09 1fff
001c0a 9165
001c0b 9175          readflashcell wl, wh
001c0c 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
001c0d 01fb          movw zl, wl
001c0e 0fee
001c0f 1fff
001c10 9105
001c11 9115          readflashcell temp0,temp1
001c12 01f8          movw zl, temp0
001c13 9409          ijmp
                 
                 .if WANT_INTERRUPTS == 1
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
001c14 939a
001c15 938a          savetos
001c16 2d8b          mov tosl, isrflag
001c17 24bb          clr isrflag
001c18 2799          clr tosh
001c19 e46c          ldi wl, LOW(XT_ISREXEC)
001c1a e072          ldi wh, HIGH(XT_ISREXEC)
001c1b cff1          rjmp DO_EXECUTE
                 .endif
                 .include "dict/nrww.inc"
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
001c1c ff04          .dw $ff04
001c1d 7865
001c1e 7469          .db "exit"
001c1f 0f03          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
001c20 1c21          .dw PFA_EXIT
                 PFA_EXIT:
001c21 91af          pop XL
001c22 91bf          pop XH
001c23 cfe1          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
001c24 ff07          .dw $ff07
001c25 7865
001c26 6365
001c27 7475
001c28 0065          .db "execute",0
001c29 1c1c          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
001c2a 1c2b          .dw PFA_EXECUTE
                 PFA_EXECUTE:
001c2b 01bc          movw wl, tosl
001c2c 9189
001c2d 9199          loadtos
001c2e cfde          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
001c2f 1c30          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
001c30 01fd          movw zl, XL
001c31 0fee
001c32 1fff
001c33 91a5
001c34 91b5          readflashcell XL,XH
001c35 cfcf          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
001c36 1c37          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
001c37 2b98          or tosh, tosl
001c38 9189
001c39 9199          loadtos
001c3a f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
001c3b 9611          adiw XL, 1
001c3c cfc8          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
001c3d 1c3e          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
001c3e 939a
001c3f 938a          savetos
001c40 01fd          movw zl, xl
001c41 0fee
001c42 1fff
001c43 9185
001c44 9195          readflashcell tosl,tosh
001c45 9611          adiw xl, 1
001c46 cfbe          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
001c47 1c48          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
001c48 939a
001c49 938a          savetos
001c4a 01fb          movw zl, wl
001c4b 9631          adiw zl,1
001c4c 0fee
001c4d 1fff
001c4e 9185
001c4f 9195          readflashcell tosl,tosh
001c50 cfb4          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
001c51 1c52          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
001c52 939a
001c53 938a          savetos
001c54 01cb          movw tosl, wl
001c55 9601          adiw tosl, 1
001c56 cfae          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
001c57 1c58          .dw PFA_DOUSER
                 PFA_DOUSER:
001c58 939a
001c59 938a          savetos
001c5a 01fb          movw zl, wl
001c5b 9631          adiw zl, 1
001c5c 0fee
001c5d 1fff
001c5e 9185
001c5f 9195          readflashcell tosl,tosh
001c60 0d84          add tosl, upl
001c61 1d95          adc tosh, uph
001c62 cfa2          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
001c63 ff07          .dw $ff07
001c64 7628
001c65 6c61
001c66 6575
001c67 0029          .db "(value)", 0
001c68 1c24          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
001c69 1c01          .dw DO_COLON
                 PFA_DOVALUE:
001c6a 029d          .dw XT_DOCREATE
001c6b 0408          .dw XT_REVEAL
001c6c 02cb          .dw XT_COMPILE
001c6d 1c6f          .dw PFA_DOVALUE1
001c6e 1c20          .dw XT_EXIT
                 PFA_DOVALUE1:
001c6f 940e 0421     call_ DO_DODOES
001c71 1cb1          .dw XT_DUP
001c72 0c71          .dw XT_ICELLPLUS
001c73 1fc1          .dw XT_FETCHI
001c74 1c2a          .dw XT_EXECUTE
001c75 1c20          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
001c76 ff01          .dw $ff01
001c77 0040          .db "@",0
001c78 1c63          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
001c79 1c7a          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
001c7a 01fc          movw zl, tosl
                     ; low byte is read before the high byte
001c7b 9181          ld tosl, z+
001c7c 9191          ld tosh, z+
001c7d cf87          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
001c7e ff01          .dw $ff01
001c7f 0021          .db "!",0
001c80 1c76          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
001c81 1c82          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
001c82 01fc          movw zl, tosl
001c83 9189
001c84 9199          loadtos
                     ; the high byte is written before the low byte
001c85 8391          std Z+1, tosh
001c86 8380          std Z+0, tosl
001c87 9189
001c88 9199          loadtos
001c89 cf7b          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
001c8a ff02          .dw $ff02
001c8b 2163          .db "c!"
001c8c 1c7e          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
001c8d 1c8e          .dw PFA_CSTORE
                 PFA_CSTORE:
001c8e 01fc          movw zl, tosl
001c8f 9189
001c90 9199          loadtos
001c91 8380          st Z, tosl
001c92 9189
001c93 9199          loadtos
001c94 cf70          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
001c95 ff02          .dw $ff02
001c96 4063          .db "c@"
001c97 1c8a          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
001c98 1c99          .dw PFA_CFETCH
                 PFA_CFETCH:
001c99 01fc          movw zl, tosl
001c9a 2799          clr tosh
001c9b 8180          ld tosl, Z
001c9c cf68          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
001c9d ff02          .dw $ff02
001c9e 7540          .db "@u"
001c9f 1c95          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
001ca0 1c01          .dw DO_COLON
                 PFA_FETCHU:
001ca1 1f02          .dw XT_UP_FETCH
001ca2 1d9d          .dw XT_PLUS
001ca3 1c79          .dw XT_FETCH
001ca4 1c20          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
001ca5 ff02          .dw $ff02
001ca6 7521          .db "!u"
001ca7 1c9d          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
001ca8 1c01          .dw DO_COLON
                 PFA_STOREU:
001ca9 1f02          .dw XT_UP_FETCH
001caa 1d9d          .dw XT_PLUS
001cab 1c81          .dw XT_STORE
001cac 1c20          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
001cad ff03          .dw $ff03
001cae 7564
001caf 0070          .db "dup",0
001cb0 1ca5          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
001cb1 1cb2          .dw PFA_DUP
                 PFA_DUP:
001cb2 939a
001cb3 938a          savetos
001cb4 cf50          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
001cb5 ff04          .dw $ff04
001cb6 643f
001cb7 7075          .db "?dup"
001cb8 1cad          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
001cb9 1cba          .dw PFA_QDUP
                 PFA_QDUP:
001cba 2f08          mov temp0, tosl
001cbb 2b09          or temp0, tosh
001cbc f011          breq PFA_QDUP1
001cbd 939a
001cbe 938a          savetos
                 PFA_QDUP1:
001cbf cf45          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
001cc0 ff04          .dw $ff04
001cc1 7773
001cc2 7061          .db "swap"
001cc3 1cb5          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
001cc4 1cc5          .dw PFA_SWAP
                 PFA_SWAP:
001cc5 018c          movw temp0, tosl
001cc6 9189
001cc7 9199          loadtos
001cc8 931a          st -Y, temp1
001cc9 930a          st -Y, temp0
001cca cf3a          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
001ccb ff04          .dw $ff04
001ccc 766f
001ccd 7265          .db "over"
001cce 1cc0          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
001ccf 1cd0          .dw PFA_OVER
                 PFA_OVER:
001cd0 939a
001cd1 938a          savetos
001cd2 818a          ldd tosl, Y+2
001cd3 819b          ldd tosh, Y+3
                 
001cd4 cf30          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
001cd5 ff04          .dw $ff04
001cd6 7264
001cd7 706f          .db "drop"
001cd8 1ccb          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
001cd9 1cda          .dw PFA_DROP
                 PFA_DROP:
001cda 9189
001cdb 9199          loadtos
001cdc cf28          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
001cdd ff03          .dw $ff03
001cde 6f72
001cdf 0074          .db "rot",0
001ce0 1cd5          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
001ce1 1ce2          .dw PFA_ROT
                 PFA_ROT:
001ce2 018c          movw temp0, tosl
001ce3 9129          ld temp2, Y+
001ce4 9139          ld temp3, Y+ 
001ce5 9189
001ce6 9199          loadtos
                         
001ce7 933a          st -Y, temp3
001ce8 932a          st -Y, temp2
001ce9 931a          st -Y, temp1
001cea 930a          st -Y, temp0
                 
001ceb cf19          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
001cec ff03          .dw $ff03
001ced 696e
001cee 0070          .db "nip",0
001cef 1cdd          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
001cf0 1cf1          .dw PFA_NIP
                 PFA_NIP:
001cf1 9622          adiw yl, 2
001cf2 cf12          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
001cf3 ff02          .dw $ff02
001cf4 3e72          .db "r>"
001cf5 1cec          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
001cf6 1cf7          .dw PFA_R_FROM
                 PFA_R_FROM:
001cf7 939a
001cf8 938a          savetos
001cf9 918f          pop tosl
001cfa 919f          pop tosh
001cfb cf09          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
001cfc ff02          .dw $ff02
001cfd 723e          .db ">r"
001cfe 1cf3          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
001cff 1d00          .dw PFA_TO_R
                 PFA_TO_R:
001d00 939f          push tosh
001d01 938f          push tosl
001d02 cfd7          jmp_ PFA_DROP
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
001d03 ff02          .dw $ff02
001d04 4072          .db "r@"
001d05 1cfc          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
001d06 1d07          .dw PFA_R_FETCH
                 PFA_R_FETCH:
001d07 939a
001d08 938a          savetos
001d09 918f          pop tosl
001d0a 919f          pop tosh
001d0b 939f          push tosh
001d0c 938f          push tosl
001d0d cef7          jmp_ DO_NEXT
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
001d0e ff02          .dw $ff02
001d0f 3e3c          .db "<>"
001d10 1d03          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
001d11 1c01          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
001d12 1fd6
001d13 1d18
001d14 1c20          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
001d15 ff02          .dw $ff02
001d16 3d30          .db "0="
001d17 1d0e          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
001d18 1d19          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
001d19 2b98          or tosh, tosl
001d1a f5e1          brne PFA_ZERO1
001d1b c032          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
001d1c ff02          .dw $ff02
001d1d 3c30          .db "0<"
001d1e 1d15          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
001d1f 1d20          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
001d20 fd97          sbrc tosh,7
001d21 c02c          rjmp PFA_TRUE1
001d22 c034          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
001d23 ff02          .dw $ff02
001d24 3e30          .db "0>"
001d25 1d1c          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
001d26 1d27          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
001d27 1582          cp tosl, zerol
001d28 0593          cpc tosh, zeroh
001d29 f16c          brlt PFA_ZERO1
001d2a f161          brbs 1, PFA_ZERO1
001d2b c022          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
001d2c ff03          .dw $ff03
001d2d 3064
001d2e 003e          .db "d0>",0
001d2f 1d23          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
001d30 1d31          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
001d31 1593          cp tosh, zeroh
001d32 f03c          brlt PFA_DGREATERZERO_FALSE ; if MSBit is set, d:arg is negative, we are done (false).
001d33 0582          cpc tosl, zerol
001d34 9189
001d35 9199          loadtos
001d36 0582          cpc tosl, zerol
001d37 0593          cpc tosh, zeroh
001d38 f0f1          brbs 1, PFA_ZERO1           ; if all 4 Bytes of d:arg are zero, we are done (false).
001d39 c014          rjmp PFA_TRUE1              ; if we get this far, d:arg was positive! (true)
                 PFA_DGREATERZERO_FALSE:
001d3a 01c1          movw tosl, zerol            ; ZERO
001d3b cfb5          rjmp PFA_NIP                ; NIP
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
001d3c ff03          .dw $ff03
001d3d 3064
001d3e 003c          .db "d0<",0
001d3f 1d2c          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
001d40 1d41          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
001d41 9622          adiw Y,2
001d42 fd97          sbrc tosh,7
001d43 940c 1d4e     jmp PFA_TRUE1
001d45 940c 1d57     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
001d47 ff04          .dw $ff04
001d48 7274
001d49 6575          .db "true"
001d4a 1d3c          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
001d4b 1d4c          .dw PFA_TRUE
                 PFA_TRUE:
001d4c 939a
001d4d 938a          savetos
                 PFA_TRUE1:
001d4e ef8f          ser tosl
001d4f ef9f          ser tosh
001d50 ceb4          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
001d51 ff01          .dw $ff01
001d52 0030          .db "0",0
001d53 1d47          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
001d54 1d55          .dw PFA_ZERO
                 PFA_ZERO:
001d55 939a
001d56 938a          savetos
                 PFA_ZERO1:
001d57 01c1          movw tosl, zerol
001d58 ceac          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
001d59 ff02          .dw $ff02
001d5a 3c75          .db "u<"
001d5b 1d51          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
001d5c 1d5d          .dw PFA_ULESS
                 PFA_ULESS:
001d5d 9129          ld temp2, Y+
001d5e 9139          ld temp3, Y+
001d5f 1782          cp tosl, temp2
001d60 0793          cpc tosh, temp3
001d61 f3a8          brlo PFA_ZERO1
001d62 f3a1          brbs 1, PFA_ZERO1
001d63 cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
001d64 ff02          .dw $ff02
001d65 3e75          .db "u>"
001d66 1d59          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
001d67 1c01          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
001d68 1cc4          .DW XT_SWAP
001d69 1d5c          .dw XT_ULESS
001d6a 1c20          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
001d6b ff01          .dw $ff01
001d6c 003c          .db "<",0
001d6d 1d64          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
001d6e 1d6f          .dw PFA_LESS
                 PFA_LESS:
001d6f 9129          ld temp2, Y+
001d70 9139          ld temp3, Y+
001d71 1728          cp temp2, tosl
001d72 0739          cpc temp3, tosh
                 PFA_LESSDONE:
001d73 f71c          brge PFA_ZERO1
001d74 cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
001d75 ff01          .dw $ff01
001d76 003e          .db ">",0
001d77 1d6b          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
001d78 1d79          .dw PFA_GREATER
                 PFA_GREATER:
001d79 9129          ld temp2, Y+
001d7a 9139          ld temp3, Y+
001d7b 1728          cp temp2, tosl
001d7c 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
001d7d f2cc          brlt PFA_ZERO1
001d7e f2c1          brbs 1, PFA_ZERO1
001d7f cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
001d80 ff04          .dw $ff04
001d81 6f6c
001d82 3267          .db "log2"
001d83 1d75          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
001d84 1d85          .dw PFA_LOG2
                 PFA_LOG2:
001d85 01fc          movw zl, tosl
001d86 2799          clr tosh
001d87 e180          ldi tosl, 16
                 PFA_LOG2_1:
001d88 958a          dec tosl
001d89 f022          brmi PFA_LOG2_2 ; wrong data
001d8a 0fee          lsl  zl
001d8b 1fff          rol  zh
001d8c f7d8          brcc PFA_LOG2_1
001d8d ce77          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
001d8e 959a          dec tosh
001d8f ce75          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
001d90 ff01          .dw $ff01
001d91 002d          .db "-",0
001d92 1d80          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
001d93 1d94          .dw PFA_MINUS
                 PFA_MINUS:
001d94 9109          ld temp0, Y+
001d95 9119          ld temp1, Y+
001d96 1b08          sub temp0, tosl
001d97 0b19          sbc temp1, tosh
001d98 01c8          movw tosl, temp0
001d99 ce6b          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
001d9a ff01          .dw $ff01
001d9b 002b          .db "+",0
001d9c 1d90          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
001d9d 1d9e          .dw PFA_PLUS
                 PFA_PLUS:
001d9e 9109          ld temp0, Y+
001d9f 9119          ld temp1, Y+
001da0 0f80          add tosl, temp0
001da1 1f91          adc tosh, temp1
001da2 ce62          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
001da3 ff02          .dw $ff02
001da4 2a6d          .db "m*"
001da5 1d9a          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
001da6 1da7          .dw PFA_MSTAR
                 PFA_MSTAR:
001da7 018c          movw temp0, tosl
001da8 9189
001da9 9199          loadtos
001daa 019c          movw temp2, tosl
                     ; high cell ah*bh
001dab 0231          muls temp3, temp1
001dac 0170          movw temp4, r0
                     ; low cell  al*bl
001dad 9f20          mul  temp2, temp0
001dae 01c0          movw tosl, r0
                     ; signed ah*bl
001daf 0330          mulsu temp3, temp0
001db0 08f3          sbc   temp5, zeroh
001db1 0d90          add   tosh,  r0
001db2 1ce1          adc   temp4, r1
001db3 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
001db4 0312          mulsu temp1, temp2
001db5 08f3          sbc   temp5, zeroh
001db6 0d90          add   tosh,  r0
001db7 1ce1          adc   temp4, r1
001db8 1cf3          adc   temp5, zeroh
                 
001db9 939a
001dba 938a          savetos
001dbb 01c7          movw tosl, temp4
001dbc ce48          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
001dbd ff06          .dw $ff06
001dbe 6d75
001dbf 6d2f
001dc0 646f          .db "um/mod"
001dc1 1da3          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
001dc2 1dc3          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
001dc3 017c          movw temp4, tosl
                 
001dc4 9129          ld temp2, Y+
001dc5 9139          ld temp3, Y+
                   
001dc6 9109          ld temp0, Y+
001dc7 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
001dc8 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
001dc9 2755          clr temp7
001dca 0f00          lsl temp0
001dcb 1f11          rol temp1
001dcc 1f22          rol temp2
001dcd 1f33          rol temp3
001dce 1f55          rol temp7
                 
                   ; try subtracting divisor
001dcf 152e          cp temp2, temp4
001dd0 053f          cpc temp3, temp5
001dd1 0552          cpc temp7,zerol
                 
001dd2 f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
001dd3 9503          inc temp0
001dd4 192e          sub temp2, temp4
001dd5 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
001dd6 954a          dec  temp6
001dd7 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
001dd8 933a          st -Y,temp3
001dd9 932a          st -Y,temp2
                 
                     ; put quotient on stack
001dda 01c8          movw tosl, temp0
001ddb ce29          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
001ddc ff03          .dw $ff03
001ddd 6d75
001dde 002a          .db "um*",0
001ddf 1dbd          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
001de0 1de1          .dw PFA_UMSTAR
                 PFA_UMSTAR:
001de1 018c          movw temp0, tosl
001de2 9189
001de3 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
001de4 9f80          mul tosl,temp0
001de5 01f0          movw zl, r0
001de6 2722          clr temp2
001de7 2733          clr temp3
                     ; middle bytes
001de8 9f90          mul tosh, temp0
001de9 0df0          add zh, r0
001dea 1d21          adc temp2, r1
001deb 1d33          adc temp3, zeroh
                         
001dec 9f81          mul tosl, temp1
001ded 0df0          add zh, r0
001dee 1d21          adc temp2, r1
001def 1d33          adc temp3, zeroh
                     
001df0 9f91          mul tosh, temp1
001df1 0d20          add temp2, r0
001df2 1d31          adc temp3, r1
001df3 01cf          movw tosl, zl
001df4 939a
001df5 938a          savetos
001df6 01c9          movw tosl, temp2
001df7 ce0d          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
001df8 ff06          .dw $ff06
001df9 6e69
001dfa 6576
001dfb 7472          .db "invert"
001dfc 1ddc          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
001dfd 1dfe          .dw PFA_INVERT
                 PFA_INVERT:
001dfe 9580          com tosl
001dff 9590          com tosh
001e00 ce04          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
001e01 ff02          .dw $ff02
001e02 2f32          .db "2/"
001e03 1df8          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
001e04 1e05          .dw PFA_2SLASH
                 PFA_2SLASH:
001e05 9595          asr tosh
001e06 9587          ror tosl
001e07 cdfd          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
001e08 ff02          .dw $ff02
001e09 2a32          .db "2*"
001e0a 1e01          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
001e0b 1e0c          .dw PFA_2STAR
                 PFA_2STAR:
001e0c 0f88          lsl tosl
001e0d 1f99          rol tosh
001e0e cdf6          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
001e0f ff03          .dw $ff03
001e10 6e61
001e11 0064          .db "and",0
001e12 1e08          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
001e13 1e14          .dw PFA_AND
                 PFA_AND:
001e14 9109          ld temp0, Y+
001e15 9119          ld temp1, Y+
001e16 2380          and tosl, temp0
001e17 2391          and tosh, temp1
001e18 cdec          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
001e19 ff02          .dw $ff02
001e1a 726f          .db "or"
001e1b 1e0f          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
001e1c 1e1d          .dw PFA_OR
                 PFA_OR:
001e1d 9109          ld temp0, Y+
001e1e 9119          ld temp1, Y+
001e1f 2b80          or tosl, temp0
001e20 2b91          or tosh, temp1
001e21 cde3          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
001e22 ff03          .dw $ff03
001e23 6f78
001e24 0072          .db "xor",0
001e25 1e19          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
001e26 1e27          .dw PFA_XOR
                 PFA_XOR:
001e27 9109          ld temp0, Y+
001e28 9119          ld temp1, Y+
001e29 2780          eor tosl, temp0
001e2a 2791          eor tosh, temp1
001e2b cdd9          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
001e2c ff02          .dw $ff02
001e2d 2b31          .db "1+"
001e2e 1e22          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
001e2f 1e30          .dw PFA_1PLUS
                 PFA_1PLUS:
001e30 9601          adiw tosl,1
001e31 cdd3          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
001e32 ff02          .dw $ff02 
001e33 2d31          .db "1-"
001e34 1e2c          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
001e35 1e36          .dw PFA_1MINUS
                 PFA_1MINUS:
001e36 9701          sbiw tosl, 1
001e37 cdcd          jmp_ DO_NEXT
                 .include "words/q-negate.asm"
                 
                 ;   0< IF NEGATE THEN ;        ...a common factor
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QNEGATE:
001e38 ff07          .dw $ff07
001e39 6e3f
001e3a 6765
001e3b 7461
../../common\words/q-negate.asm(11): warning: .cseg .db misalignment - padding zero byte
001e3c 0065          .db "?negate"
001e3d 1e32          .dw VE_HEAD
                     .set VE_HEAD = VE_QNEGATE
                 XT_QNEGATE:
001e3e 1c01          .dw DO_COLON
                 PFA_QNEGATE:
                 
                 .endif
001e3f 1d1f
001e40 1c36              .DW XT_ZEROLESS,XT_DOCONDBRANCH
001e41 1e43              DEST(QNEG1)
001e42 06ea              .DW XT_NEGATE
001e43 1c20      QNEG1:  .DW XT_EXIT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
001e44 ff06          .dw $ff06
001e45 736c
001e46 6968
001e47 7466          .db "lshift"
001e48 1e38          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
001e49 1e4a          .dw PFA_LSHIFT
                 PFA_LSHIFT:
001e4a 01fc          movw zl, tosl
001e4b 9189
001e4c 9199          loadtos
                 PFA_LSHIFT1:
001e4d 9731          sbiw zl, 1
001e4e f01a          brmi PFA_LSHIFT2
001e4f 0f88          lsl tosl
001e50 1f99          rol tosh
001e51 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
001e52 cdb2          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
001e53 ff06          .dw $ff06
001e54 7372
001e55 6968
001e56 7466          .db "rshift"
001e57 1e44          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
001e58 1e59          .dw PFA_RSHIFT
                 PFA_RSHIFT:
001e59 01fc          movw zl, tosl
001e5a 9189
001e5b 9199          loadtos
                 PFA_RSHIFT1:
001e5c 9731          sbiw zl, 1
001e5d f01a          brmi PFA_RSHIFT2
001e5e 9596          lsr tosh
001e5f 9587          ror tosl
001e60 cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
001e61 cda3          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
001e62 ff02          .dw $ff02
001e63 212b          .db "+!"
001e64 1e53          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
001e65 1e66          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
001e66 01fc          movw zl, tosl
001e67 9189
001e68 9199          loadtos
001e69 8120          ldd temp2, Z+0
001e6a 8131          ldd temp3, Z+1
001e6b 0f82          add tosl, temp2
001e6c 1f93          adc tosh, temp3
001e6d 8380          std Z+0, tosl
001e6e 8391          std Z+1, tosh
001e6f 9189
001e70 9199          loadtos
001e71 cd93          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
001e72 ff03          .dw $ff03
001e73 7072
001e74 0040          .db "rp@",0
001e75 1e62          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
001e76 1e77          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
001e77 939a
001e78 938a          savetos
001e79 b78d          in tosl, SPL
001e7a b79e          in tosh, SPH
001e7b cd89          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
001e7c ff03          .dw $ff03
001e7d 7072
001e7e 0021          .db "rp!",0
001e7f 1e72          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
001e80 1e81          .dw PFA_RP_STORE
                 PFA_RP_STORE:
001e81 b72f          in temp2, SREG
001e82 94f8          cli
001e83 bf8d          out SPL, tosl
001e84 bf9e          out SPH, tosh
001e85 bf2f          out SREG, temp2
001e86 9189
001e87 9199          loadtos
001e88 cd7c          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
001e89 ff03          .dw $ff03
001e8a 7073
001e8b 0040          .db "sp@",0
001e8c 1e7c          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
001e8d 1e8e          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
001e8e 939a
001e8f 938a          savetos
001e90 01ce          movw tosl, yl
001e91 cd73          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
001e92 ff03          .dw $ff03
001e93 7073
001e94 0021          .db "sp!",0
001e95 1e89          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
001e96 1e97          .dw PFA_SP_STORE
                 PFA_SP_STORE:
001e97 01ec          movw yl, tosl
001e98 9189
001e99 9199          loadtos
001e9a cd6a          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
001e9b 1e9c          .dw PFA_DODO
                 PFA_DODO:
001e9c 9129          ld temp2, Y+
001e9d 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
001e9e e8e0          ldi zl, $80
001e9f 0f3e          add temp3, zl
001ea0 1b82          sub  tosl, temp2
001ea1 0b93          sbc  tosh, temp3
                 
001ea2 933f          push temp3
001ea3 932f          push temp2    ; limit  ( --> limit + $8000)
001ea4 939f          push tosh
001ea5 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
001ea6 9189
001ea7 9199          loadtos
001ea8 cd5c          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
001ea9 ff01          .dw $FF01
001eaa 0069          .db "i",0
001eab 1e92          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
001eac 1ead          .dw PFA_I
                 PFA_I:
001ead 939a
001eae 938a          savetos
001eaf 918f          pop tosl
001eb0 919f          pop tosh  ; index
001eb1 91ef          pop zl
001eb2 91ff          pop zh    ; limit
001eb3 93ff          push zh
001eb4 93ef          push zl
001eb5 939f          push tosh
001eb6 938f          push tosl
001eb7 0f8e          add tosl, zl
001eb8 1f9f          adc tosh, zh
001eb9 cd4b          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
001eba 1ebb          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
001ebb 91ef          pop zl
001ebc 91ff          pop zh
001ebd 0fe8          add zl, tosl
001ebe 1ff9          adc zh, tosh
001ebf 9189
001ec0 9199          loadtos
001ec1 f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
001ec2 93ff          push zh
001ec3 93ef          push zl
001ec4 cd6b          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
001ec5 910f          pop  temp0
001ec6 911f          pop  temp1  ; remove limit
001ec7 9611          adiw xl, 1  ; skip branch-back address
001ec8 cd3c          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
001ec9 1eca          .dw PFA_DOLOOP
                 PFA_DOLOOP:
001eca 91ef          pop zl
001ecb 91ff          pop zh
001ecc 9631          adiw zl,1
001ecd f3bb          brvs PFA_DOPLUSLOOP_LEAVE
001ece cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
001ecf ff06          .dw $ff06
001ed0 6e75
001ed1 6f6c
001ed2 706f          .db "unloop"
001ed3 1ea9          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
001ed4 1ed5          .dw PFA_UNLOOP
                 PFA_UNLOOP:
001ed5 911f          pop temp1
001ed6 910f          pop temp0
001ed7 911f          pop temp1
001ed8 910f          pop temp0
001ed9 cd2b          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
001eda ff06          .dw $ff06
001edb 6d63
001edc 766f
001edd 3e65          .db "cmove>"
001ede 1ecf          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
001edf 1ee0          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
001ee0 93bf          push xh
001ee1 93af          push xl
001ee2 91e9          ld zl, Y+
001ee3 91f9          ld zh, Y+ ; addr-to
001ee4 91a9          ld xl, Y+
001ee5 91b9          ld xh, Y+ ; addr-from
001ee6 2f09          mov temp0, tosh
001ee7 2b08          or temp0, tosl
001ee8 f041          brbs 1, PFA_CMOVE_G1
001ee9 0fe8          add zl, tosl
001eea 1ff9          adc zh, tosh
001eeb 0fa8          add xl, tosl
001eec 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
001eed 911e          ld temp1, -X
001eee 9312          st -Z, temp1
001eef 9701          sbiw tosl, 1
001ef0 f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
001ef1 91af          pop xl
001ef2 91bf          pop xh
001ef3 9189
001ef4 9199          loadtos
001ef5 cd0f          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
001ef6 ff02          .dw $ff02
001ef7 3c3e          .db "><"
001ef8 1eda          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
001ef9 1efa          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
001efa 2f09          mov temp0, tosh
001efb 2f98          mov tosh, tosl
001efc 2f80          mov tosl, temp0
001efd cd07          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
001efe ff03          .dw $ff03
001eff 7075
001f00 0040          .db "up@",0
001f01 1ef6          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
001f02 1f03          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
001f03 939a
001f04 938a          savetos
001f05 01c2          movw tosl, upl
001f06 ccfe          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
001f07 ff03          .dw $ff03
001f08 7075
001f09 0021          .db "up!",0
001f0a 1efe          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
001f0b 1f0c          .dw PFA_UP_STORE
                 PFA_UP_STORE:
001f0c 012c          movw upl, tosl
001f0d 9189
001f0e 9199          loadtos
001f0f ccf5          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
001f10 ff03          .dw $ff03
001f11 3e32
001f12 0072          .db "2>r",0
001f13 1f07          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
001f14 1f15          .dw PFA_2TO_R
                 PFA_2TO_R:
001f15 01fc          movw zl, tosl
001f16 9189
001f17 9199          loadtos
001f18 939f          push tosh
001f19 938f          push tosl
001f1a 93ff          push zh
001f1b 93ef          push zl
001f1c 9189
001f1d 9199          loadtos
001f1e cce6          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
001f1f ff03          .dw $ff03
001f20 7232
001f21 003e          .db "2r>",0
001f22 1f10          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
001f23 1f24          .dw PFA_2R_FROM
                 PFA_2R_FROM:
001f24 939a
001f25 938a          savetos
001f26 91ef          pop zl
001f27 91ff          pop zh
001f28 918f          pop tosl
001f29 919f          pop tosh
001f2a 939a
001f2b 938a          savetos
001f2c 01cf          movw tosl, zl
001f2d ccd7          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
001f2e ff02          .dw $ff02
001f2f 6521          .db "!e"
001f30 1f1f          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
001f31 1f32          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
001f32 01fc          movw zl, tosl
001f33 9189
001f34 9199          loadtos
001f35 b72f          in_ temp2, SREG
001f36 94f8          cli
001f37 d028          rcall PFA_FETCHE2
001f38 b30d          in_  temp0, EEDR
001f39 1708          cp temp0,tosl
001f3a f009          breq PFA_STOREE3
001f3b d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
001f3c 9631          adiw zl,1
001f3d d022          rcall PFA_FETCHE2
001f3e b30d          in_  temp0, EEDR
001f3f 1709          cp temp0,tosh
001f40 f011          breq PFA_STOREE4
001f41 2f89          mov tosl, tosh
001f42 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
001f43 bf2f          out_ SREG, temp2
001f44 9189
001f45 9199          loadtos
001f46 ccbe          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
001f47 99e1          sbic EECR, EEPE
001f48 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
001f49 b707          in_ temp0, SPMCSR
001f4a fd00          sbrc temp0,SPMEN
001f4b cffd          rjmp PFA_STOREE2
                 
001f4c bbff          out_ EEARH,zh
001f4d bbee          out_ EEARL,zl
001f4e bb8d          out_ EEDR, tosl
001f4f 9ae2          sbi EECR,EEMPE
001f50 9ae1          sbi EECR,EEPE
                 
001f51 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
001f52 ff02          .dw $ff02
001f53 6540          .db "@e"
001f54 1f2e          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
001f55 1f56          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
001f56 b72f          in_ temp2, SREG
001f57 94f8          cli
001f58 01fc          movw zl, tosl
001f59 d006          rcall PFA_FETCHE2
001f5a b38d          in_ tosl, EEDR
                 
001f5b 9631          adiw zl,1
                 
001f5c d003          rcall PFA_FETCHE2
001f5d b39d          in_  tosh, EEDR
001f5e bf2f          out_ SREG, temp2
001f5f cca5          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
001f60 99e1          sbic EECR, EEPE
001f61 cffe          rjmp PFA_FETCHE2
                 
001f62 bbff          out_ EEARH,zh
001f63 bbee          out_ EEARL,zl
                 
001f64 9ae0          sbi EECR,EERE
001f65 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
001f66 ff02          .dw $ff02
001f67 6921          .db "!i"
001f68 1f52          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
001f69 0cd9          .dw PFA_DODEFER1
                 PFA_STOREI:
001f6a 005c          .dw EE_STOREI
001f6b 0c7a          .dw XT_EDEFERFETCH
001f6c 0c84          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                 .else
                   .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
001f6d ff09          .dw $ff09
001f6e 2128
001f6f 2d69
001f70 726e
001f71 7777
001f72 0029          .db "(!i-nrww)",0
001f73 1f66          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
001f74 1f75          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
001f75 b71f        in temp1,SREG
001f76 931f        push temp1
001f77 94f8        cli
                 
001f78 019c        movw temp2, tosl ; save the (word) address
001f79 9189
001f7a 9199        loadtos          ; get the new value for the flash cell
001f7b 93af        push xl
001f7c 93bf        push xh
001f7d 93cf        push yl
001f7e 93df        push yh
001f7f d009        rcall DO_STOREI_atmega
001f80 91df        pop yh
001f81 91cf        pop yl
001f82 91bf        pop xh
001f83 91af        pop xl
                   ; finally clear the stack
001f84 9189
001f85 9199        loadtos
001f86 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
001f87 bf1f        out SREG,temp1
                 
001f88 cc7c        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
001f89 d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
001f8a 94e0        com temp4
001f8b 94f0        com temp5
001f8c 218e        and tosl, temp4
001f8d 219f        and tosh, temp5
001f8e 2b98        or tosh, tosl
001f8f f019        breq DO_STOREI_writepage 
001f90 01f9          movw zl, temp2
001f91 e002          ldi temp0,(1<<PGERS)
001f92 d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
001f93 01f9        movw zl, temp2
001f94 e004        ldi temp0,(1<<PGWRT)
001f95 d01d        rcall dospm
                 
                   ; reenable RWW section
001f96 01f9        movw zl, temp2
001f97 e100        ldi temp0,(1<<RWWSRE)
001f98 d01a        rcall dospm
001f99 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
001f9a 01f9        movw zl, temp2
                   ; get the beginning of page
001f9b 7ce0        andi zl,low(pagemask)
001f9c 7fff        andi zh,high(pagemask)
001f9d 01ef        movw y, z
                   ; loop counter (in words)
001f9e e4a0        ldi xl,low(pagesize)
001f9f e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
001fa0 01fe        movw z, y
001fa1 0fee
001fa2 1fff
001fa3 9145
001fa4 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
001fa5 01fe        movw z, y
001fa6 17e2        cp zl, temp2
001fa7 07f3        cpc zh, temp3
001fa8 f011        breq pageload_newdata
001fa9 010a          movw r0, temp6
001faa c002          rjmp pageload_cont
                 pageload_newdata:
001fab 017a          movw temp4, temp6
001fac 010c          movw r0, tosl
                 pageload_cont:
001fad 2700        clr temp0
001fae d004        rcall dospm
001faf 9621        adiw y, 1
001fb0 9711        sbiw x, 1
001fb1 f771        brne pageload_loop
                 
                 pageload_done:
001fb2 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
001fb3 99e1        sbic EECR, EEPE
001fb4 cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
001fb5 b717        in_  temp1, SPMCSR
001fb6 fd10        sbrc temp1, SPMEN
001fb7 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
001fb8 0fee
001fb9 1fff        writeflashcell
                   ; execute spm
001fba 6001        ori temp0, (1<<SPMEN)
001fbb bf07        out_ SPMCSR,temp0
001fbc 95e8        spm
001fbd 9508        ret
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
001fbe ff02          .dw $ff02
001fbf 6940          .db "@i"
001fc0 1f6d          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
001fc1 1fc2          .dw PFA_FETCHI
                 PFA_FETCHI:
001fc2 01fc          movw zl, tosl
001fc3 0fee
001fc4 1fff
001fc5 9185
001fc6 9195          readflashcell tosl,tosh
001fc7 cc3d          jmp_ DO_NEXT
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2LITERAL:
001fc8 0008          .dw $0008
001fc9 6c32
001fca 7469
001fcb 7265
001fcc 6c61          .db "2literal"
001fcd 1fbe          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
001fce 1c01          .dw DO_COLON
                 PFA_2LITERAL:
                 .endif
001fcf 1cc4          .dw XT_SWAP
001fd0 02ec          .dw XT_LITERAL
001fd1 02ec          .dw XT_LITERAL
001fd2 1c20          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
001fd3 ff01          .dw $ff01
001fd4 003d          .db "=",0
001fd5 1fc8          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
001fd6 1c01          .dw DO_COLON
                 PFA_EQUAL:
001fd7 1d93          .dw XT_MINUS
001fd8 1d18          .dw XT_ZEROEQUAL
001fd9 1c20          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
001fda ff01          .dw $ff01
001fdb 0031          .db "1",0
001fdc 1fd3          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
001fdd 1c48          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
001fde 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
001fdf ff01          .dw $ff01
001fe0 0032          .db "2",0
001fe1 1fda          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
001fe2 1c48          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
001fe3 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
001fe4 ff02          .dw $ff02
001fe5 312d          .db "-1"
001fe6 1fdf          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
001fe7 1c48          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
001fe8 ffff              .DW -1
                 
                 .if AMFORTH_NRWW_SIZE>8000
                 .elif AMFORTH_NRWW_SIZE>4000
                 .elif AMFORTH_NRWW_SIZE>2000
                   .include "dict/core_2k.inc"
                 
                 .else
                 .endif
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
00002a ff ff     
                 ; some configs
00002c 17 0f     CFG_DP:      .dw DPSTART         ; Dictionary Pointer
00002e 1f 01     EE_HERE:     .dw HERESTART       ; Memory Allocation
000030 86 00     EE_EHERE:    .dw EHERESTART      ; EEProm Memory Allocation
000032 3d 05     CFG_WLSCOPE: .dw XT_GET_CURRENT  ; default wordlist scope
000034 52 00     CFG_FORTHRECOGNIZER: .dw CFG_RECOGNIZERLISTLEN ; Recognizer word set
                 ; LEAVE stack is between data stack and return stack.
000036 10 04     CFG_LP0:     .dw stackstart+1
000038 93 0e     CFG_TURNKEY: .dw XT_APPLTURNKEY    ; TURNKEY
00003a db 05     CFG_ENVIRONMENT:.dw VE_ENVHEAD     ; environmental queries
00003c 3e 00     CFG_CURRENT: .dw CFG_FORTHWORDLIST ; forth-wordlist
00003e e4 1f     CFG_FORTHWORDLIST:.dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
000040 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
000042 3e 00         .dw CFG_FORTHWORDLIST      ; get/set-order
000044               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
000052 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
000054 e6 0b         .dw XT_REC_FIND
000056 d2 0b         .dw XT_REC_NUM
000058               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_STOREI:
00005c 74 1f         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
00005e 5e 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
000060 00 00         .dw 0  ; USER_STATE
000062 00 00         .dw 0  ; USER_FOLLOWER
000064 5f 04         .dw rstackstart  ; USER_RP
000066 0f 04         .dw stackstart   ; USER_SP0
000068 0f 04         .dw stackstart   ; USER_SP
                     
00006a 00 00         .dw 0  ; USER_HANDLER
00006c 0a 00         .dw 10 ; USER_BASE
                     
00006e 98 00         .dw XT_TX  ; USER_EMIT
000070 a6 00         .dw XT_TXQ ; USER_EMITQ
000072 6d 00         .dw XT_RX  ; USER_KEY
000074 88 00         .dw XT_RXQ ; USER_KEYQ
000076 eb 0d         .dw XT_SOURCETIB ; USER_SOURCE
000078 00 00         .dw 0            ; USER_G_IN
00007a d8 0d         .dw XT_REFILLTIB ; USER_REFILL  
00007c c8 0a         .dw XT_DEFAULT_PROMPTOK
00007e e7 0a         .dw XT_DEFAULT_PROMPTERROR
000080 d7 0a         .dw XT_DEFAULT_PROMPTREADY
000082 02 0b         .dw XT_DEFAULT_PROMPTINPUT
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
000084 0c 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega16" register use summary:
r0 :  25 r1 :   5 r2 :  11 r3 :  12 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   7 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  85 r17:  61 r18:  61 r19:  37 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 203 r25: 138 r26:  28 r27:  17 r28:   7 r29:   4 r30:  85 r31:  47 
x  :   4 y  : 207 z  :  50 
Registers used: 29 out of 35 (82.9%)

"ATmega16" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  22 add   :  17 adiw  :  17 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   3 brcs  :   1 break :   0 breq  :   7 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  20 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   7 cbr   :   1 
clc   :   2 clh   :   0 cli   :   7 cln   :   0 clr   :  14 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  14 cp    :  11 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :   8 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  25 inc   :   3 jmp   :  26 
ld    : 139 ldd   :   4 ldi   :  41 lds   :   1 lpm   :  16 lsl   :  14 
lsr   :   2 mov   :  14 movw  :  71 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   2 out   :  22 pop   :  45 
push  :  39 rcall :  34 ret   :   7 reti  :   1 rjmp  :  92 rol   :  23 
ror   :   6 sbc   :   9 sbci  :   3 sbi   :   8 sbic  :   3 sbis  :   0 
sbiw  :  16 sbr   :   0 sbrc  :   5 sbrs  :   7 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   4 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  77 std   :   8 sts   :   1 
sub   :   6 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 73 out of 113 (64.6%)

"ATmega16" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x003fd2   2050   9638  11688   16384  71.3%
[.dseg] 0x000060 0x00011f      0    191    191    1024  18.7%
[.eseg] 0x000000 0x000086      0    134    134     512  26.2%

Assembly complete, 0 errors, 8 warnings
