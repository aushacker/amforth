
AVRASM ver. 2.1.52  atmega256.asm Sun Oct 18 18:22:41 2020

atmega256.asm(11): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega2561\device.asm'
../../avr8/devices/atmega2561\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m2561def.inc'
atmega256.asm(15): Including file '../../avr8\drivers/usart_1.asm'
../../avr8\drivers/usart_1.asm(31): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(11): Including file '../../avr8\drivers/usart-rx-buffer.asm'
../../avr8\drivers/usart_common.asm(24): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(29): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(30): Including file '../../avr8\words/usart.asm'
atmega256.asm(18): Including file '../../avr8\amforth-low.asm'
../../avr8\amforth-low.asm(11): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth-low.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth-low.asm(15): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(7): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/rww.inc(10): Including file '../../avr8\dict/appl_8k.inc'
../../avr8\dict/appl_8k.inc(1): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/newest.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/do-create.asm'
../../avr8\dict/compiler1.inc(5): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(9): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(10): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(17): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(33): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(38): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../common\words/create.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../common\words/reveal.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(53): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../common\words/recurse.asm'
../../avr8\dict/compiler1.inc(56): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(61): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(67): Including file '../../common\words/cfg-order.asm'
../../avr8\dict/compiler1.inc(68): Including file '../../common\words/cfg-recognizer.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(70): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\amforth-low.asm(16): Including file 'dict_appl.inc'
dict_appl.inc(4): Including file 'words/applturnkey.asm'
../../avr8\amforth-low.asm(17): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(35): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(36): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(42): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(45): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(46): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(49): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(56): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(63): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../common\words/q-negate.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(89): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(93): Including file '../../avr8\words/store-i_big.asm'
../../avr8\dict/nrww.inc(97): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(98): Including file '../../common\words/2literal.asm'
../../avr8\dict/nrww.inc(99): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(100): Including file '../../common\words/num-constants.asm'
../../avr8\dict/nrww.inc(103): Including file '../../avr8\dict/core_8k.inc'
../../avr8\dict/core_8k.inc(2): Including file '../../avr8\words/n_to_r.asm'
../../avr8\dict/core_8k.inc(3): Including file '../../avr8\words/n_r_from.asm'
../../avr8\dict/core_8k.inc(5): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/core_8k.inc(6): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/core_8k.inc(7): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/core_8k.inc(8): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/core_8k.inc(9): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/core_8k.inc(10): Including file '../../common\words/u-dot.asm'
../../avr8\dict/core_8k.inc(11): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/core_8k.inc(13): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/core_8k.inc(14): Including file '../../common\words/words.asm'
../../avr8\dict/core_8k.inc(17): Including file '../../common\words/pick.asm'
../../avr8\dict/core_8k.inc(18): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/core_8k.inc(19): Including file '../../common\words/squote.asm'
../../avr8\dict/core_8k.inc(21): Including file '../../avr8\words/fill.asm'
../../avr8\dict/core_8k.inc(23): Including file '../../avr8\words/environment.asm'
../../avr8\dict/core_8k.inc(24): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/core_8k.inc(25): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/core_8k.inc(26): Including file '../../common\words/env-slashhold.asm'
../../avr8\dict/core_8k.inc(27): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/core_8k.inc(28): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/core_8k.inc(29): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/core_8k.inc(30): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/core_8k.inc(31): Including file '../../common\words/env-usersize.asm'
../../avr8\dict/core_8k.inc(33): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/core_8k.inc(34): Including file '../../avr8\words/state.asm'
../../avr8\dict/core_8k.inc(35): Including file '../../common\words/base.asm'
../../avr8\dict/core_8k.inc(37): Including file '../../avr8\words/cells.asm'
../../avr8\dict/core_8k.inc(38): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/core_8k.inc(40): Including file '../../common\words/2dup.asm'
../../avr8\dict/core_8k.inc(41): Including file '../../common\words/2drop.asm'
../../avr8\dict/core_8k.inc(43): Including file '../../common\words/tuck.asm'
../../avr8\dict/core_8k.inc(45): Including file '../../common\words/to-in.asm'
../../avr8\dict/core_8k.inc(46): Including file '../../common\words/pad.asm'
../../avr8\dict/core_8k.inc(47): Including file '../../common\words/emit.asm'
../../avr8\dict/core_8k.inc(48): Including file '../../common\words/emitq.asm'
../../avr8\dict/core_8k.inc(49): Including file '../../common\words/key.asm'
../../avr8\dict/core_8k.inc(50): Including file '../../common\words/keyq.asm'
../../avr8\dict/core_8k.inc(52): Including file '../../avr8\words/dp.asm'
../../avr8\dict/core_8k.inc(53): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/core_8k.inc(54): Including file '../../avr8\words/here.asm'
../../avr8\dict/core_8k.inc(55): Including file '../../avr8\words/allot.asm'
../../avr8\dict/core_8k.inc(57): Including file '../../common\words/bin.asm'
../../avr8\dict/core_8k.inc(58): Including file '../../common\words/decimal.asm'
../../avr8\dict/core_8k.inc(59): Including file '../../common\words/hex.asm'
../../avr8\dict/core_8k.inc(60): Including file '../../common\words/bl.asm'
../../avr8\dict/core_8k.inc(62): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/core_8k.inc(64): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/core_8k.inc(65): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/core_8k.inc(66): Including file '../../avr8\words/negate.asm'
../../avr8\dict/core_8k.inc(67): Including file '../../common\words/slash.asm'
../../avr8\dict/core_8k.inc(68): Including file '../../common\words/mod.asm'
../../avr8\dict/core_8k.inc(69): Including file '../../common\words/abs.asm'
../../avr8\dict/core_8k.inc(70): Including file '../../common\words/min.asm'
../../avr8\dict/core_8k.inc(71): Including file '../../common\words/max.asm'
../../avr8\dict/core_8k.inc(72): Including file '../../common\words/within.asm'
../../avr8\dict/core_8k.inc(74): Including file '../../common\words/to-upper.asm'
../../avr8\dict/core_8k.inc(75): Including file '../../common\words/to-lower.asm'
../../avr8\dict/core_8k.inc(77): Including file '../../avr8\words/hld.asm'
../../avr8\dict/core_8k.inc(78): Including file '../../common\words/hold.asm'
../../avr8\dict/core_8k.inc(79): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/core_8k.inc(80): Including file '../../common\words/sharp.asm'
../../avr8\dict/core_8k.inc(81): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/core_8k.inc(82): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/core_8k.inc(83): Including file '../../common\words/sign.asm'
../../avr8\dict/core_8k.inc(84): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/core_8k.inc(85): Including file '../../common\words/dot-r.asm'
../../avr8\dict/core_8k.inc(86): Including file '../../common\words/d-dot.asm'
../../avr8\dict/core_8k.inc(87): Including file '../../common\words/dot.asm'
../../avr8\dict/core_8k.inc(88): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/core_8k.inc(89): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/core_8k.inc(90): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/core_8k.inc(91): Including file '../../common\words/digit-q.asm'
../../avr8\dict/core_8k.inc(93): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/core_8k.inc(94): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/core_8k.inc(95): Including file '../../avr8\words/itype.asm'
../../avr8\dict/core_8k.inc(96): Including file '../../avr8\words/icount.asm'
../../avr8\dict/core_8k.inc(97): Including file '../../common\words/cr.asm'
../../avr8\dict/core_8k.inc(98): Including file '../../common\words/space.asm'
../../avr8\dict/core_8k.inc(99): Including file '../../common\words/spaces.asm'
../../avr8\dict/core_8k.inc(100): Including file '../../common\words/type.asm'
../../avr8\dict/core_8k.inc(101): Including file '../../common\words/tick.asm'
../../avr8\dict/core_8k.inc(103): Including file '../../common\words/handler.asm'
../../avr8\dict/core_8k.inc(104): Including file '../../common\words/catch.asm'
../../avr8\dict/core_8k.inc(105): Including file '../../common\words/throw.asm'
../../avr8\dict/core_8k.inc(107): Including file '../../common\words/cskip.asm'
../../avr8\dict/core_8k.inc(108): Including file '../../common\words/cscan.asm'
../../avr8\dict/core_8k.inc(109): Including file '../../common\words/accept.asm'
../../avr8\dict/core_8k.inc(110): Including file '../../common\words/refill.asm'
../../avr8\dict/core_8k.inc(111): Including file '../../common\words/char.asm'
../../avr8\dict/core_8k.inc(112): Including file '../../common\words/number.asm'
../../avr8\dict/core_8k.inc(113): Including file '../../common\words/q-sign.asm'
../../avr8\dict/core_8k.inc(114): Including file '../../common\words/set-base.asm'
../../avr8\dict/core_8k.inc(115): Including file '../../common\words/to-number.asm'
../../avr8\dict/core_8k.inc(116): Including file '../../common\words/parse.asm'
../../avr8\dict/core_8k.inc(117): Including file '../../common\words/source.asm'
../../avr8\dict/core_8k.inc(118): Including file '../../common\words/slash-string.asm'
../../avr8\dict/core_8k.inc(119): Including file '../../common\words/parse-name.asm'
../../avr8\dict/core_8k.inc(120): Including file '../../common\words/find-xt.asm'
../../avr8\dict/core_8k.inc(122): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/core_8k.inc(123): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/core_8k.inc(124): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/core_8k.inc(125): Including file '../../common\words/prompt-input.asm'
../../avr8\dict/core_8k.inc(126): Including file '../../common\words/quit.asm'
../../avr8\dict/core_8k.inc(127): Including file '../../avr8\words/pause.asm'
../../avr8\dict/core_8k.inc(128): Including file '../../avr8\words/cold.asm'
../../avr8\dict/core_8k.inc(129): Including file '../../common\words/warm.asm'
../../avr8\dict/core_8k.inc(131): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/core_8k.inc(132): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/core_8k.inc(133): Including file '../../common\words/depth.asm'
../../avr8\dict/core_8k.inc(134): Including file '../../common\words/interpret.asm'
../../avr8\dict/core_8k.inc(135): Including file '../../avr8\words/forth-recognizer.asm'
../../avr8\dict/core_8k.inc(136): Including file '../../common\words/recognize.asm'
../../avr8\dict/core_8k.inc(137): Including file '../../common\words/rec-intnum.asm'
../../avr8\dict/core_8k.inc(138): Including file '../../common\words/rec-find.asm'
../../avr8\dict/core_8k.inc(139): Including file '../../common\words/rec-null.asm'
../../avr8\dict/core_8k.inc(141): Including file '../../common\words/q-stack.asm'
../../avr8\dict/core_8k.inc(142): Including file '../../common\words/ver.asm'
../../avr8\dict/core_8k.inc(144): Including file '../../common\words/noop.asm'
../../avr8\dict/core_8k.inc(145): Including file '../../avr8\words/unused.asm'
../../avr8\dict/core_8k.inc(147): Including file '../../common\words/to.asm'
../../avr8\dict/core_8k.inc(148): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/core_8k.inc(150): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/core_8k.inc(151): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/core_8k.inc(152): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/core_8k.inc(153): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/core_8k.inc(154): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/core_8k.inc(155): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/core_8k.inc(156): Including file '../../common\words/defer-store.asm'
../../avr8\dict/core_8k.inc(157): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/core_8k.inc(158): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/core_8k.inc(160): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/core_8k.inc(161): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/core_8k.inc(162): Including file '../../common\words/name2string.asm'
../../avr8\dict/core_8k.inc(163): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/core_8k.inc(164): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/core_8k.inc(166): Including file '../../common\words/star.asm'
../../avr8\dict/core_8k.inc(167): Including file '../../avr8\words/j.asm'
../../avr8\dict/core_8k.inc(169): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/core_8k.inc(170): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/core_8k.inc(171): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/core_8k.inc(172): Including file '../../common\words/2swap.asm'
../../avr8\dict/core_8k.inc(174): Including file '../../common\words/tib.asm'
../../avr8\dict/core_8k.inc(176): Including file '../../avr8\words/init-ram.asm'
../../avr8\dict/core_8k.inc(178): Including file '../../common\words/bounds.asm'
../../avr8\dict/core_8k.inc(179): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/core_8k.inc(180): Including file '../../avr8\words/to-body.asm'
../../avr8\dict/core_8k.inc(182): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../common\words/postpone.asm'
../../avr8\dict/core_8k.inc(183): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/irqcnt.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-num.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(10): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(11): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(12): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(13): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(15): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(16): Including file '../../avr8\words/isr-end.asm'
../../avr8\amforth-low.asm(18): Including file 'dict_appl_core.inc'
../../avr8\amforth-low.asm(27): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; both a 24bit address space and they need a special
                 ; flash store placement in the NRWW section, way outside
                 ; of the standard 16bit jump distance.
                 
                 ; note that dict_appl_core includes a store-i_big.asm
                 ; instead if the normal store-i.asm file. This file
                 ; has all the magic needed for the large address space.
                 ; *everything else* is identical to other controllers.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set USER_P_OK    = 28
                 .set USER_P_ERR   = 30
                 .set USER_P_RDY   = 32
                 .set USER_P_INPUT = 34
                 
                 .set SYSUSERSIZE = 36
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot = r10
                   .def isrflag  = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  512
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 	elpm @0, Z+
                 	elpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_TWI = 0
                 .set WANT_SPI = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_PORTE = 0
                 .set WANT_PORTF = 0
                 .set WANT_PORTG = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_USART1 = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TIMER_COUNTER_5 = 0
                 .set WANT_TIMER_COUNTER_4 = 0
                 .set WANT_TIMER_COUNTER_3 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_JTAG = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_CPU = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_BOOT_LOAD = 0
                 .equ intvecsize = 2 ; please verify; flash size: 262144 bytes
                 .equ pclen = 3 ; please verify
                 .overlap
                 .org 2
000002 d139      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d137      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d135      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d133      	 rcall isr ; External Interrupt Request 3
                 .org 10
00000a d131      	 rcall isr ; External Interrupt Request 4
                 .org 12
00000c d12f      	 rcall isr ; External Interrupt Request 5
                 .org 14
00000e d12d      	 rcall isr ; External Interrupt Request 6
                 .org 16
000010 d12b      	 rcall isr ; External Interrupt Request 7
                 .org 18
000012 d129      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 20
000014 d127      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 22
000016 d125      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 24
000018 d123      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 26
00001a d121      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 28
00001c d11f      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 30
00001e d11d      	 rcall isr ; Timer/Counter2 Overflow
                 .org 32
000020 d11b      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 34
000022 d119      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 36
000024 d117      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 38
000026 d115      	 rcall isr ; Timer/Counter1 Compare Match C
                 .org 40
000028 d113      	 rcall isr ; Timer/Counter1 Overflow
                 .org 42
00002a d111      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 44
00002c d10f      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 46
00002e d10d      	 rcall isr ; Timer/Counter0 Overflow
                 .org 48
000030 d10b      	 rcall isr ; SPI Serial Transfer Complete
                 .org 50
000032 d109      	 rcall isr ; USART0, Rx Complete
                 .org 52
000034 d107      	 rcall isr ; USART0 Data register Empty
                 .org 54
000036 d105      	 rcall isr ; USART0, Tx Complete
                 .org 56
000038 d103      	 rcall isr ; Analog Comparator
                 .org 58
00003a d101      	 rcall isr ; ADC Conversion Complete
                 .org 60
00003c d0ff      	 rcall isr ; EEPROM Ready
                 .org 62
00003e d0fd      	 rcall isr ; Timer/Counter3 Capture Event
                 .org 64
000040 d0fb      	 rcall isr ; Timer/Counter3 Compare Match A
                 .org 66
000042 d0f9      	 rcall isr ; Timer/Counter3 Compare Match B
                 .org 68
000044 d0f7      	 rcall isr ; Timer/Counter3 Compare Match C
                 .org 70
000046 d0f5      	 rcall isr ; Timer/Counter3 Overflow
                 .org 72
000048 d0f3      	 rcall isr ; USART1, Rx Complete
                 .org 74
00004a d0f1      	 rcall isr ; USART1 Data register Empty
                 .org 76
00004c d0ef      	 rcall isr ; USART1, Tx Complete
                 .org 78
00004e d0ed      	 rcall isr ; 2-wire Serial Interface
                 .org 80
000050 d0eb      	 rcall isr ; Store Program Memory Read
                 .org 82
000052 d0e9      	 rcall isr ; Timer/Counter4 Capture Event
                 .org 84
000054 d0e7      	 rcall isr ; Timer/Counter4 Compare Match A
                 .org 86
000056 d0e5      	 rcall isr ; Timer/Counter4 Compare Match B
                 .org 88
000058 d0e3      	 rcall isr ; Timer/Counter4 Compare Match C
                 .org 90
00005a d0e1      	 rcall isr ; Timer/Counter4 Overflow
                 .org 92
00005c d0df      	 rcall isr ; Timer/Counter5 Capture Event
                 .org 94
00005e d0dd      	 rcall isr ; Timer/Counter5 Compare Match A
                 .org 96
000060 d0db      	 rcall isr ; Timer/Counter5 Compare Match B
                 .org 98
000062 d0d9      	 rcall isr ; Timer/Counter5 Compare Match C
                 .org 100
000064 d0d7      	 rcall isr ; Timer/Counter5 Overflow
                 .org 102
000066 d0d5      	 rcall isr ; USART2, Rx Complete
                 .org 104
000068 d0d3      	 rcall isr ; USART2 Data register Empty
                 .org 106
00006a d0d1      	 rcall isr ; USART2, Tx Complete
                 .org 108
00006c d0cf      	 rcall isr ; USART3, Rx Complete
                 .org 110
00006e d0cd      	 rcall isr ; USART3 Data register Empty
                 .org 112
000070 d0cb      	 rcall isr ; USART3, Tx Complete
                 .equ INTVECTORS = 57
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000071 2000      	.dw 8192
                 mcu_eepromsize:
000072 1000      	.dw 4096
                 mcu_maxdp:
000073 ffff      	.dw 65535 
                 mcu_numints:
000074 0039      	.dw 57
                 mcu_name:
000075 000a      	.dw 10
000076 5441
000077 656d
000078 6167
000079 3532
00007a 3136      	.db "ATmega2561"
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 ; enabling Interrupts, disabling them affects
                 ; other settings as well. 
                 .set WANT_INTERRUPTS = 1
                 
                 ; count the number of interrupts individually.
                 ; requires a lot of RAM (one byte per interrupt)
                 ; disabled by default.
                 .set WANT_INTERRUPT_COUNTERS = 1
                 
                 ; receiving is asynchronously, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIB_SIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 14745600
                 .include "drivers/usart_1.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR1H
                   .equ USART_C = UCSR1C
                   .equ USART_B = UCSR1B
                   .equ USART_A = UCSR1A
                   .equ USART_DATA = UDR1
                 
                 .equ URXCaddr = URXC1addr
                 .equ UDREaddr = UDRE1addr
                 
                 .equ bm_USART_RXRD = 1 << RXC1
                 .equ bm_USART_TXRD = 1 << UDRE1
                 .equ bm_ENABLE_TX  = 1 << TXEN1
                 .equ bm_ENABLE_RX  = 1 << RXEN1
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE1
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE1
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_INTERRUPTS == 0
                   .if WANT_ISR_RX == 1
                   .endif
                 .endif
                 
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-rx-buffer.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000200            usart_rx_data: .byte usart_rx_size
000210            usart_rx_in:   .byte 1
000211            usart_rx_out:  .byte 1
                 .cseg
                 
                 VE_TO_RXBUF:
00007b ff07          .dw $ff07
00007c 723e
00007d 2d78
00007e 7562
00007f 0066          .db ">rx-buf",0
000080 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_RXBUF
                 XT_TO_RXBUF:
000081 0082          .dw PFA_rx_tobuf
                 PFA_rx_tobuf:
000082 2f08          mov temp0, tosl
000083 9110 0210     lds temp1, usart_rx_in
000085 e0e0          ldi zl, low(usart_rx_data)
000086 e0f2          ldi zh, high(usart_rx_data)
000087 0fe1          add zl, temp1
000088 1df3          adc zh, zeroh
000089 8300          st Z, temp0
00008a 9513          inc temp1
00008b 701f          andi temp1,usart_rx_mask
00008c 9310 0210     sts usart_rx_in, temp1
00008e 9189
00008f 9199          loadtos
000090 940c 011f     jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; setup with
                 ; ' isr-rx URXCaddr int!
                 VE_ISR_RX:
000092 ff06          .dw $ff06
000093 7369
000094 2d72
000095 7872          .db "isr-rx"
000096 007b          .dw VE_HEAD
                     .set VE_HEAD = VE_ISR_RX
                 XT_ISR_RX:
000097 011b          .dw DO_COLON
                 usart_rx_isr:
000098 04e2        .dw XT_DOLITERAL
000099 00ce        .dw usart_data
00009a 0545        .dw XT_CFETCH
00009b 055e        .dw XT_DUP
00009c 04e2        .dw XT_DOLITERAL
00009d 0003        .dw 3
00009e 084d        .dw XT_EQUAL
00009f 04db        .dw XT_DOCONDBRANCH
0000a0 00a2        .dw usart_rx_isr1
0000a1 0eca        .dw XT_COLD
                 usart_rx_isr1:
0000a2 0081        .dw XT_TO_RXBUF
0000a3 04c2        .dw XT_EXIT
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RXBUFFER:
                 ;  .dw $ff0x
                 ;  .db "+usart-buffer"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RXBUFFER
                 XT_USART_INIT_RX_BUFFER:
0000a4 011b        .dw DO_COLON
                 PFA_USART_INIT_RX_BUFFER:          ; ( -- )
0000a5 04e2
0000a6 0097        .dw XT_DOLITERAL, XT_ISR_RX
0000a7 04e2
0000a8 0048        .dw XT_DOLITERAL, URXCaddr
0000a9 1268        .dw XT_INTSTORE
                 
0000aa 04e2        .dw XT_DOLITERAL
0000ab 0200        .dw usart_rx_data
0000ac 04e2        .dw XT_DOLITERAL
0000ad 0016        .dw usart_rx_size + 6
0000ae 0601        .dw XT_ZERO
0000af 0927        .dw XT_FILL
0000b0 04c2        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_BUFFER:
0000b1 ff06          .dw $ff06
0000b2 7872
0000b3 622d
0000b4 6675          .db "rx-buf"
0000b5 0092          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_BUFFER
                 XT_RX_BUFFER:
0000b6 011b          .dw DO_COLON
                 PFA_RX_BUFFER:
0000b7 00d1        .dw XT_RXQ_BUFFER
0000b8 04db        .dw XT_DOCONDBRANCH
0000b9 00b7        .dw PFA_RX_BUFFER
0000ba 04e2        .dw XT_DOLITERAL
0000bb 0211        .dw usart_rx_out
0000bc 0545        .dw XT_CFETCH
0000bd 055e        .dw XT_DUP
0000be 04e2        .dw XT_DOLITERAL
0000bf 0200        .dw usart_rx_data
0000c0 064a        .dw XT_PLUS
0000c1 0545        .dw XT_CFETCH
0000c2 0571        .dw XT_SWAP
0000c3 06dc        .dw XT_1PLUS
0000c4 04e2        .dw XT_DOLITERAL
0000c5 000f        .dw usart_rx_mask
0000c6 06c0        .dw XT_AND
0000c7 04e2        .dw XT_DOLITERAL
0000c8 0211        .dw usart_rx_out
0000c9 053a        .dw XT_CSTORE
0000ca 04c2        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue
                 VE_RXQ_BUFFER:
0000cb ff07          .dw $ff07
0000cc 7872
0000cd 2d3f
0000ce 7562
0000cf 0066          .db "rx?-buf",0
0000d0 00b1          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_BUFFER
                 XT_RXQ_BUFFER:
0000d1 011b          .dw DO_COLON
                 PFA_RXQ_BUFFER:
0000d2 0ec2        .dw XT_PAUSE
0000d3 04e2        .dw XT_DOLITERAL
0000d4 0211        .dw usart_rx_out
0000d5 0545        .dw XT_CFETCH
0000d6 04e2        .dw XT_DOLITERAL
0000d7 0210        .dw usart_rx_in
0000d8 0545        .dw XT_CFETCH
0000d9 05be        .dw XT_NOTEQUAL
0000da 04c2        .dw XT_EXIT
                 ;  .include "drivers/timer-usart-isr.asm"
                   .set XT_RX  = XT_RX_BUFFER
                   .set XT_RXQ = XT_RXQ_BUFFER
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_BUFFER
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
0000db ff07          .dw $ff07
0000dc 7874
0000dd 702d
0000de 6c6f
0000df 006c          .db "tx-poll",0
0000e0 00cb          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
0000e1 011b          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
0000e2 00ef        .dw XT_TXQ_POLL
0000e3 04db        .dw XT_DOCONDBRANCH
0000e4 00e2        .dw PFA_TX_POLL
                   ; send to usart
0000e5 04e2        .dw XT_DOLITERAL
0000e6 00ce        .dw USART_DATA
0000e7 053a        .dw XT_CSTORE
0000e8 04c2        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
0000e9 ff08          .dw $ff08
0000ea 7874
0000eb 2d3f
0000ec 6f70
0000ed 6c6c          .db "tx?-poll"
0000ee 00db          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000ef 011b          .dw DO_COLON
                 PFA_TXQ_POLL:
0000f0 0ec2        .dw XT_PAUSE
0000f1 04e2        .dw XT_DOLITERAL
0000f2 00c8        .dw USART_A
0000f3 0545        .dw XT_CFETCH
0000f4 04e2        .dw XT_DOLITERAL
0000f5 0020        .dw bm_USART_TXRD
0000f6 06c0        .dw XT_AND
0000f7 04c2        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000f8 ff04        .dw $ff04
0000f9 6275
0000fa 7272        .db "ubrr"
0000fb 00e9        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000fc 051d        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000fd 00cc        .dw EE_UBRRVAL
0000fe 1029        .dw XT_EDEFERFETCH
0000ff 1033        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
000100 ff06        .dw $ff06
000101 752b
000102 6173
000103 7472        .db "+usart"
000104 00f8        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
000105 011b        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
000106 04e2        .dw XT_DOLITERAL
000107 0098        .dw USART_B_VALUE
000108 04e2        .dw XT_DOLITERAL
000109 00c9        .dw USART_B
00010a 053a        .dw XT_CSTORE
                 
00010b 04e2        .dw XT_DOLITERAL
00010c 0006        .dw USART_C_VALUE
00010d 04e2        .dw XT_DOLITERAL
00010e 00ca        .dw USART_C | bm_USARTC_en
00010f 053a        .dw XT_CSTORE
                 
000110 00fc        .dw XT_UBRR
000111 055e        .dw XT_DUP
000112 07a6        .dw XT_BYTESWAP
000113 04e2        .dw XT_DOLITERAL
000114 00cd        .dw BAUDRATE_HIGH
000115 053a        .dw XT_CSTORE
000116 04e2        .dw XT_DOLITERAL
000117 00cc        .dw BAUDRATE_LOW
000118 053a        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
000119 00a4        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
00011a 04c2        .dw XT_EXIT
                 
                 ; all of amforth is in one segment
                 .include "amforth-low.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set pc_ = pc
                 
                 .org $0000
000000 940c 0ecb   jmp_ PFA_COLD
                 .org pc_
                 
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
00011b 93bf          push XH
00011c 93af          push XL          ; PUSH IP
00011d 01db          movw XL, wl
00011e 9611          adiw xl, 1
                 DO_NEXT:
                 .if WANT_INTERRUPTS == 1
00011f 14b2          cp isrflag, zerol
000120 f499          brne DO_INTERRUPT
                 .endif
000121 01fd          movw zl, XL        ; READ IP
000122 2755
000123 0fee
000124 1fff
000125 1f55
000126 bf5b
000127 9167
000128 9177          readflashcell wl, wh
000129 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00012a 01fb          movw zl, wl
00012b 2755
00012c 0fee
00012d 1fff
00012e 1f55
00012f bf5b
000130 9107
000131 9117          readflashcell temp0,temp1
000132 01f8          movw zl, temp0
000133 9409          ijmp
                 
                 .if WANT_INTERRUPTS == 1
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
000134 939a
000135 938a          savetos
000136 2d8b          mov tosl, isrflag
000137 24bb          clr isrflag
000138 2799          clr tosh
000139 e864          ldi wl, LOW(XT_ISREXEC)
00013a e172          ldi wh, HIGH(XT_ISREXEC)
00013b cfee          rjmp DO_EXECUTE
                 .endif
                 .include "drivers/generic-isr.asm"
                 
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .if WANT_INTERRUPT_COUNTERS==1
                 .dseg
000212           intcnt: .byte INTVECTORS
                 .endif
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
00013c 920a          st -Y, r0
00013d b60f          in r0, SREG
00013e 920a          st -Y, r0
                 .if (pclen==3)
00013f 900f          pop r0 ; some 128+K Flash devices use 3 cells for call/ret
                 .endif
000140 900f          pop r0
000141 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
000142 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
                     ; check whether isrflag is zero. if not,
                     ; there is an still unhandled interrupt pending.
000143 20bb          tst isrflag
000144 f001          breq isr_clean
                     ; there is a collision. the previous interrupt is not yet
                     ; handled by the forth inner interpreter
                 isr_clean:
000145 2cb0          mov isrflag, r0
                 .if WANT_INTERRUPT_COUNTERS==1
000146 93ff          push zh
000147 93ef          push zl
000148 e1e2          ldi zl, low(intcnt)
000149 e0f2          ldi zh, high(intcnt)
00014a 9406          lsr r0 ; we use byte addresses in the counter array, not words
00014b 0de0          add zl, r0
00014c 1df3          adc zh, zeroh
00014d 8000          ld r0, Z
00014e 9403          inc r0
00014f 8200          st Z, r0
000150 91ef          pop zl
000151 91ff          pop zh
                 .endif
000152 9009          ld r0, Y+
000153 be0f          out SREG, r0
000154 9009          ld r0, Y+
000155 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                     ; no reti here, see words/isr-end.asm
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000156 ff02          .dw $ff02
000157 2b6d          .db "m+"
000158 0100          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
000159 011b          .dw DO_COLON
                 PFA_MPLUS:
00015a 11dc          .dw XT_S2D
00015b 08a3          .dw XT_DPLUS
00015c 04c2          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
00015d ff03          .dw $ff03
00015e 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
00015f 002a          .db "ud*"
000160 0156          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
000161 011b          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
000162 055e
000163 05ac
000164 068d
000165 0586              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000166 0571
000167 05a3
000168 068d
000169 058e
00016a 064a
00016b 04c2              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
00016c ff04          .dw $ff04
00016d 6d75
00016e 7861          .db "umax"
00016f 015d          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
000170 011b          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
000171 09be
000172 0609              .DW XT_2DUP,XT_ULESS
000173 04db      	.dw XT_DOCONDBRANCH
000174 0176      	 DEST(UMAX1)
000175 0571              .DW XT_SWAP
000176 0586      UMAX1:  .DW XT_DROP
000177 04c2      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
000178 ff04          .dw $ff04
000179 6d75
00017a 6e69          .db "umin"
00017b 016c          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
00017c 011b          .dw DO_COLON
                 PFA_UMIN:
                 .endif
00017d 09be
00017e 0614              .DW XT_2DUP,XT_UGREATER
00017f 04db      	.dw XT_DOCONDBRANCH
000180 0182      	DEST(UMIN1)
000181 0571              .DW XT_SWAP
000182 0586      UMIN1:  .DW XT_DROP
000183 04c2      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; return +1 if immediate, -1 otherwise, flag from name>flags
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
000184 011b          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000185 04e2          .dw XT_DOLITERAL
000186 8000          .dw $8000
000187 06c0          .dw XT_AND
000188 05c5          .dw XT_ZEROEQUAL
000189 04db          .dw XT_DOCONDBRANCH
00018a 018d          DEST(IMMEDIATEQ1)
00018b 0854           .dw XT_ONE
00018c 04c2           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
00018d 05f8          .dw XT_TRUE
00018e 04c2          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
00018f ff0a          .dw $ff0a
000190 616e
000191 656d
000192 663e
000193 616c
000194 7367          .db "name>flags"
000195 0178          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
000196 011b          .dw DO_COLON
                 PFA_NAME2FLAGS:
000197 0835          .dw XT_FETCHI ; skip to link field
000198 04e2          .dw XT_DOLITERAL
000199 ff00          .dw $ff00
00019a 06c0          .dw XT_AND
00019b 04c2          .dw XT_EXIT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
00019c ff03          .dw $ff03
00019d 6d31
00019e 0073          .db "1ms",0
00019f 018f          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
0001a0 01a1          .dw PFA_1MS
                 PFA_1MS:
0001a1 e6e6
0001a2 e0fe
0001a3 9731
0001a4 f7f1
0001a5 0000          delay 1000
0001a6 cf78          jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .include "dict/appl_8k.inc"
                 
                 
                 .include "words/newest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_NEWEST:
0001a7 ff06          .dw $ff06
0001a8 656e
0001a9 6577
0001aa 7473          .db "newest"
0001ab 019c          .dw VE_HEAD
                     .set VE_HEAD = VE_NEWEST
                 XT_NEWEST:
0001ac 04f0          .dw PFA_DOVARIABLE
                 PFA_NEWEST:
0001ad 024b          .dw ram_newest
                 
                 .dseg
00024b           ram_newest: .byte 4
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_LATEST:
0001ae ff06          .dw $ff06
0001af 616c
0001b0 6574
0001b1 7473          .db "latest"
0001b2 01a7          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
0001b3 04f0          .dw PFA_DOVARIABLE
                 PFA_LATEST:
0001b4 024f          .dw ram_latest
                 
                 .dseg
00024f           ram_latest: .byte 2
                 .include "words/do-create.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE:
0001b5 ff08          .dw $ff08
0001b6 6328
0001b7 6572
0001b8 7461
0001b9 2965          .db "(create)"
0001ba 01ae          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
0001bb 011b          .dw DO_COLON
                 PFA_DOCREATE:
                 .endif
0001bc 0e18
0001bd 031d          .DW XT_PARSENAME,XT_WLSCOPE  ; ( -- addr len wid)
0001be 01c8          .DW XT_DOCREATE_IN           ; ( addr len wid -- )
0001bf 04c2          .DW XT_EXIT
                 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE_IN:
0001c0 ff0b          .dw $ff0b
0001c1 6328
0001c2 6572
0001c3 7461
0001c4 2d65
0001c5 6e69
../../common\words/do-create.asm(31): warning: .cseg .db misalignment - padding zero byte
0001c6 0029          .db "(create-in)"
0001c7 01b5          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE_IN
                 XT_DOCREATE_IN:
0001c8 011b          .dw DO_COLON
                 PFA_DOCREATE_IN:
                 .endif
0001c9 055e
0001ca 01ac
0001cb 09b6
0001cc 052e          .DW XT_DUP,XT_NEWEST,XT_CELLPLUS,XT_STORE ; save the wid
0001cd 0302
0001ce 01ac
0001cf 052e          .DW XT_HEADER,XT_NEWEST,XT_STORE          ; save the nt
0001d0 04c2          .DW XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
0001d1 0001          .dw $0001
0001d2 005c          .db $5c,0
0001d3 01c0          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
0001d4 011b          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
0001d5 0dff          .dw XT_SOURCE
0001d6 059d          .dw XT_NIP
0001d7 09d7          .dw XT_TO_IN
0001d8 052e          .dw XT_STORE
0001d9 04c2          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
0001da 0001          .dw $0001
0001db 0028          .db "(" ,0
0001dc 01d1          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
0001dd 011b          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
0001de 04e2          .dw XT_DOLITERAL
0001df 0029          .dw ')'
0001e0 0deb          .dw XT_PARSE
0001e1 09c7          .dw XT_2DROP
0001e2 04c2          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
0001e3 ff07          .dw $ff07
0001e4 6f63
0001e5 706d
0001e6 6c69
0001e7 0065          .db "compile",0
0001e8 01da          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
0001e9 011b          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
0001ea 05a3          .dw XT_R_FROM
0001eb 055e          .dw XT_DUP
0001ec 1020          .dw XT_ICELLPLUS
0001ed 05ac          .dw XT_TO_R
0001ee 0835          .dw XT_FETCHI
0001ef 01f4          .dw XT_COMMA
0001f0 04c2          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
0001f1 ff01          .dw $ff01
0001f2 002c          .db ',',0 ; ,
0001f3 01e3          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
0001f4 011b          .dw DO_COLON
                 PFA_COMMA:
0001f5 0a07          .dw XT_DP
0001f6 0816          .dw XT_STOREI
0001f7 0a07          .dw XT_DP
0001f8 06dc          .dw XT_1PLUS
0001f9 100e          .dw XT_DOTO
0001fa 0a08          .dw PFA_DP
0001fb 04c2          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
0001fc 0003          .dw $0003
0001fd 275b
0001fe 005d          .db "[']",0
0001ff 01f1          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
000200 011b          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
000201 0c64          .dw XT_TICK
000202 020a          .dw XT_LITERAL
000203 04c2          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
000204 0007          .dw $0007
000205 696c
000206 6574
000207 6172
000208 006c          .db "literal",0
000209 01fc          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
00020a 011b          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
00020b 01e9              .DW XT_COMPILE
00020c 04e2              .DW XT_DOLITERAL
00020d 01f4              .DW XT_COMMA
00020e 04c2              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
00020f 0008        .dw $0008
000210 6c73
000211 7469
000212 7265
000213 6c61        .db "sliteral"
000214 0204        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
000215 011b          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
000216 01e9          .dw XT_COMPILE
000217 0bc7          .dw XT_DOSLITERAL    ; ( -- addr n)
000218 0bd5          .dw XT_SCOMMA
000219 04c2          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
00021a 011b          .dw DO_COLON
                 PFA_GMARK:
00021b 0a07          .dw XT_DP
00021c 01e9          .dw XT_COMPILE
00021d ffff          .dw -1           ; ffff does not erase flash
00021e 04c2          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
00021f 011b          .dw DO_COLON
                 PFA_GRESOLVE:
000220 0fcc          .dw XT_QSTACK
000221 0a07          .dw XT_DP
000222 0571          .dw XT_SWAP
000223 0816          .dw XT_STOREI
000224 04c2          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
000225 011b          .dw DO_COLON
                 PFA_LMARK:
000226 0a07          .dw XT_DP
000227 04c2          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
000228 011b          .dw DO_COLON
                 PFA_LRESOLVE:
000229 0fcc          .dw XT_QSTACK
00022a 01f4          .dw XT_COMMA
00022b 04c2          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
00022c 0005          .dw $0005
00022d 6861
00022e 6165
00022f 0064          .db "ahead",0
000230 020f          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
000231 011b          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
000232 01e9          .dw XT_COMPILE
000233 04d1          .dw XT_DOBRANCH
000234 021a          .dw XT_GMARK
000235 04c2          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
000236 0002          .dw $0002
000237 6669          .db "if"
000238 022c          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
000239 011b          .dw DO_COLON
                 PFA_IF:
                 .endif
00023a 01e9          .dw XT_COMPILE
00023b 04db          .dw XT_DOCONDBRANCH
00023c 021a          .dw XT_GMARK
00023d 04c2          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
00023e 0004          .dw $0004
00023f 6c65
000240 6573          .db "else"
000241 0236          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
000242 011b          .dw DO_COLON
                 PFA_ELSE:
                 .endif
000243 01e9          .dw XT_COMPILE
000244 04d1          .dw XT_DOBRANCH
000245 021a          .dw XT_GMARK
000246 0571          .dw XT_SWAP
000247 021f          .dw XT_GRESOLVE
000248 04c2          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
000249 0004          .dw $0004
00024a 6874
00024b 6e65          .db "then"
00024c 023e          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
00024d 011b          .dw DO_COLON
                 PFA_THEN:
                 .endif
00024e 021f          .dw XT_GRESOLVE
00024f 04c2          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
000250 0005          .dw $0005
000251 6562
000252 6967
000253 006e          .db "begin",0
000254 0249          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
000255 011b          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
000256 0225          .dw XT_LMARK
000257 04c2          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
000258 0005          .dw $0005
000259 6877
00025a 6c69
00025b 0065          .db "while",0
00025c 0250          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
00025d 011b          .dw DO_COLON
                 PFA_WHILE:
                 .endif
00025e 0239          .dw XT_IF
00025f 0571          .dw XT_SWAP
000260 04c2          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
000261 0006          .dw $0006
000262 6572
000263 6570
000264 7461          .db "repeat"
000265 0258          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
000266 011b          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
000267 027a          .dw XT_AGAIN
000268 024d          .dw XT_THEN
000269 04c2          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
00026a 0005          .dw $0005
00026b 6e75
00026c 6974
00026d 006c          .db "until",0
00026e 0261          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
00026f 011b          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
000270 04e2          .dw XT_DOLITERAL
000271 04db          .dw XT_DOCONDBRANCH
000272 01f4          .dw XT_COMMA
                 
000273 0228          .dw XT_LRESOLVE
000274 04c2          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
000275 0005          .dw $0005
000276 6761
000277 6961
000278 006e          .db "again",0
000279 026a          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
00027a 011b          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
00027b 01e9          .dw XT_COMPILE
00027c 04d1          .dw XT_DOBRANCH
00027d 0228          .dw XT_LRESOLVE
00027e 04c2          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
00027f 0002          .dw $0002
000280 6f64          .db "do"
000281 0275          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
000282 011b          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
000283 01e9          .dw XT_COMPILE
000284 0748          .dw XT_DODO
000285 0225          .dw XT_LMARK
000286 0601          .dw XT_ZERO
000287 02dd          .dw XT_TO_L
000288 04c2          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
000289 0004          .dw $0004
00028a 6f6c
00028b 706f          .db "loop"
00028c 027f          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
00028d 011b          .dw DO_COLON
                 PFA_LOOP:
                 .endif
00028e 01e9          .dw XT_COMPILE
00028f 0776          .dw XT_DOLOOP
000290 02c4          .dw XT_ENDLOOP
000291 04c2          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
000292 0005          .dw $0005
000293 6c2b
000294 6f6f
000295 0070          .db "+loop",0
000296 0289          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
000297 011b          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
000298 01e9          .dw XT_COMPILE
000299 0767          .dw XT_DOPLUSLOOP
00029a 02c4          .dw XT_ENDLOOP
00029b 04c2          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
00029c 0005         .dw $0005
00029d 656c
00029e 7661
00029f 0065         .db "leave",0
0002a0 0292         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
0002a1 011b          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
0002a2 01e9
0002a3 0781          .DW XT_COMPILE,XT_UNLOOP
0002a4 0231
0002a5 02dd
0002a6 04c2          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
0002a7 0003          .dw $0003
0002a8 643f
0002a9 006f          .db "?do",0
0002aa 029c          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
0002ab 011b          .dw DO_COLON
                 PFA_QDO:
                 .endif
0002ac 01e9          .dw XT_COMPILE
0002ad 02b3          .dw XT_QDOCHECK
0002ae 0239          .dw XT_IF
0002af 0282          .dw XT_DO
0002b0 0571          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
0002b1 02dd          .dw XT_TO_L    ; then follows at the end.
0002b2 04c2          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
0002b3 011b          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
0002b4 09be          .dw XT_2DUP
0002b5 084d          .dw XT_EQUAL
0002b6 055e          .dw XT_DUP
0002b7 05ac          .dw XT_TO_R
0002b8 04db          .dw XT_DOCONDBRANCH
0002b9 02bb          DEST(PFA_QDOCHECK1)
0002ba 09c7          .dw XT_2DROP
                 PFA_QDOCHECK1:
0002bb 05a3          .dw XT_R_FROM
0002bc 06aa          .dw XT_INVERT
0002bd 04c2          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
0002be ff07          .dw $ff07
0002bf 6e65
0002c0 6c64
0002c1 6f6f
0002c2 0070          .db "endloop",0
0002c3 02a7          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
0002c4 011b          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
0002c5 0228              .DW XT_LRESOLVE
0002c6 02d1
0002c7 0566
0002c8 04db      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
0002c9 02cd               DEST(LOOP2)
0002ca 024d              .DW XT_THEN
0002cb 04d1      	.dw XT_DOBRANCH
0002cc 02c6               DEST(LOOP1)
0002cd 04c2      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
0002ce ff02          .dw $ff02
0002cf 3e6c          .db "l>"
0002d0 02be          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
0002d1 011b          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
0002d2 02f0          .dw XT_LP
0002d3 0526          .dw XT_FETCH
0002d4 0526          .dw XT_FETCH
0002d5 04e2          .dw XT_DOLITERAL
0002d6 fffe          .dw -2
0002d7 02f0          .dw XT_LP
0002d8 0712          .dw XT_PLUSSTORE
0002d9 04c2          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
0002da ff02          .dw $ff02
0002db 6c3e          .db ">l"
0002dc 02ce          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
0002dd 011b          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
0002de 0859              .dw XT_TWO
0002df 02f0      	.dw XT_LP
0002e0 0712      	.dw XT_PLUSSTORE
0002e1 02f0      	.dw XT_LP
0002e2 0526      	.dw XT_FETCH
0002e3 052e      	.dw XT_STORE
0002e4 04c2      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
0002e5 ff03          .dw $ff03
0002e6 706c
0002e7 0030          .db "lp0",0
0002e8 02da          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
0002e9 051d          .dw PFA_DOVALUE1
                 PFA_LP0:
0002ea 007e          .dw CFG_LP0
0002eb 1029          .dw XT_EDEFERFETCH
0002ec 1033          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
0002ed ff02          .dw $ff02
0002ee 706c          .db "lp"
0002ef 02e5          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
0002f0 04f0          .dw PFA_DOVARIABLE
                 PFA_LP:
0002f1 0251          .dw ram_lp
                 
                 .dseg
000251           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CREATE:
0002f2 ff06          .dw $ff06
0002f3 7263
0002f4 6165
0002f5 6574          .db "create"
0002f6 02ed          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
0002f7 011b          .dw DO_COLON
                 PFA_CREATE:
                 .endif
0002f8 01bb          .dw XT_DOCREATE
0002f9 0326          .dw XT_REVEAL
0002fa 01e9          .dw XT_COMPILE
0002fb 04fd          .dw PFA_DOCONSTANT
0002fc 04c2          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
0002fd ff06          .dw $ff06
0002fe 6568
0002ff 6461
000300 7265          .db "header"
000301 02f2          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
000302 011b          .dw DO_COLON
                 PFA_HEADER:
000303 0a07          .dw XT_DP           ; the new Name Field
000304 05ac          .dw XT_TO_R
000305 05ac          .dw XT_TO_R		; ( R: NFA WID )
000306 055e          .dw XT_DUP    
000307 05d3          .dw XT_GREATERZERO 
000308 04db          .dw XT_DOCONDBRANCH
000309 0314          .dw PFA_HEADER1
00030a 055e          .dw XT_DUP
00030b 04e2          .dw XT_DOLITERAL
00030c ff00          .dw $ff00           ; all flags are off (e.g. immediate)
00030d 06c9          .dw XT_OR
00030e 0bd9          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
00030f 05a3          .dw XT_R_FROM
000310 0802          .dw XT_FETCHE
000311 01f4          .dw XT_COMMA
000312 05a3          .dw XT_R_FROM
000313 04c2          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
000314 04e2          .dw XT_DOLITERAL
000315 fff0          .dw -16
000316 0c9b          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
000317 ff07          .dw $ff07
000318 6c77
000319 6373
00031a 706f
00031b 0065          .db "wlscope",0
00031c 02fd          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
00031d 1088          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
00031e 007a          .dw CFG_WLSCOPE
00031f 1029          .dw XT_EDEFERFETCH
000320 1033          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REVEAL:
000321 ff06          .dw $ff06
000322 6572
000323 6576
000324 6c61          .db "reveal"
000325 0317          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
000326 011b          .dw DO_COLON
                 PFA_REVEAL:
                 .endif
000327 01ac
000328 09b6
000329 0526          .DW XT_NEWEST,XT_CELLPLUS,XT_FETCH ; only if wordlist is in use
00032a 0566
00032b 04db          .DW XT_QDUP,XT_DOCONDBRANCH
00032c 0331          DEST(REVEAL1)
00032d 01ac
00032e 0526
00032f 0571
000330 07de          .DW XT_NEWEST,XT_FETCH,XT_SWAP,XT_STOREE
                 ;    .DW XT_ZERO,XT_NEWEST,XT_CELLPLUS,XT_STORE ; clean wordlist entry
                 REVEAL1:
000331 04c2          .DW XT_EXIT
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
000332 0005          .dw $0005
000333 6f64
000334 7365
000335 003e          .db "does>",0
000336 0321          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000337 011b          .dw DO_COLON
                 PFA_DOES:
000338 01e9          .dw XT_COMPILE
000339 034a          .dw XT_DODOES
00033a 01e9          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
00033b 940e          .dw $940e       ; the address of this compiled
00033c 01e9          .dw XT_COMPILE  ; code will replace the XT of the 
00033d 033f          .dw DO_DODOES   ; word that CREATE created
00033e 04c2          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
00033f 939a
000340 938a          savetos
000341 01cb          movw tosl, wl
000342 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
000343 917f          pop wh ; some 128K Flash devices use 3 cells for call/ret
                 .endif
000344 917f          pop wh
000345 916f          pop wl
                 
000346 93bf          push XH
000347 93af          push XL
000348 01db          movw XL, wl
000349 cdd5          jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
00034a 011b          .dw DO_COLON
                 PFA_DODOES:
00034b 05a3          .dw XT_R_FROM
00034c 01ac          .dw XT_NEWEST
00034d 09b6          .dw XT_CELLPLUS
00034e 0526          .dw XT_FETCH
00034f 0802          .dw XT_FETCHE
000350 10f3          .dw XT_NFA2CFA
000351 0816          .dw XT_STOREI
000352 04c2          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
000353 ff01          .dw $ff01
000354 003a          .db ":",0
000355 0332          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000356 011b          .dw DO_COLON
                 PFA_COLON:
                 .endif
000357 01bb          .dw XT_DOCREATE
000358 0361          .dw XT_COLONNONAME
000359 0586          .dw XT_DROP
00035a 04c2          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
00035b ff07          .dw $ff07
00035c 6e3a
00035d 6e6f
00035e 6d61
00035f 0065          .db ":noname",0
000360 0353          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
000361 011b          .dw DO_COLON
                 PFA_COLONNONAME:
000362 0a07          .dw XT_DP
000363 055e          .dw XT_DUP
000364 01b3          .dw XT_LATEST
000365 052e          .dw XT_STORE
                 
000366 01e9          .dw XT_COMPILE
000367 011b          .dw DO_COLON
                 
000368 0376          .dw XT_RBRACKET
000369 04c2          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
00036a 0001          .dw $0001
00036b 003b          .db $3b,0
00036c 035b          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
00036d 011b          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
00036e 01e9          .dw XT_COMPILE
00036f 04c2          .dw XT_EXIT
000370 037e          .dw XT_LBRACKET
000371 0326          .dw XT_REVEAL
000372 04c2          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
000373 ff01          .dw $ff01
000374 005d          .db "]",0
000375 036a          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
000376 011b          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
000377 0854          .dw XT_ONE
000378 09a3          .dw XT_STATE
000379 052e          .dw XT_STORE
00037a 04c2          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
00037b 0001          .dw $0001
00037c 005b          .db "[",0
00037d 0373          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
00037e 011b          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
00037f 0601          .dw XT_ZERO
000380 09a3          .dw XT_STATE
000381 052e          .dw XT_STORE
000382 04c2          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
000383 ff08          .dw $ff08
000384 6176
000385 6972
000386 6261
000387 656c          .db "variable"
000388 037b          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000389 011b          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
00038a 0a18          .dw XT_HERE
00038b 0395          .dw XT_CONSTANT
00038c 0859          .dw XT_TWO
00038d 0a21          .dw XT_ALLOT
00038e 04c2          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
00038f ff08          .dw $ff08
000390 6f63
000391 736e
000392 6174
000393 746e          .db "constant"
000394 0383          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000395 011b          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
000396 01bb          .dw XT_DOCREATE
000397 0326          .dw XT_REVEAL
000398 01e9          .dw XT_COMPILE
000399 04f0          .dw PFA_DOVARIABLE
00039a 01f4          .dw XT_COMMA
00039b 04c2          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
00039c ff04          .dw $ff04
00039d 7375
00039e 7265          .db "user"
00039f 038f          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
0003a0 011b          .dw DO_COLON
                 PFA_USER:
0003a1 01bb          .dw XT_DOCREATE
0003a2 0326          .dw XT_REVEAL
                 
0003a3 01e9          .dw XT_COMPILE
0003a4 0503          .dw PFA_DOUSER
0003a5 01f4          .dw XT_COMMA
0003a6 04c2          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECURSE:
0003a7 0007          .dw $0007
0003a8 6572
0003a9 7563
0003aa 7372
0003ab 0065          .db "recurse",0
0003ac 039c          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
0003ad 011b          .dw DO_COLON
                 PFA_RECURSE:
                 .endif
0003ae 01b3          .dw XT_LATEST
0003af 0526          .dw XT_FETCH
0003b0 01f4          .dw XT_COMMA
0003b1 04c2          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
0003b2 ff09          .dw $ff09
0003b3 6d69
0003b4 656d
0003b5 6964
0003b6 7461
0003b7 0065          .db "immediate",0
0003b8 03a7          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
0003b9 011b          .dw DO_COLON
                 PFA_IMMEDIATE:
0003ba 045b          .dw XT_GET_CURRENT
0003bb 0802          .dw XT_FETCHE
0003bc 055e          .dw XT_DUP
0003bd 0835          .dw XT_FETCHI
0003be 04e2          .dw XT_DOLITERAL
0003bf 7fff          .dw $7fff
0003c0 06c0          .dw XT_AND
0003c1 0571          .dw XT_SWAP
0003c2 0816          .dw XT_STOREI
0003c3 04c2          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
0003c4 0006          .dw $0006
0003c5 635b
0003c6 6168
0003c7 5d72          .db "[char]"
0003c8 03b2          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
0003c9 011b          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
0003ca 01e9          .dw XT_COMPILE
0003cb 04e2          .dw XT_DOLITERAL
0003cc 0d49          .dw XT_CHAR
0003cd 01f4          .dw XT_COMMA
0003ce 04c2          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
0003cf 0006          .dw $0006
0003d0 6261
0003d1 726f
0003d2 2274          .db "abort",'"'
0003d3 03c4          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
0003d4 011b          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
0003d5 0919          .dw XT_SQUOTE
0003d6 01e9          .dw XT_COMPILE
0003d7 03e6          .dw XT_QABORT
0003d8 04c2          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
0003d9 ff05          .dw $ff05
0003da 6261
0003db 726f
0003dc 0074          .db "abort",0
0003dd 03cf          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
0003de 011b          .dw DO_COLON
                 PFA_ABORT:
                 .endif
0003df 05f8          .dw XT_TRUE
0003e0 0c9b          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
0003e1 ff06          .dw $ff06
0003e2 613f
0003e3 6f62
0003e4 7472          .db "?abort"
0003e5 03d9          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
0003e6 011b          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
0003e7 058e
0003e8 04db              .DW XT_ROT,XT_DOCONDBRANCH
0003e9 03ec              DEST(QABO1)
0003ea 0bfa
0003eb 03de              .DW XT_ITYPE,XT_ABORT
0003ec 09c7
0003ed 04c2      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
0003ee ff09          .dw $ff09
0003ef 6567
0003f0 2d74
0003f1 7473
0003f2 6361
0003f3 006b          .db "get-stack",0
0003f4 03e1          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
0003f5 011b          .dw DO_COLON
                 .endif
0003f6 055e          .dw XT_DUP
0003f7 09b6          .dw XT_CELLPLUS
0003f8 0571          .dw XT_SWAP
0003f9 0802          .dw XT_FETCHE
0003fa 055e          .dw XT_DUP
0003fb 05ac          .dw XT_TO_R
0003fc 0601          .dw XT_ZERO
0003fd 0571          .dw XT_SWAP    ; go from bigger to smaller addresses
0003fe 02b3          .dw XT_QDOCHECK
0003ff 04db          .dw XT_DOCONDBRANCH
000400 040c          DEST(PFA_N_FETCH_E2)
000401 0748          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
000402 0759          .dw XT_I
000403 06e2          .dw XT_1MINUS
000404 09b0          .dw XT_CELLS ; ( -- ee-addr i*2 )
000405 057c          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
000406 064a          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
000407 0802          .dw XT_FETCHE ;( -- ee-addr item_i )
000408 0571          .dw XT_SWAP   ;( -- item_i ee-addr )
000409 05f8          .dw XT_TRUE  ; shortcut for -1
00040a 0767          .dw XT_DOPLUSLOOP
00040b 0402          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
00040c 09c7          .dw XT_2DROP
00040d 05a3          .dw XT_R_FROM
00040e 04c2          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
00040f ff09          .dw $ff09
000410 6573
000411 2d74
000412 7473
000413 6361
000414 006b          .db "set-stack",0
000415 03ee          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
000416 011b          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
000417 057c          .dw XT_OVER
000418 05cc          .dw XT_ZEROLESS
000419 04db          .dw XT_DOCONDBRANCH
00041a 041e          DEST(PFA_SET_STACK0)
00041b 04e2          .dw XT_DOLITERAL
00041c fffc          .dw -4
00041d 0c9b          .dw XT_THROW
                 PFA_SET_STACK0:
00041e 09be          .dw XT_2DUP
00041f 07de          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
000420 0571          .dw XT_SWAP    
000421 0601          .dw XT_ZERO
000422 02b3          .dw XT_QDOCHECK
000423 04db          .dw XT_DOCONDBRANCH
000424 042b          DEST(PFA_SET_STACK2)
000425 0748          .dw XT_DODO
                 PFA_SET_STACK1:
000426 09b6          .dw XT_CELLPLUS ; ( -- i_x e-addr )
000427 09cf          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
000428 07de          .dw XT_STOREE
000429 0776          .dw XT_DOLOOP
00042a 0426          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
00042b 0586          .dw XT_DROP
00042c 04c2          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
00042d ff09          .dw $ff09
00042e 616d
00042f 2d70
000430 7473
000431 6361
000432 006b          .db "map-stack",0
000433 040f          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
000434 011b          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
000435 055e          .dw XT_DUP
000436 09b6          .dw XT_CELLPLUS
000437 0571          .dw XT_SWAP
000438 0802          .dw XT_FETCHE
000439 09b0          .dw XT_CELLS
00043a 11d3          .dw XT_BOUNDS
00043b 02b3          .dw XT_QDOCHECK
00043c 04db          .dw XT_DOCONDBRANCH
00043d 0450          DEST(PFA_MAPSTACK3)
00043e 0748          .dw XT_DODO
                 PFA_MAPSTACK1:
00043f 0759            .dw XT_I
000440 0802            .dw XT_FETCHE   ; -- i*x XT id
000441 0571            .dw XT_SWAP
000442 05ac            .dw XT_TO_R
000443 05b3            .dw XT_R_FETCH
000444 04cc            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
000445 0566            .dw XT_QDUP
000446 04db            .dw XT_DOCONDBRANCH
000447 044c            DEST(PFA_MAPSTACK2)
000448 05a3               .dw XT_R_FROM
000449 0586               .dw XT_DROP
00044a 0781               .dw XT_UNLOOP
00044b 04c2               .dw XT_EXIT
                 PFA_MAPSTACK2:
00044c 05a3            .dw XT_R_FROM
00044d 0859            .dw XT_TWO
00044e 0767            .dw XT_DOPLUSLOOP
00044f 043f            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
000450 0586          .dw XT_DROP
000451 0601          .dw XT_ZERO
000452 04c2          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ; ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
000453 ff0b          .dw $ff0b
000454 6567
000455 2d74
000456 7563
000457 7272
000458 6e65
000459 0074          .db "get-current",0
00045a 042d          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
00045b 011b          .dw DO_COLON
                 PFA_GET_CURRENT:
00045c 04e2          .dw XT_DOLITERAL
00045d 0084          .dw CFG_CURRENT
00045e 0802          .dw XT_FETCHE
00045f 04c2          .dw XT_EXIT
                 .include "words/cfg-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CFG_ORDER:
000460 ff09          .dw $ff09
000461 6663
000462 2d67
000463 726f
000464 6564
000465 0072          .db "cfg-order",0
000466 0453          .dw VE_HEAD
                     .set VE_HEAD = VE_CFG_ORDER
                 XT_CFG_ORDER:
000467 04f0          .dw PFA_DOVARIABLE
                 PFA_CFG_ORDER:
                 .endif
000468 0088          .dw CFG_ORDERLISTLEN
                 .include "words/cfg-recognizer.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CFG_RECOGNIZER:
000469 ff08          .dw $ff08
00046a 6663
00046b 2d67
00046c 6572
00046d 7363          .db "cfg-recs"
00046e 0460          .dw VE_HEAD
                     .set VE_HEAD = VE_CFG_RECOGNIZER
                 XT_CFG_RECOGNIZER:
00046f 04f0          .dw PFA_DOVARIABLE
                 PFA_CFG_RECOGNIZER:
                 .endif
000470 009a          .dw CFG_RECOGNIZERLISTLEN
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
000471 ff07          .dw $ff07
000472 6f63
000473 706d
000474 7261
000475 0065          .db "compare",0
000476 0469          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
000477 0478          .dw PFA_COMPARE
                 PFA_COMPARE:
000478 93bf          push xh
000479 93af          push xl
00047a 018c          movw temp0, tosl
00047b 9189
00047c 9199          loadtos
00047d 01dc          movw xl, tosl
00047e 9189
00047f 9199          loadtos
000480 019c          movw temp2, tosl
000481 9189
000482 9199          loadtos
000483 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000484 90ed          ld temp4, X+
000485 90f1          ld temp5, Z+
000486 14ef          cp temp4, temp5
000487 f451          brne PFA_COMPARE_NOTEQUAL
000488 950a          dec temp0
000489 f019          breq PFA_COMPARE_ENDREACHED2
00048a 952a          dec temp2
00048b f7c1          brne PFA_COMPARE_LOOP
00048c c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
00048d 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
00048e 2b02          or temp0, temp2
00048f f411          brne PFA_COMPARE_CHECKLASTCHAR
000490 2788          clr tosl
000491 c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000492 ef8f          ser tosl
000493 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000494 2f98          mov tosh, tosl
000495 91af          pop xl
000496 91bf          pop xh
000497 cc87          jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
000498 ff07         .dw $ff07
000499 666e
00049a 3e61
00049b 666c
00049c 0061         .db "nfa>lfa",0
00049d 0471         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
00049e 011b          .dw DO_COLON
                 PFA_NFA2LFA:
00049f 10e7          .dw XT_NAME2STRING
0004a0 06dc          .dw XT_1PLUS
0004a1 06b1          .dw XT_2SLASH
0004a2 064a          .dw XT_PLUS
0004a3 04c2          .dw XT_EXIT
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
0004a4 ff0b          .dw $ff0b
0004a5 7061
0004a6 6c70
0004a7 7574
0004a8 6e72
0004a9 656b
0004aa 0079          .db "applturnkey",0
0004ab 0498          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
0004ac 011b          .dw DO_COLON
                 PFA_APPLTURNKEY:
0004ad 0105          .dw XT_USART
                 
                 .if WANT_INTERRUPTS == 1
0004ae 1258          .dw XT_INTON
                 .endif
                 
0004af 0fd9          .dw XT_DOT_VER
0004b0 0c3c          .dw XT_SPACE
0004b1 0998          .dw XT_F_CPU
0004b2 04e2          .dw XT_DOLITERAL
0004b3 03e8          .dw 1000
0004b4 066f          .dw XT_UMSLASHMOD
0004b5 059d          .dw XT_NIP
0004b6 0a36          .dw XT_DECIMAL
0004b7 0b7c          .dw XT_DOT
0004b8 0bc7          .dw XT_DOSLITERAL
0004b9 0004          .dw 4
0004ba 486b
0004bb 207a          .db "kHz "
0004bc 0bfa          .dw XT_ITYPE
                     
0004bd 04c2          .dw XT_EXIT
                 
                 .include "dict/nrww.inc" ; well, not really nrww, but simplifies things alot
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
0004be ff04          .dw $ff04
0004bf 7865
0004c0 7469          .db "exit"
0004c1 04a4          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
0004c2 04c3          .dw PFA_EXIT
                 PFA_EXIT:
0004c3 91af          pop XL
0004c4 91bf          pop XH
0004c5 cc59          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
0004c6 ff07          .dw $ff07
0004c7 7865
0004c8 6365
0004c9 7475
0004ca 0065          .db "execute",0
0004cb 04be          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
0004cc 04cd          .dw PFA_EXECUTE
                 PFA_EXECUTE:
0004cd 01bc          movw wl, tosl
0004ce 9189
0004cf 9199          loadtos
0004d0 cc59          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
0004d1 04d2          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
0004d2 01fd          movw zl, XL
0004d3 2755
0004d4 0fee
0004d5 1fff
0004d6 1f55
0004d7 bf5b
0004d8 91a7
0004d9 91b7          readflashcell XL,XH
0004da cc44          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
0004db 04dc          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
0004dc 2b98          or tosh, tosl
0004dd 9189
0004de 9199          loadtos
0004df f391          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
0004e0 9611          adiw XL, 1
0004e1 cc3d          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
0004e2 04e3          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
0004e3 939a
0004e4 938a          savetos
0004e5 01fd          movw zl, xl
0004e6 2755
0004e7 0fee
0004e8 1fff
0004e9 1f55
0004ea bf5b
0004eb 9187
0004ec 9197          readflashcell tosl,tosh
0004ed 9611          adiw xl, 1
0004ee cc30          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
0004ef 04f0          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
0004f0 939a
0004f1 938a          savetos
0004f2 01fb          movw zl, wl
0004f3 9631          adiw zl,1
0004f4 2755
0004f5 0fee
0004f6 1fff
0004f7 1f55
0004f8 bf5b
0004f9 9187
0004fa 9197          readflashcell tosl,tosh
0004fb cc23          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
0004fc 04fd          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
0004fd 939a
0004fe 938a          savetos
0004ff 01cb          movw tosl, wl
000500 9601          adiw tosl, 1
000501 cc1d          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
000502 0503          .dw PFA_DOUSER
                 PFA_DOUSER:
000503 939a
000504 938a          savetos
000505 01fb          movw zl, wl
000506 9631          adiw zl, 1
000507 2755
000508 0fee
000509 1fff
00050a 1f55
00050b bf5b
00050c 9187
00050d 9197          readflashcell tosl,tosh
00050e 0d84          add tosl, upl
00050f 1d95          adc tosh, uph
000510 cc0e          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
000511 ff07          .dw $ff07
000512 7628
000513 6c61
000514 6575
000515 0029          .db "(value)", 0
000516 04c6          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
000517 011b          .dw DO_COLON
                 PFA_DOVALUE:
000518 01bb          .dw XT_DOCREATE
000519 0326          .dw XT_REVEAL
00051a 01e9          .dw XT_COMPILE
00051b 051d          .dw PFA_DOVALUE1
00051c 04c2          .dw XT_EXIT
                 PFA_DOVALUE1:
00051d de21          call_ DO_DODOES
00051e 055e          .dw XT_DUP
00051f 1020          .dw XT_ICELLPLUS
000520 0835          .dw XT_FETCHI
000521 04cc          .dw XT_EXECUTE
000522 04c2          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
000523 ff01          .dw $ff01
000524 0040          .db "@",0
000525 0511          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
000526 0527          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
000527 01fc          movw zl, tosl
                     ; low byte is read before the high byte
000528 9181          ld tosl, z+
000529 9191          ld tosh, z+
00052a cbf4          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
00052b ff01          .dw $ff01
00052c 0021          .db "!",0
00052d 0523          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00052e 052f          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00052f 01fc          movw zl, tosl
000530 9189
000531 9199          loadtos
                     ; the high byte is written before the low byte
000532 8391          std Z+1, tosh
000533 8380          std Z+0, tosl
000534 9189
000535 9199          loadtos
000536 cbe8          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
000537 ff02          .dw $ff02
000538 2163          .db "c!"
000539 052b          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
00053a 053b          .dw PFA_CSTORE
                 PFA_CSTORE:
00053b 01fc          movw zl, tosl
00053c 9189
00053d 9199          loadtos
00053e 8380          st Z, tosl
00053f 9189
000540 9199          loadtos
000541 cbdd          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
000542 ff02          .dw $ff02
000543 4063          .db "c@"
000544 0537          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
000545 0546          .dw PFA_CFETCH
                 PFA_CFETCH:
000546 01fc          movw zl, tosl
000547 2799          clr tosh
000548 8180          ld tosl, Z
000549 cbd5          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
00054a ff02          .dw $ff02
00054b 7540          .db "@u"
00054c 0542          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00054d 011b          .dw DO_COLON
                 PFA_FETCHU:
00054e 07af          .dw XT_UP_FETCH
00054f 064a          .dw XT_PLUS
000550 0526          .dw XT_FETCH
000551 04c2          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
000552 ff02          .dw $ff02
000553 7521          .db "!u"
000554 054a          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
000555 011b          .dw DO_COLON
                 PFA_STOREU:
000556 07af          .dw XT_UP_FETCH
000557 064a          .dw XT_PLUS
000558 052e          .dw XT_STORE
000559 04c2          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
00055a ff03          .dw $ff03
00055b 7564
00055c 0070          .db "dup",0
00055d 0552          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
00055e 055f          .dw PFA_DUP
                 PFA_DUP:
00055f 939a
000560 938a          savetos
000561 cbbd          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
000562 ff04          .dw $ff04
000563 643f
000564 7075          .db "?dup"
000565 055a          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
000566 0567          .dw PFA_QDUP
                 PFA_QDUP:
000567 2f08          mov temp0, tosl
000568 2b09          or temp0, tosh
000569 f011          breq PFA_QDUP1
00056a 939a
00056b 938a          savetos
                 PFA_QDUP1:
00056c cbb2          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
00056d ff04          .dw $ff04
00056e 7773
00056f 7061          .db "swap"
000570 0562          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
000571 0572          .dw PFA_SWAP
                 PFA_SWAP:
000572 018c          movw temp0, tosl
000573 9189
000574 9199          loadtos
000575 931a          st -Y, temp1
000576 930a          st -Y, temp0
000577 cba7          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
000578 ff04          .dw $ff04
000579 766f
00057a 7265          .db "over"
00057b 056d          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
00057c 057d          .dw PFA_OVER
                 PFA_OVER:
00057d 939a
00057e 938a          savetos
00057f 818a          ldd tosl, Y+2
000580 819b          ldd tosh, Y+3
                 
000581 cb9d          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
000582 ff04          .dw $ff04
000583 7264
000584 706f          .db "drop"
000585 0578          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
000586 0587          .dw PFA_DROP
                 PFA_DROP:
000587 9189
000588 9199          loadtos
000589 cb95          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
00058a ff03          .dw $ff03
00058b 6f72
00058c 0074          .db "rot",0
00058d 0582          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
00058e 058f          .dw PFA_ROT
                 PFA_ROT:
00058f 018c          movw temp0, tosl
000590 9129          ld temp2, Y+
000591 9139          ld temp3, Y+ 
000592 9189
000593 9199          loadtos
                         
000594 933a          st -Y, temp3
000595 932a          st -Y, temp2
000596 931a          st -Y, temp1
000597 930a          st -Y, temp0
                 
000598 cb86          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
000599 ff03          .dw $ff03
00059a 696e
00059b 0070          .db "nip",0
00059c 058a          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
00059d 059e          .dw PFA_NIP
                 PFA_NIP:
00059e 9622          adiw yl, 2
00059f cb7f          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
0005a0 ff02          .dw $ff02
0005a1 3e72          .db "r>"
0005a2 0599          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
0005a3 05a4          .dw PFA_R_FROM
                 PFA_R_FROM:
0005a4 939a
0005a5 938a          savetos
0005a6 918f          pop tosl
0005a7 919f          pop tosh
0005a8 cb76          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
0005a9 ff02          .dw $ff02
0005aa 723e          .db ">r"
0005ab 05a0          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
0005ac 05ad          .dw PFA_TO_R
                 PFA_TO_R:
0005ad 939f          push tosh
0005ae 938f          push tosl
0005af cfd7          jmp_ PFA_DROP
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
0005b0 ff02          .dw $ff02
0005b1 4072          .db "r@"
0005b2 05a9          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
0005b3 05b4          .dw PFA_R_FETCH
                 PFA_R_FETCH:
0005b4 939a
0005b5 938a          savetos
0005b6 918f          pop tosl
0005b7 919f          pop tosh
0005b8 939f          push tosh
0005b9 938f          push tosl
0005ba cb64          jmp_ DO_NEXT
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
0005bb ff02          .dw $ff02
0005bc 3e3c          .db "<>"
0005bd 05b0          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
0005be 011b          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
0005bf 084d
0005c0 05c5
0005c1 04c2          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
0005c2 ff02          .dw $ff02
0005c3 3d30          .db "0="
0005c4 05bb          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
0005c5 05c6          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
0005c6 2b98          or tosh, tosl
0005c7 f5e1          brne PFA_ZERO1
0005c8 c032          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
0005c9 ff02          .dw $ff02
0005ca 3c30          .db "0<"
0005cb 05c2          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
0005cc 05cd          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
0005cd fd97          sbrc tosh,7
0005ce c02c          rjmp PFA_TRUE1
0005cf c034          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
0005d0 ff02          .dw $ff02
0005d1 3e30          .db "0>"
0005d2 05c9          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
0005d3 05d4          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
0005d4 1582          cp tosl, zerol
0005d5 0593          cpc tosh, zeroh
0005d6 f16c          brlt PFA_ZERO1
0005d7 f161          brbs 1, PFA_ZERO1
0005d8 c022          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
0005d9 ff03          .dw $ff03
0005da 3064
0005db 003e          .db "d0>",0
0005dc 05d0          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
0005dd 05de          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
0005de 1593          cp tosh, zeroh
0005df f03c          brlt PFA_DGREATERZERO_FALSE ; if MSBit is set, d:arg is negative, we are done (false).
0005e0 0582          cpc tosl, zerol
0005e1 9189
0005e2 9199          loadtos
0005e3 0582          cpc tosl, zerol
0005e4 0593          cpc tosh, zeroh
0005e5 f0f1          brbs 1, PFA_ZERO1           ; if all 4 Bytes of d:arg are zero, we are done (false).
0005e6 c014          rjmp PFA_TRUE1              ; if we get this far, d:arg was positive! (true)
                 PFA_DGREATERZERO_FALSE:
0005e7 01c1          movw tosl, zerol            ; ZERO
0005e8 cfb5          rjmp PFA_NIP                ; NIP
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
0005e9 ff03          .dw $ff03
0005ea 3064
0005eb 003c          .db "d0<",0
0005ec 05d9          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
0005ed 05ee          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
0005ee 9622          adiw Y,2
0005ef fd97          sbrc tosh,7
0005f0 940c 05fb     jmp PFA_TRUE1
0005f2 940c 0604     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
0005f4 ff04          .dw $ff04
0005f5 7274
0005f6 6575          .db "true"
0005f7 05e9          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
0005f8 05f9          .dw PFA_TRUE
                 PFA_TRUE:
0005f9 939a
0005fa 938a          savetos
                 PFA_TRUE1:
0005fb ef8f          ser tosl
0005fc ef9f          ser tosh
0005fd cb21          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
0005fe ff01          .dw $ff01
0005ff 0030          .db "0",0
000600 05f4          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
000601 0602          .dw PFA_ZERO
                 PFA_ZERO:
000602 939a
000603 938a          savetos
                 PFA_ZERO1:
000604 01c1          movw tosl, zerol
000605 cb19          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
000606 ff02          .dw $ff02
000607 3c75          .db "u<"
000608 05fe          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
000609 060a          .dw PFA_ULESS
                 PFA_ULESS:
00060a 9129          ld temp2, Y+
00060b 9139          ld temp3, Y+
00060c 1782          cp tosl, temp2
00060d 0793          cpc tosh, temp3
00060e f3a8          brlo PFA_ZERO1
00060f f3a1          brbs 1, PFA_ZERO1
000610 cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
000611 ff02          .dw $ff02
000612 3e75          .db "u>"
000613 0606          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
000614 011b          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
000615 0571          .DW XT_SWAP
000616 0609          .dw XT_ULESS
000617 04c2          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
000618 ff01          .dw $ff01
000619 003c          .db "<",0
00061a 0611          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
00061b 061c          .dw PFA_LESS
                 PFA_LESS:
00061c 9129          ld temp2, Y+
00061d 9139          ld temp3, Y+
00061e 1728          cp temp2, tosl
00061f 0739          cpc temp3, tosh
                 PFA_LESSDONE:
000620 f71c          brge PFA_ZERO1
000621 cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
000622 ff01          .dw $ff01
000623 003e          .db ">",0
000624 0618          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
000625 0626          .dw PFA_GREATER
                 PFA_GREATER:
000626 9129          ld temp2, Y+
000627 9139          ld temp3, Y+
000628 1728          cp temp2, tosl
000629 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
00062a f2cc          brlt PFA_ZERO1
00062b f2c1          brbs 1, PFA_ZERO1
00062c cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
00062d ff04          .dw $ff04
00062e 6f6c
00062f 3267          .db "log2"
000630 0622          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
000631 0632          .dw PFA_LOG2
                 PFA_LOG2:
000632 01fc          movw zl, tosl
000633 2799          clr tosh
000634 e180          ldi tosl, 16
                 PFA_LOG2_1:
000635 958a          dec tosl
000636 f022          brmi PFA_LOG2_2 ; wrong data
000637 0fee          lsl  zl
000638 1fff          rol  zh
000639 f7d8          brcc PFA_LOG2_1
00063a cae4          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
00063b 959a          dec tosh
00063c cae2          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
00063d ff01          .dw $ff01
00063e 002d          .db "-",0
00063f 062d          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
000640 0641          .dw PFA_MINUS
                 PFA_MINUS:
000641 9109          ld temp0, Y+
000642 9119          ld temp1, Y+
000643 1b08          sub temp0, tosl
000644 0b19          sbc temp1, tosh
000645 01c8          movw tosl, temp0
000646 cad8          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
000647 ff01          .dw $ff01
000648 002b          .db "+",0
000649 063d          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
00064a 064b          .dw PFA_PLUS
                 PFA_PLUS:
00064b 9109          ld temp0, Y+
00064c 9119          ld temp1, Y+
00064d 0f80          add tosl, temp0
00064e 1f91          adc tosh, temp1
00064f cacf          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
000650 ff02          .dw $ff02
000651 2a6d          .db "m*"
000652 0647          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
000653 0654          .dw PFA_MSTAR
                 PFA_MSTAR:
000654 018c          movw temp0, tosl
000655 9189
000656 9199          loadtos
000657 019c          movw temp2, tosl
                     ; high cell ah*bh
000658 0231          muls temp3, temp1
000659 0170          movw temp4, r0
                     ; low cell  al*bl
00065a 9f20          mul  temp2, temp0
00065b 01c0          movw tosl, r0
                     ; signed ah*bl
00065c 0330          mulsu temp3, temp0
00065d 08f3          sbc   temp5, zeroh
00065e 0d90          add   tosh,  r0
00065f 1ce1          adc   temp4, r1
000660 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
000661 0312          mulsu temp1, temp2
000662 08f3          sbc   temp5, zeroh
000663 0d90          add   tosh,  r0
000664 1ce1          adc   temp4, r1
000665 1cf3          adc   temp5, zeroh
                 
000666 939a
000667 938a          savetos
000668 01c7          movw tosl, temp4
000669 cab5          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
00066a ff06          .dw $ff06
00066b 6d75
00066c 6d2f
00066d 646f          .db "um/mod"
00066e 0650          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
00066f 0670          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
000670 017c          movw temp4, tosl
                 
000671 9129          ld temp2, Y+
000672 9139          ld temp3, Y+
                   
000673 9109          ld temp0, Y+
000674 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
000675 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
000676 2755          clr temp7
000677 0f00          lsl temp0
000678 1f11          rol temp1
000679 1f22          rol temp2
00067a 1f33          rol temp3
00067b 1f55          rol temp7
                 
                   ; try subtracting divisor
00067c 152e          cp temp2, temp4
00067d 053f          cpc temp3, temp5
00067e 0552          cpc temp7,zerol
                 
00067f f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
000680 9503          inc temp0
000681 192e          sub temp2, temp4
000682 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
000683 954a          dec  temp6
000684 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
000685 933a          st -Y,temp3
000686 932a          st -Y,temp2
                 
                     ; put quotient on stack
000687 01c8          movw tosl, temp0
000688 ca96          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
000689 ff03          .dw $ff03
00068a 6d75
00068b 002a          .db "um*",0
00068c 066a          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
00068d 068e          .dw PFA_UMSTAR
                 PFA_UMSTAR:
00068e 018c          movw temp0, tosl
00068f 9189
000690 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
000691 9f80          mul tosl,temp0
000692 01f0          movw zl, r0
000693 2722          clr temp2
000694 2733          clr temp3
                     ; middle bytes
000695 9f90          mul tosh, temp0
000696 0df0          add zh, r0
000697 1d21          adc temp2, r1
000698 1d33          adc temp3, zeroh
                         
000699 9f81          mul tosl, temp1
00069a 0df0          add zh, r0
00069b 1d21          adc temp2, r1
00069c 1d33          adc temp3, zeroh
                     
00069d 9f91          mul tosh, temp1
00069e 0d20          add temp2, r0
00069f 1d31          adc temp3, r1
0006a0 01cf          movw tosl, zl
0006a1 939a
0006a2 938a          savetos
0006a3 01c9          movw tosl, temp2
0006a4 ca7a          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
0006a5 ff06          .dw $ff06
0006a6 6e69
0006a7 6576
0006a8 7472          .db "invert"
0006a9 0689          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
0006aa 06ab          .dw PFA_INVERT
                 PFA_INVERT:
0006ab 9580          com tosl
0006ac 9590          com tosh
0006ad ca71          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
0006ae ff02          .dw $ff02
0006af 2f32          .db "2/"
0006b0 06a5          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
0006b1 06b2          .dw PFA_2SLASH
                 PFA_2SLASH:
0006b2 9595          asr tosh
0006b3 9587          ror tosl
0006b4 ca6a          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
0006b5 ff02          .dw $ff02
0006b6 2a32          .db "2*"
0006b7 06ae          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
0006b8 06b9          .dw PFA_2STAR
                 PFA_2STAR:
0006b9 0f88          lsl tosl
0006ba 1f99          rol tosh
0006bb ca63          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
0006bc ff03          .dw $ff03
0006bd 6e61
0006be 0064          .db "and",0
0006bf 06b5          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
0006c0 06c1          .dw PFA_AND
                 PFA_AND:
0006c1 9109          ld temp0, Y+
0006c2 9119          ld temp1, Y+
0006c3 2380          and tosl, temp0
0006c4 2391          and tosh, temp1
0006c5 ca59          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
0006c6 ff02          .dw $ff02
0006c7 726f          .db "or"
0006c8 06bc          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
0006c9 06ca          .dw PFA_OR
                 PFA_OR:
0006ca 9109          ld temp0, Y+
0006cb 9119          ld temp1, Y+
0006cc 2b80          or tosl, temp0
0006cd 2b91          or tosh, temp1
0006ce ca50          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
0006cf ff03          .dw $ff03
0006d0 6f78
0006d1 0072          .db "xor",0
0006d2 06c6          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
0006d3 06d4          .dw PFA_XOR
                 PFA_XOR:
0006d4 9109          ld temp0, Y+
0006d5 9119          ld temp1, Y+
0006d6 2780          eor tosl, temp0
0006d7 2791          eor tosh, temp1
0006d8 ca46          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
0006d9 ff02          .dw $ff02
0006da 2b31          .db "1+"
0006db 06cf          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
0006dc 06dd          .dw PFA_1PLUS
                 PFA_1PLUS:
0006dd 9601          adiw tosl,1
0006de ca40          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
0006df ff02          .dw $ff02 
0006e0 2d31          .db "1-"
0006e1 06d9          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
0006e2 06e3          .dw PFA_1MINUS
                 PFA_1MINUS:
0006e3 9701          sbiw tosl, 1
0006e4 ca3a          jmp_ DO_NEXT
                 .include "words/q-negate.asm"
                 
                 ;   0< IF NEGATE THEN ;        ...a common factor
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QNEGATE:
0006e5 ff07          .dw $ff07
0006e6 6e3f
0006e7 6765
0006e8 7461
../../common\words/q-negate.asm(11): warning: .cseg .db misalignment - padding zero byte
0006e9 0065          .db "?negate"
0006ea 06df          .dw VE_HEAD
                     .set VE_HEAD = VE_QNEGATE
                 XT_QNEGATE:
0006eb 011b          .dw DO_COLON
                 PFA_QNEGATE:
                 
                 .endif
0006ec 05cc
0006ed 04db              .DW XT_ZEROLESS,XT_DOCONDBRANCH
0006ee 06f0              DEST(QNEG1)
0006ef 0a99              .DW XT_NEGATE
0006f0 04c2      QNEG1:  .DW XT_EXIT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
0006f1 ff06          .dw $ff06
0006f2 736c
0006f3 6968
0006f4 7466          .db "lshift"
0006f5 06e5          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
0006f6 06f7          .dw PFA_LSHIFT
                 PFA_LSHIFT:
0006f7 01fc          movw zl, tosl
0006f8 9189
0006f9 9199          loadtos
                 PFA_LSHIFT1:
0006fa 9731          sbiw zl, 1
0006fb f01a          brmi PFA_LSHIFT2
0006fc 0f88          lsl tosl
0006fd 1f99          rol tosh
0006fe cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
0006ff ca1f          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
000700 ff06          .dw $ff06
000701 7372
000702 6968
000703 7466          .db "rshift"
000704 06f1          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
000705 0706          .dw PFA_RSHIFT
                 PFA_RSHIFT:
000706 01fc          movw zl, tosl
000707 9189
000708 9199          loadtos
                 PFA_RSHIFT1:
000709 9731          sbiw zl, 1
00070a f01a          brmi PFA_RSHIFT2
00070b 9596          lsr tosh
00070c 9587          ror tosl
00070d cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
00070e ca10          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
00070f ff02          .dw $ff02
000710 212b          .db "+!"
000711 0700          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
000712 0713          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
000713 01fc          movw zl, tosl
000714 9189
000715 9199          loadtos
000716 8120          ldd temp2, Z+0
000717 8131          ldd temp3, Z+1
000718 0f82          add tosl, temp2
000719 1f93          adc tosh, temp3
00071a 8380          std Z+0, tosl
00071b 8391          std Z+1, tosh
00071c 9189
00071d 9199          loadtos
00071e ca00          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
00071f ff03          .dw $ff03
000720 7072
000721 0040          .db "rp@",0
000722 070f          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
000723 0724          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
000724 939a
000725 938a          savetos
000726 b78d          in tosl, SPL
000727 b79e          in tosh, SPH
000728 c9f6          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
000729 ff03          .dw $ff03
00072a 7072
00072b 0021          .db "rp!",0
00072c 071f          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
00072d 072e          .dw PFA_RP_STORE
                 PFA_RP_STORE:
00072e b72f          in temp2, SREG
00072f 94f8          cli
000730 bf8d          out SPL, tosl
000731 bf9e          out SPH, tosh
000732 bf2f          out SREG, temp2
000733 9189
000734 9199          loadtos
000735 c9e9          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
000736 ff03          .dw $ff03
000737 7073
000738 0040          .db "sp@",0
000739 0729          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
00073a 073b          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
00073b 939a
00073c 938a          savetos
00073d 01ce          movw tosl, yl
00073e c9e0          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
00073f ff03          .dw $ff03
000740 7073
000741 0021          .db "sp!",0
000742 0736          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
000743 0744          .dw PFA_SP_STORE
                 PFA_SP_STORE:
000744 01ec          movw yl, tosl
000745 9189
000746 9199          loadtos
000747 c9d7          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
000748 0749          .dw PFA_DODO
                 PFA_DODO:
000749 9129          ld temp2, Y+
00074a 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
00074b e8e0          ldi zl, $80
00074c 0f3e          add temp3, zl
00074d 1b82          sub  tosl, temp2
00074e 0b93          sbc  tosh, temp3
                 
00074f 933f          push temp3
000750 932f          push temp2    ; limit  ( --> limit + $8000)
000751 939f          push tosh
000752 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
000753 9189
000754 9199          loadtos
000755 c9c9          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
000756 ff01          .dw $FF01
000757 0069          .db "i",0
000758 073f          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
000759 075a          .dw PFA_I
                 PFA_I:
00075a 939a
00075b 938a          savetos
00075c 918f          pop tosl
00075d 919f          pop tosh  ; index
00075e 91ef          pop zl
00075f 91ff          pop zh    ; limit
000760 93ff          push zh
000761 93ef          push zl
000762 939f          push tosh
000763 938f          push tosl
000764 0f8e          add tosl, zl
000765 1f9f          adc tosh, zh
000766 c9b8          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
000767 0768          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
000768 91ef          pop zl
000769 91ff          pop zh
00076a 0fe8          add zl, tosl
00076b 1ff9          adc zh, tosh
00076c 9189
00076d 9199          loadtos
00076e f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
00076f 93ff          push zh
000770 93ef          push zl
000771 cd60          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
000772 910f          pop  temp0
000773 911f          pop  temp1  ; remove limit
000774 9611          adiw xl, 1  ; skip branch-back address
000775 c9a9          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
000776 0777          .dw PFA_DOLOOP
                 PFA_DOLOOP:
000777 91ef          pop zl
000778 91ff          pop zh
000779 9631          adiw zl,1
00077a f3bb          brvs PFA_DOPLUSLOOP_LEAVE
00077b cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
00077c ff06          .dw $ff06
00077d 6e75
00077e 6f6c
00077f 706f          .db "unloop"
000780 0756          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
000781 0782          .dw PFA_UNLOOP
                 PFA_UNLOOP:
000782 911f          pop temp1
000783 910f          pop temp0
000784 911f          pop temp1
000785 910f          pop temp0
000786 c998          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
000787 ff06          .dw $ff06
000788 6d63
000789 766f
00078a 3e65          .db "cmove>"
00078b 077c          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
00078c 078d          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
00078d 93bf          push xh
00078e 93af          push xl
00078f 91e9          ld zl, Y+
000790 91f9          ld zh, Y+ ; addr-to
000791 91a9          ld xl, Y+
000792 91b9          ld xh, Y+ ; addr-from
000793 2f09          mov temp0, tosh
000794 2b08          or temp0, tosl
000795 f041          brbs 1, PFA_CMOVE_G1
000796 0fe8          add zl, tosl
000797 1ff9          adc zh, tosh
000798 0fa8          add xl, tosl
000799 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
00079a 911e          ld temp1, -X
00079b 9312          st -Z, temp1
00079c 9701          sbiw tosl, 1
00079d f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
00079e 91af          pop xl
00079f 91bf          pop xh
0007a0 9189
0007a1 9199          loadtos
0007a2 c97c          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
0007a3 ff02          .dw $ff02
0007a4 3c3e          .db "><"
0007a5 0787          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
0007a6 07a7          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
0007a7 2f09          mov temp0, tosh
0007a8 2f98          mov tosh, tosl
0007a9 2f80          mov tosl, temp0
0007aa c974          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
0007ab ff03          .dw $ff03
0007ac 7075
0007ad 0040          .db "up@",0
0007ae 07a3          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
0007af 07b0          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
0007b0 939a
0007b1 938a          savetos
0007b2 01c2          movw tosl, upl
0007b3 c96b          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
0007b4 ff03          .dw $ff03
0007b5 7075
0007b6 0021          .db "up!",0
0007b7 07ab          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
0007b8 07b9          .dw PFA_UP_STORE
                 PFA_UP_STORE:
0007b9 012c          movw upl, tosl
0007ba 9189
0007bb 9199          loadtos
0007bc c962          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
0007bd ff03          .dw $ff03
0007be 3e32
0007bf 0072          .db "2>r",0
0007c0 07b4          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
0007c1 07c2          .dw PFA_2TO_R
                 PFA_2TO_R:
0007c2 01fc          movw zl, tosl
0007c3 9189
0007c4 9199          loadtos
0007c5 939f          push tosh
0007c6 938f          push tosl
0007c7 93ff          push zh
0007c8 93ef          push zl
0007c9 9189
0007ca 9199          loadtos
0007cb c953          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
0007cc ff03          .dw $ff03
0007cd 7232
0007ce 003e          .db "2r>",0
0007cf 07bd          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
0007d0 07d1          .dw PFA_2R_FROM
                 PFA_2R_FROM:
0007d1 939a
0007d2 938a          savetos
0007d3 91ef          pop zl
0007d4 91ff          pop zh
0007d5 918f          pop tosl
0007d6 919f          pop tosh
0007d7 939a
0007d8 938a          savetos
0007d9 01cf          movw tosl, zl
0007da c944          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
0007db ff02          .dw $ff02
0007dc 6521          .db "!e"
0007dd 07cc          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
0007de 07df          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
0007df 01fc          movw zl, tosl
0007e0 9189
0007e1 9199          loadtos
0007e2 b72f          in_ temp2, SREG
0007e3 94f8          cli
0007e4 d028          rcall PFA_FETCHE2
0007e5 b500          in_  temp0, EEDR
0007e6 1708          cp temp0,tosl
0007e7 f009          breq PFA_STOREE3
0007e8 d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
0007e9 9631          adiw zl,1
0007ea d022          rcall PFA_FETCHE2
0007eb b500          in_  temp0, EEDR
0007ec 1709          cp temp0,tosh
0007ed f011          breq PFA_STOREE4
0007ee 2f89          mov tosl, tosh
0007ef d004          rcall PFA_STOREE1
                 PFA_STOREE4:
0007f0 bf2f          out_ SREG, temp2
0007f1 9189
0007f2 9199          loadtos
0007f3 c92b          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
0007f4 99f9          sbic EECR, EEPE
0007f5 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
0007f6 b707          in_ temp0, SPMCSR
0007f7 fd00          sbrc temp0,SPMEN
0007f8 cffd          rjmp PFA_STOREE2
                 
0007f9 bdf2          out_ EEARH,zh
0007fa bde1          out_ EEARL,zl
0007fb bd80          out_ EEDR, tosl
0007fc 9afa          sbi EECR,EEMPE
0007fd 9af9          sbi EECR,EEPE
                 
0007fe 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
0007ff ff02          .dw $ff02
000800 6540          .db "@e"
000801 07db          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
000802 0803          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
000803 b72f          in_ temp2, SREG
000804 94f8          cli
000805 01fc          movw zl, tosl
000806 d006          rcall PFA_FETCHE2
000807 b580          in_ tosl, EEDR
                 
000808 9631          adiw zl,1
                 
000809 d003          rcall PFA_FETCHE2
00080a b590          in_  tosh, EEDR
00080b bf2f          out_ SREG, temp2
00080c c912          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
00080d 99f9          sbic EECR, EEPE
00080e cffe          rjmp PFA_FETCHE2
                 
00080f bdf2          out_ EEARH,zh
000810 bde1          out_ EEARL,zl
                 
000811 9af8          sbi EECR,EERE
000812 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
000813 ff02          .dw $ff02
000814 6921          .db "!i"
000815 07ff          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
000816 1088          .dw PFA_DODEFER1
                 PFA_STOREI:
000817 00a4          .dw EE_STOREI
000818 1029          .dw XT_EDEFERFETCH
000819 1033          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                   .include "words/store-i_big.asm"
                 
                 ; R( -- )
                 ; writes a cell in flash
                 VE_DO_STOREI_BIG:
00081a ff04          .dw $ff04
00081b 6928
00081c 2921          .db "(i!)"
00081d 0813          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_BIG
                 XT_DO_STOREI:
00081e 081f          .dw PFA_DO_STOREI_BIG
                 PFA_DO_STOREI_BIG:
00081f 019c        movw temp2, tosl ; save the (word) address
000820 9189
000821 9199        loadtos          ; get the new value for the flash cell
000822 93af        push xl
000823 93bf        push xh
000824 93cf        push yl
000825 93df        push yh
000826 e0e1        ldi zl, byte3(DO_STOREI_atmega)
000827 bfec        out_ eind, zl
000828 eff0        ldi zh, byte2(DO_STOREI_atmega)
000829 e0e0        ldi zl, byte1(DO_STOREI_atmega)
00082a 9519        eicall 
00082b 91df        pop yh
00082c 91cf        pop yl
00082d 91bf        pop xh
00082e 91af        pop xl
                   ; finally clear the stack
00082f 9189
000830 9199        loadtos
000831 c8ed        jmp_ DO_NEXT
                 
                 ;
                 .set _pc = pc
                 .org NRWW_START_ADDR
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
01f000 d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
01f001 94e0        com temp4
01f002 94f0        com temp5
01f003 218e        and tosl, temp4
01f004 219f        and tosh, temp5
01f005 2b98        or tosh, tosl
01f006 f019        breq DO_STOREI_writepage 
                 
01f007 01f9          movw zl, temp2
01f008 e003          ldi temp0,(1<<PGERS|1<<SPMEN)
01f009 d023          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
01f00a 01f9        movw zl, temp2
01f00b e005        ldi temp0,(1<<PGWRT|1<<SPMEN)
01f00c d020        rcall dospm
                 
                   ; reenable RWW section
01f00d 01f9        movw zl, temp2
01f00e e101        ldi temp0,(1<<RWWSRE|1<<SPMEN)
01f00f d01d        rcall dospm
01f010 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
01f011 01f9        movw zl, temp2
                   ; get the beginning of page
01f012 78e0        andi zl,low(pagemask)
01f013 7fff        andi zh,high(pagemask)
01f014 01ef        movw y, z
                   ; loop counter (in words)
01f015 e8a0        ldi xl,low(pagesize)
01f016 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
01f017 01fe        movw z, y
01f018 2755
01f019 0fee
01f01a 1fff
01f01b 1f55
01f01c bf5b
01f01d 9147
01f01e 9157        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
01f01f 01fe        movw z, y
01f020 17e2        cp zl, temp2
01f021 07f3        cpc zh, temp3
01f022 f011        breq pageload_newdata
01f023 010a          movw r0, temp6
01f024 c002          rjmp pageload_cont
                 pageload_newdata:
01f025 017a          movw temp4, temp6
01f026 010c          movw r0, tosl
                 pageload_cont:
01f027 e001        ldi temp0,(1<<SPMEN)
01f028 d004        rcall dospm
01f029 9621        adiw y, 1
01f02a 9711        sbiw x, 1
01f02b f759        brne pageload_loop
                 
                 pageload_done:
01f02c 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                   ; store status register
01f02d b71f        in temp1,SREG
01f02e 931f        push temp1
01f02f 94f8        cli
                 Wait_ee:
01f030 99f9        sbic EECR, EEPE
01f031 cffe        rjmp Wait_ee
                 wait_spm:
01f032 b717        in   temp1, SPMCSR
01f033 fd10        sbrc temp1, SPMEN
01f034 cffd        rjmp Wait_spm
                 
                   ; turn the word addres into a byte address
01f035 2755
01f036 0fee
01f037 1fff
01f038 1f55
01f039 bf5b        writeflashcell
                   ; execute spm
01f03a bf07        out SPMCSR,temp0
01f03b 95e8        spm
01f03c 911f        pop temp1
                   ; restore status register
01f03d bf1f        out SREG,temp1
01f03e 9508        ret
                 
                 .org _pc
                 .else
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
000832 ff02          .dw $ff02
000833 6940          .db "@i"
000834 081a          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
000835 0836          .dw PFA_FETCHI
                 PFA_FETCHI:
000836 01fc          movw zl, tosl
000837 2755
000838 0fee
000839 1fff
00083a 1f55
00083b bf5b
00083c 9187
00083d 9197          readflashcell tosl,tosh
00083e c8e0          jmp_ DO_NEXT
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2LITERAL:
00083f 0008          .dw $0008
000840 6c32
000841 7469
000842 7265
000843 6c61          .db "2literal"
000844 0832          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
000845 011b          .dw DO_COLON
                 PFA_2LITERAL:
                 .endif
000846 0571          .dw XT_SWAP
000847 020a          .dw XT_LITERAL
000848 020a          .dw XT_LITERAL
000849 04c2          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
00084a ff01          .dw $ff01
00084b 003d          .db "=",0
00084c 083f          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
00084d 011b          .dw DO_COLON
                 PFA_EQUAL:
00084e 0640          .dw XT_MINUS
00084f 05c5          .dw XT_ZEROEQUAL
000850 04c2          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
000851 ff01          .dw $ff01
000852 0031          .db "1",0
000853 084a          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
000854 04f0          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
000855 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
000856 ff01          .dw $ff01
000857 0032          .db "2",0
000858 0851          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
000859 04f0          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
00085a 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
00085b ff02          .dw $ff02
00085c 312d          .db "-1"
00085d 0856          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
00085e 04f0          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
00085f ffff              .DW -1
                 
                 .if AMFORTH_NRWW_SIZE>8000
                   .include "dict/core_8k.inc"
                 
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
000860 ff03          .dw $ff03
000861 3e6e
000862 0072          .db "n>r",0
000863 085b          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
000864 0865          .dw PFA_N_TO_R
                 PFA_N_TO_R:
000865 01fc          movw zl, tosl
000866 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
000867 9189
000868 9199          loadtos
000869 939f          push tosh
00086a 938f          push tosl
00086b 950a          dec temp0
00086c f7d1          brne PFA_N_TO_R1
00086d 93ef          push zl
00086e 93ff          push zh
00086f 9189
000870 9199          loadtos
000871 c8ad          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
000872 ff03          .dw $ff03
000873 726e
000874 003e          .db "nr>",0
000875 0860          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
000876 0877          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
000877 939a
000878 938a          savetos
000879 91ff          pop zh
00087a 91ef          pop zl
00087b 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
00087c 918f          pop tosl
00087d 919f          pop tosh
00087e 939a
00087f 938a          savetos
000880 950a          dec temp0
000881 f7d1          brne PFA_N_R_FROM1
000882 01cf          movw tosl, zl
000883 c89b          jmp_ DO_NEXT
                 
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
000884 ff03          .dw $ff03
000885 3264
000886 002a          .db "d2*",0
000887 0872          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
000888 0889          .dw PFA_D2STAR
                 PFA_D2STAR:
000889 9109          ld temp0, Y+
00088a 9119          ld temp1, Y+
00088b 0f00          lsl temp0
00088c 1f11          rol temp1
00088d 1f88          rol tosl
00088e 1f99          rol tosh
00088f 931a          st -Y, temp1
000890 930a          st -Y, temp0
000891 c88d          jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
000892 ff03          .dw $ff03
000893 3264
000894 002f          .db "d2/",0
000895 0884          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
000896 0897          .dw PFA_D2SLASH
                 PFA_D2SLASH:
000897 9109          ld temp0, Y+
000898 9119          ld temp1, Y+
000899 9595          asr tosh
00089a 9587          ror tosl
00089b 9517          ror temp1
00089c 9507          ror temp0
00089d 931a          st -Y, temp1
00089e 930a          st -Y, temp0
00089f c87f          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
0008a0 ff02          .dw $ff02
0008a1 2b64          .db "d+"
0008a2 0892          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
0008a3 08a4          .dw PFA_DPLUS
                 PFA_DPLUS:
0008a4 9129          ld temp2, Y+
0008a5 9139          ld temp3, Y+
                 
0008a6 90e9          ld temp4, Y+
0008a7 90f9          ld temp5, Y+
0008a8 9149          ld temp6, Y+
0008a9 9159          ld temp7, Y+
                 
0008aa 0f24          add temp2, temp6
0008ab 1f35          adc temp3, temp7
0008ac 1d8e          adc tosl, temp4
0008ad 1d9f          adc tosh, temp5
                     
0008ae 933a          st -Y, temp3
0008af 932a          st -Y, temp2
0008b0 c86e          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
0008b1 ff02          .dw $ff02
0008b2 2d64          .db "d-"
0008b3 08a0          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
0008b4 08b5          .dw PFA_DMINUS
                 PFA_DMINUS:
0008b5 9129          ld temp2, Y+
0008b6 9139          ld temp3, Y+
                 
0008b7 90e9          ld temp4, Y+
0008b8 90f9          ld temp5, Y+
0008b9 9149          ld temp6, Y+
0008ba 9159          ld temp7, Y+
                 
0008bb 1b42          sub temp6, temp2
0008bc 0b53          sbc temp7, temp3
0008bd 0ae8          sbc temp4, tosl
0008be 0af9          sbc temp5, tosh
                 
0008bf 935a          st -Y, temp7
0008c0 934a          st -Y, temp6
0008c1 01c7          movw tosl, temp4
0008c2 c85c          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
0008c3 ff07          .dw $ff07
0008c4 6964
0008c5 766e
0008c6 7265
0008c7 0074          .db "dinvert",0
0008c8 08b1          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
0008c9 08ca          .dw PFA_DINVERT
                 PFA_DINVERT:
0008ca 9109          ld temp0, Y+
0008cb 9119          ld temp1, Y+
0008cc 9580          com tosl
0008cd 9590          com tosh
0008ce 9500          com temp0
0008cf 9510          com temp1
0008d0 931a          st -Y, temp1
0008d1 930a          st -Y, temp0
0008d2 c84c          jmp_ DO_NEXT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
0008d3 ff02          .dw $ff02
0008d4 2e75          .db "u."
0008d5 08c3          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
0008d6 011b          .dw DO_COLON
                 PFA_UDOT:
                 .endif
0008d7 0601          .dw XT_ZERO
0008d8 0b84          .dw XT_UDDOT
0008d9 04c2          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
0008da ff03          .dw $ff03
0008db 2e75
0008dc 0072          .db "u.r",0
0008dd 08d3          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
0008de 011b          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
0008df 0601          .dw XT_ZERO
0008e0 0571          .dw XT_SWAP
0008e1 0b8d          .dw XT_UDDOTR
0008e2 04c2          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
0008e3 ff0d          .dw $ff0d
0008e4 6873
0008e5 776f
0008e6 772d
0008e7 726f
0008e8 6c64
0008e9 7369
0008ea 0074          .db "show-wordlist",0
0008eb 08da          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
0008ec 011b          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
0008ed 04e2          .dw XT_DOLITERAL
0008ee 08f2          .dw XT_SHOWWORD
0008ef 0571          .dw XT_SWAP
0008f0 10cc          .dw XT_TRAVERSEWORDLIST
0008f1 04c2          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
0008f2 011b          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
0008f3 10e7          .dw XT_NAME2STRING
0008f4 0bfa          .dw XT_ITYPE
0008f5 0c3c          .dw XT_SPACE         ; ( -- addr n)
0008f6 05f8          .dw XT_TRUE
0008f7 04c2          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_WORDS:
0008f8 ff05          .dw $ff05
0008f9 6f77
0008fa 6472
0008fb 0073          .db "words",0
0008fc 08e3          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
0008fd 011b          .dw DO_COLON
                 PFA_WORDS:
                 .endif
0008fe 04e2          .dw XT_DOLITERAL
0008ff 008a          .dw CFG_ORDERLISTLEN+2
000900 0802          .dw XT_FETCHE
000901 08ec          .dw XT_SHOWWORDLIST
000902 04c2          .dw XT_EXIT
                 
                 
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
000903 ff04          .dw $ff04
000904 6970
000905 6b63          .db "pick"
000906 08f8          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
000907 011b          .dw DO_COLON
                 PFA_PICK:
                 .endif
000908 06dc          .dw XT_1PLUS
000909 09b0          .dw XT_CELLS
00090a 073a          .dw XT_SP_FETCH
00090b 064a          .dw XT_PLUS
00090c 0526          .dw XT_FETCH
00090d 04c2          .dw XT_EXIT
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
00090e 0002          .dw $0002
00090f 222e          .db ".",$22
000910 0903          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
000911 011b          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
000912 0919          .dw XT_SQUOTE
000913 01e9          .dw XT_COMPILE
000914 0bfa          .dw XT_ITYPE
000915 04c2          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
000916 0002        .dw $0002
000917 2273        .db "s",$22
000918 090e        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
000919 011b          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
00091a 04e2          .dw XT_DOLITERAL
00091b 0022          .dw 34   ; 0x22 
00091c 0deb          .dw XT_PARSE       ; ( -- addr n)
00091d 09a3          .dw XT_STATE
00091e 0526          .dw XT_FETCH
00091f 04db          .dw XT_DOCONDBRANCH
000920 0922          DEST(PFA_SQUOTE1)
000921 0215            .dw XT_SLITERAL
                 PFA_SQUOTE1:
000922 04c2          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
000923 ff04          .dw $ff04
000924 6966
000925 6c6c          .db "fill"
000926 0916          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
000927 011b          .dw DO_COLON
                 PFA_FILL:
000928 058e          .dw XT_ROT
000929 058e          .dw XT_ROT
00092a 0566
00092b 04db          .dw XT_QDUP,XT_DOCONDBRANCH
00092c 0934          DEST(PFA_FILL2)
00092d 11d3          .dw XT_BOUNDS
00092e 0748          .dw XT_DODO
                 PFA_FILL1:
00092f 055e          .dw XT_DUP
000930 0759          .dw XT_I
000931 053a          .dw XT_CSTORE  ; ( -- c c-addr)
000932 0776          .dw XT_DOLOOP
000933 092f          .dw PFA_FILL1
                 PFA_FILL2:
000934 0586          .dw XT_DROP
000935 04c2          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
000936 ff0b          .dw $ff0b
000937 6e65
000938 6976
000939 6f72
00093a 6d6e
00093b 6e65
00093c 0074          .db "environment",0
00093d 0923          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
00093e 04f0          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
00093f 0082          .dw CFG_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
000940 ff09          .dw $ff09
000941 6f77
000942 6472
000943 696c
000944 7473
000945 0073          .db "wordlists",0
000946 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
000947 011b          .dw DO_COLON
                 PFA_ENVWORDLISTS:
000948 04e2          .dw XT_DOLITERAL
000949 0008          .dw NUMWORDLISTS
00094a 04c2          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
00094b ff04          .dw $ff04
00094c 702f
00094d 6461          .db "/pad"
00094e 0940          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
00094f 011b          .dw DO_COLON
                 PFA_ENVSLASHPAD:
000950 073a          .dw XT_SP_FETCH
000951 09dd          .dw XT_PAD
000952 0640          .dw XT_MINUS
000953 04c2          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENVSLASHHOLD:
000954 ff05          .dw $ff05
000955 682f
000956 6c6f
000957 0064          .db "/hold",0
000958 094b          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
000959 011b          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
                 .endif
00095a 09dd          .dw XT_PAD
00095b 0a18          .dw XT_HERE
00095c 0640          .dw XT_MINUS
00095d 04c2          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
00095e ff0a          .dw $ff0a
00095f 6f66
000960 7472
000961 2d68
000962 616e
000963 656d          .db "forth-name"
000964 0954          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
000965 011b          .dw DO_COLON
                 PFA_EN_FORTHNAME:
000966 0bc7          .dw XT_DOSLITERAL
000967 0007          .dw 7
                 .endif
000968 6d61
000969 6f66
00096a 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
00096b 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
00096c 04c2          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
00096d ff07          .dw $ff07
00096e 6576
00096f 7372
000970 6f69
000971 006e          .db "version",0
000972 095e          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
000973 011b          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
000974 04e2          .dw XT_DOLITERAL
000975 0045          .dw 69
000976 04c2          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
000977 ff03          .dw $ff03
000978 7063
000979 0075          .db "cpu",0
00097a 096d          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
00097b 011b          .dw DO_COLON
                 PFA_EN_CPU:
                 .endif
00097c 04e2          .dw XT_DOLITERAL
00097d 0075          .dw mcu_name
00097e 0c26          .dw XT_ICOUNT
00097f 04c2          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
000980 ff08          .dw $ff08
000981 636d
000982 2d75
000983 6e69
000984 6f66          .db "mcu-info"
000985 0977          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
000986 011b          .dw DO_COLON
                 PFA_EN_MCUINFO:
000987 04e2          .dw XT_DOLITERAL
000988 0071          .dw mcu_info
000989 04c2          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_ENVUSERSIZE:
00098a ff05          .dw $ff05
00098b 752f
00098c 6573
00098d 0072          .db "/user",0
00098e 0980          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
00098f 011b          .dw DO_COLON
                 PFA_ENVUSERSIZE:
                 .endif
000990 04e2          .dw XT_DOLITERAL
000991 002e          .dw SYSUSERSIZE + APPUSERSIZE
000992 04c2          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
000993 ff05          .dw $ff05
000994 5f66
000995 7063
000996 0075          .db "f_cpu",0
000997 0936          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
000998 011b          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
000999 04e2          .dw XT_DOLITERAL
00099a 0000          .dw (F_CPU % 65536)
00099b 04e2          .dw XT_DOLITERAL
00099c 00e1          .dw (F_CPU / 65536)
00099d 04c2          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
00099e ff05          .dw $ff05
00099f 7473
0009a0 7461
0009a1 0065          .db "state",0
0009a2 0993          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
0009a3 04f0          .dw PFA_DOVARIABLE
                 PFA_STATE:
0009a4 0253          .dw ram_state
                 
                 .dseg
000253           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
0009a5 ff04          .dw $ff04
0009a6 6162
0009a7 6573          .db "base"
0009a8 099e          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
0009a9 0503          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
0009aa 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
0009ab ff05          .dw $ff05
0009ac 6563
0009ad 6c6c
0009ae 0073          .db "cells",0
0009af 09a5          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
0009b0 06b9          .dw PFA_2STAR
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
0009b1 ff05          .dw $ff05
0009b2 6563
0009b3 6c6c
0009b4 002b          .db "cell+",0
0009b5 09ab          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
0009b6 09b7          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
0009b7 9602          adiw tosl, CELLSIZE
0009b8 940c 011f     jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
0009ba ff04          .dw $ff04
0009bb 6432
0009bc 7075          .db "2dup"
0009bd 09b1          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
0009be 011b          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
0009bf 057c          .dw XT_OVER
0009c0 057c          .dw XT_OVER
0009c1 04c2          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
0009c2 ff05          .dw $ff05
0009c3 6432
0009c4 6f72
0009c5 0070          .db "2drop",0
0009c6 09ba          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
0009c7 011b          .dw DO_COLON
                 PFA_2DROP:
                 .endif
0009c8 0586          .dw XT_DROP
0009c9 0586          .dw XT_DROP
0009ca 04c2          .dw XT_EXIT
                 
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
0009cb ff04          .dw $ff04
0009cc 7574
0009cd 6b63          .db "tuck"
0009ce 09c2          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
0009cf 011b          .dw DO_COLON
                 PFA_TUCK:
                 .endif
0009d0 0571          .dw XT_SWAP
0009d1 057c          .dw XT_OVER
0009d2 04c2          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
0009d3 ff03          .dw $ff03
0009d4 693e
0009d5 006e          .db ">in",0
0009d6 09cb          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
0009d7 0503          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
0009d8 0018          .dw USER_TO_IN
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PAD:
0009d9 ff03          .dw $ff03
0009da 6170
0009db 0064          .db "pad",0
0009dc 09d3          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
0009dd 011b          .dw DO_COLON
                 PFA_PAD:
                 .endif
0009de 0a18          .dw XT_HERE
0009df 04e2          .dw XT_DOLITERAL
0009e0 0028          .dw 40
0009e1 064a          .dw XT_PLUS
0009e2 04c2          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMIT:
0009e3 ff04          .dw $ff04
0009e4 6d65
0009e5 7469          .db "emit"
0009e6 09d9          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
0009e7 1088          .dw PFA_DODEFER1
                 PFA_EMIT:
                 .endif
0009e8 000e          .dw USER_EMIT
0009e9 1051          .dw XT_UDEFERFETCH
0009ea 105d          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMITQ:
0009eb ff05          .dw $ff05
0009ec 6d65
0009ed 7469
0009ee 003f          .db "emit?",0
0009ef 09e3          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
0009f0 1088          .dw PFA_DODEFER1
                 PFA_EMITQ:
                 .endif
0009f1 0010          .dw USER_EMITQ
0009f2 1051          .dw XT_UDEFERFETCH
0009f3 105d          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEY:
0009f4 ff03          .dw $ff03
0009f5 656b
0009f6 0079          .db "key",0
0009f7 09eb          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
0009f8 1088          .dw PFA_DODEFER1
                 PFA_KEY:
                 .endif
0009f9 0012          .dw USER_KEY
0009fa 1051          .dw XT_UDEFERFETCH
0009fb 105d          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEYQ:
0009fc ff04          .dw $ff04
0009fd 656b
0009fe 3f79          .db "key?"
0009ff 09f4          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
000a00 1088          .dw PFA_DODEFER1
                 PFA_KEYQ:
                 .endif
000a01 0014          .dw USER_KEYQ
000a02 1051          .dw XT_UDEFERFETCH
000a03 105d          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
000a04 ff02          .dw $ff02
000a05 7064          .db "dp"
000a06 09fc          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
000a07 051d          .dw PFA_DOVALUE1
                 PFA_DP:
000a08 0074          .dw CFG_DP
000a09 1029          .dw XT_EDEFERFETCH
000a0a 1033          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
000a0b ff05          .dw $ff05
000a0c 6865
000a0d 7265
000a0e 0065          .db "ehere",0
000a0f 0a04          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
000a10 051d          .dw PFA_DOVALUE1
                 PFA_EHERE:
000a11 0078          .dw EE_EHERE
000a12 1029          .dw XT_EDEFERFETCH
000a13 1033          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
000a14 ff04          .dw $ff04
000a15 6568
000a16 6572          .db "here"
000a17 0a0b          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
000a18 051d          .dw PFA_DOVALUE1
                 PFA_HERE:
000a19 0076          .dw EE_HERE
000a1a 1029          .dw XT_EDEFERFETCH
000a1b 1033          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
000a1c ff05          .dw $ff05
000a1d 6c61
000a1e 6f6c
000a1f 0074          .db "allot",0
000a20 0a14          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
000a21 011b          .dw DO_COLON
                 PFA_ALLOT:
000a22 0a18          .dw XT_HERE
000a23 064a          .dw XT_PLUS
000a24 100e          .dw XT_DOTO
000a25 0a19          .dw PFA_HERE
000a26 04c2          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
000a27 ff03          .dw $ff03
000a28 6962
000a29 006e          .db "bin",0
000a2a 0a1c          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
000a2b 011b          .dw DO_COLON
                 PFA_BIN:
                 .endif
000a2c 0859          .dw XT_TWO
000a2d 09a9          .dw XT_BASE
000a2e 052e          .dw XT_STORE
000a2f 04c2          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
000a30 ff07          .dw $ff07
000a31 6564
000a32 6963
000a33 616d
000a34 006c          .db "decimal",0
000a35 0a27          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
000a36 011b          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
000a37 04e2          .dw XT_DOLITERAL
000a38 000a          .dw 10
000a39 09a9          .dw XT_BASE
000a3a 052e          .dw XT_STORE
000a3b 04c2          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
000a3c ff03          .dw $ff03
000a3d 6568
000a3e 0078          .db "hex",0
000a3f 0a30          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
000a40 011b          .dw DO_COLON
                 PFA_HEX:
                 .endif
000a41 04e2          .dw XT_DOLITERAL
000a42 0010          .dw 16
000a43 09a9          .dw XT_BASE
000a44 052e          .dw XT_STORE
000a45 04c2          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
000a46 ff02          .dw $ff02
000a47 6c62          .db "bl"
000a48 0a3c          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
000a49 04f0          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
000a4a 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
000a4b ff07          .dw $ff07
000a4c 7574
000a4d 6e72
000a4e 656b
000a4f 0079          .db "turnkey",0
000a50 0a46          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
000a51 1088          .dw PFA_DODEFER1
                 PFA_TURNKEY:
000a52 0080          .dw CFG_TURNKEY
000a53 1029          .dw XT_EDEFERFETCH
000a54 1033          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
000a55 ff04          .dw $ff04
000a56 6d2f
000a57 646f          .db "/mod"
000a58 0a4b          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
000a59 0a5a          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
000a5a 019c          movw temp2, tosl
                     
000a5b 9109          ld temp0, Y+
000a5c 9119          ld temp1, Y+
                 
000a5d 2f41          mov	temp6,temp1	;move dividend High to sign register
000a5e 2743          eor	temp6,temp3	;xor divisor High with sign register
000a5f ff17          sbrs	temp1,7	;if MSB in dividend set
000a60 c004          rjmp	PFA_SLASHMOD_1
000a61 9510          com	temp1		;    change sign of dividend
000a62 9500          com	temp0		
000a63 5f0f          subi	temp0,low(-1)
000a64 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
000a65 ff37          sbrs	temp3,7	;if MSB in divisor set
000a66 c004          rjmp	PFA_SLASHMOD_2
000a67 9530          com	temp3		;    change sign of divisor
000a68 9520          com	temp2		
000a69 5f2f          subi	temp2,low(-1)
000a6a 4f3f          sbci	temp3,high(-1)
000a6b 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
000a6c 18ff          sub	temp5,temp5;clear remainder High byte and carry
000a6d e151          ldi	temp7,17	;init loop counter
                 
000a6e 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
000a6f 1f11          rol	temp1
000a70 955a          dec	temp7		;decrement counter
000a71 f439          brne	PFA_SLASHMOD_5		;if done
000a72 ff47          sbrs	temp6,7		;    if MSB in sign register set
000a73 c004          rjmp	PFA_SLASHMOD_4
000a74 9510          com	temp1	;        change sign of result
000a75 9500          com	temp0
000a76 5f0f          subi	temp0,low(-1)
000a77 4f1f          sbci	temp1,high(-1)
000a78 c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
000a79 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
000a7a 1cff          rol	temp5
000a7b 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
000a7c 0af3          sbc	temp5,temp3	;
000a7d f420          brcc	PFA_SLASHMOD_6		;if result negative
000a7e 0ee2          add	temp4,temp2	;    restore remainder
000a7f 1ef3          adc	temp5,temp3
000a80 9488          clc			;    clear carry to be shifted into result
000a81 cfec          rjmp	PFA_SLASHMOD_3		;else
000a82 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
000a83 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
000a84 92fa          st -Y,temp5
000a85 92ea          st -Y,temp4
                 
                     ; put quotient on stack
000a86 01c8          movw tosl, temp0
000a87 940c 011f     jmp_ DO_NEXT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
000a89 ff05          .dw $ff05
000a8a 2f75
000a8b 6f6d
000a8c 0064          .db "u/mod",0
000a8d 0a55          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
000a8e 011b          .dw DO_COLON
                 PFA_USLASHMOD:
000a8f 05ac          .dw XT_TO_R
000a90 0601          .dw XT_ZERO
000a91 05a3          .dw XT_R_FROM
000a92 066f          .dw XT_UMSLASHMOD
000a93 04c2          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
000a94 ff06          .dw $ff06
000a95 656e
000a96 6167
000a97 6574          .db "negate"
000a98 0a89          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
000a99 011b          .dw DO_COLON
                 PFA_NEGATE:
000a9a 06aa          .dw XT_INVERT
000a9b 06dc          .dw XT_1PLUS
000a9c 04c2          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
000a9d ff01          .dw $ff01
000a9e 002f          .db "/",0
000a9f 0a94          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
000aa0 011b          .dw DO_COLON
                 PFA_SLASH:
                 .endif
000aa1 0a59          .dw XT_SLASHMOD
000aa2 059d          .dw XT_NIP
000aa3 04c2          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
000aa4 ff03          .dw $ff03
000aa5 6f6d
000aa6 0064          .db "mod",0
000aa7 0a9d          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
000aa8 011b          .dw DO_COLON
                 PFA_MOD:
                 .endif
000aa9 0a59          .dw XT_SLASHMOD
000aaa 0586          .dw XT_DROP
000aab 04c2          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ;   DUP ?NEGATE ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABS:
000aac ff03          .dw $ff03
000aad 6261
000aae 0073          .db "abs",0
000aaf 0aa4          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
000ab0 011b          .dw DO_COLON
                 PFA_ABS:
                 
                 .endif
                 
000ab1 055e
000ab2 06eb
000ab3 04c2          .DW XT_DUP,XT_QNEGATE,XT_EXIT
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
000ab4 ff03          .dw $ff03
000ab5 696d
000ab6 006e          .db "min",0
000ab7 0aac          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
000ab8 011b          .dw DO_COLON
                 PFA_MIN:
                 .endif
000ab9 09be          .dw XT_2DUP
000aba 0625          .dw XT_GREATER
000abb 04db          .dw XT_DOCONDBRANCH
000abc 0abe          DEST(PFA_MIN1)
000abd 0571          .dw XT_SWAP
                 PFA_MIN1:
000abe 0586          .dw XT_DROP
000abf 04c2          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
000ac0 ff03          .dw $ff03
000ac1 616d
000ac2 0078          .db "max",0
000ac3 0ab4          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
000ac4 011b          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
000ac5 09be          .dw XT_2DUP
000ac6 061b          .dw XT_LESS
000ac7 04db          .dw XT_DOCONDBRANCH
000ac8 0aca          DEST(PFA_MAX1)
000ac9 0571          .dw XT_SWAP
                 PFA_MAX1:
000aca 0586          .dw XT_DROP
000acb 04c2          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
000acc ff06          .dw $ff06
000acd 6977
000ace 6874
000acf 6e69          .db "within"
000ad0 0ac0          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
000ad1 011b          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
000ad2 057c          .dw XT_OVER
000ad3 0640          .dw XT_MINUS
000ad4 05ac          .dw XT_TO_R
000ad5 0640          .dw XT_MINUS
000ad6 05a3          .dw XT_R_FROM
000ad7 0609          .dw XT_ULESS
000ad8 04c2          .dw XT_EXIT
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
000ad9 ff07          .dw $ff07 
000ada 6f74
000adb 7075
000adc 6570
000add 0072          .db "toupper",0
000ade 0acc          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
000adf 011b          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
000ae0 055e          .dw XT_DUP 
000ae1 04e2          .dw XT_DOLITERAL 
000ae2 0061          .dw 'a' 
000ae3 04e2          .dw XT_DOLITERAL 
000ae4 007b          .dw 'z'+1
000ae5 0ad1          .dw XT_WITHIN 
000ae6 04db          .dw XT_DOCONDBRANCH
000ae7 0aeb          DEST(PFA_TOUPPER0)
000ae8 04e2          .dw XT_DOLITERAL
000ae9 00df          .dw 223 ; inverse of 0x20: 0xdf
000aea 06c0          .dw XT_AND 
                 PFA_TOUPPER0:
000aeb 04c2          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
000aec ff07          .dw $ff07
000aed 6f74
000aee 6f6c
000aef 6577
000af0 0072          .db "tolower",0
000af1 0ad9          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
000af2 011b          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
000af3 055e          .dw XT_DUP
000af4 04e2          .dw XT_DOLITERAL
000af5 0041          .dw 'A'
000af6 04e2          .dw XT_DOLITERAL
000af7 005b          .dw 'Z'+1
000af8 0ad1          .dw XT_WITHIN
000af9 04db          .dw XT_DOCONDBRANCH
000afa 0afe          DEST(PFA_TOLOWER0)
000afb 04e2          .dw XT_DOLITERAL
000afc 0020          .dw 32
000afd 06c9          .dw XT_OR 
                 PFA_TOLOWER0:
000afe 04c2          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
000aff ff03          .dw $ff03
000b00 6c68
000b01 0064          .db "hld",0
000b02 0aec          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
000b03 04f0          .dw PFA_DOVARIABLE
                 PFA_HLD:
000b04 0255          .dw ram_hld
                 
                 .dseg
000255           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
000b05 ff04          .dw $ff04
000b06 6f68
000b07 646c          .db "hold"
000b08 0aff          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
000b09 011b          .dw DO_COLON
                 PFA_HOLD:
                 .endif
000b0a 0b03          .dw XT_HLD
000b0b 055e          .dw XT_DUP
000b0c 0526          .dw XT_FETCH
000b0d 06e2          .dw XT_1MINUS
000b0e 055e          .dw XT_DUP
000b0f 05ac          .dw XT_TO_R
000b10 0571          .dw XT_SWAP
000b11 052e          .dw XT_STORE
000b12 05a3          .dw XT_R_FROM
000b13 053a          .dw XT_CSTORE
000b14 04c2          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
000b15 ff02          .dw $ff02
000b16 233c          .db "<#"
000b17 0b05          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
000b18 011b          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
000b19 09dd          .dw XT_PAD
000b1a 0b03          .dw XT_HLD
000b1b 052e          .dw XT_STORE
000b1c 04c2          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
000b1d ff01          .dw $ff01
000b1e 0023          .db "#",0
000b1f 0b15          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
000b20 011b          .dw DO_COLON
                 PFA_SHARP:
                 .endif
000b21 09a9          .dw XT_BASE
000b22 0526          .dw XT_FETCH
000b23 0b9d          .dw XT_UDSLASHMOD
000b24 058e          .dw XT_ROT
000b25 04e2          .dw XT_DOLITERAL
000b26 0009          .dw 9
000b27 057c          .dw XT_OVER
000b28 061b          .dw XT_LESS
000b29 04db          .dw XT_DOCONDBRANCH
000b2a 0b2e          DEST(PFA_SHARP1)
000b2b 04e2          .dw XT_DOLITERAL
000b2c 0007          .dw 7
000b2d 064a          .dw XT_PLUS
                 PFA_SHARP1:
000b2e 04e2          .dw XT_DOLITERAL
000b2f 0030          .dw 48 ; ASCII 0
000b30 064a          .dw XT_PLUS
000b31 0b09          .dw XT_HOLD
000b32 04c2          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
000b33 ff02          .dw $ff02
000b34 7323          .db "#s"
000b35 0b1d          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
000b36 011b          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
000b37 0b20          .dw XT_SHARP
000b38 09be          .dw XT_2DUP
000b39 06c9          .dw XT_OR
000b3a 05c5          .dw XT_ZEROEQUAL
000b3b 04db          .dw XT_DOCONDBRANCH
000b3c 0b37          DEST(NUMS1) ; PFA_SHARP_S
000b3d 04c2          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
000b3e ff02          .dw $ff02
000b3f 3e23          .db "#>"
000b40 0b33          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
000b41 011b          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
000b42 09c7          .dw XT_2DROP
000b43 0b03          .dw XT_HLD
000b44 0526          .dw XT_FETCH
000b45 09dd          .dw XT_PAD
000b46 057c          .dw XT_OVER
000b47 0640          .dw XT_MINUS
000b48 04c2          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
000b49 ff04          .dw $ff04
000b4a 6973
000b4b 6e67          .db "sign"
000b4c 0b3e          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
000b4d 011b          .dw DO_COLON
                 PFA_SIGN:
                 .endif
000b4e 05cc          .dw XT_ZEROLESS
000b4f 04db          .dw XT_DOCONDBRANCH
000b50 0b54          DEST(PFA_SIGN1)
000b51 04e2          .dw XT_DOLITERAL
000b52 002d          .dw 45 ; ascii -
000b53 0b09          .dw XT_HOLD
                 PFA_SIGN1:
000b54 04c2          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
000b55 ff03          .dw $ff03
000b56 2e64
000b57 0072          .db "d.r",0
000b58 0b49          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
000b59 011b          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
000b5a 05ac          .dw XT_TO_R
000b5b 09cf          .dw XT_TUCK
000b5c 1149          .dw XT_DABS
000b5d 0b18          .dw XT_L_SHARP
000b5e 0b36          .dw XT_SHARP_S
000b5f 058e          .dw XT_ROT
000b60 0b4d          .dw XT_SIGN
000b61 0b41          .dw XT_SHARP_G
000b62 05a3          .dw XT_R_FROM
000b63 057c          .dw XT_OVER
000b64 0640          .dw XT_MINUS
000b65 0c45          .dw XT_SPACES
000b66 0c55          .dw XT_TYPE
000b67 04c2          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
000b68 ff02          .dw $ff02
000b69 722e          .db ".r"
000b6a 0b55          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
000b6b 011b          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
000b6c 05ac          .dw XT_TO_R
000b6d 11dc          .dw XT_S2D
000b6e 05a3          .dw XT_R_FROM
000b6f 0b59          .dw XT_DDOTR
000b70 04c2          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
000b71 ff02          .dw $ff02
000b72 2e64          .db "d."
000b73 0b68          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
000b74 011b          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
000b75 0601          .dw XT_ZERO
000b76 0b59          .dw XT_DDOTR
000b77 0c3c          .dw XT_SPACE
000b78 04c2          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
000b79 ff01          .dw $ff01
000b7a 002e          .db ".",0
000b7b 0b71          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
000b7c 011b          .dw DO_COLON
                 PFA_DOT:
                 .endif
000b7d 11dc          .dw XT_S2D
000b7e 0b74          .dw XT_DDOT
000b7f 04c2          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
000b80 ff03          .dw $ff03
000b81 6475
000b82 002e          .db "ud.",0
000b83 0b79          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
000b84 011b          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
000b85 0601          .dw XT_ZERO
000b86 0b8d          .dw XT_UDDOTR
000b87 0c3c          .dw XT_SPACE
000b88 04c2          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
000b89 ff04          .dw $ff04
000b8a 6475
000b8b 722e          .db "ud.r"
000b8c 0b80          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
000b8d 011b          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
000b8e 05ac          .dw XT_TO_R
000b8f 0b18          .dw XT_L_SHARP
000b90 0b36          .dw XT_SHARP_S
000b91 0b41          .dw XT_SHARP_G
000b92 05a3          .dw XT_R_FROM
000b93 057c          .dw XT_OVER
000b94 0640          .dw XT_MINUS
000b95 0c45          .dw XT_SPACES
000b96 0c55          .dw XT_TYPE
000b97 04c2          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
000b98 ff06          .dw $ff06
000b99 6475
000b9a 6d2f
000b9b 646f          .db "ud/mod"
000b9c 0b89          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
000b9d 011b          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
000b9e 05ac          .dw XT_TO_R
000b9f 0601          .dw XT_ZERO
000ba0 05b3          .dw XT_R_FETCH
000ba1 066f          .dw XT_UMSLASHMOD
000ba2 05a3          .dw XT_R_FROM
000ba3 0571          .dw XT_SWAP
000ba4 05ac          .dw XT_TO_R
000ba5 066f          .dw XT_UMSLASHMOD
000ba6 05a3          .dw XT_R_FROM
000ba7 04c2          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
000ba8 ff06          .dw $ff06 
000ba9 6964
000baa 6967
000bab 3f74          .db "digit?"
000bac 0b98          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
000bad 011b          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
000bae 0adf          .dw XT_TOUPPER
000baf 055e
000bb0 04e2
000bb1 0039
000bb2 0625
000bb3 04e2
000bb4 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
000bb5 06c0
000bb6 064a
000bb7 055e
000bb8 04e2
000bb9 0140
000bba 0625          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
000bbb 04e2
000bbc 0107
000bbd 06c0
000bbe 0640
000bbf 04e2
000bc0 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
000bc1 0640
000bc2 055e
000bc3 09a9
000bc4 0526
000bc5 0609          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
000bc6 04c2          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
000bc7 011b        .dw DO_COLON
                 PFA_DOSLITERAL:
000bc8 05b3        .dw XT_R_FETCH   ; ( -- addr )
000bc9 0c26        .dw XT_ICOUNT
000bca 05a3        .dw XT_R_FROM
000bcb 057c        .dw XT_OVER     ; ( -- addr' n addr n)
000bcc 06dc        .dw XT_1PLUS
000bcd 06b1        .dw XT_2SLASH   ; ( -- addr' n addr k )
000bce 064a        .dw XT_PLUS     ; ( -- addr' n addr'' )
000bcf 06dc        .dw XT_1PLUS
000bd0 05ac        .dw XT_TO_R     ; ( -- )
000bd1 04c2        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
000bd2 ff02        .dw $ff02
000bd3 2c73        .db "s",$2c
000bd4 0ba8        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
000bd5 011b          .dw DO_COLON
                 PFA_SCOMMA:
000bd6 055e          .dw XT_DUP
000bd7 0bd9          .dw XT_DOSCOMMA
000bd8 04c2          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
000bd9 011b          .dw DO_COLON
                 PFA_DOSCOMMA:
000bda 01f4          .dw XT_COMMA
000bdb 055e          .dw XT_DUP   ; ( --addr len len)
000bdc 06b1          .dw XT_2SLASH ; ( -- addr len len/2
000bdd 09cf          .dw XT_TUCK   ; ( -- addr len/2 len len/2
000bde 06b8          .dw XT_2STAR  ; ( -- addr len/2 len len'
000bdf 0640          .dw XT_MINUS  ; ( -- addr len/2 rem
000be0 05ac          .dw XT_TO_R
000be1 0601          .dw XT_ZERO
000be2 02b3          .dw XT_QDOCHECK
000be3 04db          .dw XT_DOCONDBRANCH
000be4 0bec          .dw PFA_SCOMMA2
000be5 0748          .dw XT_DODO
                 PFA_SCOMMA1:
000be6 055e          .dw XT_DUP         ; ( -- addr addr )
000be7 0526          .dw XT_FETCH       ; ( -- addr c1c2 )
000be8 01f4          .dw XT_COMMA       ; ( -- addr )
000be9 09b6          .dw XT_CELLPLUS    ; ( -- addr+cell )
000bea 0776          .dw XT_DOLOOP
000beb 0be6          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
000bec 05a3          .dw XT_R_FROM
000bed 05d3          .dw XT_GREATERZERO
000bee 04db          .dw XT_DOCONDBRANCH
000bef 0bf3          .dw PFA_SCOMMA3
000bf0 055e            .dw XT_DUP     ; well, tricky
000bf1 0545            .dw XT_CFETCH
000bf2 01f4            .dw XT_COMMA
                 PFA_SCOMMA3:
000bf3 0586          .dw XT_DROP        ; ( -- )
000bf4 04c2          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
000bf5 ff05          .dw $ff05
000bf6 7469
000bf7 7079
000bf8 0065          .db "itype",0
000bf9 0bd2          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
000bfa 011b          .dw DO_COLON
                 PFA_ITYPE:
000bfb 055e          .dw XT_DUP    ; ( --addr len len)
000bfc 06b1          .dw XT_2SLASH ; ( -- addr len len/2
000bfd 09cf          .dw XT_TUCK   ; ( -- addr len/2 len len/2
000bfe 06b8          .dw XT_2STAR  ; ( -- addr len/2 len len'
000bff 0640          .dw XT_MINUS  ; ( -- addr len/2 rem
000c00 05ac          .dw XT_TO_R
000c01 0601          .dw XT_ZERO
000c02 02b3          .dw XT_QDOCHECK
000c03 04db          .dw XT_DOCONDBRANCH
000c04 0c0e          .dw PFA_ITYPE2
000c05 0748          .dw XT_DODO
                 PFA_ITYPE1:
000c06 055e          .dw XT_DUP         ; ( -- addr addr )
000c07 0835          .dw XT_FETCHI      ; ( -- addr c1c2 )
000c08 055e          .dw XT_DUP
000c09 0c1b          .dw XT_LOWEMIT
000c0a 0c17          .dw XT_HIEMIT
000c0b 06dc          .dw XT_1PLUS    ; ( -- addr+cell )
000c0c 0776          .dw XT_DOLOOP
000c0d 0c06          .dw PFA_ITYPE1
                 PFA_ITYPE2:
000c0e 05a3          .dw XT_R_FROM
000c0f 05d3          .dw XT_GREATERZERO
000c10 04db          .dw XT_DOCONDBRANCH
000c11 0c15          .dw PFA_ITYPE3
000c12 055e            .dw XT_DUP     ; make sure the drop below has always something to do
000c13 0835            .dw XT_FETCHI
000c14 0c1b            .dw XT_LOWEMIT
                 PFA_ITYPE3:
000c15 0586          .dw XT_DROP
000c16 04c2          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
000c17 011b          .dw DO_COLON
                 PFA_HIEMIT:
000c18 07a6          .dw XT_BYTESWAP
000c19 0c1b          .dw XT_LOWEMIT
000c1a 04c2          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
000c1b 011b          .dw DO_COLON
                 PFA_LOWEMIT:
000c1c 04e2          .dw XT_DOLITERAL
000c1d 00ff          .dw $00ff
000c1e 06c0          .dw XT_AND
000c1f 09e7          .dw XT_EMIT
000c20 04c2          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
000c21 ff06          .dw $ff06
000c22 6369
000c23 756f
000c24 746e          .db "icount"
000c25 0bf5          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
000c26 011b          .dw DO_COLON
                 PFA_ICOUNT:
000c27 055e          .dw XT_DUP
000c28 06dc          .dw XT_1PLUS
000c29 0571          .dw XT_SWAP
000c2a 0835          .dw XT_FETCHI
000c2b 04c2          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
000c2c ff02          .dw 0xff02
000c2d 7263          .db "cr"
000c2e 0c21          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
000c2f 011b          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
000c30 04e2          .dw XT_DOLITERAL
000c31 000d          .dw 13
000c32 09e7          .dw XT_EMIT
000c33 04e2          .dw XT_DOLITERAL
000c34 000a          .dw 10
000c35 09e7          .dw XT_EMIT
000c36 04c2          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
000c37 ff05          .dw $ff05
000c38 7073
000c39 6361
000c3a 0065          .db "space",0
000c3b 0c2c          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
000c3c 011b          .dw DO_COLON
                 PFA_SPACE:
                 .endif
000c3d 0a49          .dw XT_BL
000c3e 09e7          .dw XT_EMIT
000c3f 04c2          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
000c40 ff06          .dw $ff06
000c41 7073
000c42 6361
000c43 7365          .db "spaces"
000c44 0c37          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
000c45 011b          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
000c46 0601
000c47 0ac4      	.DW XT_ZERO, XT_MAX
000c48 055e
000c49 04db      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
000c4a 0c4f              DEST(SPCS2)
000c4b 0c3c
000c4c 06e2
000c4d 04d1              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
000c4e 0c48              DEST(SPCS1)
000c4f 0586
000c50 04c2      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
000c51 ff04          .dw $ff04
000c52 7974
000c53 6570          .db "type"
000c54 0c40          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
000c55 011b          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
000c56 11d3          .dw XT_BOUNDS
000c57 02b3          .dw XT_QDOCHECK
000c58 04db          .dw XT_DOCONDBRANCH
000c59 0c60          DEST(PFA_TYPE2)
000c5a 0748          .dw XT_DODO
                 PFA_TYPE1:
000c5b 0759          .dw XT_I
000c5c 0545          .dw XT_CFETCH
000c5d 09e7          .dw XT_EMIT
000c5e 0776          .dw XT_DOLOOP
000c5f 0c5b          DEST(PFA_TYPE1)
                 PFA_TYPE2:
000c60 04c2          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
000c61 ff01          .dw $ff01
000c62 0027          .db "'",0
000c63 0c51          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
000c64 011b          .dw DO_COLON
                 PFA_TICK:
                 .endif
000c65 0e18          .dw XT_PARSENAME
000c66 0f38          .dw XT_FORTHRECOGNIZER
000c67 0f43          .dw XT_RECOGNIZE
                     ; a word is tickable unless RECTYPE-TOKEN is RECTYPE-NULL or 
                     ; the interpret action is a NOOP
000c68 055e          .dw XT_DUP
000c69 0fbf          .dw XT_RECTYPE_NULL
000c6a 084d          .dw XT_EQUAL
000c6b 0571          .dw XT_SWAP
000c6c 0835          .dw XT_FETCHI
000c6d 04e2          .dw XT_DOLITERAL
000c6e 0ff4          .dw XT_NOOP
000c6f 084d          .dw XT_EQUAL
000c70 06c9          .dw XT_OR
000c71 04db          .dw XT_DOCONDBRANCH
000c72 0c76          DEST(PFA_TICK1)
000c73 04e2            .dw XT_DOLITERAL
000c74 fff3            .dw -13
000c75 0c9b            .dw XT_THROW
                 PFA_TICK1:
000c76 0586          .dw XT_DROP
000c77 04c2          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
000c78 ff07          .dw $ff07
000c79 6168
000c7a 646e
000c7b 656c
000c7c 0072          .db "handler",0
000c7d 0c61          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
000c7e 0503          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
000c7f 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
000c80 ff05          .dw $ff05
000c81 6163
000c82 6374
000c83 0068          .db "catch",0
000c84 0c78          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
000c85 011b          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
000c86 073a          .dw XT_SP_FETCH
000c87 05ac          .dw XT_TO_R
                     ; handler @ >r
000c88 0c7e          .dw XT_HANDLER
000c89 0526          .dw XT_FETCH
000c8a 05ac          .dw XT_TO_R
                     ; rp@ handler !
000c8b 0723          .dw XT_RP_FETCH
000c8c 0c7e          .dw XT_HANDLER
000c8d 052e          .dw XT_STORE
000c8e 04cc          .dw XT_EXECUTE
                     ; r> handler !
000c8f 05a3          .dw XT_R_FROM
000c90 0c7e          .dw XT_HANDLER
000c91 052e          .dw XT_STORE
000c92 05a3          .dw XT_R_FROM
000c93 0586          .dw XT_DROP
000c94 0601          .dw XT_ZERO
000c95 04c2          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
000c96 ff05          .dw $ff05
000c97 6874
000c98 6f72
000c99 0077          .db "throw",0
000c9a 0c80          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
000c9b 011b          .dw DO_COLON
                 PFA_THROW:
                 .endif
000c9c 0566          .dw XT_QDUP
000c9d 04db          .dw XT_DOCONDBRANCH
000c9e 0cab          DEST(PFA_THROW1)
000c9f 0c7e            .dw XT_HANDLER
000ca0 0526            .dw XT_FETCH
000ca1 072d            .dw XT_RP_STORE
000ca2 05a3            .dw XT_R_FROM
000ca3 0c7e            .dw XT_HANDLER
000ca4 052e            .dw XT_STORE
000ca5 05a3            .dw XT_R_FROM
000ca6 0571            .dw XT_SWAP
000ca7 05ac            .dw XT_TO_R
000ca8 0743            .dw XT_SP_STORE
000ca9 0586            .dw XT_DROP
000caa 05a3            .dw XT_R_FROM    
                 PFA_THROW1:
000cab 04c2          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
000cac ff05          .dw $ff05
000cad 7363
000cae 696b
000caf 0070          .db "cskip",0
000cb0 0c96          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
000cb1 011b          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
000cb2 05ac          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
000cb3 055e          .dw XT_DUP            ; ( -- addr' n' n' )
000cb4 04db          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000cb5 0cc0          DEST(PFA_CSKIP2)
000cb6 057c          .dw XT_OVER           ; ( -- addr' n' addr' )
000cb7 0545          .dw XT_CFETCH         ; ( -- addr' n' c' )
000cb8 05b3          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
000cb9 084d          .dw XT_EQUAL          ; ( -- addr' n' f )
000cba 04db          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000cbb 0cc0          DEST(PFA_CSKIP2)
000cbc 0854          .dw XT_ONE
000cbd 0e09          .dw XT_SLASHSTRING
000cbe 04d1          .dw XT_DOBRANCH
000cbf 0cb3          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
000cc0 05a3          .dw XT_R_FROM
000cc1 0586          .dw XT_DROP           ; ( -- addr2 n2)
000cc2 04c2          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
000cc3 ff05          .dw $ff05
000cc4 7363
000cc5 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
000cc6 006e          .db "cscan"
000cc7 0cac          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
000cc8 011b          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
000cc9 05ac          .dw XT_TO_R
000cca 057c          .dw XT_OVER
                 PFA_CSCAN1:
000ccb 055e          .dw XT_DUP
000ccc 0545          .dw XT_CFETCH
000ccd 05b3          .dw XT_R_FETCH
000cce 084d          .dw XT_EQUAL
000ccf 05c5          .dw XT_ZEROEQUAL
000cd0 04db          .dw XT_DOCONDBRANCH
000cd1 0cdd          DEST(PFA_CSCAN2)
000cd2 0571            .dw XT_SWAP
000cd3 06e2            .dw XT_1MINUS
000cd4 0571            .dw XT_SWAP
000cd5 057c            .dw XT_OVER
000cd6 05cc            .dw XT_ZEROLESS ; not negative
000cd7 05c5            .dw XT_ZEROEQUAL
000cd8 04db            .dw XT_DOCONDBRANCH
000cd9 0cdd            DEST(PFA_CSCAN2)
000cda 06dc              .dw XT_1PLUS
000cdb 04d1              .dw XT_DOBRANCH
000cdc 0ccb              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
000cdd 059d          .dw XT_NIP
000cde 057c          .dw XT_OVER
000cdf 0640          .dw XT_MINUS
000ce0 05a3          .dw XT_R_FROM
000ce1 0586          .dw XT_DROP
000ce2 04c2          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
000ce3 ff06          .dw $ff06
000ce4 6361
000ce5 6563
000ce6 7470          .db "accept"
000ce7 0cc3          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
000ce8 011b          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
000ce9 057c
000cea 064a
000ceb 057c              .DW XT_OVER,XT_PLUS,XT_OVER
000cec 09f8
000ced 055e
000cee 0d31
000cef 05c5
000cf0 04db      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
000cf1 0d24              DEST(ACC5)
000cf2 055e
000cf3 04e2
000cf4 0008
000cf5 084d
000cf6 04db              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
000cf7 0d0a              DEST(ACC3)
000cf8 0586
000cf9 058e
000cfa 09be
000cfb 0625
000cfc 05ac
000cfd 058e
000cfe 058e
000cff 05a3
000d00 04db              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
000d01 0d08      	DEST(ACC6)
000d02 0d29
000d03 06e2
000d04 05ac
000d05 057c
000d06 05a3
000d07 0170      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
000d08 04d1      ACC6:   .DW XT_DOBRANCH
000d09 0d22              DEST(ACC4)
                     
                 
                 ACC3:    ; check for remaining control characters, replace them with blank
000d0a 055e      	.dw XT_DUP            ; ( -- addr k k )
000d0b 0a49              .dw XT_BL
000d0c 061b              .dw XT_LESS
000d0d 04db              .dw XT_DOCONDBRANCH
000d0e 0d11              DEST(PFA_ACCEPT6)
000d0f 0586              .dw XT_DROP
000d10 0a49              .dw XT_BL
                 PFA_ACCEPT6:
000d11 05ac
000d12 09be
000d13 0625
000d14 05a3
000d15 0571
000d16 04db      	.DW XT_TO_R,XT_2DUP,XT_GREATER,XT_R_FROM,XT_SWAP,XT_DOCONDBRANCH
000d17 0d21              DEST(ACC7)
000d18 055e
000d19 09e7
000d1a 057c
000d1b 053a
000d1c 06dc
000d1d 057c
000d1e 017c                  .DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
000d1f 04d1      	    .DW XT_DOBRANCH
000d20 0d22      	    DEST(ACC4)
000d21 0586      ACC7:   .DW XT_DROP
000d22 04d1      ACC4:   .DW XT_DOBRANCH
000d23 0cec              DEST(ACC1)
000d24 0586
000d25 059d
000d26 0571
000d27 0640
000d28 04c2      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
000d29 011b          .dw DO_COLON
                 .endif
000d2a 04e2          .dw XT_DOLITERAL
000d2b 0008          .dw 8
000d2c 055e          .dw XT_DUP
000d2d 09e7          .dw XT_EMIT
000d2e 0c3c          .dw XT_SPACE
000d2f 09e7          .dw XT_EMIT
000d30 04c2          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
000d31 011b          .dw DO_COLON
                 .endif
000d32 055e          .dw XT_DUP
000d33 04e2          .dw XT_DOLITERAL
000d34 000d          .dw 13
000d35 084d          .dw XT_EQUAL
000d36 0571          .dw XT_SWAP
000d37 04e2          .dw XT_DOLITERAL
000d38 000a          .dw 10
000d39 084d          .dw XT_EQUAL
000d3a 06c9          .dw XT_OR
000d3b 04c2          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILL:
000d3c ff06          .dw $ff06
000d3d 6572
000d3e 6966
000d3f 6c6c          .db "refill"
000d40 0ce3          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
000d41 1088          .dw PFA_DODEFER1
                 PFA_REFILL:
                 .endif
000d42 001a          .dw USER_REFILL
000d43 1051          .dw XT_UDEFERFETCH
000d44 105d          .dw XT_UDEFERSTORE
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
000d45 ff04          .dw $ff04
000d46 6863
000d47 7261          .db "char"
000d48 0d3c          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
000d49 011b          .dw DO_COLON
                 PFA_CHAR:
                 .endif
000d4a 0e18          .dw XT_PARSENAME
000d4b 05c5
000d4c 04db          .dw XT_ZEROEQUAL,XT_DOCONDBRANCH 
000d4d 0d51          DEST(CHAR_1)
000d4e 04e2
000d4f fff0
000d50 0c9b             .dw XT_DOLITERAL, -16, XT_THROW
                 CHAR_1:
                 
000d51 0545          .dw XT_CFETCH
000d52 04c2          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
000d53 ff06          .dw $ff06
000d54 756e
000d55 626d
000d56 7265          .db "number"
000d57 0d45          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
000d58 011b          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
000d59 09a9          .dw XT_BASE
000d5a 0526          .dw XT_FETCH
000d5b 05ac          .dw XT_TO_R
000d5c 0d9c          .dw XT_QSIGN
000d5d 05ac          .dw XT_TO_R
000d5e 0daf          .dw XT_SET_BASE
000d5f 0d9c          .dw XT_QSIGN
000d60 05a3          .dw XT_R_FROM
000d61 06c9          .dw XT_OR
000d62 05ac          .dw XT_TO_R
                     ; check whether something is left
000d63 055e          .dw XT_DUP
000d64 05c5          .dw XT_ZEROEQUAL
000d65 04db          .dw XT_DOCONDBRANCH
000d66 0d6f          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
000d67 09c7            .dw XT_2DROP
000d68 05a3            .dw XT_R_FROM
000d69 0586            .dw XT_DROP
000d6a 05a3            .dw XT_R_FROM
000d6b 09a9            .dw XT_BASE
000d6c 052e            .dw XT_STORE
000d6d 0601            .dw XT_ZERO
000d6e 04c2            .dw XT_EXIT
                 PFA_NUMBER0:
000d6f 07c1          .dw XT_2TO_R
000d70 0601          .dw XT_ZERO       ; starting value
000d71 0601          .dw XT_ZERO
000d72 07d0          .dw XT_2R_FROM
000d73 0dcd          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
000d74 0566          .dw XT_QDUP
000d75 04db          .dw XT_DOCONDBRANCH
000d76 0d91          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
000d77 0854          .dw XT_ONE
000d78 084d          .dw XT_EQUAL
000d79 04db          .dw XT_DOCONDBRANCH
000d7a 0d88          DEST(PFA_NUMBER2)
                 	; excatly one character is left
000d7b 0545      	.dw XT_CFETCH
000d7c 04e2      	.dw XT_DOLITERAL
000d7d 002e      	.dw 46 ; .
000d7e 084d      	.dw XT_EQUAL
000d7f 04db      	.dw XT_DOCONDBRANCH
000d80 0d89      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
000d81 05a3      	.dw XT_R_FROM
000d82 04db              .dw XT_DOCONDBRANCH
000d83 0d85      	DEST(PFA_NUMBER3)
000d84 1156              .dw XT_DNEGATE
                 PFA_NUMBER3:
000d85 0859      	.dw XT_TWO
000d86 04d1      	.dw XT_DOBRANCH
000d87 0d97      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
000d88 0586      	.dw XT_DROP
                 PFA_NUMBER6:
000d89 09c7      	.dw XT_2DROP
000d8a 05a3      	.dw XT_R_FROM
000d8b 0586      	.dw XT_DROP
000d8c 05a3              .dw XT_R_FROM
000d8d 09a9              .dw XT_BASE
000d8e 052e              .dw XT_STORE
000d8f 0601      	.dw XT_ZERO
000d90 04c2      	.dw XT_EXIT
                 PFA_NUMBER1:
000d91 09c7          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
000d92 05a3          .dw XT_R_FROM
000d93 04db          .dw XT_DOCONDBRANCH
000d94 0d96          DEST(PFA_NUMBER4)
000d95 0a99          .dw XT_NEGATE
                 PFA_NUMBER4:
000d96 0854          .dw XT_ONE
                 PFA_NUMBER5:
000d97 05a3          .dw XT_R_FROM
000d98 09a9          .dw XT_BASE
000d99 052e          .dw XT_STORE
000d9a 05f8          .dw XT_TRUE
000d9b 04c2          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
000d9c 011b          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
000d9d 057c          .dw XT_OVER    ; ( -- addr len addr )
000d9e 0545          .dw XT_CFETCH
000d9f 04e2          .dw XT_DOLITERAL
000da0 002d          .dw '-'
000da1 084d          .dw XT_EQUAL  ; ( -- addr len flag )
000da2 055e          .dw XT_DUP
000da3 05ac          .dw XT_TO_R
000da4 04db          .dw XT_DOCONDBRANCH
000da5 0da8          DEST(PFA_NUMBERSIGN_DONE)
000da6 0854          .dw XT_ONE    ; skip sign character
000da7 0e09          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
000da8 05a3          .dw XT_R_FROM
000da9 04c2          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
000daa 04fd          .dw PFA_DOCONSTANT
                 .endif
000dab 000a
000dac 0010
000dad 0002
000dae 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
000daf 011b          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
000db0 057c          .dw XT_OVER
000db1 0545          .dw XT_CFETCH
000db2 04e2          .dw XT_DOLITERAL
000db3 0023          .dw 35
000db4 0640          .dw XT_MINUS
000db5 055e          .dw XT_DUP
000db6 0601          .dw XT_ZERO
000db7 04e2          .dw XT_DOLITERAL
000db8 0004          .dw 4
000db9 0ad1          .dw XT_WITHIN
000dba 04db          .dw XT_DOCONDBRANCH
000dbb 0dc5          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
000dbc 0daa      	.dw XT_BASES
000dbd 064a      	.dw XT_PLUS
000dbe 0835      	.dw XT_FETCHI
000dbf 09a9      	.dw XT_BASE
000dc0 052e      	.dw XT_STORE
000dc1 0854      	.dw XT_ONE
000dc2 0e09      	.dw XT_SLASHSTRING
000dc3 04d1      	.dw XT_DOBRANCH
000dc4 0dc6      	DEST(SET_BASE2)
                 SET_BASE1:
000dc5 0586      	.dw XT_DROP
                 SET_BASE2:
000dc6 04c2          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
000dc7 ff07          .dw $ff07
000dc8 6e3e
000dc9 6d75
000dca 6562
000dcb 0072          .db ">number",0
000dcc 0d53          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
000dcd 011b          .dw DO_COLON
                 
                 .endif
                 
000dce 055e
000dcf 04db      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
000dd0 0de5              DEST(TONUM3)
000dd1 057c
000dd2 0545
000dd3 0bad              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
000dd4 05c5
000dd5 04db              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
000dd6 0dd9              DEST(TONUM2)
000dd7 0586
000dd8 04c2              .DW XT_DROP,XT_EXIT
000dd9 05ac
000dda 117a
000ddb 09a9
000ddc 0526
000ddd 0161      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
000dde 05a3
000ddf 0159
000de0 117a              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
000de1 0854
000de2 0e09
000de3 04d1              .DW XT_ONE,XT_SLASHSTRING,XT_DOBRANCH
000de4 0dce              DEST(TONUM1)
000de5 04c2      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
000de6 ff05          .dw $ff05
000de7 6170
000de8 7372
000de9 0065          .db "parse",0
000dea 0dc7          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
000deb 011b          .dw DO_COLON
                 PFA_PARSE:
                 .endif
000dec 05ac          .dw XT_TO_R     ; ( -- )
000ded 0dff          .dw XT_SOURCE   ; ( -- addr len)
000dee 09d7          .dw XT_TO_IN     ; ( -- addr len >in)
000def 0526          .dw XT_FETCH
000df0 0e09          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
000df1 05a3          .dw XT_R_FROM      ; ( -- addr' len' c)
000df2 0cc8          .dw XT_CSCAN       ; ( -- addr' len'')
000df3 055e          .dw XT_DUP         ; ( -- addr' len'' len'')
000df4 06dc          .dw XT_1PLUS
000df5 09d7          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
000df6 0712          .dw XT_PLUSSTORE   ; ( -- addr' len')
000df7 0854          .dw XT_ONE
000df8 0e09          .dw XT_SLASHSTRING
000df9 04c2          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCE:
000dfa ff06          .dw $FF06
000dfb 6f73
000dfc 7275
000dfd 6563          .db "source"
000dfe 0de6          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
000dff 1088          .dw PFA_DODEFER1
                 PFA_SOURCE:
                 .endif
000e00 0016          .dw USER_SOURCE
000e01 1051          .dw XT_UDEFERFETCH
000e02 105d          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
000e03 ff07          .dw $ff07
000e04 732f
000e05 7274
000e06 6e69
000e07 0067          .db "/string",0
000e08 0dfa          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
000e09 011b          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
000e0a 058e          .dw XT_ROT
000e0b 057c          .dw XT_OVER
000e0c 064a          .dw XT_PLUS
000e0d 058e          .dw XT_ROT
000e0e 058e          .dw XT_ROT
000e0f 0640          .dw XT_MINUS
000e10 04c2          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
000e11 ff0a          .dw $FF0A 
000e12 6170
000e13 7372
000e14 2d65
000e15 616e
000e16 656d          .db "parse-name"
000e17 0e03          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
000e18 011b          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
000e19 0a49          .dw XT_BL
000e1a 0e1c          .dw XT_SKIPSCANCHAR
000e1b 04c2          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
000e1c 011b          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
000e1d 05ac          .dw XT_TO_R
000e1e 0dff          .dw XT_SOURCE 
000e1f 09d7          .dw XT_TO_IN 
000e20 0526          .dw XT_FETCH 
000e21 0e09          .dw XT_SLASHSTRING 
                 
000e22 05b3          .dw XT_R_FETCH
000e23 0cb1          .dw XT_CSKIP
000e24 05a3          .dw XT_R_FROM
000e25 0cc8          .dw XT_CSCAN
                 
                     ; adjust >IN
000e26 09be          .dw XT_2DUP
000e27 064a          .dw XT_PLUS
000e28 0dff          .dw XT_SOURCE 
000e29 0586          .dw XT_DROP
000e2a 0640          .dw XT_MINUS
000e2b 09d7          .dw XT_TO_IN
000e2c 052e          .dw XT_STORE
000e2d 04c2          .dw XT_EXIT
                 .include "words/find-xt.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the xt from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDXT:
000e2e ff07          .dw $ff07
000e2f 6966
000e30 646e
000e31 782d
000e32 0074          .db "find-xt",0
000e33 0e11          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDXT
                 XT_FINDXT:
000e34 011b          .dw DO_COLON
                 PFA_FINDXT:
                 .endif
000e35 04e2          .dw XT_DOLITERAL
000e36 0e40          .dw XT_FINDXTA
000e37 04e2          .dw XT_DOLITERAL
000e38 0088          .dw CFG_ORDERLISTLEN
000e39 0434          .dw XT_MAPSTACK
000e3a 05c5          .dw XT_ZEROEQUAL
000e3b 04db          .dw XT_DOCONDBRANCH
000e3c 0e3f          DEST(PFA_FINDXT1)
000e3d 09c7            .dw XT_2DROP
000e3e 0601            .dw XT_ZERO
                 PFA_FINDXT1:
000e3f 04c2          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDXTA:
000e40 011b          .dw DO_COLON
                 PFA_FINDXTA:
                 .endif
000e41 05ac          .dw XT_TO_R
000e42 09be          .dw XT_2DUP
000e43 05a3          .dw XT_R_FROM
000e44 109a          .dw XT_SEARCH_WORDLIST
000e45 055e          .dw XT_DUP
000e46 04db          .dw XT_DOCONDBRANCH
000e47 0e4d          DEST(PFA_FINDXTA1)
000e48 05ac            .dw XT_TO_R
000e49 059d            .dw XT_NIP
000e4a 059d            .dw XT_NIP
000e4b 05a3            .dw XT_R_FROM
000e4c 05f8            .dw XT_TRUE
                 PFA_FINDXTA1:
000e4d 04c2          .dw XT_EXIT
                 
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_DEFAULT_PROMPTOK:
000e4e 011b          .dw DO_COLON
                 PFA_DEFAULT_PROMPTOK:
000e4f 0bc7          .dw XT_DOSLITERAL
000e50 0003          .dw 3
000e51 6f20
000e52 006b          .db " ok",0
                 .endif
000e53 0bfa          .dw XT_ITYPE
000e54 04c2          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTOK:
000e55 ff03          .dw $FF03
000e56 6f2e
../../common\words/prompt-ok.asm(43): warning: .cseg .db misalignment - padding zero byte
000e57 006b          .db ".ok"
000e58 0e2e          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
000e59 1088          .dw PFA_DODEFER1
                 PFA_PROMPTOK:
                 .endif
000e5a 001c          .dw USER_P_OK
000e5b 1051          .dw XT_UDEFERFETCH
000e5c 105d          .dw XT_UDEFERSTORE
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_DEFAULT_PROMPTREADY:
000e5d 011b          .dw DO_COLON
                 PFA_DEFAULT_PROMPTREADY:
000e5e 0bc7          .dw XT_DOSLITERAL
000e5f 0002          .dw 2
000e60 203e          .db "> "
                 .endif
000e61 0c2f          .dw XT_CR
000e62 0bfa          .dw XT_ITYPE
000e63 04c2          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTREADY:
000e64 ff06          .dw $FF06
000e65 722e
000e66 6165
000e67 7964          .db ".ready"
000e68 0e55          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTREADY
                 XT_PROMPTREADY:
000e69 1088          .dw PFA_DODEFER1
                 PFA_PROMPTREADY:
                 .endif
000e6a 0020          .dw USER_P_RDY
000e6b 1051          .dw XT_UDEFERFETCH
000e6c 105d          .dw XT_UDEFERSTORE
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_DEFAULT_PROMPTERROR:
000e6d 011b          .dw DO_COLON
                 PFA_DEFAULT_PROMPTERROR:
000e6e 0bc7      	.dw XT_DOSLITERAL
000e6f 0004          .dw 4
000e70 3f20
000e71 203f          .db " ?? "
                 .endif
000e72 0bfa          .dw XT_ITYPE
000e73 09a9          .dw XT_BASE
000e74 0526          .dw XT_FETCH
000e75 05ac          .dw XT_TO_R
000e76 0a36          .dw XT_DECIMAL
000e77 0b7c          .dw XT_DOT
000e78 09d7          .dw XT_TO_IN
000e79 0526          .dw XT_FETCH
000e7a 0b7c          .dw XT_DOT
000e7b 05a3          .dw XT_R_FROM
000e7c 09a9          .dw XT_BASE
000e7d 052e          .dw XT_STORE
000e7e 04c2          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTERROR:
000e7f ff06          .dw $FF06
000e80 652e
000e81 7272
000e82 726f          .db ".error"
000e83 0e64          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
000e84 1088          .dw PFA_DODEFER1
                 PFA_PROMPTERROR:
                 .endif
000e85 001e          .dw USER_P_ERR
000e86 1051          .dw XT_UDEFERFETCH
000e87 105d          .dw XT_UDEFERSTORE
                 .include "words/prompt-input.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_DEFAULT_PROMPTINPUT:
000e88 011b          .dw DO_COLON
                 PFA_DEFAULT_PROMPTINPUT:
                 .endif
000e89 0c2f          .dw XT_CR
000e8a 04c2          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTINPUT:
000e8b ff06          .dw $FF06
000e8c 692e
000e8d 706e
000e8e 7475          .db ".input"
000e8f 0e7f          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTINPUT
                 XT_PROMPTINPUT:
000e90 1088          .dw PFA_DODEFER1
                 PFA_PROMPTINPUT:
                 .endif
000e91 0022          .dw USER_P_INPUT
000e92 1051          .dw XT_UDEFERFETCH
000e93 105d          .dw XT_UDEFERSTORE
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
000e94 ff04          .dw $ff04
000e95 7571
000e96 7469          .db "quit"
000e97 0e8b          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
000e98 011b          .dw DO_COLON
                 .endif
                 PFA_QUIT:
000e99 02e9
000e9a 02f0
000e9b 052e          .dw XT_LP0,XT_LP,XT_STORE
000e9c 0efa          .dw XT_SP0
000e9d 0743          .dw XT_SP_STORE
000e9e 0f02          .dw XT_RP0
000e9f 072d          .dw XT_RP_STORE
000ea0 037e          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
000ea1 09a3          .dw XT_STATE
000ea2 0526          .dw XT_FETCH
000ea3 05c5          .dw XT_ZEROEQUAL
000ea4 04db          .dw XT_DOCONDBRANCH
000ea5 0ea7          DEST(PFA_QUIT4)
000ea6 0e69          .dw XT_PROMPTREADY
                 PFA_QUIT4:
000ea7 0d41          .dw XT_REFILL
000ea8 0e90          .dw XT_PROMPTINPUT
000ea9 04db          .dw XT_DOCONDBRANCH
000eaa 0eba          DEST(PFA_QUIT3)
000eab 04e2          .dw XT_DOLITERAL
000eac 0f1b          .dw XT_INTERPRET
000ead 0c85          .dw XT_CATCH
000eae 0566          .dw XT_QDUP
000eaf 04db          .dw XT_DOCONDBRANCH
000eb0 0eba          DEST(PFA_QUIT3)
000eb1 055e      	.dw XT_DUP
000eb2 04e2      	.dw XT_DOLITERAL
000eb3 fffe      	.dw -2
000eb4 061b      	.dw XT_LESS
000eb5 04db      	.dw XT_DOCONDBRANCH
000eb6 0eb8      	DEST(PFA_QUIT5)
000eb7 0e84      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
000eb8 04d1      	.dw XT_DOBRANCH
000eb9 0e99      	DEST(PFA_QUIT)
                 PFA_QUIT3:
000eba 0e59          .dw XT_PROMPTOK
000ebb 04d1          .dw XT_DOBRANCH
000ebc 0ea1          DEST(PFA_QUIT2)
                 ;    .dw XT_EXIT ; never reached
                 
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
000ebd ff05          .dw $ff05
000ebe 6170
000ebf 7375
000ec0 0065          .db "pause",0
000ec1 0e94          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
000ec2 1088          .dw PFA_DODEFER1
                 PFA_PAUSE:
000ec3 0257          .dw ram_pause
000ec4 103d          .dw XT_RDEFERFETCH
000ec5 1047          .dw XT_RDEFERSTORE
                 
                 .dseg
000257           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
000ec6 ff04          .dw $ff04
000ec7 6f63
000ec8 646c          .db "cold"
000ec9 0ebd          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
000eca 0ecb          .dw PFA_COLD
                 PFA_COLD:
000ecb b6a4          in_ mcu_boot, MCUSR
000ecc 2422          clr zerol
000ecd 2433          clr zeroh
000ece 24bb          clr isrflag
000ecf be24          out_ MCUSR, zerol
                     ; clear RAM
000ed0 e0e0          ldi zl, low(ramstart)
000ed1 e0f2          ldi zh, high(ramstart)
                 clearloop:
000ed2 9221          st Z+, zerol
000ed3 30e0          cpi zl, low(sram_size+ramstart)
000ed4 f7e9          brne clearloop
000ed5 32f2          cpi zh, high(sram_size+ramstart)
000ed6 f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000259           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
000ed7 e5e9          ldi zl, low(ram_user1)
000ed8 e0f2          ldi zh, high(ram_user1)
000ed9 012f          movw upl, zl
                     ; init return stack pointer
000eda ef0f          ldi temp0,low(rstackstart)
000edb bf0d          out_ SPL,temp0
000edc 8304          std Z+4, temp0
000edd e211          ldi temp1,high(rstackstart)
000ede bf1e          out_ SPH,temp1
000edf 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
000ee0 eacf          ldi yl,low(stackstart)
000ee1 83c6          std Z+6, yl
000ee2 e2d1          ldi yh,high(stackstart)
000ee3 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
000ee4 eead          ldi XL, low(PFA_WARM)
000ee5 e0be          ldi XH, high(PFA_WARM)
                     ; its a far jump...
000ee6 940c 011f     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WARM:
000ee8 ff04          .dw $ff04
000ee9 6177
000eea 6d72          .db "warm"
000eeb 0ec6          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
000eec 011b          .dw DO_COLON
                 PFA_WARM:
                 .endif
000eed 11c5          .dw XT_INIT_RAM
000eee 04e2          .dw XT_DOLITERAL
000eef 0ff4          .dw XT_NOOP
000ef0 04e2          .dw XT_DOLITERAL
000ef1 0ec2          .dw XT_PAUSE
000ef2 1068          .dw XT_DEFERSTORE
000ef3 037e          .dw XT_LBRACKET
000ef4 0a51          .dw XT_TURNKEY
000ef5 0e98          .dw XT_QUIT     ; never returns
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
000ef6 ff03          .dw $ff03
000ef7 7073
000ef8 0030          .db "sp0",0
000ef9 0ee8          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
000efa 051d          .dw PFA_DOVALUE1
                 PFA_SP0:
000efb 0006          .dw USER_SP0
000efc 1051          .dw XT_UDEFERFETCH
000efd 105d          .dw XT_UDEFERSTORE
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
000efe ff03          .dw $ff03
000eff 7072
000f00 0030          .db "rp0",0
000f01 0ef6          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
000f02 011b          .dw DO_COLON
                 PFA_RP0:
000f03 0f06          .dw XT_DORP0
000f04 0526          .dw XT_FETCH
000f05 04c2          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
000f06 0503          .dw PFA_DOUSER
                 PFA_DORP0:
000f07 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
000f08 ff05          .dw $ff05
000f09 6564
000f0a 7470
000f0b 0068          .db "depth",0
000f0c 0efe          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
000f0d 011b          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
000f0e 0efa          .dw XT_SP0
000f0f 073a          .dw XT_SP_FETCH
000f10 0640          .dw XT_MINUS
000f11 06b1          .dw XT_2SLASH
000f12 06e2          .dw XT_1MINUS
000f13 04c2          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
000f14 ff09          .dw $ff09
000f15 6e69
000f16 6574
000f17 7072
000f18 6572
000f19 0074          .db "interpret",0
000f1a 0f08          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
000f1b 011b          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
000f1c 0e18          .dw XT_PARSENAME ; ( -- addr len )
000f1d 055e          .dw XT_DUP   ; ( -- addr len flag)
000f1e 04db          .dw XT_DOCONDBRANCH
000f1f 0f2c          DEST(PFA_INTERPRET2)
000f20 0f38            .dw XT_FORTHRECOGNIZER
000f21 0f43            .dw XT_RECOGNIZE
000f22 09a3            .dw XT_STATE
000f23 0526            .dw XT_FETCH
000f24 04db            .dw XT_DOCONDBRANCH
000f25 0f27          DEST(PFA_INTERPRET1)
000f26 1020            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
000f27 0835            .dw XT_FETCHI
000f28 04cc            .dw XT_EXECUTE
000f29 0fcc            .dw XT_QSTACK
000f2a 04d1          .dw XT_DOBRANCH
000f2b 0f1c          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
000f2c 09c7          .dw XT_2DROP
000f2d 04c2          .dw XT_EXIT
                 .include "words/forth-recognizer.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_FORTHRECOGNIZER:
000f2e ff10          .dw $ff10
000f2f 6f66
000f30 7472
000f31 2d68
000f32 6572
000f33 6f63
000f34 6e67
000f35 7a69
000f36 7265          .db "forth-recognizer"
000f37 0f14          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHRECOGNIZER
                 XT_FORTHRECOGNIZER:
000f38 051d          .dw PFA_DOVALUE1
                 PFA_FORTHRECOGNIZER:
000f39 007c          .dw CFG_FORTHRECOGNIZER
000f3a 1029          .dw XT_EDEFERFETCH
000f3b 1033          .dw XT_EDEFERSTORE
                 .include "words/recognize.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECOGNIZE:
000f3c ff09          .dw $ff09
000f3d 6572
000f3e 6f63
000f3f 6e67
000f40 7a69
000f41 0065          .db "recognize",0
000f42 0f2e          .dw VE_HEAD
                     .set VE_HEAD = VE_RECOGNIZE
                 XT_RECOGNIZE:
000f43 011b          .dw DO_COLON
                 PFA_RECOGNIZE:
                 .endif
000f44 04e2          .dw XT_DOLITERAL
000f45 0f4e          .dw XT_RECOGNIZE_A
000f46 0571          .dw XT_SWAP
000f47 0434          .dw XT_MAPSTACK
000f48 05c5          .dw XT_ZEROEQUAL
000f49 04db          .dw XT_DOCONDBRANCH
000f4a 0f4d          DEST(PFA_RECOGNIZE1)
000f4b 09c7            .dw XT_2DROP
000f4c 0fbf            .dw XT_RECTYPE_NULL
                 PFA_RECOGNIZE1:
000f4d 04c2          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ; ( addr len XT -- addr len [ rectype-* -1 | 0 ] )
                 XT_RECOGNIZE_A:
000f4e 011b         .dw DO_COLON
                 PFA_RECOGNIZE_A:
                 .endif
000f4f 058e         .dw XT_ROT  ; -- len xt addr
000f50 058e         .dw XT_ROT  ; -- xt addr len
000f51 09be         .dw XT_2DUP 
000f52 07c1         .dw XT_2TO_R
000f53 058e         .dw XT_ROT  ; -- addr len xt
000f54 04cc         .dw XT_EXECUTE ; -- i*x rectype-* | rectype-null
000f55 07d0         .dw XT_2R_FROM
000f56 058e         .dw XT_ROT
000f57 055e         .dw XT_DUP
000f58 0fbf         .dw XT_RECTYPE_NULL
000f59 084d         .dw XT_EQUAL
000f5a 04db         .dw XT_DOCONDBRANCH
000f5b 0f5f         DEST(PFA_RECOGNIZE_A1)
000f5c 0586           .dw XT_DROP
000f5d 0601           .dw XT_ZERO
000f5e 04c2           .dw XT_EXIT
                 PFA_RECOGNIZE_A1:
000f5f 059d         .dw XT_NIP 
000f60 059d         .dw XT_NIP
000f61 05f8         .dw XT_TRUE
000f62 04c2         .dw XT_EXIT
                 
                 ; : recognize ( addr len stack-id -- i*x rectype-* | rectype-null )
                 ;   [: ( addr len -- addr len 0 | i*x rectype-* -1 )
                 ;      rot rot 2dup 2>r rot execute 2r> rot 
                 ;      dup rectype-null = ( -- addr len rectype-* f )
                 ;      if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    map-stack ( -- i*x addr len rectype-* f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop rectype-null
                 ;    then ;
                 ;
                 .include "words/rec-intnum.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_NUM:
000f63 ff0b          .dw $ff0b
000f64 6572
000f65 7463
000f66 7079
000f67 2d65
000f68 756e
000f69 006d          .db "rectype-num",0
000f6a 0f3c          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_NUM
                 XT_RECTYPE_NUM:
000f6b 04fd          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_NUM:
                 .endif
000f6c 0ff4          .dw XT_NOOP    ; interpret
000f6d 020a          .dw XT_LITERAL ; compile
000f6e 020a          .dw XT_LITERAL ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_DNUM:
000f6f ff0c          .dw $ff0c
000f70 6572
000f71 7463
000f72 7079
000f73 2d65
000f74 6e64
000f75 6d75          .db "rectype-dnum"
000f76 0f63          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_DNUM
                 XT_RECTYPE_DNUM:
000f77 04fd          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_DNUM:
                 .endif
000f78 0ff4          .dw XT_NOOP     ; interpret
000f79 0845          .dw XT_2LITERAL ; compile
000f7a 0845          .dw XT_2LITERAL ; postpone
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
000f7b ff07          .dw $ff07
000f7c 6572
000f7d 2d63
000f7e 756e
000f7f 006d          .db "rec-num",0
000f80 0f6f          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
000f81 011b          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
000f82 0d58          .dw XT_NUMBER
000f83 04db          .dw XT_DOCONDBRANCH
000f84 0f8d          DEST(PFA_REC_NONUMBER)
000f85 0854          .dw XT_ONE
000f86 084d          .dw XT_EQUAL
000f87 04db          .dw XT_DOCONDBRANCH
000f88 0f8b          DEST(PFA_REC_INTNUM2)
000f89 0f6b            .dw XT_RECTYPE_NUM
000f8a 04c2            .dw XT_EXIT
                 PFA_REC_INTNUM2:
000f8b 0f77            .dw XT_RECTYPE_DNUM
000f8c 04c2            .dw XT_EXIT
                 PFA_REC_NONUMBER:
000f8d 0fbf          .dw XT_RECTYPE_NULL
000f8e 04c2          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_FIND:
000f8f ff08          .dw $ff08
000f90 6572
000f91 2d63
000f92 6966
000f93 646e          .db "rec-find"
000f94 0f7b          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
000f95 011b          .dw DO_COLON
                 PFA_REC_FIND:
                 .endif
000f96 0e34          .DW XT_FINDXT
000f97 055e          .dw XT_DUP
000f98 05c5          .dw XT_ZEROEQUAL
000f99 04db          .dw XT_DOCONDBRANCH
000f9a 0f9e          DEST(PFA_REC_WORD_FOUND)
000f9b 0586              .dw XT_DROP
000f9c 0fbf      	.dw XT_RECTYPE_NULL
000f9d 04c2      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
000f9e 0fa7          .dw XT_RECTYPE_XT
                 
000f9f 04c2          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_XT:
000fa0 ff0a          .dw $ff0a
000fa1 6572
000fa2 7463
000fa3 7079
000fa4 2d65
000fa5 7478          .db "rectype-xt"
000fa6 0f8f          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_XT
                 XT_RECTYPE_XT:
000fa7 04fd          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_XT:
                 .endif
000fa8 0fab          .dw XT_R_WORD_INTERPRET
000fa9 0faf          .dw XT_R_WORD_COMPILE
000faa 0845          .dw XT_2LITERAL
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
000fab 011b          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
000fac 0586          .dw XT_DROP ; the flags are in the way
000fad 04cc          .dw XT_EXECUTE
000fae 04c2          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
000faf 011b          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
000fb0 05cc          .dw XT_ZEROLESS
000fb1 04db          .dw XT_DOCONDBRANCH
000fb2 0fb5          DEST(PFA_R_WORD_COMPILE1)
000fb3 01f4      	.dw XT_COMMA
000fb4 04c2              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
000fb5 04cc              .dw XT_EXECUTE
000fb6 04c2          .dw XT_EXIT
                 .include "words/rec-null.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_NULL:
000fb7 ff0c          .dw $ff0c
000fb8 6572
000fb9 7463
000fba 7079
000fbb 2d65
000fbc 756e
000fbd 6c6c          .db "rectype-null"
000fbe 0fa0          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_NULL
                 XT_RECTYPE_NULL:
000fbf 04fd          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_NULL:
                 .endif
000fc0 0fc3          .dw XT_FAIL  ; interpret
000fc1 0fc3          .dw XT_FAIL  ; compile
000fc2 0fc3          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
000fc3 011b          .dw DO_COLON
                 PFA_FAIL:
                 .endif
000fc4 04e2          .dw XT_DOLITERAL
000fc5 fff3          .dw -13
000fc6 0c9b          .dw XT_THROW
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
000fc7 ff06          .dw $ff06
000fc8 733f
000fc9 6174
000fca 6b63          .db "?stack"
000fcb 0fb7          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
000fcc 011b          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
000fcd 0f0d          .dw XT_DEPTH
000fce 05cc          .dw XT_ZEROLESS
000fcf 04db          .dw XT_DOCONDBRANCH
000fd0 0fd4          DEST(PFA_QSTACK1)
000fd1 04e2            .dw XT_DOLITERAL
000fd2 fffc            .dw -4
000fd3 0c9b            .dw XT_THROW
                 PFA_QSTACK1:
000fd4 04c2          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
000fd5 ff03          .dw $ff03
000fd6 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
000fd7 0072          .db "ver"
000fd8 0fc7          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
000fd9 011b          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
000fda 0965          .dw XT_ENV_FORTHNAME
000fdb 0bfa          .dw XT_ITYPE
000fdc 0c3c          .dw XT_SPACE
000fdd 09a9          .dw XT_BASE
000fde 0526          .dw XT_FETCH
                 
000fdf 0973          .dw XT_ENV_FORTHVERSION
000fe0 0a36          .dw XT_DECIMAL
000fe1 11dc          .dw XT_S2D
000fe2 0b18          .dw XT_L_SHARP
000fe3 0b20          .dw XT_SHARP
000fe4 04e2          .dw XT_DOLITERAL
000fe5 002e          .dw '.'
000fe6 0b09          .dw XT_HOLD
000fe7 0b36          .dw XT_SHARP_S
000fe8 0b41          .dw XT_SHARP_G
000fe9 0c55          .dw XT_TYPE
000fea 09a9          .dw XT_BASE
000feb 052e          .dw XT_STORE
000fec 0c3c          .dw XT_SPACE
000fed 097b          .dw XT_ENV_CPU
000fee 0bfa          .dw XT_ITYPE
                 
000fef 04c2          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOOP:
000ff0 ff04          .dw $ff04
000ff1 6f6e
000ff2 706f          .db "noop"
000ff3 0fd5          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
000ff4 011b          .dw DO_COLON
                 PFA_NOOP:
                 .endif
000ff5 04c2         .DW XT_EXIT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
000ff6 ff06          .dw $ff06
000ff7 6e75
000ff8 7375
000ff9 6465          .db "unused"
000ffa 0ff0          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
000ffb 011b          .dw DO_COLON
                 PFA_UNUSED:
000ffc 073a          .dw XT_SP_FETCH
000ffd 0a18          .dw XT_HERE
000ffe 0640          .dw XT_MINUS
000fff 04c2          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
001000 0002          .dw $0002
001001 6f74          .db "to"
001002 0ff6          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
001003 011b          .dw DO_COLON
                 PFA_TO:
                 .endif
001004 0c64          .dw XT_TICK
001005 11e5          .dw XT_TO_BODY
001006 09a3          .dw XT_STATE
001007 0526          .dw XT_FETCH
001008 04db          .dw XT_DOCONDBRANCH
001009 1014          DEST(PFA_TO1)
00100a 01e9          .dw XT_COMPILE
00100b 100e          .dw XT_DOTO
00100c 01f4          .dw XT_COMMA
00100d 04c2          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
00100e 011b          .dw DO_COLON
                 PFA_DOTO:
                 .endif
00100f 05a3          .dw XT_R_FROM
001010 055e          .dw XT_DUP
001011 1020          .dw XT_ICELLPLUS
001012 05ac          .dw XT_TO_R
001013 0835          .dw XT_FETCHI
                 PFA_TO1:
001014 055e          .dw XT_DUP
001015 1020          .dw XT_ICELLPLUS
001016 1020          .dw XT_ICELLPLUS
001017 0835          .dw XT_FETCHI
001018 04cc          .dw XT_EXECUTE
001019 04c2          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
00101a ff07          .dw $FF07
00101b 2d69
00101c 6563
00101d 6c6c
00101e 002b          .db "i-cell+",0
00101f 1000          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
001020 011b          .dw DO_COLON
                 PFA_ICELLPLUS:
001021 06dc          .dw XT_1PLUS
001022 04c2          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
001023 ff07          .dw $ff07
001024 6445
001025 6665
001026 7265
001027 0040          .db "Edefer@",0
001028 101a          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
001029 011b          .dw DO_COLON
                 PFA_EDEFERFETCH:
00102a 0835          .dw XT_FETCHI
00102b 0802          .dw XT_FETCHE
00102c 04c2          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
00102d ff07          .dw $ff07
00102e 6445
00102f 6665
001030 7265
001031 0021          .db "Edefer!",0
001032 1023          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
001033 011b          .dw DO_COLON
                 PFA_EDEFERSTORE:
001034 0835          .dw XT_FETCHI
001035 07de          .dw XT_STOREE
001036 04c2          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
001037 ff07          .dw $ff07
001038 6452
001039 6665
00103a 7265
00103b 0040          .db "Rdefer@",0
00103c 102d          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
00103d 011b          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
00103e 0835          .dw XT_FETCHI
00103f 0526          .dw XT_FETCH
001040 04c2          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
001041 ff07          .dw $ff07
001042 6452
001043 6665
001044 7265
001045 0021          .db "Rdefer!",0
001046 1037          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
001047 011b          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
001048 0835          .dw XT_FETCHI
001049 052e          .dw XT_STORE
00104a 04c2          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
00104b ff07          .dw $ff07
00104c 6455
00104d 6665
00104e 7265
00104f 0040          .db "Udefer@",0
001050 1041          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
001051 011b          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
001052 0835          .dw XT_FETCHI
001053 07af          .dw XT_UP_FETCH
001054 064a          .dw XT_PLUS
001055 0526          .dw XT_FETCH
001056 04c2          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
001057 ff07          .dw $ff07
001058 6455
001059 6665
00105a 7265
00105b 0021          .db "Udefer!",0
00105c 104b          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
00105d 011b          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
00105e 0835          .dw XT_FETCHI
00105f 07af          .dw XT_UP_FETCH
001060 064a          .dw XT_PLUS
001061 052e          .dw XT_STORE
001062 04c2          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
001063 ff06          .dw $ff06
001064 6564
001065 6566
001066 2172          .db "defer!"
001067 1057          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
001068 011b          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
001069 11e5          .dw XT_TO_BODY
00106a 055e          .dw XT_DUP
00106b 1020          .dw XT_ICELLPLUS
00106c 1020          .dw XT_ICELLPLUS
00106d 0835          .dw XT_FETCHI
00106e 04cc          .dw XT_EXECUTE
00106f 04c2          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
001070 ff06          .dw $ff06
001071 6564
001072 6566
001073 4072          .db "defer@"
001074 1063          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
001075 011b          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
001076 11e5          .dw XT_TO_BODY 
001077 055e          .dw XT_DUP
001078 1020          .dw XT_ICELLPLUS
001079 0835          .dw XT_FETCHI
00107a 04cc          .dw XT_EXECUTE
00107b 04c2          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
00107c ff07          .dw $ff07
00107d 6428
00107e 6665
00107f 7265
001080 0029          .db "(defer)", 0
001081 1070          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
001082 011b          .dw DO_COLON
                 PFA_DODEFER:
001083 01bb          .dw XT_DOCREATE
001084 0326          .dw XT_REVEAL
001085 01e9          .dw XT_COMPILE
001086 1088          .dw PFA_DODEFER1
001087 04c2          .dw XT_EXIT
                 PFA_DODEFER1:
001088 940e 033f     call_ DO_DODOES
00108a 055e          .dw XT_DUP
00108b 1020          .dw XT_ICELLPLUS
00108c 0835          .dw XT_FETCHI
00108d 04cc          .dw XT_EXECUTE 
00108e 04cc          .dw XT_EXECUTE
00108f 04c2          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
001090 ff0f          .dw $ff0f
001091 6573
001092 7261
001093 6863
001094 772d
001095 726f
001096 6c64
001097 7369
001098 0074          .db "search-wordlist",0
001099 107c          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
00109a 011b          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
00109b 05ac          .dw XT_TO_R
00109c 0601          .dw XT_ZERO
00109d 04e2          .dw XT_DOLITERAL
00109e 10af          .dw XT_ISWORD
00109f 05a3          .dw XT_R_FROM
0010a0 10cc          .dw XT_TRAVERSEWORDLIST
0010a1 055e          .dw XT_DUP
0010a2 05c5          .dw XT_ZEROEQUAL
0010a3 04db          .dw XT_DOCONDBRANCH
0010a4 10a9          DEST(PFA_SEARCH_WORDLIST1)
0010a5 09c7             .dw XT_2DROP
0010a6 0586             .dw XT_DROP
0010a7 0601             .dw XT_ZERO
0010a8 04c2             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
0010a9 055e            .dw XT_DUP
0010aa 10f3            .dw XT_NFA2CFA
                       ; .. and get the header flag
0010ab 0571            .dw XT_SWAP
0010ac 0196            .dw XT_NAME2FLAGS
0010ad 0184            .dw XT_IMMEDIATEQ
0010ae 04c2          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
0010af 011b          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
0010b0 05ac          .dw XT_TO_R
0010b1 0586          .dw XT_DROP
0010b2 09be          .dw XT_2DUP
0010b3 05b3          .dw XT_R_FETCH  ; -- addr len addr len nt
0010b4 10e7          .dw XT_NAME2STRING
0010b5 10fd          .dw XT_ICOMPARE      ; (-- addr len f )
0010b6 04db          .dw XT_DOCONDBRANCH
0010b7 10bd          DEST(PFA_ISWORD3)
                       ; not now
0010b8 05a3            .dw XT_R_FROM
0010b9 0586            .dw XT_DROP
0010ba 0601            .dw XT_ZERO
0010bb 05f8            .dw XT_TRUE         ; maybe next word
0010bc 04c2            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
0010bd 09c7            .dw XT_2DROP
0010be 05a3            .dw XT_R_FROM
0010bf 0601            .dw XT_ZERO       ; finish traverse-wordlist
0010c0 04c2            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
0010c1 ff11          .dw $ff11
0010c2 7274
0010c3 7661
0010c4 7265
0010c5 6573
0010c6 772d
0010c7 726f
0010c8 6c64
0010c9 7369
0010ca 0074          .db "traverse-wordlist",0
0010cb 1090          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
0010cc 011b          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
0010cd 0802          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
0010ce 055e          .dw XT_DUP           ; ( -- xt nt nt )
0010cf 04db          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
0010d0 10dd          DEST(PFA_TRAVERSEWORDLIST2)
0010d1 09be          .dw XT_2DUP
0010d2 07c1          .dw XT_2TO_R
0010d3 0571          .dw XT_SWAP
0010d4 04cc          .dw XT_EXECUTE
0010d5 07d0          .dw XT_2R_FROM
0010d6 058e          .dw XT_ROT
0010d7 04db          .dw XT_DOCONDBRANCH
0010d8 10dd          DEST(PFA_TRAVERSEWORDLIST2)
0010d9 049e          .dw XT_NFA2LFA
0010da 0835          .dw XT_FETCHI
0010db 04d1          .dw XT_DOBRANCH      ; ( -- addr )
0010dc 10ce          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
0010dd 09c7          .dw XT_2DROP
0010de 04c2          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' )
                 ;        begin @ dup
                 ;        while
                 ;          2dup 2>r
                 ;          swap execute ( i*x nt -- i*x' f )
                 ;          2r> rot
                 ;        while
                 ;          nfa>lfa @i
                 ;        repeat then 2drop ;
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
0010df ff0b          .dw $ff0b
0010e0 616e
0010e1 656d
0010e2 733e
0010e3 7274
0010e4 6e69
0010e5 0067          .db "name>string",0
0010e6 10c1          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
0010e7 011b          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
0010e8 0c26          .dw XT_ICOUNT   ; ( -- addr n )
0010e9 04e2          .dw XT_DOLITERAL
0010ea 00ff          .dw 255
0010eb 06c0          .dw XT_AND      ; mask immediate bit
0010ec 04c2          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
0010ed ff07          .dw $ff07
0010ee 666e
0010ef 3e61
0010f0 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
0010f1 0061          .db "nfa>cfa"
0010f2 10df          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
0010f3 011b          .dw DO_COLON
                 PFA_NFA2CFA:
0010f4 049e          .dw XT_NFA2LFA ; skip to link field
0010f5 06dc          .dw XT_1PLUS   ; next is the execution token
0010f6 04c2          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
0010f7 ff08          .dw $ff08
0010f8 6369
0010f9 6d6f
0010fa 6170
0010fb 6572          .db "icompare"
0010fc 10ed          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
0010fd 011b          .dw DO_COLON
                 PFA_ICOMPARE:
0010fe 05ac          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
0010ff 057c          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
001100 05a3          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
001101 05be          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
001102 04db          .dw XT_DOCONDBRANCH
001103 1108          .dw PFA_ICOMPARE_SAMELEN
001104 09c7            .dw XT_2DROP
001105 0586            .dw XT_DROP
001106 05f8            .dw XT_TRUE
001107 04c2            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
001108 0571          .dw XT_SWAP ; ( -- r-addr f-addr len )
001109 0601          .dw XT_ZERO
00110a 02b3          .dw XT_QDOCHECK
00110b 04db          .dw XT_DOCONDBRANCH
00110c 112b          .dw PFA_ICOMPARE_DONE
00110d 0748          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
00110e 057c          .dw XT_OVER
00110f 0526          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
                 .endif
001110 057c          .dw XT_OVER
001111 0835          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
001112 055e          .dw XT_DUP
                     ;.dw XT_BYTESWAP
001113 04e2          .dw XT_DOLITERAL
001114 0100          .dw $100
001115 0609          .dw XT_ULESS
001116 04db          .dw XT_DOCONDBRANCH
001117 111c          .dw PFA_ICOMPARE_LASTCELL
001118 0571          .dw XT_SWAP
001119 04e2          .dw XT_DOLITERAL
00111a 00ff          .dw $00FF
00111b 06c0          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
00111c 05be          .dw XT_NOTEQUAL
00111d 04db          .dw XT_DOCONDBRANCH
00111e 1123          .dw PFA_ICOMPARE_NEXTLOOP
00111f 09c7          .dw XT_2DROP
001120 05f8          .dw XT_TRUE
001121 0781          .dw XT_UNLOOP
001122 04c2          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
001123 06dc          .dw XT_1PLUS
001124 0571          .dw XT_SWAP
001125 09b6          .dw XT_CELLPLUS
001126 0571          .dw XT_SWAP
001127 04e2          .dw XT_DOLITERAL
001128 0002          .dw 2
001129 0767          .dw XT_DOPLUSLOOP
00112a 110e          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
00112b 09c7          .dw XT_2DROP
00112c 0601          .dw XT_ZERO
00112d 04c2          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
00112e ff01          .dw $ff01
00112f 002a          .db "*",0
001130 10f7          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
001131 011b          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
001132 0653          .dw XT_MSTAR
001133 0586          .dw XT_DROP
001134 04c2          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
001135 ff01          .dw $FF01
001136 006a          .db "j",0
001137 112e          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
001138 011b          .dw DO_COLON
                 PFA_J:
001139 0723          .dw XT_RP_FETCH
00113a 04e2          .dw XT_DOLITERAL
00113b 0007          .dw 7
00113c 064a          .dw XT_PLUS
00113d 0526          .dw XT_FETCH
00113e 0723          .dw XT_RP_FETCH
00113f 04e2          .dw XT_DOLITERAL
001140 0009          .dw 9
001141 064a          .dw XT_PLUS
001142 0526          .dw XT_FETCH
001143 064a          .dw XT_PLUS
001144 04c2          .dw XT_EXIT
                 
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
001145 ff04          .dw $ff04
001146 6164
001147 7362          .db "dabs"
001148 1135          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
001149 011b          .dw DO_COLON
                 PFA_DABS:
00114a 055e          .dw XT_DUP
00114b 05cc          .dw XT_ZEROLESS
00114c 04db          .dw XT_DOCONDBRANCH
00114d 114f          .dw PFA_DABS1
00114e 1156          .dw XT_DNEGATE
                 PFA_DABS1:
00114f 04c2          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
001150 ff07          .dw $ff07
001151 6e64
001152 6765
001153 7461
001154 0065          .db "dnegate",0
001155 1145          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
001156 011b          .dw DO_COLON
                 PFA_DNEGATE:
001157 08c9          .dw XT_DINVERT
001158 0854          .dw XT_ONE
001159 0601          .dw XT_ZERO
00115a 08a3          .dw XT_DPLUS
00115b 04c2          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
00115c ff05          .dw $ff05
00115d 6d63
00115e 766f
00115f 0065          .db "cmove",0
001160 1150          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
001161 1162          .dw PFA_CMOVE
                 PFA_CMOVE:
001162 93bf          push xh
001163 93af          push xl
001164 91e9          ld zl, Y+
001165 91f9          ld zh, Y+ ; addr-to
001166 91a9          ld xl, Y+
001167 91b9          ld xh, Y+ ; addr-from
001168 2f09          mov temp0, tosh
001169 2b08          or temp0, tosl
00116a f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
00116b 911d          ld temp1, X+
00116c 9311          st Z+, temp1
00116d 9701          sbiw tosl, 1
00116e f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
00116f 91af          pop xl
001170 91bf          pop xh
001171 9189
001172 9199          loadtos
001173 940c 011f     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
001175 ff05          .dw $ff05
001176 7332
001177 6177
001178 0070          .db "2swap",0
001179 115c          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
00117a 011b          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
00117b 058e          .dw XT_ROT
00117c 05ac          .dw XT_TO_R
00117d 058e          .dw XT_ROT
00117e 05a3          .dw XT_R_FROM
00117f 04c2          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System
                 ; refills the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILLTIB:
001180 ff0a          .dw $ff0a
001181 6572
001182 6966
001183 6c6c
001184 742d
001185 6269          .db "refill-tib"
001186 1175          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
001187 011b          .dw DO_COLON
                 PFA_REFILLTIB:
                 .endif
001188 11a3          .dw XT_TIB
001189 04e2          .dw XT_DOLITERAL
00118a 005a          .dw TIB_SIZE
00118b 0ce8          .dw XT_ACCEPT
00118c 11a9          .dw XT_NUMBERTIB
00118d 052e          .dw XT_STORE
00118e 0601          .dw XT_ZERO
00118f 09d7          .dw XT_TO_IN
001190 052e          .dw XT_STORE
001191 05f8          .dw XT_TRUE ; -1
001192 04c2          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCETIB:
001193 ff0a          .dw $FF0A
001194 6f73
001195 7275
001196 6563
001197 742d
001198 6269          .db "source-tib"
001199 1180          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
00119a 011b          .dw DO_COLON
                 PFA_SOURCETIB:
                 .endif
00119b 11a3          .dw XT_TIB
00119c 11a9          .dw XT_NUMBERTIB
00119d 0526          .dw XT_FETCH
00119e 04c2          .dw XT_EXIT
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; terminal input buffer address
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TIB:
00119f ff03          .dw $ff03
0011a0 6974
0011a1 0062          .db "tib",0
0011a2 1193          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
0011a3 04f0          .dw PFA_DOVARIABLE
                 PFA_TIB:
0011a4 0287          .dw ram_tib
                 .dseg
000287           ram_tib: .byte TIB_SIZE
                 .cseg
                 .endif
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBERTIB:
0011a5 ff04          .dw $ff04
0011a6 7423
0011a7 6269          .db "#tib"
0011a8 119f          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
0011a9 04f0          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
0011aa 02e1          .dw ram_sharptib
                 .dseg
0002e1           ram_sharptib: .byte 2
                 .cseg
                 .endif
                 
                 .include "words/init-ram.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
0011ab ff06        .dw $ff06
0011ac 6565
0011ad 723e
0011ae 6d61        .db "ee>ram"
0011af 11a5        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
0011b0 011b        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
0011b1 0601          .dw XT_ZERO
0011b2 0748          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
0011b3 057c          .dw XT_OVER
0011b4 0802          .dw XT_FETCHE
0011b5 057c          .dw XT_OVER
0011b6 052e          .dw XT_STORE
0011b7 09b6          .dw XT_CELLPLUS
0011b8 0571          .dw XT_SWAP
0011b9 09b6          .dw XT_CELLPLUS
0011ba 0571          .dw XT_SWAP
0011bb 0776          .dw XT_DOLOOP
0011bc 11b3          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
0011bd 09c7          .dw XT_2DROP
0011be 04c2          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INIT_RAM:
0011bf ff08        .dw $ff08
0011c0 6e69
0011c1 7469
0011c2 722d
0011c3 6d61        .db "init-ram"
0011c4 11ab        .dw VE_HEAD
                   .set VE_HEAD = VE_INIT_RAM
                 XT_INIT_RAM:
0011c5 011b        .dw DO_COLON
                 PFA_INI_RAM:          ; ( -- )
0011c6 04e2          .dw XT_DOLITERAL
0011c7 00a8          .dw EE_INITUSER
0011c8 07af          .dw XT_UP_FETCH
0011c9 04e2          .dw XT_DOLITERAL
0011ca 0024          .dw SYSUSERSIZE
0011cb 06b1          .dw XT_2SLASH
0011cc 11b0          .dw XT_EE2RAM
0011cd 04c2          .dw XT_EXIT
                 
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
0011ce ff06          .dw $ff06
0011cf 6f62
0011d0 6e75
0011d1 7364          .db "bounds"
0011d2 11bf          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
0011d3 011b          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
0011d4 057c          .dw XT_OVER
0011d5 064a          .dw XT_PLUS
0011d6 0571          .dw XT_SWAP
0011d7 04c2          .dw XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
0011d8 ff03          .dw $ff03
0011d9 3e73
0011da 0064          .db "s>d",0
0011db 11ce          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
0011dc 011b          .dw DO_COLON
                 PFA_S2D:
                 .endif
0011dd 055e          .dw XT_DUP
0011de 05cc          .dw XT_ZEROLESS
0011df 04c2          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
0011e0 ff05          .dw $ff05
0011e1 623e
0011e2 646f
0011e3 0079          .db ">body",0
0011e4 11d8          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
0011e5 06dd          .dw PFA_1PLUS
                 
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
0011e6 ff0b          .dw $ff0b
0011e7 6573
0011e8 2d74
0011e9 7563
0011ea 7272
0011eb 6e65
0011ec 0074          .db "set-current",0
0011ed 11e0          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
0011ee 011b          .dw DO_COLON
                 PFA_SET_CURRENT:
0011ef 04e2          .dw XT_DOLITERAL
0011f0 0084          .dw CFG_CURRENT
0011f1 07de          .dw XT_STOREE
0011f2 04c2          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
0011f3 ff08          .dw $ff08
0011f4 6f77
0011f5 6472
0011f6 696c
0011f7 7473          .db "wordlist"
0011f8 11e6          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
0011f9 011b          .dw DO_COLON
                 PFA_WORDLIST:
0011fa 0a10          .dw XT_EHERE
0011fb 0601          .dw XT_ZERO
0011fc 057c          .dw XT_OVER
0011fd 07de          .dw XT_STOREE
0011fe 055e          .dw XT_DUP
0011ff 09b6          .dw XT_CELLPLUS
001200 100e          .dw XT_DOTO
001201 0a11          .dw PFA_EHERE
001202 04c2          .dw XT_EXIT
                 
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTHWORDLIST:
001203 ff0e          .dw $ff0e
001204 6f66
001205 7472
001206 2d68
001207 6f77
001208 6472
001209 696c
00120a 7473          .db "forth-wordlist"
00120b 11f3          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHWORDLIST
                 XT_FORTHWORDLIST:
00120c 04f0          .dw PFA_DOVARIABLE
                 PFA_FORTHWORDLIST:
00120d 0086          .dw CFG_FORTHWORDLIST
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
00120e ff04          .dw $ff04
00120f 6f63
001210 6564          .db "code"
001211 1203          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
001212 011b          .dw DO_COLON
                 PFA_CODE:
001213 01bb          .dw XT_DOCREATE
001214 0326          .dw XT_REVEAL
001215 0a07          .dw XT_DP
001216 1020          .dw XT_ICELLPLUS
001217 01f4          .dw XT_COMMA
001218 04c2          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
001219 ff08          .dw $ff08
00121a 6e65
00121b 2d64
00121c 6f63
00121d 6564          .db "end-code"
00121e 120e          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
00121f 011b          .dw DO_COLON
                 PFA_ENDCODE:
001220 01e9          .dw XT_COMPILE
001221 940c          .dw $940c
001222 01e9          .dw XT_COMPILE
001223 011f          .dw DO_NEXT
001224 04c2          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
001225 ff08          .dw $ff08
001226 6d28
001227 7261
001228 656b
001229 2972          .db "(marker)"
00122a 1219          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
00122b 051d          .dw PFA_DOVALUE1
                 PFA_MARKER:
00122c 00a6          .dw EE_MARKER
00122d 1029          .dw XT_EDEFERFETCH
00122e 1033          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
00122f 0008          .dw $0008
001230 6f70
001231 7473
001232 6f70
001233 656e          .db "postpone"
001234 1225          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
001235 011b          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
001236 0e18          .dw XT_PARSENAME
001237 0f38          .dw XT_FORTHRECOGNIZER
001238 0f43          .dw XT_RECOGNIZE
001239 055e          .dw XT_DUP
00123a 05ac          .dw XT_TO_R
00123b 1020          .dw XT_ICELLPLUS
00123c 1020          .dw XT_ICELLPLUS
00123d 0835          .dw XT_FETCHI
00123e 04cc          .dw XT_EXECUTE
00123f 05a3          .dw XT_R_FROM
001240 1020          .dw XT_ICELLPLUS
001241 0835          .dw XT_FETCHI
001242 01f4          .dw XT_COMMA
001243 04c2          .dw XT_EXIT
                 .endif
                 .include "dict/interrupt.inc"
                 
                 .if WANT_INTERRUPTS == 1
                 
                 .if WANT_INTERRUPT_COUNTERS == 1
                   .include "words/irqcnt.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_IRQCNTADDR:
001244 ff06          .dw $ff06
001245 7269
001246 5b71
001247 235d          .db "irq[]#"
001248 122f          .dw VE_HEAD
                     .set VE_HEAD = VE_IRQCNTADDR
                 XT_IRQCNTADDR:
001249 011b          .dw DO_COLON
                 PFA_IRQCNTADDR:
00124a 04e2          .dw XT_DOLITERAL
00124b 0212          .dw intcnt
00124c 064a          .dw XT_PLUS
00124d 04c2          .dw XT_EXIT
                   .include "words/int-num.asm"
                 
                 ; Interrupt
                 ; number of interrupt vectors (0 based)
                 VE_NUMINT:
00124e ff04          .dw $ff04
00124f 6923
001250 746e          .db "#int"
001251 1244          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMINT
                 XT_NUMINT:
001252 04f0          .dw PFA_DOVARIABLE
                 PFA_NUMINT:
001253 0039          .dw INTVECTORS
                 .endif
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
001254 ff04          .dw $ff04
001255 692b
001256 746e          .db "+int"
001257 124e          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
001258 1259          .dw PFA_INTON
                 PFA_INTON:
001259 9478          sei
00125a 940c 011f     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
00125c ff04          .dw $ff04
00125d 692d
00125e 746e          .db "-int"
00125f 1254          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
001260 1261          .dw PFA_INTOFF
                 PFA_INTOFF:
001261 94f8          cli
001262 940c 011f     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
001264 ff04          .dw $ff04
001265 6e69
001266 2174          .db "int!"
001267 125c          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
001268 011b          .dw DO_COLON
                 PFA_INTSTORE:
001269 04e2          .dw XT_DOLITERAL
00126a 0000          .dw intvec
00126b 064a          .dw XT_PLUS
00126c 07de          .dw XT_STOREE
00126d 04c2          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
00126e ff04          .dw $ff04
00126f 6e69
001270 4074          .db "int@"
001271 1264          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
001272 011b          .dw DO_COLON
                 PFA_INTFETCH:
001273 04e2          .dw XT_DOLITERAL
001274 0000          .dw intvec
001275 064a          .dw XT_PLUS
001276 0802          .dw XT_FETCHE
001277 04c2          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
001278 ff08          .dw $ff08
001279 6e69
00127a 2d74
00127b 7274
00127c 7061          .db "int-trap"
00127d 126e          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
00127e 127f          .dw PFA_INTTRAP
                 PFA_INTTRAP:
00127f 2eb8          mov isrflag, tosl
001280 9189
001281 9199          loadtos
001282 940c 011f     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
001284 011b          .dw DO_COLON
                 PFA_ISREXEC:
001285 1272          .dw XT_INTFETCH
001286 04cc          .dw XT_EXECUTE
001287 1289          .dw XT_ISREND
001288 04c2          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
001289 128a          .dw PFA_ISREND
                 PFA_ISREND:
00128a d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
00128b 940c 011f     jmp_ DO_NEXT
                 PFA_ISREND1:
00128d 9518          reti
                 .endif
                 .elif AMFORTH_NRWW_SIZE>4000
                 .elif AMFORTH_NRWW_SIZE>2000
                 .else
                 .endif
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 
                 .set DPSTART = pc
                 .set flashlast = pc
                 
                 .dseg
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000072 ff ff     
                 ; some configs
000074 8e 12     CFG_DP:      .dw DPSTART         ; Dictionary Pointer
000076 e3 02     EE_HERE:     .dw HERESTART       ; Memory Allocation
000078 ce 00     EE_EHERE:    .dw EHERESTART      ; EEProm Memory Allocation
00007a 5b 04     CFG_WLSCOPE: .dw XT_GET_CURRENT  ; default wordlist scope
00007c 9a 00     CFG_FORTHRECOGNIZER: .dw CFG_RECOGNIZERLISTLEN ; Recognizer word set
                 ; LEAVE stack is between data stack and return stack.
00007e b0 21     CFG_LP0:     .dw stackstart+1
000080 ac 04     CFG_TURNKEY: .dw XT_APPLTURNKEY    ; TURNKEY
000082 8a 09     CFG_ENVIRONMENT:.dw VE_ENVHEAD     ; environmental queries
000084 86 00     CFG_CURRENT: .dw CFG_FORTHWORDLIST ; forth-wordlist
000086 78 12     CFG_FORTHWORDLIST:.dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
000088 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
00008a 86 00         .dw CFG_FORTHWORDLIST      ; get/set-order
00008c               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
00009a 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
00009c 95 0f         .dw XT_REC_FIND
00009e 81 0f         .dw XT_REC_NUM
0000a0               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_STOREI:
0000a4 1e 08         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
0000a6 a6 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
0000a8 00 00         .dw 0  ; USER_STATE
0000aa 00 00         .dw 0  ; USER_FOLLOWER
0000ac ff 21         .dw rstackstart  ; USER_RP
0000ae af 21         .dw stackstart   ; USER_SP0
0000b0 af 21         .dw stackstart   ; USER_SP
                     
0000b2 00 00         .dw 0  ; USER_HANDLER
0000b4 0a 00         .dw 10 ; USER_BASE
                     
0000b6 e1 00         .dw XT_TX  ; USER_EMIT
0000b8 ef 00         .dw XT_TXQ ; USER_EMITQ
0000ba b6 00         .dw XT_RX  ; USER_KEY
0000bc d1 00         .dw XT_RXQ ; USER_KEYQ
0000be 9a 11         .dw XT_SOURCETIB ; USER_SOURCE
0000c0 00 00         .dw 0            ; USER_G_IN
0000c2 87 11         .dw XT_REFILLTIB ; USER_REFILL  
0000c4 4e 0e         .dw XT_DEFAULT_PROMPTOK
0000c6 6d 0e         .dw XT_DEFAULT_PROMPTERROR
0000c8 5d 0e         .dw XT_DEFAULT_PROMPTREADY
0000ca 88 0e         .dw XT_DEFAULT_PROMPTINPUT
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
0000cc 17 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega2561" register use summary:
r0 :  26 r1 :   5 r2 :  10 r3 :  12 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   7 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  77 r17:  57 r18:  52 r19:  37 r20:  13 r21:  38 r22:  11 r23:   4 
r24: 187 r25: 132 r26:  28 r27:  17 r28:   7 r29:   4 r30:  81 r31:  41 
x  :   4 y  : 201 z  :  41 
Registers used: 29 out of 35 (82.9%)

"ATmega2561" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  22 add   :  17 adiw  :  17 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   2 brcs  :   1 break :   0 breq  :   7 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  13 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   1 cbi   :   0 cbr   :   0 
clc   :   1 clh   :   0 cli   :   5 cln   :   0 clr   :  21 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  14 cp    :  11 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :  10 eicall:   1 eijmp :   0 elpm  :  16 
eor   :   3 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 
in    :  14 inc   :   3 jmp   :  12 ld    : 134 ldd   :   4 ldi   :  31 
lds   :   1 lpm   :   0 lsl   :  14 lsr   :   2 mov   :  15 movw  :  66 
mul   :   5 muls  :   1 mulsu :   2 neg   :   0 nop   :   1 or    :   9 
ori   :   0 out   :  26 pop   :  47 push  :  39 rcall :  69 ret   :   6 
reti  :   1 rjmp  :  99 rol   :  32 ror   :   5 sbc   :   9 sbci  :   3 
sbi   :   3 sbic  :   3 sbis  :   0 sbiw  :   7 sbr   :   0 sbrc  :   4 
sbrs  :   3 sec   :   1 seh   :   0 sei   :   1 sen   :   0 ser   :   3 
ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 spm   :   2 
st    :  74 std   :   8 sts   :   1 sub   :   6 subi  :   3 swap  :   0 
tst   :   1 wdr   :   0 
Instructions used: 72 out of 116 (62.1%)

"ATmega2561" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x03e07e   1974  12846  14820  262144   5.7%
[.dseg] 0x000200 0x0002e3      0    227    227    8192   2.8%
[.eseg] 0x000000 0x0000ce      0    206    206    4096   5.0%

Assembly complete, 0 errors, 8 warnings
