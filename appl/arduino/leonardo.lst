
AVRASM ver. 2.1.52  leonardo.asm Sun Oct 18 18:22:40 2020

leonardo.asm(5): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega32u4\device.asm'
../../avr8/devices/atmega32u4\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m32U4def.inc'
leonardo.asm(13): Including file '../../avr8\drivers/usart_1.asm'
../../avr8\drivers/usart_1.asm(31): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(11): Including file '../../avr8\drivers/usart-rx-buffer.asm'
../../avr8\drivers/usart_common.asm(24): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(29): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(30): Including file '../../avr8\words/usart.asm'
leonardo.asm(15): Including file '../../avr8\amforth.asm'
../../avr8\amforth.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth.asm(14): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(7): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/rww.inc(12): Including file '../../avr8\dict/appl_4k.inc'
../../avr8\dict/appl_4k.inc(1): Including file '../../common\words/ver.asm'
../../avr8\dict/appl_4k.inc(5): Including file '../../avr8\words/unused.asm'
../../avr8\dict/appl_4k.inc(6): Including file '../../common\words/to.asm'
../../avr8\dict/appl_4k.inc(7): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/appl_4k.inc(8): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/appl_4k.inc(9): Including file '../../common\words/star.asm'
../../avr8\dict/appl_4k.inc(10): Including file '../../avr8\words/j.asm'
../../avr8\dict/appl_4k.inc(11): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/appl_4k.inc(12): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/appl_4k.inc(13): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/appl_4k.inc(14): Including file '../../common\words/2swap.asm'
../../avr8\dict/appl_4k.inc(15): Including file '../../common\words/tib.asm'
../../avr8\dict/appl_4k.inc(16): Including file '../../avr8\words/init-ram.asm'
../../avr8\dict/appl_4k.inc(20): Including file '../../avr8\words/environment.asm'
../../avr8\dict/appl_4k.inc(21): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/appl_4k.inc(22): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/appl_4k.inc(23): Including file '../../common\words/env-slashhold.asm'
../../avr8\dict/appl_4k.inc(24): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/appl_4k.inc(25): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/appl_4k.inc(26): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/appl_4k.inc(27): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/appl_4k.inc(28): Including file '../../common\words/env-usersize.asm'
../../avr8\dict/appl_4k.inc(30): Including file '../../avr8\words/hld.asm'
../../avr8\dict/appl_4k.inc(31): Including file '../../common\words/hold.asm'
../../avr8\dict/appl_4k.inc(32): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/appl_4k.inc(33): Including file '../../common\words/sharp.asm'
../../avr8\dict/appl_4k.inc(34): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/appl_4k.inc(35): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/appl_4k.inc(36): Including file '../../common\words/sign.asm'
../../avr8\dict/appl_4k.inc(37): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/appl_4k.inc(38): Including file '../../common\words/dot-r.asm'
../../avr8\dict/appl_4k.inc(39): Including file '../../common\words/d-dot.asm'
../../avr8\dict/appl_4k.inc(40): Including file '../../common\words/dot.asm'
../../avr8\dict/appl_4k.inc(41): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/appl_4k.inc(42): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/appl_4k.inc(43): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/appl_4k.inc(44): Including file '../../common\words/digit-q.asm'
../../avr8\dict/appl_4k.inc(46): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/appl_4k.inc(47): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/appl_4k.inc(48): Including file '../../avr8\words/itype.asm'
../../avr8\dict/appl_4k.inc(49): Including file '../../avr8\words/icount.asm'
../../avr8\dict/appl_4k.inc(50): Including file '../../common\words/type.asm'
../../avr8\dict/appl_4k.inc(51): Including file '../../common\words/tick.asm'
../../avr8\dict/appl_4k.inc(53): Including file '../../common\words/cskip.asm'
../../avr8\dict/appl_4k.inc(54): Including file '../../common\words/cscan.asm'
../../avr8\dict/appl_4k.inc(55): Including file '../../common\words/accept.asm'
../../avr8\dict/appl_4k.inc(56): Including file '../../common\words/refill.asm'
../../avr8\dict/appl_4k.inc(57): Including file '../../common\words/char.asm'
../../avr8\dict/appl_4k.inc(58): Including file '../../common\words/number.asm'
../../avr8\dict/appl_4k.inc(59): Including file '../../common\words/q-sign.asm'
../../avr8\dict/appl_4k.inc(60): Including file '../../common\words/set-base.asm'
../../avr8\dict/appl_4k.inc(61): Including file '../../common\words/to-number.asm'
../../avr8\dict/appl_4k.inc(62): Including file '../../common\words/parse.asm'
../../avr8\dict/appl_4k.inc(63): Including file '../../common\words/source.asm'
../../avr8\dict/appl_4k.inc(64): Including file '../../common\words/slash-string.asm'
../../avr8\dict/appl_4k.inc(65): Including file '../../common\words/parse-name.asm'
../../avr8\dict/appl_4k.inc(66): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/appl_4k.inc(67): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/appl_4k.inc(68): Including file '../../common\words/depth.asm'
../../avr8\dict/appl_4k.inc(69): Including file '../../avr8\words/forth-recognizer.asm'
../../avr8\dict/appl_4k.inc(70): Including file '../../common\words/recognize.asm'
../../avr8\dict/appl_4k.inc(71): Including file '../../common\words/interpret.asm'
../../avr8\dict/appl_4k.inc(72): Including file '../../common\words/rec-intnum.asm'
../../avr8\dict/appl_4k.inc(73): Including file '../../common\words/rec-find.asm'
../../avr8\dict/appl_4k.inc(74): Including file '../../common\words/rec-null.asm'
../../avr8\dict/appl_4k.inc(75): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/appl_4k.inc(76): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/appl_4k.inc(77): Including file '../../common\words/name2string.asm'
../../avr8\dict/appl_4k.inc(78): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/appl_4k.inc(79): Including file '../../common\words/find-xt.asm'
../../avr8\dict/appl_4k.inc(81): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/newest.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/do-create.asm'
../../avr8\dict/compiler1.inc(5): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(9): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(10): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(17): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(33): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(38): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../common\words/create.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../common\words/reveal.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(53): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../common\words/recurse.asm'
../../avr8\dict/compiler1.inc(56): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(61): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(67): Including file '../../common\words/cfg-order.asm'
../../avr8\dict/compiler1.inc(68): Including file '../../common\words/cfg-recognizer.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(70): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\dict/appl_4k.inc(82): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/irqcnt.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-num.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(10): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(11): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(12): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(13): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(15): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(16): Including file '../../avr8\words/isr-end.asm'
../../avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(4): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../common\words/postpone.asm'
dict_appl.inc(6): Including file 'words/applturnkey.asm'
../../avr8\amforth.asm(23): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth.asm(24): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(35): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(36): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(42): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(45): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(46): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(49): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(56): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(63): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../common\words/q-negate.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(89): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(95): Including file '../../avr8\words/store-i_nrww.asm'
../../avr8\dict/nrww.inc(97): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(98): Including file '../../common\words/2literal.asm'
../../avr8\dict/nrww.inc(99): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(100): Including file '../../common\words/num-constants.asm'
../../avr8\dict/nrww.inc(105): Including file '../../avr8\dict/core_4k.inc'
../../avr8\dict/core_4k.inc(3): Including file '../../avr8\words/n_to_r.asm'
../../avr8\dict/core_4k.inc(4): Including file '../../avr8\words/n_r_from.asm'
../../avr8\dict/core_4k.inc(5): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/core_4k.inc(6): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/core_4k.inc(7): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/core_4k.inc(8): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/core_4k.inc(9): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/core_4k.inc(10): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/core_4k.inc(11): Including file '../../common\words/abs.asm'
../../avr8\dict/core_4k.inc(12): Including file '../../common\words/pick.asm'
../../avr8\dict/core_4k.inc(13): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/core_4k.inc(16): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/core_4k.inc(17): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/core_4k.inc(18): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/core_4k.inc(19): Including file '../../common\words/prompt-input.asm'
../../avr8\dict/core_4k.inc(20): Including file '../../common\words/quit.asm'
../../avr8\dict/core_4k.inc(21): Including file '../../avr8\words/pause.asm'
../../avr8\dict/core_4k.inc(22): Including file '../../avr8\words/cold.asm'
../../avr8\dict/core_4k.inc(23): Including file '../../common\words/warm.asm'
../../avr8\dict/core_4k.inc(25): Including file '../../common\words/handler.asm'
../../avr8\dict/core_4k.inc(26): Including file '../../common\words/catch.asm'
../../avr8\dict/core_4k.inc(27): Including file '../../common\words/throw.asm'
../../avr8\dict/core_4k.inc(30): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/core_4k.inc(31): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/core_4k.inc(32): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/core_4k.inc(33): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/core_4k.inc(34): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/core_4k.inc(35): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/core_4k.inc(36): Including file '../../common\words/defer-store.asm'
../../avr8\dict/core_4k.inc(37): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/core_4k.inc(38): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/core_4k.inc(40): Including file '../../common\words/u-dot.asm'
../../avr8\dict/core_4k.inc(41): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/core_4k.inc(44): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/core_4k.inc(45): Including file '../../avr8\words/negate.asm'
../../avr8\dict/core_4k.inc(46): Including file '../../common\words/slash.asm'
../../avr8\dict/core_4k.inc(47): Including file '../../common\words/mod.asm'
../../avr8\dict/core_4k.inc(49): Including file '../../common\words/min.asm'
../../avr8\dict/core_4k.inc(50): Including file '../../common\words/max.asm'
../../avr8\dict/core_4k.inc(51): Including file '../../common\words/within.asm'
../../avr8\dict/core_4k.inc(53): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/core_4k.inc(54): Including file '../../common\words/words.asm'
../../avr8\dict/core_4k.inc(56): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/core_4k.inc(57): Including file '../../common\words/squote.asm'
../../avr8\dict/core_4k.inc(58): Including file '../../avr8\words/fill.asm'
../../avr8\dict/core_4k.inc(60): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/core_4k.inc(61): Including file '../../avr8\words/state.asm'
../../avr8\dict/core_4k.inc(62): Including file '../../common\words/base.asm'
../../avr8\dict/core_4k.inc(64): Including file '../../avr8\words/cells.asm'
../../avr8\dict/core_4k.inc(66): Including file '../../common\words/2dup.asm'
../../avr8\dict/core_4k.inc(67): Including file '../../common\words/2drop.asm'
../../avr8\dict/core_4k.inc(68): Including file '../../common\words/tuck.asm'
../../avr8\dict/core_4k.inc(70): Including file '../../common\words/to-in.asm'
../../avr8\dict/core_4k.inc(71): Including file '../../common\words/pad.asm'
../../avr8\dict/core_4k.inc(72): Including file '../../common\words/emit.asm'
../../avr8\dict/core_4k.inc(73): Including file '../../common\words/emitq.asm'
../../avr8\dict/core_4k.inc(74): Including file '../../common\words/key.asm'
../../avr8\dict/core_4k.inc(75): Including file '../../common\words/keyq.asm'
../../avr8\dict/core_4k.inc(77): Including file '../../avr8\words/dp.asm'
../../avr8\dict/core_4k.inc(78): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/core_4k.inc(79): Including file '../../avr8\words/here.asm'
../../avr8\dict/core_4k.inc(80): Including file '../../avr8\words/allot.asm'
../../avr8\dict/core_4k.inc(82): Including file '../../common\words/bin.asm'
../../avr8\dict/core_4k.inc(83): Including file '../../common\words/decimal.asm'
../../avr8\dict/core_4k.inc(84): Including file '../../common\words/hex.asm'
../../avr8\dict/core_4k.inc(85): Including file '../../common\words/bl.asm'
../../avr8\dict/core_4k.inc(87): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/core_4k.inc(88): Including file '../../common\words/to-upper.asm'
../../avr8\dict/core_4k.inc(89): Including file '../../common\words/to-lower.asm'
../../avr8\dict/core_4k.inc(91): Including file '../../common\words/q-stack.asm'
../../avr8\dict/core_4k.inc(92): Including file '../../common\words/bounds.asm'
../../avr8\dict/core_4k.inc(93): Including file '../../common\words/cr.asm'
../../avr8\dict/core_4k.inc(94): Including file '../../common\words/space.asm'
../../avr8\dict/core_4k.inc(95): Including file '../../common\words/spaces.asm'
../../avr8\dict/core_4k.inc(96): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/core_4k.inc(97): Including file '../../avr8\words/to-body.asm'
../../avr8\dict/core_4k.inc(98): Including file '../../common\words/noop.asm'
../../avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
../../avr8\amforth.asm(36): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; file see ../template/template.asm. You may want to
                 ; copy that file to this one and edit it afterwards.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set USER_P_OK    = 28
                 .set USER_P_ERR   = 30
                 .set USER_P_RDY   = 32
                 .set USER_P_INPUT = 34
                 
                 .set SYSUSERSIZE = 36
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot = r10
                   .def isrflag  = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  256
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	lsl zl
                 	rol zh
                 	lpm @0, Z+
                 	lpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	lsl zl
                 	rol zh
                 .endmacro
                 .set WANT_WATCHDOG = 0
                 .set WANT_PORTD = 0
                 .set WANT_SPI = 0
                 .set WANT_USART1 = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_3 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_JTAG = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_TIMER_COUNTER_4 = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTE = 0
                 .set WANT_PORTF = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_CPU = 0
                 .set WANT_PLL = 0
                 .set WANT_USB_DEVICE = 0
                 .equ intvecsize = 2 ; please verify; flash size: 32768 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d0fc      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d0fa      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d0f8      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d0f6      	 rcall isr ; External Interrupt Request 3
                 .org 10
00000a d0f4      	 rcall isr ; Reserved1
                 .org 12
00000c d0f2      	 rcall isr ; Reserved2
                 .org 14
00000e d0f0      	 rcall isr ; External Interrupt Request 6
                 .org 16
000010 d0ee      	 rcall isr ; Reserved3
                 .org 18
000012 d0ec      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 20
000014 d0ea      	 rcall isr ; USB General Interrupt Request
                 .org 22
000016 d0e8      	 rcall isr ; USB Endpoint/Pipe Interrupt Communication Request
                 .org 24
000018 d0e6      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 26
00001a d0e4      	 rcall isr ; Reserved4
                 .org 28
00001c d0e2      	 rcall isr ; Reserved5
                 .org 30
00001e d0e0      	 rcall isr ; Reserved6
                 .org 32
000020 d0de      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 34
000022 d0dc      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 36
000024 d0da      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 38
000026 d0d8      	 rcall isr ; Timer/Counter1 Compare Match C
                 .org 40
000028 d0d6      	 rcall isr ; Timer/Counter1 Overflow
                 .org 42
00002a d0d4      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 44
00002c d0d2      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 46
00002e d0d0      	 rcall isr ; Timer/Counter0 Overflow
                 .org 48
000030 d0ce      	 rcall isr ; SPI Serial Transfer Complete
                 .org 50
000032 d0cc      	 rcall isr ; USART1, Rx Complete
                 .org 52
000034 d0ca      	 rcall isr ; USART1 Data register Empty
                 .org 54
000036 d0c8      	 rcall isr ; USART1, Tx Complete
                 .org 56
000038 d0c6      	 rcall isr ; Analog Comparator
                 .org 58
00003a d0c4      	 rcall isr ; ADC Conversion Complete
                 .org 60
00003c d0c2      	 rcall isr ; EEPROM Ready
                 .org 62
00003e d0c0      	 rcall isr ; Timer/Counter3 Capture Event
                 .org 64
000040 d0be      	 rcall isr ; Timer/Counter3 Compare Match A
                 .org 66
000042 d0bc      	 rcall isr ; Timer/Counter3 Compare Match B
                 .org 68
000044 d0ba      	 rcall isr ; Timer/Counter3 Compare Match C
                 .org 70
000046 d0b8      	 rcall isr ; Timer/Counter3 Overflow
                 .org 72
000048 d0b6      	 rcall isr ; 2-wire Serial Interface        
                 .org 74
00004a d0b4      	 rcall isr ; Store Program Memory Read
                 .org 76
00004c d0b2      	 rcall isr ; Timer/Counter4 Compare Match A
                 .org 78
00004e d0b0      	 rcall isr ; Timer/Counter4 Compare Match B
                 .org 80
000050 d0ae      	 rcall isr ; Timer/Counter4 Compare Match D
                 .org 82
000052 d0ac      	 rcall isr ; Timer/Counter4 Overflow
                 .org 84
000054 d0aa      	 rcall isr ; Timer/Counter4 Fault Protection Interrupt
                 .equ INTVECTORS = 43
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000055 0a00      	.dw 2560
                 mcu_eepromsize:
000056 0400      	.dw 1024
                 mcu_maxdp:
000057 7000      	.dw 28672 
                 mcu_numints:
000058 002b      	.dw 43
                 mcu_name:
000059 000a      	.dw 10
00005a 5441
00005b 656d
00005c 6167
00005d 3233
00005e 3455      	.db "ATmega32U4"
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 ; enabling Interrupts, disabling them affects
                 ; other settings as well. 
                 .set WANT_INTERRUPTS = 1
                 
                 ; count the number of interrupts individually.
                 ; requires a lot of RAM (one byte per interrupt)
                 ; disabled by default.
                 .set WANT_INTERRUPT_COUNTERS = 1
                 
                 ; receiving is asynchronously, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIB_SIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 ; letters the same. Set to 0 if you do not want it
                 .set WANT_IGNORECASE = 1
                 
                 ; cpu clock in hertz
                 .equ F_CPU = 16000000
                 
                 .include "drivers/usart_1.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR1H
                   .equ USART_C = UCSR1C
                   .equ USART_B = UCSR1B
                   .equ USART_A = UCSR1A
                   .equ USART_DATA = UDR1
                 
                 .equ URXCaddr = URXC1addr
                 .equ UDREaddr = UDRE1addr
                 
                 .equ bm_USART_RXRD = 1 << RXC1
                 .equ bm_USART_TXRD = 1 << UDRE1
                 .equ bm_ENABLE_TX  = 1 << TXEN1
                 .equ bm_ENABLE_RX  = 1 << RXEN1
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE1
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE1
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_INTERRUPTS == 0
                   .if WANT_ISR_RX == 1
                   .endif
                 .endif
                 
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-rx-buffer.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000100            usart_rx_data: .byte usart_rx_size
000110            usart_rx_in:   .byte 1
000111            usart_rx_out:  .byte 1
                 .cseg
                 
                 VE_TO_RXBUF:
00005f ff07          .dw $ff07
000060 723e
000061 2d78
000062 7562
000063 0066          .db ">rx-buf",0
000064 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_RXBUF
                 XT_TO_RXBUF:
000065 0066          .dw PFA_rx_tobuf
                 PFA_rx_tobuf:
000066 2f08          mov temp0, tosl
000067 9110 0110     lds temp1, usart_rx_in
000069 e0e0          ldi zl, low(usart_rx_data)
00006a e0f1          ldi zh, high(usart_rx_data)
00006b 0fe1          add zl, temp1
00006c 1df3          adc zh, zeroh
00006d 8300          st Z, temp0
00006e 9513          inc temp1
00006f 701f          andi temp1,usart_rx_mask
000070 9310 0110     sts usart_rx_in, temp1
000072 9189
000073 9199          loadtos
000074 940c 3804     jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; setup with
                 ; ' isr-rx URXCaddr int!
                 VE_ISR_RX:
000076 ff06          .dw $ff06
000077 7369
000078 2d72
000079 7872          .db "isr-rx"
00007a 005f          .dw VE_HEAD
                     .set VE_HEAD = VE_ISR_RX
                 XT_ISR_RX:
00007b 3800          .dw DO_COLON
                 usart_rx_isr:
00007c 383c        .dw XT_DOLITERAL
00007d 00ce        .dw usart_data
00007e 3897        .dw XT_CFETCH
00007f 38b0        .dw XT_DUP
000080 383c        .dw XT_DOLITERAL
000081 0003        .dw 3
000082 3bd5        .dw XT_EQUAL
000083 3835        .dw XT_DOCONDBRANCH
000084 0086        .dw usart_rx_isr1
000085 3d25        .dw XT_COLD
                 usart_rx_isr1:
000086 0065        .dw XT_TO_RXBUF
000087 381f        .dw XT_EXIT
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RXBUFFER:
                 ;  .dw $ff0x
                 ;  .db "+usart-buffer"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RXBUFFER
                 XT_USART_INIT_RX_BUFFER:
000088 3800        .dw DO_COLON
                 PFA_USART_INIT_RX_BUFFER:          ; ( -- )
000089 383c
00008a 007b        .dw XT_DOLITERAL, XT_ISR_RX
00008b 383c
00008c 0032        .dw XT_DOLITERAL, URXCaddr
00008d 0a46        .dw XT_INTSTORE
                 
00008e 383c        .dw XT_DOLITERAL
00008f 0100        .dw usart_rx_data
000090 383c        .dw XT_DOLITERAL
000091 0016        .dw usart_rx_size + 6
000092 3953        .dw XT_ZERO
000093 3e82        .dw XT_FILL
000094 381f        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_BUFFER:
000095 ff06          .dw $ff06
000096 7872
000097 622d
000098 6675          .db "rx-buf"
000099 0076          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_BUFFER
                 XT_RX_BUFFER:
00009a 3800          .dw DO_COLON
                 PFA_RX_BUFFER:
00009b 00b5        .dw XT_RXQ_BUFFER
00009c 3835        .dw XT_DOCONDBRANCH
00009d 009b        .dw PFA_RX_BUFFER
00009e 383c        .dw XT_DOLITERAL
00009f 0111        .dw usart_rx_out
0000a0 3897        .dw XT_CFETCH
0000a1 38b0        .dw XT_DUP
0000a2 383c        .dw XT_DOLITERAL
0000a3 0100        .dw usart_rx_data
0000a4 399c        .dw XT_PLUS
0000a5 3897        .dw XT_CFETCH
0000a6 38c3        .dw XT_SWAP
0000a7 3a2e        .dw XT_1PLUS
0000a8 383c        .dw XT_DOLITERAL
0000a9 000f        .dw usart_rx_mask
0000aa 3a12        .dw XT_AND
0000ab 383c        .dw XT_DOLITERAL
0000ac 0111        .dw usart_rx_out
0000ad 388c        .dw XT_CSTORE
0000ae 381f        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue
                 VE_RXQ_BUFFER:
0000af ff07          .dw $ff07
0000b0 7872
0000b1 2d3f
0000b2 7562
0000b3 0066          .db "rx?-buf",0
0000b4 0095          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_BUFFER
                 XT_RXQ_BUFFER:
0000b5 3800          .dw DO_COLON
                 PFA_RXQ_BUFFER:
0000b6 3d1d        .dw XT_PAUSE
0000b7 383c        .dw XT_DOLITERAL
0000b8 0111        .dw usart_rx_out
0000b9 3897        .dw XT_CFETCH
0000ba 383c        .dw XT_DOLITERAL
0000bb 0110        .dw usart_rx_in
0000bc 3897        .dw XT_CFETCH
0000bd 3910        .dw XT_NOTEQUAL
0000be 381f        .dw XT_EXIT
                 ;  .include "drivers/timer-usart-isr.asm"
                   .set XT_RX  = XT_RX_BUFFER
                   .set XT_RXQ = XT_RXQ_BUFFER
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_BUFFER
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
0000bf ff07          .dw $ff07
0000c0 7874
0000c1 702d
0000c2 6c6f
0000c3 006c          .db "tx-poll",0
0000c4 00af          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
0000c5 3800          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
0000c6 00d3        .dw XT_TXQ_POLL
0000c7 3835        .dw XT_DOCONDBRANCH
0000c8 00c6        .dw PFA_TX_POLL
                   ; send to usart
0000c9 383c        .dw XT_DOLITERAL
0000ca 00ce        .dw USART_DATA
0000cb 388c        .dw XT_CSTORE
0000cc 381f        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
0000cd ff08          .dw $ff08
0000ce 7874
0000cf 2d3f
0000d0 6f70
0000d1 6c6c          .db "tx?-poll"
0000d2 00bf          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000d3 3800          .dw DO_COLON
                 PFA_TXQ_POLL:
0000d4 3d1d        .dw XT_PAUSE
0000d5 383c        .dw XT_DOLITERAL
0000d6 00c8        .dw USART_A
0000d7 3897        .dw XT_CFETCH
0000d8 383c        .dw XT_DOLITERAL
0000d9 0020        .dw bm_USART_TXRD
0000da 3a12        .dw XT_AND
0000db 381f        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000dc ff04        .dw $ff04
0000dd 6275
0000de 7272        .db "ubrr"
0000df 00cd        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000e0 386e        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000e1 00b0        .dw EE_UBRRVAL
0000e2 3d8a        .dw XT_EDEFERFETCH
0000e3 3d94        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
0000e4 ff06        .dw $ff06
0000e5 752b
0000e6 6173
0000e7 7472        .db "+usart"
0000e8 00dc        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
0000e9 3800        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
0000ea 383c        .dw XT_DOLITERAL
0000eb 0098        .dw USART_B_VALUE
0000ec 383c        .dw XT_DOLITERAL
0000ed 00c9        .dw USART_B
0000ee 388c        .dw XT_CSTORE
                 
0000ef 383c        .dw XT_DOLITERAL
0000f0 0006        .dw USART_C_VALUE
0000f1 383c        .dw XT_DOLITERAL
0000f2 00ca        .dw USART_C | bm_USARTC_en
0000f3 388c        .dw XT_CSTORE
                 
0000f4 00e0        .dw XT_UBRR
0000f5 38b0        .dw XT_DUP
0000f6 3af8        .dw XT_BYTESWAP
0000f7 383c        .dw XT_DOLITERAL
0000f8 00cd        .dw BAUDRATE_HIGH
0000f9 388c        .dw XT_CSTORE
0000fa 383c        .dw XT_DOLITERAL
0000fb 00cc        .dw BAUDRATE_LOW
0000fc 388c        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
0000fd 0088        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
0000fe 381f        .dw XT_EXIT
                 
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 
                 .set corepc = pc
                 .org $0000
000000 940c 3d26   jmp_ PFA_COLD
                 
                 .org corepc
                 .include "drivers/generic-isr.asm"
                 
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .if WANT_INTERRUPT_COUNTERS==1
                 .dseg
000112           intcnt: .byte INTVECTORS
                 .endif
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
0000ff 920a          st -Y, r0
000100 b60f          in r0, SREG
000101 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
000102 900f          pop r0
000103 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
000104 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
                     ; check whether isrflag is zero. if not,
                     ; there is an still unhandled interrupt pending.
000105 20bb          tst isrflag
000106 f001          breq isr_clean
                     ; there is a collision. the previous interrupt is not yet
                     ; handled by the forth inner interpreter
                 isr_clean:
000107 2cb0          mov isrflag, r0
                 .if WANT_INTERRUPT_COUNTERS==1
000108 93ff          push zh
000109 93ef          push zl
00010a e1e2          ldi zl, low(intcnt)
00010b e0f1          ldi zh, high(intcnt)
00010c 9406          lsr r0 ; we use byte addresses in the counter array, not words
00010d 0de0          add zl, r0
00010e 1df3          adc zh, zeroh
00010f 8000          ld r0, Z
000110 9403          inc r0
000111 8200          st Z, r0
000112 91ef          pop zl
000113 91ff          pop zh
                 .endif
000114 9009          ld r0, Y+
000115 be0f          out SREG, r0
000116 9009          ld r0, Y+
000117 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                     ; no reti here, see words/isr-end.asm
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000118 ff02          .dw $ff02
000119 2b6d          .db "m+"
00011a 00e4          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
00011b 3800          .dw DO_COLON
                 PFA_MPLUS:
00011c 3fb1          .dw XT_S2D
00011d 3c2b          .dw XT_DPLUS
00011e 381f          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
00011f ff03          .dw $ff03
000120 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
000121 002a          .db "ud*"
000122 0118          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
000123 3800          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
000124 38b0
000125 38fe
000126 39df
000127 38d8              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000128 38c3
000129 38f5
00012a 39df
00012b 38e0
00012c 399c
00012d 381f              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
00012e ff04          .dw $ff04
00012f 6d75
000130 7861          .db "umax"
000131 011f          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
000132 3800          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
000133 3eb3
000134 395b              .DW XT_2DUP,XT_ULESS
000135 3835      	.dw XT_DOCONDBRANCH
000136 0138      	 DEST(UMAX1)
000137 38c3              .DW XT_SWAP
000138 38d8      UMAX1:  .DW XT_DROP
000139 381f      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
00013a ff04          .dw $ff04
00013b 6d75
00013c 6e69          .db "umin"
00013d 012e          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
00013e 3800          .dw DO_COLON
                 PFA_UMIN:
                 .endif
00013f 3eb3
000140 3966              .DW XT_2DUP,XT_UGREATER
000141 3835      	.dw XT_DOCONDBRANCH
000142 0144      	DEST(UMIN1)
000143 38c3              .DW XT_SWAP
000144 38d8      UMIN1:  .DW XT_DROP
000145 381f      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; return +1 if immediate, -1 otherwise, flag from name>flags
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
000146 3800          .dw DO_COLON
                 PFA_IMMEDIATEQ:
000147 383c          .dw XT_DOLITERAL
000148 8000          .dw $8000
000149 3a12          .dw XT_AND
00014a 3917          .dw XT_ZEROEQUAL
00014b 3835          .dw XT_DOCONDBRANCH
00014c 014f          DEST(IMMEDIATEQ1)
00014d 3bdc           .dw XT_ONE
00014e 381f           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
00014f 394a          .dw XT_TRUE
000150 381f          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
000151 ff0a          .dw $ff0a
000152 616e
000153 656d
000154 663e
000155 616c
000156 7367          .db "name>flags"
000157 013a          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
000158 3800          .dw DO_COLON
                 PFA_NAME2FLAGS:
000159 3bc0          .dw XT_FETCHI ; skip to link field
00015a 383c          .dw XT_DOLITERAL
00015b ff00          .dw $ff00
00015c 3a12          .dw XT_AND
00015d 381f          .dw XT_EXIT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
00015e ff03          .dw $ff03
00015f 6d31
000160 0073          .db "1ms",0
000161 0151          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
000162 0163          .dw PFA_1MS
                 PFA_1MS:
000163 eae0
000164 e0ff
000165 9731
000166 f7f1          delay 1000
000167 940c 3804     jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .include "dict/appl_4k.inc"
                 
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
000169 ff03          .dw $ff03
00016a 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
00016b 0072          .db "ver"
00016c 015e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
00016d 3800          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
00016e 02c8          .dw XT_ENV_FORTHNAME
00016f 03f1          .dw XT_ITYPE
000170 3f98          .dw XT_SPACE
000171 3ea7          .dw XT_BASE
000172 3878          .dw XT_FETCH
                 
000173 02d6          .dw XT_ENV_FORTHVERSION
000174 3f2b          .dw XT_DECIMAL
000175 3fb1          .dw XT_S2D
000176 030f          .dw XT_L_SHARP
000177 0317          .dw XT_SHARP
000178 383c          .dw XT_DOLITERAL
000179 002e          .dw '.'
00017a 0300          .dw XT_HOLD
00017b 032d          .dw XT_SHARP_S
00017c 0338          .dw XT_SHARP_G
00017d 0427          .dw XT_TYPE
00017e 3ea7          .dw XT_BASE
00017f 3880          .dw XT_STORE
000180 3f98          .dw XT_SPACE
000181 02de          .dw XT_ENV_CPU
000182 03f1          .dw XT_ITYPE
                 
000183 381f          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
000184 ff06          .dw $ff06
000185 6e75
000186 7375
000187 6465          .db "unused"
000188 0169          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
000189 3800          .dw DO_COLON
                 PFA_UNUSED:
00018a 3a8c          .dw XT_SP_FETCH
00018b 3f0d          .dw XT_HERE
00018c 3992          .dw XT_MINUS
00018d 381f          .dw XT_EXIT
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
00018e 0002          .dw $0002
00018f 6f74          .db "to"
000190 0184          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
000191 3800          .dw DO_COLON
                 PFA_TO:
                 .endif
000192 0436          .dw XT_TICK
000193 3fba          .dw XT_TO_BODY
000194 3ea1          .dw XT_STATE
000195 3878          .dw XT_FETCH
000196 3835          .dw XT_DOCONDBRANCH
000197 01a2          DEST(PFA_TO1)
000198 0766          .dw XT_COMPILE
000199 019c          .dw XT_DOTO
00019a 0771          .dw XT_COMMA
00019b 381f          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
00019c 3800          .dw DO_COLON
                 PFA_DOTO:
                 .endif
00019d 38f5          .dw XT_R_FROM
00019e 38b0          .dw XT_DUP
00019f 01ae          .dw XT_ICELLPLUS
0001a0 38fe          .dw XT_TO_R
0001a1 3bc0          .dw XT_FETCHI
                 PFA_TO1:
0001a2 38b0          .dw XT_DUP
0001a3 01ae          .dw XT_ICELLPLUS
0001a4 01ae          .dw XT_ICELLPLUS
0001a5 3bc0          .dw XT_FETCHI
0001a6 3829          .dw XT_EXECUTE
0001a7 381f          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
0001a8 ff07          .dw $FF07
0001a9 2d69
0001aa 6563
0001ab 6c6c
0001ac 002b          .db "i-cell+",0
0001ad 018e          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
0001ae 3800          .dw DO_COLON
                 PFA_ICELLPLUS:
0001af 3a2e          .dw XT_1PLUS
0001b0 381f          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
0001b1 ff08          .dw $ff08
0001b2 6369
0001b3 6d6f
0001b4 6170
0001b5 6572          .db "icompare"
0001b6 01a8          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
0001b7 3800          .dw DO_COLON
                 PFA_ICOMPARE:
0001b8 38fe          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
0001b9 38ce          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
0001ba 38f5          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
0001bb 3910          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
0001bc 3835          .dw XT_DOCONDBRANCH
0001bd 01c2          .dw PFA_ICOMPARE_SAMELEN
0001be 3ebc            .dw XT_2DROP
0001bf 38d8            .dw XT_DROP
0001c0 394a            .dw XT_TRUE
0001c1 381f            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
0001c2 38c3          .dw XT_SWAP ; ( -- r-addr f-addr len )
0001c3 3953          .dw XT_ZERO
0001c4 0830          .dw XT_QDOCHECK
0001c5 3835          .dw XT_DOCONDBRANCH
0001c6 01e7          .dw PFA_ICOMPARE_DONE
0001c7 3a9a          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
0001c8 38ce          .dw XT_OVER
0001c9 3878          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
0001ca 01ea          .dw XT_ICOMPARE_LC
                 .endif
0001cb 38ce          .dw XT_OVER
0001cc 3bc0          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
0001cd 01ea          .dw XT_ICOMPARE_LC
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
0001ce 38b0          .dw XT_DUP
                     ;.dw XT_BYTESWAP
0001cf 383c          .dw XT_DOLITERAL
0001d0 0100          .dw $100
0001d1 395b          .dw XT_ULESS
0001d2 3835          .dw XT_DOCONDBRANCH
0001d3 01d8          .dw PFA_ICOMPARE_LASTCELL
0001d4 38c3          .dw XT_SWAP
0001d5 383c          .dw XT_DOLITERAL
0001d6 00ff          .dw $00FF
0001d7 3a12          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
0001d8 3910          .dw XT_NOTEQUAL
0001d9 3835          .dw XT_DOCONDBRANCH
0001da 01df          .dw PFA_ICOMPARE_NEXTLOOP
0001db 3ebc          .dw XT_2DROP
0001dc 394a          .dw XT_TRUE
0001dd 3ad3          .dw XT_UNLOOP
0001de 381f          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
0001df 3a2e          .dw XT_1PLUS
0001e0 38c3          .dw XT_SWAP
0001e1 3ca6          .dw XT_CELLPLUS
0001e2 38c3          .dw XT_SWAP
0001e3 383c          .dw XT_DOLITERAL
0001e4 0002          .dw 2
0001e5 3ab9          .dw XT_DOPLUSLOOP
0001e6 01c8          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
0001e7 3ebc          .dw XT_2DROP
0001e8 3953          .dw XT_ZERO
0001e9 381f          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 ; ( cc1 cc2 -- f) 
                 ; Tools
                 ; compares two packed characters 
                 ;VE_ICOMPARELC:
                 ;    .dw $ff08
                 ;    .db "icompare-lower"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ICOMPARELC
                 XT_ICOMPARE_LC:
0001ea 3800          .dw DO_COLON
                 PFA_ICOMPARE_LC:
0001eb 38b0          .dw XT_DUP
0001ec 383c          .dw XT_DOLITERAL
0001ed 00ff          .dw $00ff
0001ee 3a12          .dw XT_AND
0001ef 3f63          .dw XT_TOLOWER
0001f0 38c3          .dw XT_SWAP
0001f1 3af8          .dw XT_BYTESWAP
0001f2 383c          .dw XT_DOLITERAL
0001f3 00ff          .dw $00ff
0001f4 3a12          .dw XT_AND
0001f5 3f63          .dw XT_TOLOWER
0001f6 3af8          .dw XT_BYTESWAP
0001f7 3a1b          .dw XT_OR
0001f8 381f          .dw XT_EXIT
                 .endif
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
0001f9 ff01          .dw $ff01
0001fa 002a          .db "*",0
0001fb 01b1          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
0001fc 3800          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
0001fd 39a5          .dw XT_MSTAR
0001fe 38d8          .dw XT_DROP
0001ff 381f          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
000200 ff01          .dw $FF01
000201 006a          .db "j",0
000202 01f9          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
000203 3800          .dw DO_COLON
                 PFA_J:
000204 3a75          .dw XT_RP_FETCH
000205 383c          .dw XT_DOLITERAL
000206 0007          .dw 7
000207 399c          .dw XT_PLUS
000208 3878          .dw XT_FETCH
000209 3a75          .dw XT_RP_FETCH
00020a 383c          .dw XT_DOLITERAL
00020b 0009          .dw 9
00020c 399c          .dw XT_PLUS
00020d 3878          .dw XT_FETCH
00020e 399c          .dw XT_PLUS
00020f 381f          .dw XT_EXIT
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
000210 ff04          .dw $ff04
000211 6164
000212 7362          .db "dabs"
000213 0200          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
000214 3800          .dw DO_COLON
                 PFA_DABS:
000215 38b0          .dw XT_DUP
000216 391e          .dw XT_ZEROLESS
000217 3835          .dw XT_DOCONDBRANCH
000218 021a          .dw PFA_DABS1
000219 0221          .dw XT_DNEGATE
                 PFA_DABS1:
00021a 381f          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
00021b ff07          .dw $ff07
00021c 6e64
00021d 6765
00021e 7461
00021f 0065          .db "dnegate",0
000220 0210          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
000221 3800          .dw DO_COLON
                 PFA_DNEGATE:
000222 3c51          .dw XT_DINVERT
000223 3bdc          .dw XT_ONE
000224 3953          .dw XT_ZERO
000225 3c2b          .dw XT_DPLUS
000226 381f          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
000227 ff05          .dw $ff05
000228 6d63
000229 766f
00022a 0065          .db "cmove",0
00022b 021b          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
00022c 022d          .dw PFA_CMOVE
                 PFA_CMOVE:
00022d 93bf          push xh
00022e 93af          push xl
00022f 91e9          ld zl, Y+
000230 91f9          ld zh, Y+ ; addr-to
000231 91a9          ld xl, Y+
000232 91b9          ld xh, Y+ ; addr-from
000233 2f09          mov temp0, tosh
000234 2b08          or temp0, tosl
000235 f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
000236 911d          ld temp1, X+
000237 9311          st Z+, temp1
000238 9701          sbiw tosl, 1
000239 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
00023a 91af          pop xl
00023b 91bf          pop xh
00023c 9189
00023d 9199          loadtos
00023e 940c 3804     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
000240 ff05          .dw $ff05
000241 7332
000242 6177
000243 0070          .db "2swap",0
000244 0227          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
000245 3800          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
000246 38e0          .dw XT_ROT
000247 38fe          .dw XT_TO_R
000248 38e0          .dw XT_ROT
000249 38f5          .dw XT_R_FROM
00024a 381f          .dw XT_EXIT
                 .include "words/tib.asm"
                 
                 ; System
                 ; refills the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILLTIB:
00024b ff0a          .dw $ff0a
00024c 6572
00024d 6966
00024e 6c6c
00024f 742d
000250 6269          .db "refill-tib"
000251 0240          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
000252 3800          .dw DO_COLON
                 PFA_REFILLTIB:
                 .endif
000253 026e          .dw XT_TIB
000254 383c          .dw XT_DOLITERAL
000255 005a          .dw TIB_SIZE
000256 0486          .dw XT_ACCEPT
000257 0274          .dw XT_NUMBERTIB
000258 3880          .dw XT_STORE
000259 3953          .dw XT_ZERO
00025a 3ecc          .dw XT_TO_IN
00025b 3880          .dw XT_STORE
00025c 394a          .dw XT_TRUE ; -1
00025d 381f          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCETIB:
00025e ff0a          .dw $FF0A
00025f 6f73
000260 7275
000261 6563
000262 742d
000263 6269          .db "source-tib"
000264 024b          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
000265 3800          .dw DO_COLON
                 PFA_SOURCETIB:
                 .endif
000266 026e          .dw XT_TIB
000267 0274          .dw XT_NUMBERTIB
000268 3878          .dw XT_FETCH
000269 381f          .dw XT_EXIT
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; terminal input buffer address
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TIB:
00026a ff03          .dw $ff03
00026b 6974
00026c 0062          .db "tib",0
00026d 025e          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
00026e 3847          .dw PFA_DOVARIABLE
                 PFA_TIB:
00026f 013d          .dw ram_tib
                 .dseg
00013d           ram_tib: .byte TIB_SIZE
                 .cseg
                 .endif
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBERTIB:
000270 ff04          .dw $ff04
000271 7423
000272 6269          .db "#tib"
000273 026a          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
000274 3847          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
000275 0197          .dw ram_sharptib
                 .dseg
000197           ram_sharptib: .byte 2
                 .cseg
                 .endif
                 .include "words/init-ram.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
000276 ff06        .dw $ff06
000277 6565
000278 723e
000279 6d61        .db "ee>ram"
00027a 0270        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
00027b 3800        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
00027c 3953          .dw XT_ZERO
00027d 3a9a          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
00027e 38ce          .dw XT_OVER
00027f 3b54          .dw XT_FETCHE
000280 38ce          .dw XT_OVER
000281 3880          .dw XT_STORE
000282 3ca6          .dw XT_CELLPLUS
000283 38c3          .dw XT_SWAP
000284 3ca6          .dw XT_CELLPLUS
000285 38c3          .dw XT_SWAP
000286 3ac8          .dw XT_DOLOOP
000287 027e          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
000288 3ebc          .dw XT_2DROP
000289 381f          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INIT_RAM:
00028a ff08        .dw $ff08
00028b 6e69
00028c 7469
00028d 722d
00028e 6d61        .db "init-ram"
00028f 0276        .dw VE_HEAD
                   .set VE_HEAD = VE_INIT_RAM
                 XT_INIT_RAM:
000290 3800        .dw DO_COLON
                 PFA_INI_RAM:          ; ( -- )
000291 383c          .dw XT_DOLITERAL
000292 008c          .dw EE_INITUSER
000293 3b01          .dw XT_UP_FETCH
000294 383c          .dw XT_DOLITERAL
000295 0024          .dw SYSUSERSIZE
000296 3a03          .dw XT_2SLASH
000297 027b          .dw XT_EE2RAM
000298 381f          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
000299 ff0b          .dw $ff0b
00029a 6e65
00029b 6976
00029c 6f72
00029d 6d6e
00029e 6e65
00029f 0074          .db "environment",0
0002a0 028a          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
0002a1 3847          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
0002a2 0066          .dw CFG_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
0002a3 ff09          .dw $ff09
0002a4 6f77
0002a5 6472
0002a6 696c
0002a7 7473
0002a8 0073          .db "wordlists",0
0002a9 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
0002aa 3800          .dw DO_COLON
                 PFA_ENVWORDLISTS:
0002ab 383c          .dw XT_DOLITERAL
0002ac 0008          .dw NUMWORDLISTS
0002ad 381f          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
0002ae ff04          .dw $ff04
0002af 702f
0002b0 6461          .db "/pad"
0002b1 02a3          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
0002b2 3800          .dw DO_COLON
                 PFA_ENVSLASHPAD:
0002b3 3a8c          .dw XT_SP_FETCH
0002b4 3ed2          .dw XT_PAD
0002b5 3992          .dw XT_MINUS
0002b6 381f          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENVSLASHHOLD:
0002b7 ff05          .dw $ff05
0002b8 682f
0002b9 6c6f
0002ba 0064          .db "/hold",0
0002bb 02ae          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
0002bc 3800          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
                 .endif
0002bd 3ed2          .dw XT_PAD
0002be 3f0d          .dw XT_HERE
0002bf 3992          .dw XT_MINUS
0002c0 381f          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
0002c1 ff0a          .dw $ff0a
0002c2 6f66
0002c3 7472
0002c4 2d68
0002c5 616e
0002c6 656d          .db "forth-name"
0002c7 02b7          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
0002c8 3800          .dw DO_COLON
                 PFA_EN_FORTHNAME:
0002c9 03be          .dw XT_DOSLITERAL
0002ca 0007          .dw 7
                 .endif
0002cb 6d61
0002cc 6f66
0002cd 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
0002ce 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
0002cf 381f          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
0002d0 ff07          .dw $ff07
0002d1 6576
0002d2 7372
0002d3 6f69
0002d4 006e          .db "version",0
0002d5 02c1          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
0002d6 3800          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
0002d7 383c          .dw XT_DOLITERAL
0002d8 0045          .dw 69
0002d9 381f          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
0002da ff03          .dw $ff03
0002db 7063
0002dc 0075          .db "cpu",0
0002dd 02d0          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
0002de 3800          .dw DO_COLON
                 PFA_EN_CPU:
                 .endif
0002df 383c          .dw XT_DOLITERAL
0002e0 0059          .dw mcu_name
0002e1 041d          .dw XT_ICOUNT
0002e2 381f          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
0002e3 ff08          .dw $ff08
0002e4 636d
0002e5 2d75
0002e6 6e69
0002e7 6f66          .db "mcu-info"
0002e8 02da          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
0002e9 3800          .dw DO_COLON
                 PFA_EN_MCUINFO:
0002ea 383c          .dw XT_DOLITERAL
0002eb 0055          .dw mcu_info
0002ec 381f          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_ENVUSERSIZE:
0002ed ff05          .dw $ff05
0002ee 752f
0002ef 6573
0002f0 0072          .db "/user",0
0002f1 02e3          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
0002f2 3800          .dw DO_COLON
                 PFA_ENVUSERSIZE:
                 .endif
0002f3 383c          .dw XT_DOLITERAL
0002f4 002e          .dw SYSUSERSIZE + APPUSERSIZE
0002f5 381f          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
0002f6 ff03          .dw $ff03
0002f7 6c68
0002f8 0064          .db "hld",0
0002f9 0299          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
0002fa 3847          .dw PFA_DOVARIABLE
                 PFA_HLD:
0002fb 0199          .dw ram_hld
                 
                 .dseg
000199           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
0002fc ff04          .dw $ff04
0002fd 6f68
0002fe 646c          .db "hold"
0002ff 02f6          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
000300 3800          .dw DO_COLON
                 PFA_HOLD:
                 .endif
000301 02fa          .dw XT_HLD
000302 38b0          .dw XT_DUP
000303 3878          .dw XT_FETCH
000304 3a34          .dw XT_1MINUS
000305 38b0          .dw XT_DUP
000306 38fe          .dw XT_TO_R
000307 38c3          .dw XT_SWAP
000308 3880          .dw XT_STORE
000309 38f5          .dw XT_R_FROM
00030a 388c          .dw XT_CSTORE
00030b 381f          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
00030c ff02          .dw $ff02
00030d 233c          .db "<#"
00030e 02fc          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
00030f 3800          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
000310 3ed2          .dw XT_PAD
000311 02fa          .dw XT_HLD
000312 3880          .dw XT_STORE
000313 381f          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
000314 ff01          .dw $ff01
000315 0023          .db "#",0
000316 030c          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
000317 3800          .dw DO_COLON
                 PFA_SHARP:
                 .endif
000318 3ea7          .dw XT_BASE
000319 3878          .dw XT_FETCH
00031a 0394          .dw XT_UDSLASHMOD
00031b 38e0          .dw XT_ROT
00031c 383c          .dw XT_DOLITERAL
00031d 0009          .dw 9
00031e 38ce          .dw XT_OVER
00031f 396d          .dw XT_LESS
000320 3835          .dw XT_DOCONDBRANCH
000321 0325          DEST(PFA_SHARP1)
000322 383c          .dw XT_DOLITERAL
000323 0007          .dw 7
000324 399c          .dw XT_PLUS
                 PFA_SHARP1:
000325 383c          .dw XT_DOLITERAL
000326 0030          .dw 48 ; ASCII 0
000327 399c          .dw XT_PLUS
000328 0300          .dw XT_HOLD
000329 381f          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
00032a ff02          .dw $ff02
00032b 7323          .db "#s"
00032c 0314          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
00032d 3800          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
00032e 0317          .dw XT_SHARP
00032f 3eb3          .dw XT_2DUP
000330 3a1b          .dw XT_OR
000331 3917          .dw XT_ZEROEQUAL
000332 3835          .dw XT_DOCONDBRANCH
000333 032e          DEST(NUMS1) ; PFA_SHARP_S
000334 381f          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
000335 ff02          .dw $ff02
000336 3e23          .db "#>"
000337 032a          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
000338 3800          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
000339 3ebc          .dw XT_2DROP
00033a 02fa          .dw XT_HLD
00033b 3878          .dw XT_FETCH
00033c 3ed2          .dw XT_PAD
00033d 38ce          .dw XT_OVER
00033e 3992          .dw XT_MINUS
00033f 381f          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
000340 ff04          .dw $ff04
000341 6973
000342 6e67          .db "sign"
000343 0335          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
000344 3800          .dw DO_COLON
                 PFA_SIGN:
                 .endif
000345 391e          .dw XT_ZEROLESS
000346 3835          .dw XT_DOCONDBRANCH
000347 034b          DEST(PFA_SIGN1)
000348 383c          .dw XT_DOLITERAL
000349 002d          .dw 45 ; ascii -
00034a 0300          .dw XT_HOLD
                 PFA_SIGN1:
00034b 381f          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
00034c ff03          .dw $ff03
00034d 2e64
00034e 0072          .db "d.r",0
00034f 0340          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
000350 3800          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
000351 38fe          .dw XT_TO_R
000352 3ec4          .dw XT_TUCK
000353 0214          .dw XT_DABS
000354 030f          .dw XT_L_SHARP
000355 032d          .dw XT_SHARP_S
000356 38e0          .dw XT_ROT
000357 0344          .dw XT_SIGN
000358 0338          .dw XT_SHARP_G
000359 38f5          .dw XT_R_FROM
00035a 38ce          .dw XT_OVER
00035b 3992          .dw XT_MINUS
00035c 3fa1          .dw XT_SPACES
00035d 0427          .dw XT_TYPE
00035e 381f          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
00035f ff02          .dw $ff02
000360 722e          .db ".r"
000361 034c          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
000362 3800          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
000363 38fe          .dw XT_TO_R
000364 3fb1          .dw XT_S2D
000365 38f5          .dw XT_R_FROM
000366 0350          .dw XT_DDOTR
000367 381f          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
000368 ff02          .dw $ff02
000369 2e64          .db "d."
00036a 035f          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
00036b 3800          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
00036c 3953          .dw XT_ZERO
00036d 0350          .dw XT_DDOTR
00036e 3f98          .dw XT_SPACE
00036f 381f          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
000370 ff01          .dw $ff01
000371 002e          .db ".",0
000372 0368          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
000373 3800          .dw DO_COLON
                 PFA_DOT:
                 .endif
000374 3fb1          .dw XT_S2D
000375 036b          .dw XT_DDOT
000376 381f          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
000377 ff03          .dw $ff03
000378 6475
000379 002e          .db "ud.",0
00037a 0370          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
00037b 3800          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
00037c 3953          .dw XT_ZERO
00037d 0384          .dw XT_UDDOTR
00037e 3f98          .dw XT_SPACE
00037f 381f          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
000380 ff04          .dw $ff04
000381 6475
000382 722e          .db "ud.r"
000383 0377          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
000384 3800          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
000385 38fe          .dw XT_TO_R
000386 030f          .dw XT_L_SHARP
000387 032d          .dw XT_SHARP_S
000388 0338          .dw XT_SHARP_G
000389 38f5          .dw XT_R_FROM
00038a 38ce          .dw XT_OVER
00038b 3992          .dw XT_MINUS
00038c 3fa1          .dw XT_SPACES
00038d 0427          .dw XT_TYPE
00038e 381f          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
00038f ff06          .dw $ff06
000390 6475
000391 6d2f
000392 646f          .db "ud/mod"
000393 0380          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
000394 3800          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
000395 38fe          .dw XT_TO_R
000396 3953          .dw XT_ZERO
000397 3905          .dw XT_R_FETCH
000398 39c1          .dw XT_UMSLASHMOD
000399 38f5          .dw XT_R_FROM
00039a 38c3          .dw XT_SWAP
00039b 38fe          .dw XT_TO_R
00039c 39c1          .dw XT_UMSLASHMOD
00039d 38f5          .dw XT_R_FROM
00039e 381f          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
00039f ff06          .dw $ff06 
0003a0 6964
0003a1 6967
0003a2 3f74          .db "digit?"
0003a3 038f          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
0003a4 3800          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
0003a5 3f50          .dw XT_TOUPPER
0003a6 38b0
0003a7 383c
0003a8 0039
0003a9 3977
0003aa 383c
0003ab 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
0003ac 3a12
0003ad 399c
0003ae 38b0
0003af 383c
0003b0 0140
0003b1 3977          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
0003b2 383c
0003b3 0107
0003b4 3a12
0003b5 3992
0003b6 383c
0003b7 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
0003b8 3992
0003b9 38b0
0003ba 3ea7
0003bb 3878
0003bc 395b          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
0003bd 381f          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
0003be 3800        .dw DO_COLON
                 PFA_DOSLITERAL:
0003bf 3905        .dw XT_R_FETCH   ; ( -- addr )
0003c0 041d        .dw XT_ICOUNT
0003c1 38f5        .dw XT_R_FROM
0003c2 38ce        .dw XT_OVER     ; ( -- addr' n addr n)
0003c3 3a2e        .dw XT_1PLUS
0003c4 3a03        .dw XT_2SLASH   ; ( -- addr' n addr k )
0003c5 399c        .dw XT_PLUS     ; ( -- addr' n addr'' )
0003c6 3a2e        .dw XT_1PLUS
0003c7 38fe        .dw XT_TO_R     ; ( -- )
0003c8 381f        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
0003c9 ff02        .dw $ff02
0003ca 2c73        .db "s",$2c
0003cb 039f        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
0003cc 3800          .dw DO_COLON
                 PFA_SCOMMA:
0003cd 38b0          .dw XT_DUP
0003ce 03d0          .dw XT_DOSCOMMA
0003cf 381f          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
0003d0 3800          .dw DO_COLON
                 PFA_DOSCOMMA:
0003d1 0771          .dw XT_COMMA
0003d2 38b0          .dw XT_DUP   ; ( --addr len len)
0003d3 3a03          .dw XT_2SLASH ; ( -- addr len len/2
0003d4 3ec4          .dw XT_TUCK   ; ( -- addr len/2 len len/2
0003d5 3a0a          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003d6 3992          .dw XT_MINUS  ; ( -- addr len/2 rem
0003d7 38fe          .dw XT_TO_R
0003d8 3953          .dw XT_ZERO
0003d9 0830          .dw XT_QDOCHECK
0003da 3835          .dw XT_DOCONDBRANCH
0003db 03e3          .dw PFA_SCOMMA2
0003dc 3a9a          .dw XT_DODO
                 PFA_SCOMMA1:
0003dd 38b0          .dw XT_DUP         ; ( -- addr addr )
0003de 3878          .dw XT_FETCH       ; ( -- addr c1c2 )
0003df 0771          .dw XT_COMMA       ; ( -- addr )
0003e0 3ca6          .dw XT_CELLPLUS    ; ( -- addr+cell )
0003e1 3ac8          .dw XT_DOLOOP
0003e2 03dd          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
0003e3 38f5          .dw XT_R_FROM
0003e4 3925          .dw XT_GREATERZERO
0003e5 3835          .dw XT_DOCONDBRANCH
0003e6 03ea          .dw PFA_SCOMMA3
0003e7 38b0            .dw XT_DUP     ; well, tricky
0003e8 3897            .dw XT_CFETCH
0003e9 0771            .dw XT_COMMA
                 PFA_SCOMMA3:
0003ea 38d8          .dw XT_DROP        ; ( -- )
0003eb 381f          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
0003ec ff05          .dw $ff05
0003ed 7469
0003ee 7079
0003ef 0065          .db "itype",0
0003f0 03c9          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
0003f1 3800          .dw DO_COLON
                 PFA_ITYPE:
0003f2 38b0          .dw XT_DUP    ; ( --addr len len)
0003f3 3a03          .dw XT_2SLASH ; ( -- addr len len/2
0003f4 3ec4          .dw XT_TUCK   ; ( -- addr len/2 len len/2
0003f5 3a0a          .dw XT_2STAR  ; ( -- addr len/2 len len'
0003f6 3992          .dw XT_MINUS  ; ( -- addr len/2 rem
0003f7 38fe          .dw XT_TO_R
0003f8 3953          .dw XT_ZERO
0003f9 0830          .dw XT_QDOCHECK
0003fa 3835          .dw XT_DOCONDBRANCH
0003fb 0405          .dw PFA_ITYPE2
0003fc 3a9a          .dw XT_DODO
                 PFA_ITYPE1:
0003fd 38b0          .dw XT_DUP         ; ( -- addr addr )
0003fe 3bc0          .dw XT_FETCHI      ; ( -- addr c1c2 )
0003ff 38b0          .dw XT_DUP
000400 0412          .dw XT_LOWEMIT
000401 040e          .dw XT_HIEMIT
000402 3a2e          .dw XT_1PLUS    ; ( -- addr+cell )
000403 3ac8          .dw XT_DOLOOP
000404 03fd          .dw PFA_ITYPE1
                 PFA_ITYPE2:
000405 38f5          .dw XT_R_FROM
000406 3925          .dw XT_GREATERZERO
000407 3835          .dw XT_DOCONDBRANCH
000408 040c          .dw PFA_ITYPE3
000409 38b0            .dw XT_DUP     ; make sure the drop below has always something to do
00040a 3bc0            .dw XT_FETCHI
00040b 0412            .dw XT_LOWEMIT
                 PFA_ITYPE3:
00040c 38d8          .dw XT_DROP
00040d 381f          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
00040e 3800          .dw DO_COLON
                 PFA_HIEMIT:
00040f 3af8          .dw XT_BYTESWAP
000410 0412          .dw XT_LOWEMIT
000411 381f          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
000412 3800          .dw DO_COLON
                 PFA_LOWEMIT:
000413 383c          .dw XT_DOLITERAL
000414 00ff          .dw $00ff
000415 3a12          .dw XT_AND
000416 3edc          .dw XT_EMIT
000417 381f          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
000418 ff06          .dw $ff06
000419 6369
00041a 756f
00041b 746e          .db "icount"
00041c 03ec          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
00041d 3800          .dw DO_COLON
                 PFA_ICOUNT:
00041e 38b0          .dw XT_DUP
00041f 3a2e          .dw XT_1PLUS
000420 38c3          .dw XT_SWAP
000421 3bc0          .dw XT_FETCHI
000422 381f          .dw XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
000423 ff04          .dw $ff04
000424 7974
000425 6570          .db "type"
000426 0418          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
000427 3800          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
000428 3f83          .dw XT_BOUNDS
000429 0830          .dw XT_QDOCHECK
00042a 3835          .dw XT_DOCONDBRANCH
00042b 0432          DEST(PFA_TYPE2)
00042c 3a9a          .dw XT_DODO
                 PFA_TYPE1:
00042d 3aab          .dw XT_I
00042e 3897          .dw XT_CFETCH
00042f 3edc          .dw XT_EMIT
000430 3ac8          .dw XT_DOLOOP
000431 042d          DEST(PFA_TYPE1)
                 PFA_TYPE2:
000432 381f          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
000433 ff01          .dw $ff01
000434 0027          .db "'",0
000435 0423          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
000436 3800          .dw DO_COLON
                 PFA_TICK:
                 .endif
000437 05b6          .dw XT_PARSENAME
000438 05f4          .dw XT_FORTHRECOGNIZER
000439 05ff          .dw XT_RECOGNIZE
                     ; a word is tickable unless RECTYPE-TOKEN is RECTYPE-NULL or 
                     ; the interpret action is a NOOP
00043a 38b0          .dw XT_DUP
00043b 0695          .dw XT_RECTYPE_NULL
00043c 3bd5          .dw XT_EQUAL
00043d 38c3          .dw XT_SWAP
00043e 3bc0          .dw XT_FETCHI
00043f 383c          .dw XT_DOLITERAL
000440 3fbf          .dw XT_NOOP
000441 3bd5          .dw XT_EQUAL
000442 3a1b          .dw XT_OR
000443 3835          .dw XT_DOCONDBRANCH
000444 0448          DEST(PFA_TICK1)
000445 383c            .dw XT_DOLITERAL
000446 fff3            .dw -13
000447 3d73            .dw XT_THROW
                 PFA_TICK1:
000448 38d8          .dw XT_DROP
000449 381f          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
00044a ff05          .dw $ff05
00044b 7363
00044c 696b
00044d 0070          .db "cskip",0
00044e 0433          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
00044f 3800          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
000450 38fe          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
000451 38b0          .dw XT_DUP            ; ( -- addr' n' n' )
000452 3835          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000453 045e          DEST(PFA_CSKIP2)
000454 38ce          .dw XT_OVER           ; ( -- addr' n' addr' )
000455 3897          .dw XT_CFETCH         ; ( -- addr' n' c' )
000456 3905          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
000457 3bd5          .dw XT_EQUAL          ; ( -- addr' n' f )
000458 3835          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
000459 045e          DEST(PFA_CSKIP2)
00045a 3bdc          .dw XT_ONE
00045b 05a7          .dw XT_SLASHSTRING
00045c 382e          .dw XT_DOBRANCH
00045d 0451          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
00045e 38f5          .dw XT_R_FROM
00045f 38d8          .dw XT_DROP           ; ( -- addr2 n2)
000460 381f          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
000461 ff05          .dw $ff05
000462 7363
000463 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
000464 006e          .db "cscan"
000465 044a          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
000466 3800          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
000467 38fe          .dw XT_TO_R
000468 38ce          .dw XT_OVER
                 PFA_CSCAN1:
000469 38b0          .dw XT_DUP
00046a 3897          .dw XT_CFETCH
00046b 3905          .dw XT_R_FETCH
00046c 3bd5          .dw XT_EQUAL
00046d 3917          .dw XT_ZEROEQUAL
00046e 3835          .dw XT_DOCONDBRANCH
00046f 047b          DEST(PFA_CSCAN2)
000470 38c3            .dw XT_SWAP
000471 3a34            .dw XT_1MINUS
000472 38c3            .dw XT_SWAP
000473 38ce            .dw XT_OVER
000474 391e            .dw XT_ZEROLESS ; not negative
000475 3917            .dw XT_ZEROEQUAL
000476 3835            .dw XT_DOCONDBRANCH
000477 047b            DEST(PFA_CSCAN2)
000478 3a2e              .dw XT_1PLUS
000479 382e              .dw XT_DOBRANCH
00047a 0469              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
00047b 38ef          .dw XT_NIP
00047c 38ce          .dw XT_OVER
00047d 3992          .dw XT_MINUS
00047e 38f5          .dw XT_R_FROM
00047f 38d8          .dw XT_DROP
000480 381f          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
000481 ff06          .dw $ff06
000482 6361
000483 6563
000484 7470          .db "accept"
000485 0461          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
000486 3800          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
000487 38ce
000488 399c
000489 38ce              .DW XT_OVER,XT_PLUS,XT_OVER
00048a 3eed
00048b 38b0
00048c 04cf
00048d 3917
00048e 3835      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
00048f 04c2              DEST(ACC5)
000490 38b0
000491 383c
000492 0008
000493 3bd5
000494 3835              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
000495 04a8              DEST(ACC3)
000496 38d8
000497 38e0
000498 3eb3
000499 3977
00049a 38fe
00049b 38e0
00049c 38e0
00049d 38f5
00049e 3835              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
00049f 04a6      	DEST(ACC6)
0004a0 04c7
0004a1 3a34
0004a2 38fe
0004a3 38ce
0004a4 38f5
0004a5 0132      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
0004a6 382e      ACC6:   .DW XT_DOBRANCH
0004a7 04c0              DEST(ACC4)
                     
                 
                 ACC3:    ; check for remaining control characters, replace them with blank
0004a8 38b0      	.dw XT_DUP            ; ( -- addr k k )
0004a9 3f3e              .dw XT_BL
0004aa 396d              .dw XT_LESS
0004ab 3835              .dw XT_DOCONDBRANCH
0004ac 04af              DEST(PFA_ACCEPT6)
0004ad 38d8              .dw XT_DROP
0004ae 3f3e              .dw XT_BL
                 PFA_ACCEPT6:
0004af 38fe
0004b0 3eb3
0004b1 3977
0004b2 38f5
0004b3 38c3
0004b4 3835      	.DW XT_TO_R,XT_2DUP,XT_GREATER,XT_R_FROM,XT_SWAP,XT_DOCONDBRANCH
0004b5 04bf              DEST(ACC7)
0004b6 38b0
0004b7 3edc
0004b8 38ce
0004b9 388c
0004ba 3a2e
0004bb 38ce
0004bc 013e                  .DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
0004bd 382e      	    .DW XT_DOBRANCH
0004be 04c0      	    DEST(ACC4)
0004bf 38d8      ACC7:   .DW XT_DROP
0004c0 382e      ACC4:   .DW XT_DOBRANCH
0004c1 048a              DEST(ACC1)
0004c2 38d8
0004c3 38ef
0004c4 38c3
0004c5 3992
0004c6 381f      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
0004c7 3800          .dw DO_COLON
                 .endif
0004c8 383c          .dw XT_DOLITERAL
0004c9 0008          .dw 8
0004ca 38b0          .dw XT_DUP
0004cb 3edc          .dw XT_EMIT
0004cc 3f98          .dw XT_SPACE
0004cd 3edc          .dw XT_EMIT
0004ce 381f          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
0004cf 3800          .dw DO_COLON
                 .endif
0004d0 38b0          .dw XT_DUP
0004d1 383c          .dw XT_DOLITERAL
0004d2 000d          .dw 13
0004d3 3bd5          .dw XT_EQUAL
0004d4 38c3          .dw XT_SWAP
0004d5 383c          .dw XT_DOLITERAL
0004d6 000a          .dw 10
0004d7 3bd5          .dw XT_EQUAL
0004d8 3a1b          .dw XT_OR
0004d9 381f          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILL:
0004da ff06          .dw $ff06
0004db 6572
0004dc 6966
0004dd 6c6c          .db "refill"
0004de 0481          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
0004df 3de9          .dw PFA_DODEFER1
                 PFA_REFILL:
                 .endif
0004e0 001a          .dw USER_REFILL
0004e1 3db2          .dw XT_UDEFERFETCH
0004e2 3dbe          .dw XT_UDEFERSTORE
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
0004e3 ff04          .dw $ff04
0004e4 6863
0004e5 7261          .db "char"
0004e6 04da          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
0004e7 3800          .dw DO_COLON
                 PFA_CHAR:
                 .endif
0004e8 05b6          .dw XT_PARSENAME
0004e9 3917
0004ea 3835          .dw XT_ZEROEQUAL,XT_DOCONDBRANCH 
0004eb 04ef          DEST(CHAR_1)
0004ec 383c
0004ed fff0
0004ee 3d73             .dw XT_DOLITERAL, -16, XT_THROW
                 CHAR_1:
                 
0004ef 3897          .dw XT_CFETCH
0004f0 381f          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
0004f1 ff06          .dw $ff06
0004f2 756e
0004f3 626d
0004f4 7265          .db "number"
0004f5 04e3          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
0004f6 3800          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
0004f7 3ea7          .dw XT_BASE
0004f8 3878          .dw XT_FETCH
0004f9 38fe          .dw XT_TO_R
0004fa 053a          .dw XT_QSIGN
0004fb 38fe          .dw XT_TO_R
0004fc 054d          .dw XT_SET_BASE
0004fd 053a          .dw XT_QSIGN
0004fe 38f5          .dw XT_R_FROM
0004ff 3a1b          .dw XT_OR
000500 38fe          .dw XT_TO_R
                     ; check whether something is left
000501 38b0          .dw XT_DUP
000502 3917          .dw XT_ZEROEQUAL
000503 3835          .dw XT_DOCONDBRANCH
000504 050d          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
000505 3ebc            .dw XT_2DROP
000506 38f5            .dw XT_R_FROM
000507 38d8            .dw XT_DROP
000508 38f5            .dw XT_R_FROM
000509 3ea7            .dw XT_BASE
00050a 3880            .dw XT_STORE
00050b 3953            .dw XT_ZERO
00050c 381f            .dw XT_EXIT
                 PFA_NUMBER0:
00050d 3b13          .dw XT_2TO_R
00050e 3953          .dw XT_ZERO       ; starting value
00050f 3953          .dw XT_ZERO
000510 3b22          .dw XT_2R_FROM
000511 056b          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
000512 38b8          .dw XT_QDUP
000513 3835          .dw XT_DOCONDBRANCH
000514 052f          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
000515 3bdc          .dw XT_ONE
000516 3bd5          .dw XT_EQUAL
000517 3835          .dw XT_DOCONDBRANCH
000518 0526          DEST(PFA_NUMBER2)
                 	; excatly one character is left
000519 3897      	.dw XT_CFETCH
00051a 383c      	.dw XT_DOLITERAL
00051b 002e      	.dw 46 ; .
00051c 3bd5      	.dw XT_EQUAL
00051d 3835      	.dw XT_DOCONDBRANCH
00051e 0527      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
00051f 38f5      	.dw XT_R_FROM
000520 3835              .dw XT_DOCONDBRANCH
000521 0523      	DEST(PFA_NUMBER3)
000522 0221              .dw XT_DNEGATE
                 PFA_NUMBER3:
000523 3be1      	.dw XT_TWO
000524 382e      	.dw XT_DOBRANCH
000525 0535      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
000526 38d8      	.dw XT_DROP
                 PFA_NUMBER6:
000527 3ebc      	.dw XT_2DROP
000528 38f5      	.dw XT_R_FROM
000529 38d8      	.dw XT_DROP
00052a 38f5              .dw XT_R_FROM
00052b 3ea7              .dw XT_BASE
00052c 3880              .dw XT_STORE
00052d 3953      	.dw XT_ZERO
00052e 381f      	.dw XT_EXIT
                 PFA_NUMBER1:
00052f 3ebc          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
000530 38f5          .dw XT_R_FROM
000531 3835          .dw XT_DOCONDBRANCH
000532 0534          DEST(PFA_NUMBER4)
000533 3e11          .dw XT_NEGATE
                 PFA_NUMBER4:
000534 3bdc          .dw XT_ONE
                 PFA_NUMBER5:
000535 38f5          .dw XT_R_FROM
000536 3ea7          .dw XT_BASE
000537 3880          .dw XT_STORE
000538 394a          .dw XT_TRUE
000539 381f          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
00053a 3800          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
00053b 38ce          .dw XT_OVER    ; ( -- addr len addr )
00053c 3897          .dw XT_CFETCH
00053d 383c          .dw XT_DOLITERAL
00053e 002d          .dw '-'
00053f 3bd5          .dw XT_EQUAL  ; ( -- addr len flag )
000540 38b0          .dw XT_DUP
000541 38fe          .dw XT_TO_R
000542 3835          .dw XT_DOCONDBRANCH
000543 0546          DEST(PFA_NUMBERSIGN_DONE)
000544 3bdc          .dw XT_ONE    ; skip sign character
000545 05a7          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
000546 38f5          .dw XT_R_FROM
000547 381f          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
000548 3851          .dw PFA_DOCONSTANT
                 .endif
000549 000a
00054a 0010
00054b 0002
00054c 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
00054d 3800          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
00054e 38ce          .dw XT_OVER
00054f 3897          .dw XT_CFETCH
000550 383c          .dw XT_DOLITERAL
000551 0023          .dw 35
000552 3992          .dw XT_MINUS
000553 38b0          .dw XT_DUP
000554 3953          .dw XT_ZERO
000555 383c          .dw XT_DOLITERAL
000556 0004          .dw 4
000557 3e41          .dw XT_WITHIN
000558 3835          .dw XT_DOCONDBRANCH
000559 0563          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
00055a 0548      	.dw XT_BASES
00055b 399c      	.dw XT_PLUS
00055c 3bc0      	.dw XT_FETCHI
00055d 3ea7      	.dw XT_BASE
00055e 3880      	.dw XT_STORE
00055f 3bdc      	.dw XT_ONE
000560 05a7      	.dw XT_SLASHSTRING
000561 382e      	.dw XT_DOBRANCH
000562 0564      	DEST(SET_BASE2)
                 SET_BASE1:
000563 38d8      	.dw XT_DROP
                 SET_BASE2:
000564 381f          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
000565 ff07          .dw $ff07
000566 6e3e
000567 6d75
000568 6562
000569 0072          .db ">number",0
00056a 04f1          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
00056b 3800          .dw DO_COLON
                 
                 .endif
                 
00056c 38b0
00056d 3835      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
00056e 0583              DEST(TONUM3)
00056f 38ce
000570 3897
000571 03a4              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
000572 3917
000573 3835              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
000574 0577              DEST(TONUM2)
000575 38d8
000576 381f              .DW XT_DROP,XT_EXIT
000577 38fe
000578 0245
000579 3ea7
00057a 3878
00057b 0123      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
00057c 38f5
00057d 011b
00057e 0245              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
00057f 3bdc
000580 05a7
000581 382e              .DW XT_ONE,XT_SLASHSTRING,XT_DOBRANCH
000582 056c              DEST(TONUM1)
000583 381f      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
000584 ff05          .dw $ff05
000585 6170
000586 7372
000587 0065          .db "parse",0
000588 0565          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
000589 3800          .dw DO_COLON
                 PFA_PARSE:
                 .endif
00058a 38fe          .dw XT_TO_R     ; ( -- )
00058b 059d          .dw XT_SOURCE   ; ( -- addr len)
00058c 3ecc          .dw XT_TO_IN     ; ( -- addr len >in)
00058d 3878          .dw XT_FETCH
00058e 05a7          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
00058f 38f5          .dw XT_R_FROM      ; ( -- addr' len' c)
000590 0466          .dw XT_CSCAN       ; ( -- addr' len'')
000591 38b0          .dw XT_DUP         ; ( -- addr' len'' len'')
000592 3a2e          .dw XT_1PLUS
000593 3ecc          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
000594 3a64          .dw XT_PLUSSTORE   ; ( -- addr' len')
000595 3bdc          .dw XT_ONE
000596 05a7          .dw XT_SLASHSTRING
000597 381f          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCE:
000598 ff06          .dw $FF06
000599 6f73
00059a 7275
00059b 6563          .db "source"
00059c 0584          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
00059d 3de9          .dw PFA_DODEFER1
                 PFA_SOURCE:
                 .endif
00059e 0016          .dw USER_SOURCE
00059f 3db2          .dw XT_UDEFERFETCH
0005a0 3dbe          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
0005a1 ff07          .dw $ff07
0005a2 732f
0005a3 7274
0005a4 6e69
0005a5 0067          .db "/string",0
0005a6 0598          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
0005a7 3800          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
0005a8 38e0          .dw XT_ROT
0005a9 38ce          .dw XT_OVER
0005aa 399c          .dw XT_PLUS
0005ab 38e0          .dw XT_ROT
0005ac 38e0          .dw XT_ROT
0005ad 3992          .dw XT_MINUS
0005ae 381f          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
0005af ff0a          .dw $FF0A 
0005b0 6170
0005b1 7372
0005b2 2d65
0005b3 616e
0005b4 656d          .db "parse-name"
0005b5 05a1          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
0005b6 3800          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
0005b7 3f3e          .dw XT_BL
0005b8 05ba          .dw XT_SKIPSCANCHAR
0005b9 381f          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
0005ba 3800          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
0005bb 38fe          .dw XT_TO_R
0005bc 059d          .dw XT_SOURCE 
0005bd 3ecc          .dw XT_TO_IN 
0005be 3878          .dw XT_FETCH 
0005bf 05a7          .dw XT_SLASHSTRING 
                 
0005c0 3905          .dw XT_R_FETCH
0005c1 044f          .dw XT_CSKIP
0005c2 38f5          .dw XT_R_FROM
0005c3 0466          .dw XT_CSCAN
                 
                     ; adjust >IN
0005c4 3eb3          .dw XT_2DUP
0005c5 399c          .dw XT_PLUS
0005c6 059d          .dw XT_SOURCE 
0005c7 38d8          .dw XT_DROP
0005c8 3992          .dw XT_MINUS
0005c9 3ecc          .dw XT_TO_IN
0005ca 3880          .dw XT_STORE
0005cb 381f          .dw XT_EXIT
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
0005cc ff03          .dw $ff03
0005cd 7073
0005ce 0030          .db "sp0",0
0005cf 05af          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
0005d0 386e          .dw PFA_DOVALUE1
                 PFA_SP0:
0005d1 0006          .dw USER_SP0
0005d2 3db2          .dw XT_UDEFERFETCH
0005d3 3dbe          .dw XT_UDEFERSTORE
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
0005d4 ff03          .dw $ff03
0005d5 7072
0005d6 0030          .db "rp0",0
0005d7 05cc          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
0005d8 3800          .dw DO_COLON
                 PFA_RP0:
0005d9 05dc          .dw XT_DORP0
0005da 3878          .dw XT_FETCH
0005db 381f          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
0005dc 3857          .dw PFA_DOUSER
                 PFA_DORP0:
0005dd 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
0005de ff05          .dw $ff05
0005df 6564
0005e0 7470
0005e1 0068          .db "depth",0
0005e2 05d4          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
0005e3 3800          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
0005e4 05d0          .dw XT_SP0
0005e5 3a8c          .dw XT_SP_FETCH
0005e6 3992          .dw XT_MINUS
0005e7 3a03          .dw XT_2SLASH
0005e8 3a34          .dw XT_1MINUS
0005e9 381f          .dw XT_EXIT
                 .include "words/forth-recognizer.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_FORTHRECOGNIZER:
0005ea ff10          .dw $ff10
0005eb 6f66
0005ec 7472
0005ed 2d68
0005ee 6572
0005ef 6f63
0005f0 6e67
0005f1 7a69
0005f2 7265          .db "forth-recognizer"
0005f3 05de          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHRECOGNIZER
                 XT_FORTHRECOGNIZER:
0005f4 386e          .dw PFA_DOVALUE1
                 PFA_FORTHRECOGNIZER:
0005f5 0060          .dw CFG_FORTHRECOGNIZER
0005f6 3d8a          .dw XT_EDEFERFETCH
0005f7 3d94          .dw XT_EDEFERSTORE
                 .include "words/recognize.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECOGNIZE:
0005f8 ff09          .dw $ff09
0005f9 6572
0005fa 6f63
0005fb 6e67
0005fc 7a69
0005fd 0065          .db "recognize",0
0005fe 05ea          .dw VE_HEAD
                     .set VE_HEAD = VE_RECOGNIZE
                 XT_RECOGNIZE:
0005ff 3800          .dw DO_COLON
                 PFA_RECOGNIZE:
                 .endif
000600 383c          .dw XT_DOLITERAL
000601 060a          .dw XT_RECOGNIZE_A
000602 38c3          .dw XT_SWAP
000603 09b1          .dw XT_MAPSTACK
000604 3917          .dw XT_ZEROEQUAL
000605 3835          .dw XT_DOCONDBRANCH
000606 0609          DEST(PFA_RECOGNIZE1)
000607 3ebc            .dw XT_2DROP
000608 0695            .dw XT_RECTYPE_NULL
                 PFA_RECOGNIZE1:
000609 381f          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ; ( addr len XT -- addr len [ rectype-* -1 | 0 ] )
                 XT_RECOGNIZE_A:
00060a 3800         .dw DO_COLON
                 PFA_RECOGNIZE_A:
                 .endif
00060b 38e0         .dw XT_ROT  ; -- len xt addr
00060c 38e0         .dw XT_ROT  ; -- xt addr len
00060d 3eb3         .dw XT_2DUP 
00060e 3b13         .dw XT_2TO_R
00060f 38e0         .dw XT_ROT  ; -- addr len xt
000610 3829         .dw XT_EXECUTE ; -- i*x rectype-* | rectype-null
000611 3b22         .dw XT_2R_FROM
000612 38e0         .dw XT_ROT
000613 38b0         .dw XT_DUP
000614 0695         .dw XT_RECTYPE_NULL
000615 3bd5         .dw XT_EQUAL
000616 3835         .dw XT_DOCONDBRANCH
000617 061b         DEST(PFA_RECOGNIZE_A1)
000618 38d8           .dw XT_DROP
000619 3953           .dw XT_ZERO
00061a 381f           .dw XT_EXIT
                 PFA_RECOGNIZE_A1:
00061b 38ef         .dw XT_NIP 
00061c 38ef         .dw XT_NIP
00061d 394a         .dw XT_TRUE
00061e 381f         .dw XT_EXIT
                 
                 ; : recognize ( addr len stack-id -- i*x rectype-* | rectype-null )
                 ;   [: ( addr len -- addr len 0 | i*x rectype-* -1 )
                 ;      rot rot 2dup 2>r rot execute 2r> rot 
                 ;      dup rectype-null = ( -- addr len rectype-* f )
                 ;      if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    map-stack ( -- i*x addr len rectype-* f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop rectype-null
                 ;    then ;
                 ;
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
00061f ff09          .dw $ff09
000620 6e69
000621 6574
000622 7072
000623 6572
000624 0074          .db "interpret",0
000625 05f8          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
000626 3800          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
000627 05b6          .dw XT_PARSENAME ; ( -- addr len )
000628 38b0          .dw XT_DUP   ; ( -- addr len flag)
000629 3835          .dw XT_DOCONDBRANCH
00062a 0637          DEST(PFA_INTERPRET2)
00062b 05f4            .dw XT_FORTHRECOGNIZER
00062c 05ff            .dw XT_RECOGNIZE
00062d 3ea1            .dw XT_STATE
00062e 3878            .dw XT_FETCH
00062f 3835            .dw XT_DOCONDBRANCH
000630 0632          DEST(PFA_INTERPRET1)
000631 01ae            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
000632 3bc0            .dw XT_FETCHI
000633 3829            .dw XT_EXECUTE
000634 3f75            .dw XT_QSTACK
000635 382e          .dw XT_DOBRANCH
000636 0627          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
000637 3ebc          .dw XT_2DROP
000638 381f          .dw XT_EXIT
                 .include "words/rec-intnum.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_NUM:
000639 ff0b          .dw $ff0b
00063a 6572
00063b 7463
00063c 7079
00063d 2d65
00063e 756e
00063f 006d          .db "rectype-num",0
000640 061f          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_NUM
                 XT_RECTYPE_NUM:
000641 3851          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_NUM:
                 .endif
000642 3fbf          .dw XT_NOOP    ; interpret
000643 0787          .dw XT_LITERAL ; compile
000644 0787          .dw XT_LITERAL ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_DNUM:
000645 ff0c          .dw $ff0c
000646 6572
000647 7463
000648 7079
000649 2d65
00064a 6e64
00064b 6d75          .db "rectype-dnum"
00064c 0639          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_DNUM
                 XT_RECTYPE_DNUM:
00064d 3851          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_DNUM:
                 .endif
00064e 3fbf          .dw XT_NOOP     ; interpret
00064f 3bcd          .dw XT_2LITERAL ; compile
000650 3bcd          .dw XT_2LITERAL ; postpone
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
000651 ff07          .dw $ff07
000652 6572
000653 2d63
000654 756e
000655 006d          .db "rec-num",0
000656 0645          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
000657 3800          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
000658 04f6          .dw XT_NUMBER
000659 3835          .dw XT_DOCONDBRANCH
00065a 0663          DEST(PFA_REC_NONUMBER)
00065b 3bdc          .dw XT_ONE
00065c 3bd5          .dw XT_EQUAL
00065d 3835          .dw XT_DOCONDBRANCH
00065e 0661          DEST(PFA_REC_INTNUM2)
00065f 0641            .dw XT_RECTYPE_NUM
000660 381f            .dw XT_EXIT
                 PFA_REC_INTNUM2:
000661 064d            .dw XT_RECTYPE_DNUM
000662 381f            .dw XT_EXIT
                 PFA_REC_NONUMBER:
000663 0695          .dw XT_RECTYPE_NULL
000664 381f          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_FIND:
000665 ff08          .dw $ff08
000666 6572
000667 2d63
000668 6966
000669 646e          .db "rec-find"
00066a 0651          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
00066b 3800          .dw DO_COLON
                 PFA_REC_FIND:
                 .endif
00066c 070a          .DW XT_FINDXT
00066d 38b0          .dw XT_DUP
00066e 3917          .dw XT_ZEROEQUAL
00066f 3835          .dw XT_DOCONDBRANCH
000670 0674          DEST(PFA_REC_WORD_FOUND)
000671 38d8              .dw XT_DROP
000672 0695      	.dw XT_RECTYPE_NULL
000673 381f      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
000674 067d          .dw XT_RECTYPE_XT
                 
000675 381f          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_XT:
000676 ff0a          .dw $ff0a
000677 6572
000678 7463
000679 7079
00067a 2d65
00067b 7478          .db "rectype-xt"
00067c 0665          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_XT
                 XT_RECTYPE_XT:
00067d 3851          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_XT:
                 .endif
00067e 0681          .dw XT_R_WORD_INTERPRET
00067f 0685          .dw XT_R_WORD_COMPILE
000680 3bcd          .dw XT_2LITERAL
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
000681 3800          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
000682 38d8          .dw XT_DROP ; the flags are in the way
000683 3829          .dw XT_EXECUTE
000684 381f          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
000685 3800          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
000686 391e          .dw XT_ZEROLESS
000687 3835          .dw XT_DOCONDBRANCH
000688 068b          DEST(PFA_R_WORD_COMPILE1)
000689 0771      	.dw XT_COMMA
00068a 381f              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
00068b 3829              .dw XT_EXECUTE
00068c 381f          .dw XT_EXIT
                 .include "words/rec-null.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_NULL:
00068d ff0c          .dw $ff0c
00068e 6572
00068f 7463
000690 7079
000691 2d65
000692 756e
000693 6c6c          .db "rectype-null"
000694 0676          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_NULL
                 XT_RECTYPE_NULL:
000695 3851          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_NULL:
                 .endif
000696 0699          .dw XT_FAIL  ; interpret
000697 0699          .dw XT_FAIL  ; compile
000698 0699          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
000699 3800          .dw DO_COLON
                 PFA_FAIL:
                 .endif
00069a 383c          .dw XT_DOLITERAL
00069b fff3          .dw -13
00069c 3d73          .dw XT_THROW
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
00069d ff0f          .dw $ff0f
00069e 6573
00069f 7261
0006a0 6863
0006a1 772d
0006a2 726f
0006a3 6c64
0006a4 7369
0006a5 0074          .db "search-wordlist",0
0006a6 068d          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
0006a7 3800          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
0006a8 38fe          .dw XT_TO_R
0006a9 3953          .dw XT_ZERO
0006aa 383c          .dw XT_DOLITERAL
0006ab 06bc          .dw XT_ISWORD
0006ac 38f5          .dw XT_R_FROM
0006ad 06d9          .dw XT_TRAVERSEWORDLIST
0006ae 38b0          .dw XT_DUP
0006af 3917          .dw XT_ZEROEQUAL
0006b0 3835          .dw XT_DOCONDBRANCH
0006b1 06b6          DEST(PFA_SEARCH_WORDLIST1)
0006b2 3ebc             .dw XT_2DROP
0006b3 38d8             .dw XT_DROP
0006b4 3953             .dw XT_ZERO
0006b5 381f             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
0006b6 38b0            .dw XT_DUP
0006b7 0700            .dw XT_NFA2CFA
                       ; .. and get the header flag
0006b8 38c3            .dw XT_SWAP
0006b9 0158            .dw XT_NAME2FLAGS
0006ba 0146            .dw XT_IMMEDIATEQ
0006bb 381f          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
0006bc 3800          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
0006bd 38fe          .dw XT_TO_R
0006be 38d8          .dw XT_DROP
0006bf 3eb3          .dw XT_2DUP
0006c0 3905          .dw XT_R_FETCH  ; -- addr len addr len nt
0006c1 06f4          .dw XT_NAME2STRING
0006c2 01b7          .dw XT_ICOMPARE      ; (-- addr len f )
0006c3 3835          .dw XT_DOCONDBRANCH
0006c4 06ca          DEST(PFA_ISWORD3)
                       ; not now
0006c5 38f5            .dw XT_R_FROM
0006c6 38d8            .dw XT_DROP
0006c7 3953            .dw XT_ZERO
0006c8 394a            .dw XT_TRUE         ; maybe next word
0006c9 381f            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
0006ca 3ebc            .dw XT_2DROP
0006cb 38f5            .dw XT_R_FROM
0006cc 3953            .dw XT_ZERO       ; finish traverse-wordlist
0006cd 381f            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
0006ce ff11          .dw $ff11
0006cf 7274
0006d0 7661
0006d1 7265
0006d2 6573
0006d3 772d
0006d4 726f
0006d5 6c64
0006d6 7369
0006d7 0074          .db "traverse-wordlist",0
0006d8 069d          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
0006d9 3800          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
0006da 3b54          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
0006db 38b0          .dw XT_DUP           ; ( -- xt nt nt )
0006dc 3835          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
0006dd 06ea          DEST(PFA_TRAVERSEWORDLIST2)
0006de 3eb3          .dw XT_2DUP
0006df 3b13          .dw XT_2TO_R
0006e0 38c3          .dw XT_SWAP
0006e1 3829          .dw XT_EXECUTE
0006e2 3b22          .dw XT_2R_FROM
0006e3 38e0          .dw XT_ROT
0006e4 3835          .dw XT_DOCONDBRANCH
0006e5 06ea          DEST(PFA_TRAVERSEWORDLIST2)
0006e6 0a1c          .dw XT_NFA2LFA
0006e7 3bc0          .dw XT_FETCHI
0006e8 382e          .dw XT_DOBRANCH      ; ( -- addr )
0006e9 06db          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
0006ea 3ebc          .dw XT_2DROP
0006eb 381f          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' )
                 ;        begin @ dup
                 ;        while
                 ;          2dup 2>r
                 ;          swap execute ( i*x nt -- i*x' f )
                 ;          2r> rot
                 ;        while
                 ;          nfa>lfa @i
                 ;        repeat then 2drop ;
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
0006ec ff0b          .dw $ff0b
0006ed 616e
0006ee 656d
0006ef 733e
0006f0 7274
0006f1 6e69
0006f2 0067          .db "name>string",0
0006f3 06ce          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
0006f4 3800          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
0006f5 041d          .dw XT_ICOUNT   ; ( -- addr n )
0006f6 383c          .dw XT_DOLITERAL
0006f7 00ff          .dw 255
0006f8 3a12          .dw XT_AND      ; mask immediate bit
0006f9 381f          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
0006fa ff07          .dw $ff07
0006fb 666e
0006fc 3e61
0006fd 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
0006fe 0061          .db "nfa>cfa"
0006ff 06ec          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
000700 3800          .dw DO_COLON
                 PFA_NFA2CFA:
000701 0a1c          .dw XT_NFA2LFA ; skip to link field
000702 3a2e          .dw XT_1PLUS   ; next is the execution token
000703 381f          .dw XT_EXIT
                 .include "words/find-xt.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the xt from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDXT:
000704 ff07          .dw $ff07
000705 6966
000706 646e
000707 782d
000708 0074          .db "find-xt",0
000709 06fa          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDXT
                 XT_FINDXT:
00070a 3800          .dw DO_COLON
                 PFA_FINDXT:
                 .endif
00070b 383c          .dw XT_DOLITERAL
00070c 0716          .dw XT_FINDXTA
00070d 383c          .dw XT_DOLITERAL
00070e 006c          .dw CFG_ORDERLISTLEN
00070f 09b1          .dw XT_MAPSTACK
000710 3917          .dw XT_ZEROEQUAL
000711 3835          .dw XT_DOCONDBRANCH
000712 0715          DEST(PFA_FINDXT1)
000713 3ebc            .dw XT_2DROP
000714 3953            .dw XT_ZERO
                 PFA_FINDXT1:
000715 381f          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDXTA:
000716 3800          .dw DO_COLON
                 PFA_FINDXTA:
                 .endif
000717 38fe          .dw XT_TO_R
000718 3eb3          .dw XT_2DUP
000719 38f5          .dw XT_R_FROM
00071a 06a7          .dw XT_SEARCH_WORDLIST
00071b 38b0          .dw XT_DUP
00071c 3835          .dw XT_DOCONDBRANCH
00071d 0723          DEST(PFA_FINDXTA1)
00071e 38fe            .dw XT_TO_R
00071f 38ef            .dw XT_NIP
000720 38ef            .dw XT_NIP
000721 38f5            .dw XT_R_FROM
000722 394a            .dw XT_TRUE
                 PFA_FINDXTA1:
000723 381f          .dw XT_EXIT
                 
                 .include "dict/compiler1.inc"
                 
                 .include "words/newest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_NEWEST:
000724 ff06          .dw $ff06
000725 656e
000726 6577
000727 7473          .db "newest"
000728 0704          .dw VE_HEAD
                     .set VE_HEAD = VE_NEWEST
                 XT_NEWEST:
000729 3847          .dw PFA_DOVARIABLE
                 PFA_NEWEST:
00072a 019b          .dw ram_newest
                 
                 .dseg
00019b           ram_newest: .byte 4
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_LATEST:
00072b ff06          .dw $ff06
00072c 616c
00072d 6574
00072e 7473          .db "latest"
00072f 0724          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
000730 3847          .dw PFA_DOVARIABLE
                 PFA_LATEST:
000731 019f          .dw ram_latest
                 
                 .dseg
00019f           ram_latest: .byte 2
                 .include "words/do-create.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE:
000732 ff08          .dw $ff08
000733 6328
000734 6572
000735 7461
000736 2965          .db "(create)"
000737 072b          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
000738 3800          .dw DO_COLON
                 PFA_DOCREATE:
                 .endif
000739 05b6
00073a 089a          .DW XT_PARSENAME,XT_WLSCOPE  ; ( -- addr len wid)
00073b 0745          .DW XT_DOCREATE_IN           ; ( addr len wid -- )
00073c 381f          .DW XT_EXIT
                 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE_IN:
00073d ff0b          .dw $ff0b
00073e 6328
00073f 6572
000740 7461
000741 2d65
000742 6e69
../../common\words/do-create.asm(31): warning: .cseg .db misalignment - padding zero byte
000743 0029          .db "(create-in)"
000744 0732          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE_IN
                 XT_DOCREATE_IN:
000745 3800          .dw DO_COLON
                 PFA_DOCREATE_IN:
                 .endif
000746 38b0
000747 0729
000748 3ca6
000749 3880          .DW XT_DUP,XT_NEWEST,XT_CELLPLUS,XT_STORE ; save the wid
00074a 087f
00074b 0729
00074c 3880          .DW XT_HEADER,XT_NEWEST,XT_STORE          ; save the nt
00074d 381f          .DW XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
00074e 0001          .dw $0001
00074f 005c          .db $5c,0
000750 073d          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
000751 3800          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
000752 059d          .dw XT_SOURCE
000753 38ef          .dw XT_NIP
000754 3ecc          .dw XT_TO_IN
000755 3880          .dw XT_STORE
000756 381f          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
000757 0001          .dw $0001
000758 0028          .db "(" ,0
000759 074e          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
00075a 3800          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
00075b 383c          .dw XT_DOLITERAL
00075c 0029          .dw ')'
00075d 0589          .dw XT_PARSE
00075e 3ebc          .dw XT_2DROP
00075f 381f          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
000760 ff07          .dw $ff07
000761 6f63
000762 706d
000763 6c69
000764 0065          .db "compile",0
000765 0757          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
000766 3800          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
000767 38f5          .dw XT_R_FROM
000768 38b0          .dw XT_DUP
000769 01ae          .dw XT_ICELLPLUS
00076a 38fe          .dw XT_TO_R
00076b 3bc0          .dw XT_FETCHI
00076c 0771          .dw XT_COMMA
00076d 381f          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
00076e ff01          .dw $ff01
00076f 002c          .db ',',0 ; ,
000770 0760          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
000771 3800          .dw DO_COLON
                 PFA_COMMA:
000772 3efc          .dw XT_DP
000773 3b68          .dw XT_STOREI
000774 3efc          .dw XT_DP
000775 3a2e          .dw XT_1PLUS
000776 019c          .dw XT_DOTO
000777 3efd          .dw PFA_DP
000778 381f          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
000779 0003          .dw $0003
00077a 275b
00077b 005d          .db "[']",0
00077c 076e          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
00077d 3800          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
00077e 0436          .dw XT_TICK
00077f 0787          .dw XT_LITERAL
000780 381f          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
000781 0007          .dw $0007
000782 696c
000783 6574
000784 6172
000785 006c          .db "literal",0
000786 0779          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
000787 3800          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
000788 0766              .DW XT_COMPILE
000789 383c              .DW XT_DOLITERAL
00078a 0771              .DW XT_COMMA
00078b 381f              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
00078c 0008        .dw $0008
00078d 6c73
00078e 7469
00078f 7265
000790 6c61        .db "sliteral"
000791 0781        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
000792 3800          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
000793 0766          .dw XT_COMPILE
000794 03be          .dw XT_DOSLITERAL    ; ( -- addr n)
000795 03cc          .dw XT_SCOMMA
000796 381f          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
000797 3800          .dw DO_COLON
                 PFA_GMARK:
000798 3efc          .dw XT_DP
000799 0766          .dw XT_COMPILE
00079a ffff          .dw -1           ; ffff does not erase flash
00079b 381f          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
00079c 3800          .dw DO_COLON
                 PFA_GRESOLVE:
00079d 3f75          .dw XT_QSTACK
00079e 3efc          .dw XT_DP
00079f 38c3          .dw XT_SWAP
0007a0 3b68          .dw XT_STOREI
0007a1 381f          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
0007a2 3800          .dw DO_COLON
                 PFA_LMARK:
0007a3 3efc          .dw XT_DP
0007a4 381f          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
0007a5 3800          .dw DO_COLON
                 PFA_LRESOLVE:
0007a6 3f75          .dw XT_QSTACK
0007a7 0771          .dw XT_COMMA
0007a8 381f          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
0007a9 0005          .dw $0005
0007aa 6861
0007ab 6165
0007ac 0064          .db "ahead",0
0007ad 078c          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
0007ae 3800          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
0007af 0766          .dw XT_COMPILE
0007b0 382e          .dw XT_DOBRANCH
0007b1 0797          .dw XT_GMARK
0007b2 381f          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
0007b3 0002          .dw $0002
0007b4 6669          .db "if"
0007b5 07a9          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
0007b6 3800          .dw DO_COLON
                 PFA_IF:
                 .endif
0007b7 0766          .dw XT_COMPILE
0007b8 3835          .dw XT_DOCONDBRANCH
0007b9 0797          .dw XT_GMARK
0007ba 381f          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
0007bb 0004          .dw $0004
0007bc 6c65
0007bd 6573          .db "else"
0007be 07b3          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
0007bf 3800          .dw DO_COLON
                 PFA_ELSE:
                 .endif
0007c0 0766          .dw XT_COMPILE
0007c1 382e          .dw XT_DOBRANCH
0007c2 0797          .dw XT_GMARK
0007c3 38c3          .dw XT_SWAP
0007c4 079c          .dw XT_GRESOLVE
0007c5 381f          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
0007c6 0004          .dw $0004
0007c7 6874
0007c8 6e65          .db "then"
0007c9 07bb          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
0007ca 3800          .dw DO_COLON
                 PFA_THEN:
                 .endif
0007cb 079c          .dw XT_GRESOLVE
0007cc 381f          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
0007cd 0005          .dw $0005
0007ce 6562
0007cf 6967
0007d0 006e          .db "begin",0
0007d1 07c6          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
0007d2 3800          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
0007d3 07a2          .dw XT_LMARK
0007d4 381f          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
0007d5 0005          .dw $0005
0007d6 6877
0007d7 6c69
0007d8 0065          .db "while",0
0007d9 07cd          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
0007da 3800          .dw DO_COLON
                 PFA_WHILE:
                 .endif
0007db 07b6          .dw XT_IF
0007dc 38c3          .dw XT_SWAP
0007dd 381f          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
0007de 0006          .dw $0006
0007df 6572
0007e0 6570
0007e1 7461          .db "repeat"
0007e2 07d5          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
0007e3 3800          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
0007e4 07f7          .dw XT_AGAIN
0007e5 07ca          .dw XT_THEN
0007e6 381f          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
0007e7 0005          .dw $0005
0007e8 6e75
0007e9 6974
0007ea 006c          .db "until",0
0007eb 07de          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
0007ec 3800          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
0007ed 383c          .dw XT_DOLITERAL
0007ee 3835          .dw XT_DOCONDBRANCH
0007ef 0771          .dw XT_COMMA
                 
0007f0 07a5          .dw XT_LRESOLVE
0007f1 381f          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
0007f2 0005          .dw $0005
0007f3 6761
0007f4 6961
0007f5 006e          .db "again",0
0007f6 07e7          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
0007f7 3800          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
0007f8 0766          .dw XT_COMPILE
0007f9 382e          .dw XT_DOBRANCH
0007fa 07a5          .dw XT_LRESOLVE
0007fb 381f          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
0007fc 0002          .dw $0002
0007fd 6f64          .db "do"
0007fe 07f2          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
0007ff 3800          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
000800 0766          .dw XT_COMPILE
000801 3a9a          .dw XT_DODO
000802 07a2          .dw XT_LMARK
000803 3953          .dw XT_ZERO
000804 085a          .dw XT_TO_L
000805 381f          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
000806 0004          .dw $0004
000807 6f6c
000808 706f          .db "loop"
000809 07fc          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
00080a 3800          .dw DO_COLON
                 PFA_LOOP:
                 .endif
00080b 0766          .dw XT_COMPILE
00080c 3ac8          .dw XT_DOLOOP
00080d 0841          .dw XT_ENDLOOP
00080e 381f          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
00080f 0005          .dw $0005
000810 6c2b
000811 6f6f
000812 0070          .db "+loop",0
000813 0806          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
000814 3800          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
000815 0766          .dw XT_COMPILE
000816 3ab9          .dw XT_DOPLUSLOOP
000817 0841          .dw XT_ENDLOOP
000818 381f          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
000819 0005         .dw $0005
00081a 656c
00081b 7661
00081c 0065         .db "leave",0
00081d 080f         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
00081e 3800          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
00081f 0766
000820 3ad3          .DW XT_COMPILE,XT_UNLOOP
000821 07ae
000822 085a
000823 381f          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
000824 0003          .dw $0003
000825 643f
000826 006f          .db "?do",0
000827 0819          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
000828 3800          .dw DO_COLON
                 PFA_QDO:
                 .endif
000829 0766          .dw XT_COMPILE
00082a 0830          .dw XT_QDOCHECK
00082b 07b6          .dw XT_IF
00082c 07ff          .dw XT_DO
00082d 38c3          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
00082e 085a          .dw XT_TO_L    ; then follows at the end.
00082f 381f          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
000830 3800          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
000831 3eb3          .dw XT_2DUP
000832 3bd5          .dw XT_EQUAL
000833 38b0          .dw XT_DUP
000834 38fe          .dw XT_TO_R
000835 3835          .dw XT_DOCONDBRANCH
000836 0838          DEST(PFA_QDOCHECK1)
000837 3ebc          .dw XT_2DROP
                 PFA_QDOCHECK1:
000838 38f5          .dw XT_R_FROM
000839 39fc          .dw XT_INVERT
00083a 381f          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
00083b ff07          .dw $ff07
00083c 6e65
00083d 6c64
00083e 6f6f
00083f 0070          .db "endloop",0
000840 0824          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
000841 3800          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
000842 07a5              .DW XT_LRESOLVE
000843 084e
000844 38b8
000845 3835      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
000846 084a               DEST(LOOP2)
000847 07ca              .DW XT_THEN
000848 382e      	.dw XT_DOBRANCH
000849 0843               DEST(LOOP1)
00084a 381f      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
00084b ff02          .dw $ff02
00084c 3e6c          .db "l>"
00084d 083b          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
00084e 3800          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
00084f 086d          .dw XT_LP
000850 3878          .dw XT_FETCH
000851 3878          .dw XT_FETCH
000852 383c          .dw XT_DOLITERAL
000853 fffe          .dw -2
000854 086d          .dw XT_LP
000855 3a64          .dw XT_PLUSSTORE
000856 381f          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
000857 ff02          .dw $ff02
000858 6c3e          .db ">l"
000859 084b          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
00085a 3800          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
00085b 3be1              .dw XT_TWO
00085c 086d      	.dw XT_LP
00085d 3a64      	.dw XT_PLUSSTORE
00085e 086d      	.dw XT_LP
00085f 3878      	.dw XT_FETCH
000860 3880      	.dw XT_STORE
000861 381f      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
000862 ff03          .dw $ff03
000863 706c
000864 0030          .db "lp0",0
000865 0857          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
000866 386e          .dw PFA_DOVALUE1
                 PFA_LP0:
000867 0062          .dw CFG_LP0
000868 3d8a          .dw XT_EDEFERFETCH
000869 3d94          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
00086a ff02          .dw $ff02
00086b 706c          .db "lp"
00086c 0862          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
00086d 3847          .dw PFA_DOVARIABLE
                 PFA_LP:
00086e 01a1          .dw ram_lp
                 
                 .dseg
0001a1           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CREATE:
00086f ff06          .dw $ff06
000870 7263
000871 6165
000872 6574          .db "create"
000873 086a          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
000874 3800          .dw DO_COLON
                 PFA_CREATE:
                 .endif
000875 0738          .dw XT_DOCREATE
000876 08a3          .dw XT_REVEAL
000877 0766          .dw XT_COMPILE
000878 3851          .dw PFA_DOCONSTANT
000879 381f          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
00087a ff06          .dw $ff06
00087b 6568
00087c 6461
00087d 7265          .db "header"
00087e 086f          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
00087f 3800          .dw DO_COLON
                 PFA_HEADER:
000880 3efc          .dw XT_DP           ; the new Name Field
000881 38fe          .dw XT_TO_R
000882 38fe          .dw XT_TO_R		; ( R: NFA WID )
000883 38b0          .dw XT_DUP    
000884 3925          .dw XT_GREATERZERO 
000885 3835          .dw XT_DOCONDBRANCH
000886 0891          .dw PFA_HEADER1
000887 38b0          .dw XT_DUP
000888 383c          .dw XT_DOLITERAL
000889 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
00088a 3a1b          .dw XT_OR
00088b 03d0          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
00088c 38f5          .dw XT_R_FROM
00088d 3b54          .dw XT_FETCHE
00088e 0771          .dw XT_COMMA
00088f 38f5          .dw XT_R_FROM
000890 381f          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
000891 383c          .dw XT_DOLITERAL
000892 fff0          .dw -16
000893 3d73          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
000894 ff07          .dw $ff07
000895 6c77
000896 6373
000897 706f
000898 0065          .db "wlscope",0
000899 087a          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
00089a 3de9          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
00089b 005e          .dw CFG_WLSCOPE
00089c 3d8a          .dw XT_EDEFERFETCH
00089d 3d94          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REVEAL:
00089e ff06          .dw $ff06
00089f 6572
0008a0 6576
0008a1 6c61          .db "reveal"
0008a2 0894          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
0008a3 3800          .dw DO_COLON
                 PFA_REVEAL:
                 .endif
0008a4 0729
0008a5 3ca6
0008a6 3878          .DW XT_NEWEST,XT_CELLPLUS,XT_FETCH ; only if wordlist is in use
0008a7 38b8
0008a8 3835          .DW XT_QDUP,XT_DOCONDBRANCH
0008a9 08ae          DEST(REVEAL1)
0008aa 0729
0008ab 3878
0008ac 38c3
0008ad 3b30          .DW XT_NEWEST,XT_FETCH,XT_SWAP,XT_STOREE
                 ;    .DW XT_ZERO,XT_NEWEST,XT_CELLPLUS,XT_STORE ; clean wordlist entry
                 REVEAL1:
0008ae 381f          .DW XT_EXIT
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
0008af 0005          .dw $0005
0008b0 6f64
0008b1 7365
0008b2 003e          .db "does>",0
0008b3 089e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
0008b4 3800          .dw DO_COLON
                 PFA_DOES:
0008b5 0766          .dw XT_COMPILE
0008b6 08c7          .dw XT_DODOES
0008b7 0766          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
0008b8 940e          .dw $940e       ; the address of this compiled
0008b9 0766          .dw XT_COMPILE  ; code will replace the XT of the 
0008ba 08bc          .dw DO_DODOES   ; word that CREATE created
0008bb 381f          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
0008bc 939a
0008bd 938a          savetos
0008be 01cb          movw tosl, wl
0008bf 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
0008c0 917f          pop wh
0008c1 916f          pop wl
                 
0008c2 93bf          push XH
0008c3 93af          push XL
0008c4 01db          movw XL, wl
0008c5 940c 3804     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
0008c7 3800          .dw DO_COLON
                 PFA_DODOES:
0008c8 38f5          .dw XT_R_FROM
0008c9 0729          .dw XT_NEWEST
0008ca 3ca6          .dw XT_CELLPLUS
0008cb 3878          .dw XT_FETCH
0008cc 3b54          .dw XT_FETCHE
0008cd 0700          .dw XT_NFA2CFA
0008ce 3b68          .dw XT_STOREI
0008cf 381f          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
0008d0 ff01          .dw $ff01
0008d1 003a          .db ":",0
0008d2 08af          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
0008d3 3800          .dw DO_COLON
                 PFA_COLON:
                 .endif
0008d4 0738          .dw XT_DOCREATE
0008d5 08de          .dw XT_COLONNONAME
0008d6 38d8          .dw XT_DROP
0008d7 381f          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
0008d8 ff07          .dw $ff07
0008d9 6e3a
0008da 6e6f
0008db 6d61
0008dc 0065          .db ":noname",0
0008dd 08d0          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
0008de 3800          .dw DO_COLON
                 PFA_COLONNONAME:
0008df 3efc          .dw XT_DP
0008e0 38b0          .dw XT_DUP
0008e1 0730          .dw XT_LATEST
0008e2 3880          .dw XT_STORE
                 
0008e3 0766          .dw XT_COMPILE
0008e4 3800          .dw DO_COLON
                 
0008e5 08f3          .dw XT_RBRACKET
0008e6 381f          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
0008e7 0001          .dw $0001
0008e8 003b          .db $3b,0
0008e9 08d8          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
0008ea 3800          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
0008eb 0766          .dw XT_COMPILE
0008ec 381f          .dw XT_EXIT
0008ed 08fb          .dw XT_LBRACKET
0008ee 08a3          .dw XT_REVEAL
0008ef 381f          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
0008f0 ff01          .dw $ff01
0008f1 005d          .db "]",0
0008f2 08e7          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
0008f3 3800          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
0008f4 3bdc          .dw XT_ONE
0008f5 3ea1          .dw XT_STATE
0008f6 3880          .dw XT_STORE
0008f7 381f          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
0008f8 0001          .dw $0001
0008f9 005b          .db "[",0
0008fa 08f0          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
0008fb 3800          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
0008fc 3953          .dw XT_ZERO
0008fd 3ea1          .dw XT_STATE
0008fe 3880          .dw XT_STORE
0008ff 381f          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
000900 ff08          .dw $ff08
000901 6176
000902 6972
000903 6261
000904 656c          .db "variable"
000905 08f8          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
000906 3800          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
000907 3f0d          .dw XT_HERE
000908 0912          .dw XT_CONSTANT
000909 3be1          .dw XT_TWO
00090a 3f16          .dw XT_ALLOT
00090b 381f          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
00090c ff08          .dw $ff08
00090d 6f63
00090e 736e
00090f 6174
000910 746e          .db "constant"
000911 0900          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
000912 3800          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
000913 0738          .dw XT_DOCREATE
000914 08a3          .dw XT_REVEAL
000915 0766          .dw XT_COMPILE
000916 3847          .dw PFA_DOVARIABLE
000917 0771          .dw XT_COMMA
000918 381f          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
000919 ff04          .dw $ff04
00091a 7375
00091b 7265          .db "user"
00091c 090c          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
00091d 3800          .dw DO_COLON
                 PFA_USER:
00091e 0738          .dw XT_DOCREATE
00091f 08a3          .dw XT_REVEAL
                 
000920 0766          .dw XT_COMPILE
000921 3857          .dw PFA_DOUSER
000922 0771          .dw XT_COMMA
000923 381f          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECURSE:
000924 0007          .dw $0007
000925 6572
000926 7563
000927 7372
000928 0065          .db "recurse",0
000929 0919          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
00092a 3800          .dw DO_COLON
                 PFA_RECURSE:
                 .endif
00092b 0730          .dw XT_LATEST
00092c 3878          .dw XT_FETCH
00092d 0771          .dw XT_COMMA
00092e 381f          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
00092f ff09          .dw $ff09
000930 6d69
000931 656d
000932 6964
000933 7461
000934 0065          .db "immediate",0
000935 0924          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
000936 3800          .dw DO_COLON
                 PFA_IMMEDIATE:
000937 09d8          .dw XT_GET_CURRENT
000938 3b54          .dw XT_FETCHE
000939 38b0          .dw XT_DUP
00093a 3bc0          .dw XT_FETCHI
00093b 383c          .dw XT_DOLITERAL
00093c 7fff          .dw $7fff
00093d 3a12          .dw XT_AND
00093e 38c3          .dw XT_SWAP
00093f 3b68          .dw XT_STOREI
000940 381f          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
000941 0006          .dw $0006
000942 635b
000943 6168
000944 5d72          .db "[char]"
000945 092f          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
000946 3800          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
000947 0766          .dw XT_COMPILE
000948 383c          .dw XT_DOLITERAL
000949 04e7          .dw XT_CHAR
00094a 0771          .dw XT_COMMA
00094b 381f          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
00094c 0006          .dw $0006
00094d 6261
00094e 726f
00094f 2274          .db "abort",'"'
000950 0941          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
000951 3800          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
000952 3e74          .dw XT_SQUOTE
000953 0766          .dw XT_COMPILE
000954 0963          .dw XT_QABORT
000955 381f          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
000956 ff05          .dw $ff05
000957 6261
000958 726f
000959 0074          .db "abort",0
00095a 094c          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
00095b 3800          .dw DO_COLON
                 PFA_ABORT:
                 .endif
00095c 394a          .dw XT_TRUE
00095d 3d73          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
00095e ff06          .dw $ff06
00095f 613f
000960 6f62
000961 7472          .db "?abort"
000962 0956          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
000963 3800          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
000964 38e0
000965 3835              .DW XT_ROT,XT_DOCONDBRANCH
000966 0969              DEST(QABO1)
000967 03f1
000968 095b              .DW XT_ITYPE,XT_ABORT
000969 3ebc
00096a 381f      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
00096b ff09          .dw $ff09
00096c 6567
00096d 2d74
00096e 7473
00096f 6361
000970 006b          .db "get-stack",0
000971 095e          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
000972 3800          .dw DO_COLON
                 .endif
000973 38b0          .dw XT_DUP
000974 3ca6          .dw XT_CELLPLUS
000975 38c3          .dw XT_SWAP
000976 3b54          .dw XT_FETCHE
000977 38b0          .dw XT_DUP
000978 38fe          .dw XT_TO_R
000979 3953          .dw XT_ZERO
00097a 38c3          .dw XT_SWAP    ; go from bigger to smaller addresses
00097b 0830          .dw XT_QDOCHECK
00097c 3835          .dw XT_DOCONDBRANCH
00097d 0989          DEST(PFA_N_FETCH_E2)
00097e 3a9a          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
00097f 3aab          .dw XT_I
000980 3a34          .dw XT_1MINUS
000981 3eae          .dw XT_CELLS ; ( -- ee-addr i*2 )
000982 38ce          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
000983 399c          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
000984 3b54          .dw XT_FETCHE ;( -- ee-addr item_i )
000985 38c3          .dw XT_SWAP   ;( -- item_i ee-addr )
000986 394a          .dw XT_TRUE  ; shortcut for -1
000987 3ab9          .dw XT_DOPLUSLOOP
000988 097f          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
000989 3ebc          .dw XT_2DROP
00098a 38f5          .dw XT_R_FROM
00098b 381f          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
00098c ff09          .dw $ff09
00098d 6573
00098e 2d74
00098f 7473
000990 6361
000991 006b          .db "set-stack",0
000992 096b          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
000993 3800          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
000994 38ce          .dw XT_OVER
000995 391e          .dw XT_ZEROLESS
000996 3835          .dw XT_DOCONDBRANCH
000997 099b          DEST(PFA_SET_STACK0)
000998 383c          .dw XT_DOLITERAL
000999 fffc          .dw -4
00099a 3d73          .dw XT_THROW
                 PFA_SET_STACK0:
00099b 3eb3          .dw XT_2DUP
00099c 3b30          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
00099d 38c3          .dw XT_SWAP    
00099e 3953          .dw XT_ZERO
00099f 0830          .dw XT_QDOCHECK
0009a0 3835          .dw XT_DOCONDBRANCH
0009a1 09a8          DEST(PFA_SET_STACK2)
0009a2 3a9a          .dw XT_DODO
                 PFA_SET_STACK1:
0009a3 3ca6          .dw XT_CELLPLUS ; ( -- i_x e-addr )
0009a4 3ec4          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
0009a5 3b30          .dw XT_STOREE
0009a6 3ac8          .dw XT_DOLOOP
0009a7 09a3          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
0009a8 38d8          .dw XT_DROP
0009a9 381f          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
0009aa ff09          .dw $ff09
0009ab 616d
0009ac 2d70
0009ad 7473
0009ae 6361
0009af 006b          .db "map-stack",0
0009b0 098c          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
0009b1 3800          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
0009b2 38b0          .dw XT_DUP
0009b3 3ca6          .dw XT_CELLPLUS
0009b4 38c3          .dw XT_SWAP
0009b5 3b54          .dw XT_FETCHE
0009b6 3eae          .dw XT_CELLS
0009b7 3f83          .dw XT_BOUNDS
0009b8 0830          .dw XT_QDOCHECK
0009b9 3835          .dw XT_DOCONDBRANCH
0009ba 09cd          DEST(PFA_MAPSTACK3)
0009bb 3a9a          .dw XT_DODO
                 PFA_MAPSTACK1:
0009bc 3aab            .dw XT_I
0009bd 3b54            .dw XT_FETCHE   ; -- i*x XT id
0009be 38c3            .dw XT_SWAP
0009bf 38fe            .dw XT_TO_R
0009c0 3905            .dw XT_R_FETCH
0009c1 3829            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
0009c2 38b8            .dw XT_QDUP
0009c3 3835            .dw XT_DOCONDBRANCH
0009c4 09c9            DEST(PFA_MAPSTACK2)
0009c5 38f5               .dw XT_R_FROM
0009c6 38d8               .dw XT_DROP
0009c7 3ad3               .dw XT_UNLOOP
0009c8 381f               .dw XT_EXIT
                 PFA_MAPSTACK2:
0009c9 38f5            .dw XT_R_FROM
0009ca 3be1            .dw XT_TWO
0009cb 3ab9            .dw XT_DOPLUSLOOP
0009cc 09bc            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
0009cd 38d8          .dw XT_DROP
0009ce 3953          .dw XT_ZERO
0009cf 381f          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ; ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
0009d0 ff0b          .dw $ff0b
0009d1 6567
0009d2 2d74
0009d3 7563
0009d4 7272
0009d5 6e65
0009d6 0074          .db "get-current",0
0009d7 09aa          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
0009d8 3800          .dw DO_COLON
                 PFA_GET_CURRENT:
0009d9 383c          .dw XT_DOLITERAL
0009da 0068          .dw CFG_CURRENT
0009db 3b54          .dw XT_FETCHE
0009dc 381f          .dw XT_EXIT
                 .include "words/cfg-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CFG_ORDER:
0009dd ff09          .dw $ff09
0009de 6663
0009df 2d67
0009e0 726f
0009e1 6564
0009e2 0072          .db "cfg-order",0
0009e3 09d0          .dw VE_HEAD
                     .set VE_HEAD = VE_CFG_ORDER
                 XT_CFG_ORDER:
0009e4 3847          .dw PFA_DOVARIABLE
                 PFA_CFG_ORDER:
                 .endif
0009e5 006c          .dw CFG_ORDERLISTLEN
                 .include "words/cfg-recognizer.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CFG_RECOGNIZER:
0009e6 ff08          .dw $ff08
0009e7 6663
0009e8 2d67
0009e9 6572
0009ea 7363          .db "cfg-recs"
0009eb 09dd          .dw VE_HEAD
                     .set VE_HEAD = VE_CFG_RECOGNIZER
                 XT_CFG_RECOGNIZER:
0009ec 3847          .dw PFA_DOVARIABLE
                 PFA_CFG_RECOGNIZER:
                 .endif
0009ed 007e          .dw CFG_RECOGNIZERLISTLEN
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
0009ee ff07          .dw $ff07
0009ef 6f63
0009f0 706d
0009f1 7261
0009f2 0065          .db "compare",0
0009f3 09e6          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
0009f4 09f5          .dw PFA_COMPARE
                 PFA_COMPARE:
0009f5 93bf          push xh
0009f6 93af          push xl
0009f7 018c          movw temp0, tosl
0009f8 9189
0009f9 9199          loadtos
0009fa 01dc          movw xl, tosl
0009fb 9189
0009fc 9199          loadtos
0009fd 019c          movw temp2, tosl
0009fe 9189
0009ff 9199          loadtos
000a00 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
000a01 90ed          ld temp4, X+
000a02 90f1          ld temp5, Z+
000a03 14ef          cp temp4, temp5
000a04 f451          brne PFA_COMPARE_NOTEQUAL
000a05 950a          dec temp0
000a06 f019          breq PFA_COMPARE_ENDREACHED2
000a07 952a          dec temp2
000a08 f7c1          brne PFA_COMPARE_LOOP
000a09 c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
000a0a 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
000a0b 2b02          or temp0, temp2
000a0c f411          brne PFA_COMPARE_CHECKLASTCHAR
000a0d 2788          clr tosl
000a0e c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
000a0f ef8f          ser tosl
000a10 c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
000a11 2f98          mov tosh, tosl
000a12 91af          pop xl
000a13 91bf          pop xh
000a14 940c 3804     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
000a16 ff07         .dw $ff07
000a17 666e
000a18 3e61
000a19 666c
000a1a 0061         .db "nfa>lfa",0
000a1b 09ee         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
000a1c 3800          .dw DO_COLON
                 PFA_NFA2LFA:
000a1d 06f4          .dw XT_NAME2STRING
000a1e 3a2e          .dw XT_1PLUS
000a1f 3a03          .dw XT_2SLASH
000a20 399c          .dw XT_PLUS
000a21 381f          .dw XT_EXIT
                 .include "dict/interrupt.inc"
                 
                 .if WANT_INTERRUPTS == 1
                 
                 .if WANT_INTERRUPT_COUNTERS == 1
                   .include "words/irqcnt.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_IRQCNTADDR:
000a22 ff06          .dw $ff06
000a23 7269
000a24 5b71
000a25 235d          .db "irq[]#"
000a26 0a16          .dw VE_HEAD
                     .set VE_HEAD = VE_IRQCNTADDR
                 XT_IRQCNTADDR:
000a27 3800          .dw DO_COLON
                 PFA_IRQCNTADDR:
000a28 383c          .dw XT_DOLITERAL
000a29 0112          .dw intcnt
000a2a 399c          .dw XT_PLUS
000a2b 381f          .dw XT_EXIT
                   .include "words/int-num.asm"
                 
                 ; Interrupt
                 ; number of interrupt vectors (0 based)
                 VE_NUMINT:
000a2c ff04          .dw $ff04
000a2d 6923
000a2e 746e          .db "#int"
000a2f 0a22          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMINT
                 XT_NUMINT:
000a30 3847          .dw PFA_DOVARIABLE
                 PFA_NUMINT:
000a31 002b          .dw INTVECTORS
                 .endif
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
000a32 ff04          .dw $ff04
000a33 692b
000a34 746e          .db "+int"
000a35 0a2c          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
000a36 0a37          .dw PFA_INTON
                 PFA_INTON:
000a37 9478          sei
000a38 940c 3804     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
000a3a ff04          .dw $ff04
000a3b 692d
000a3c 746e          .db "-int"
000a3d 0a32          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
000a3e 0a3f          .dw PFA_INTOFF
                 PFA_INTOFF:
000a3f 94f8          cli
000a40 940c 3804     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
000a42 ff04          .dw $ff04
000a43 6e69
000a44 2174          .db "int!"
000a45 0a3a          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
000a46 3800          .dw DO_COLON
                 PFA_INTSTORE:
000a47 383c          .dw XT_DOLITERAL
000a48 0000          .dw intvec
000a49 399c          .dw XT_PLUS
000a4a 3b30          .dw XT_STOREE
000a4b 381f          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
000a4c ff04          .dw $ff04
000a4d 6e69
000a4e 4074          .db "int@"
000a4f 0a42          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
000a50 3800          .dw DO_COLON
                 PFA_INTFETCH:
000a51 383c          .dw XT_DOLITERAL
000a52 0000          .dw intvec
000a53 399c          .dw XT_PLUS
000a54 3b54          .dw XT_FETCHE
000a55 381f          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
000a56 ff08          .dw $ff08
000a57 6e69
000a58 2d74
000a59 7274
000a5a 7061          .db "int-trap"
000a5b 0a4c          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
000a5c 0a5d          .dw PFA_INTTRAP
                 PFA_INTTRAP:
000a5d 2eb8          mov isrflag, tosl
000a5e 9189
000a5f 9199          loadtos
000a60 940c 3804     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
000a62 3800          .dw DO_COLON
                 PFA_ISREXEC:
000a63 0a50          .dw XT_INTFETCH
000a64 3829          .dw XT_EXECUTE
000a65 0a67          .dw XT_ISREND
000a66 381f          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
000a67 0a68          .dw PFA_ISREND
                 PFA_ISREND:
000a68 d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
000a69 940c 3804     jmp_ DO_NEXT
                 PFA_ISREND1:
000a6b 9518          reti
                 .endif
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 
                 .include "dict/compiler2.inc" ; additional words for the compiler
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
000a6c ff0b          .dw $ff0b
000a6d 6573
000a6e 2d74
000a6f 7563
000a70 7272
000a71 6e65
000a72 0074          .db "set-current",0
000a73 0a56          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
000a74 3800          .dw DO_COLON
                 PFA_SET_CURRENT:
000a75 383c          .dw XT_DOLITERAL
000a76 0068          .dw CFG_CURRENT
000a77 3b30          .dw XT_STOREE
000a78 381f          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
000a79 ff08          .dw $ff08
000a7a 6f77
000a7b 6472
000a7c 696c
000a7d 7473          .db "wordlist"
000a7e 0a6c          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
000a7f 3800          .dw DO_COLON
                 PFA_WORDLIST:
000a80 3f05          .dw XT_EHERE
000a81 3953          .dw XT_ZERO
000a82 38ce          .dw XT_OVER
000a83 3b30          .dw XT_STOREE
000a84 38b0          .dw XT_DUP
000a85 3ca6          .dw XT_CELLPLUS
000a86 019c          .dw XT_DOTO
000a87 3f06          .dw PFA_EHERE
000a88 381f          .dw XT_EXIT
                 
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTHWORDLIST:
000a89 ff0e          .dw $ff0e
000a8a 6f66
000a8b 7472
000a8c 2d68
000a8d 6f77
000a8e 6472
000a8f 696c
000a90 7473          .db "forth-wordlist"
000a91 0a79          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHWORDLIST
                 XT_FORTHWORDLIST:
000a92 3847          .dw PFA_DOVARIABLE
                 PFA_FORTHWORDLIST:
000a93 006a          .dw CFG_FORTHWORDLIST
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
000a94 ff04          .dw $ff04
000a95 6f63
000a96 6564          .db "code"
000a97 0a89          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
000a98 3800          .dw DO_COLON
                 PFA_CODE:
000a99 0738          .dw XT_DOCREATE
000a9a 08a3          .dw XT_REVEAL
000a9b 3efc          .dw XT_DP
000a9c 01ae          .dw XT_ICELLPLUS
000a9d 0771          .dw XT_COMMA
000a9e 381f          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000a9f ff08          .dw $ff08
000aa0 6e65
000aa1 2d64
000aa2 6f63
000aa3 6564          .db "end-code"
000aa4 0a94          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000aa5 3800          .dw DO_COLON
                 PFA_ENDCODE:
000aa6 0766          .dw XT_COMPILE
000aa7 940c          .dw $940c
000aa8 0766          .dw XT_COMPILE
000aa9 3804          .dw DO_NEXT
000aaa 381f          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
000aab ff08          .dw $ff08
000aac 6d28
000aad 7261
000aae 656b
000aaf 2972          .db "(marker)"
000ab0 0a9f          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
000ab1 386e          .dw PFA_DOVALUE1
                 PFA_MARKER:
000ab2 008a          .dw EE_MARKER
000ab3 3d8a          .dw XT_EDEFERFETCH
000ab4 3d94          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
000ab5 0008          .dw $0008
000ab6 6f70
000ab7 7473
000ab8 6f70
000ab9 656e          .db "postpone"
000aba 0aab          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
000abb 3800          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
000abc 05b6          .dw XT_PARSENAME
000abd 05f4          .dw XT_FORTHRECOGNIZER
000abe 05ff          .dw XT_RECOGNIZE
000abf 38b0          .dw XT_DUP
000ac0 38fe          .dw XT_TO_R
000ac1 01ae          .dw XT_ICELLPLUS
000ac2 01ae          .dw XT_ICELLPLUS
000ac3 3bc0          .dw XT_FETCHI
000ac4 3829          .dw XT_EXECUTE
000ac5 38f5          .dw XT_R_FROM
000ac6 01ae          .dw XT_ICELLPLUS
000ac7 3bc0          .dw XT_FETCHI
000ac8 0771          .dw XT_COMMA
000ac9 381f          .dw XT_EXIT
                 .endif
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
000aca ff0b          .dw $ff0b
000acb 7061
000acc 6c70
000acd 7574
000ace 6e72
000acf 656b
000ad0 0079          .db "applturnkey",0
000ad1 0ab5          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000ad2 3800          .dw DO_COLON
                 PFA_APPLTURNKEY:
000ad3 00e9          .dw XT_USART
                 
                 .if WANT_INTERRUPTS == 1
000ad4 0a36          .dw XT_INTON
                 .endif
                 
000ad5 016d          .dw XT_DOT_VER
000ad6 3f98          .dw XT_SPACE
000ad7 03be          .dw XT_DOSLITERAL
000ad8 000a          .dw 10
000ad9 6f46
000ada 7472
000adb 6468
000adc 6975
000add 6f6e          .db "Forthduino"
000ade 03f1          .dw XT_ITYPE
                 
000adf 381f          .dw XT_EXIT
                 
                 
                 .set DPSTART = pc
                 .if(pc>AMFORTH_RO_SEG)
                 .endif
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
003800 93bf          push XH
003801 93af          push XL          ; PUSH IP
003802 01db          movw XL, wl
003803 9611          adiw xl, 1
                 DO_NEXT:
                 .if WANT_INTERRUPTS == 1
003804 14b2          cp isrflag, zerol
003805 f469          brne DO_INTERRUPT
                 .endif
003806 01fd          movw zl, XL        ; READ IP
003807 0fee
003808 1fff
003809 9165
00380a 9175          readflashcell wl, wh
00380b 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00380c 01fb          movw zl, wl
00380d 0fee
00380e 1fff
00380f 9105
003810 9115          readflashcell temp0,temp1
003811 01f8          movw zl, temp0
003812 9409          ijmp
                 
                 .if WANT_INTERRUPTS == 1
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
003813 939a
003814 938a          savetos
003815 2d8b          mov tosl, isrflag
003816 24bb          clr isrflag
003817 2799          clr tosh
003818 e662          ldi wl, LOW(XT_ISREXEC)
003819 e07a          ldi wh, HIGH(XT_ISREXEC)
00381a cff1          rjmp DO_EXECUTE
                 .endif
                 .include "dict/nrww.inc"
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
00381b ff04          .dw $ff04
00381c 7865
00381d 7469          .db "exit"
00381e 0aca          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00381f 3820          .dw PFA_EXIT
                 PFA_EXIT:
003820 91af          pop XL
003821 91bf          pop XH
003822 cfe1          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
003823 ff07          .dw $ff07
003824 7865
003825 6365
003826 7475
003827 0065          .db "execute",0
003828 381b          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
003829 382a          .dw PFA_EXECUTE
                 PFA_EXECUTE:
00382a 01bc          movw wl, tosl
00382b 9189
00382c 9199          loadtos
00382d cfde          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
00382e 382f          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00382f 01fd          movw zl, XL
003830 0fee
003831 1fff
003832 91a5
003833 91b5          readflashcell XL,XH
003834 cfcf          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
003835 3836          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
003836 2b98          or tosh, tosl
003837 9189
003838 9199          loadtos
003839 f3a9          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
00383a 9611          adiw XL, 1
00383b cfc8          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
00383c 383d          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
00383d 939a
00383e 938a          savetos
00383f 01fd          movw zl, xl
003840 0fee
003841 1fff
003842 9185
003843 9195          readflashcell tosl,tosh
003844 9611          adiw xl, 1
003845 cfbe          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
003846 3847          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
003847 939a
003848 938a          savetos
003849 01fb          movw zl, wl
00384a 9631          adiw zl,1
00384b 0fee
00384c 1fff
00384d 9185
00384e 9195          readflashcell tosl,tosh
00384f cfb4          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
003850 3851          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
003851 939a
003852 938a          savetos
003853 01cb          movw tosl, wl
003854 9601          adiw tosl, 1
003855 cfae          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
003856 3857          .dw PFA_DOUSER
                 PFA_DOUSER:
003857 939a
003858 938a          savetos
003859 01fb          movw zl, wl
00385a 9631          adiw zl, 1
00385b 0fee
00385c 1fff
00385d 9185
00385e 9195          readflashcell tosl,tosh
00385f 0d84          add tosl, upl
003860 1d95          adc tosh, uph
003861 cfa2          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
003862 ff07          .dw $ff07
003863 7628
003864 6c61
003865 6575
003866 0029          .db "(value)", 0
003867 3823          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
003868 3800          .dw DO_COLON
                 PFA_DOVALUE:
003869 0738          .dw XT_DOCREATE
00386a 08a3          .dw XT_REVEAL
00386b 0766          .dw XT_COMPILE
00386c 386e          .dw PFA_DOVALUE1
00386d 381f          .dw XT_EXIT
                 PFA_DOVALUE1:
00386e 940e 08bc     call_ DO_DODOES
003870 38b0          .dw XT_DUP
003871 01ae          .dw XT_ICELLPLUS
003872 3bc0          .dw XT_FETCHI
003873 3829          .dw XT_EXECUTE
003874 381f          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
003875 ff01          .dw $ff01
003876 0040          .db "@",0
003877 3862          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
003878 3879          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
003879 01fc          movw zl, tosl
                     ; low byte is read before the high byte
00387a 9181          ld tosl, z+
00387b 9191          ld tosh, z+
00387c cf87          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
00387d ff01          .dw $ff01
00387e 0021          .db "!",0
00387f 3875          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
003880 3881          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
003881 01fc          movw zl, tosl
003882 9189
003883 9199          loadtos
                     ; the high byte is written before the low byte
003884 8391          std Z+1, tosh
003885 8380          std Z+0, tosl
003886 9189
003887 9199          loadtos
003888 cf7b          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
003889 ff02          .dw $ff02
00388a 2163          .db "c!"
00388b 387d          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
00388c 388d          .dw PFA_CSTORE
                 PFA_CSTORE:
00388d 01fc          movw zl, tosl
00388e 9189
00388f 9199          loadtos
003890 8380          st Z, tosl
003891 9189
003892 9199          loadtos
003893 cf70          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
003894 ff02          .dw $ff02
003895 4063          .db "c@"
003896 3889          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
003897 3898          .dw PFA_CFETCH
                 PFA_CFETCH:
003898 01fc          movw zl, tosl
003899 2799          clr tosh
00389a 8180          ld tosl, Z
00389b cf68          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
00389c ff02          .dw $ff02
00389d 7540          .db "@u"
00389e 3894          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00389f 3800          .dw DO_COLON
                 PFA_FETCHU:
0038a0 3b01          .dw XT_UP_FETCH
0038a1 399c          .dw XT_PLUS
0038a2 3878          .dw XT_FETCH
0038a3 381f          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
0038a4 ff02          .dw $ff02
0038a5 7521          .db "!u"
0038a6 389c          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
0038a7 3800          .dw DO_COLON
                 PFA_STOREU:
0038a8 3b01          .dw XT_UP_FETCH
0038a9 399c          .dw XT_PLUS
0038aa 3880          .dw XT_STORE
0038ab 381f          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
0038ac ff03          .dw $ff03
0038ad 7564
0038ae 0070          .db "dup",0
0038af 38a4          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
0038b0 38b1          .dw PFA_DUP
                 PFA_DUP:
0038b1 939a
0038b2 938a          savetos
0038b3 cf50          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
0038b4 ff04          .dw $ff04
0038b5 643f
0038b6 7075          .db "?dup"
0038b7 38ac          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
0038b8 38b9          .dw PFA_QDUP
                 PFA_QDUP:
0038b9 2f08          mov temp0, tosl
0038ba 2b09          or temp0, tosh
0038bb f011          breq PFA_QDUP1
0038bc 939a
0038bd 938a          savetos
                 PFA_QDUP1:
0038be cf45          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
0038bf ff04          .dw $ff04
0038c0 7773
0038c1 7061          .db "swap"
0038c2 38b4          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
0038c3 38c4          .dw PFA_SWAP
                 PFA_SWAP:
0038c4 018c          movw temp0, tosl
0038c5 9189
0038c6 9199          loadtos
0038c7 931a          st -Y, temp1
0038c8 930a          st -Y, temp0
0038c9 cf3a          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
0038ca ff04          .dw $ff04
0038cb 766f
0038cc 7265          .db "over"
0038cd 38bf          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
0038ce 38cf          .dw PFA_OVER
                 PFA_OVER:
0038cf 939a
0038d0 938a          savetos
0038d1 818a          ldd tosl, Y+2
0038d2 819b          ldd tosh, Y+3
                 
0038d3 cf30          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
0038d4 ff04          .dw $ff04
0038d5 7264
0038d6 706f          .db "drop"
0038d7 38ca          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
0038d8 38d9          .dw PFA_DROP
                 PFA_DROP:
0038d9 9189
0038da 9199          loadtos
0038db cf28          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
0038dc ff03          .dw $ff03
0038dd 6f72
0038de 0074          .db "rot",0
0038df 38d4          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
0038e0 38e1          .dw PFA_ROT
                 PFA_ROT:
0038e1 018c          movw temp0, tosl
0038e2 9129          ld temp2, Y+
0038e3 9139          ld temp3, Y+ 
0038e4 9189
0038e5 9199          loadtos
                         
0038e6 933a          st -Y, temp3
0038e7 932a          st -Y, temp2
0038e8 931a          st -Y, temp1
0038e9 930a          st -Y, temp0
                 
0038ea cf19          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
0038eb ff03          .dw $ff03
0038ec 696e
0038ed 0070          .db "nip",0
0038ee 38dc          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
0038ef 38f0          .dw PFA_NIP
                 PFA_NIP:
0038f0 9622          adiw yl, 2
0038f1 cf12          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
0038f2 ff02          .dw $ff02
0038f3 3e72          .db "r>"
0038f4 38eb          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
0038f5 38f6          .dw PFA_R_FROM
                 PFA_R_FROM:
0038f6 939a
0038f7 938a          savetos
0038f8 918f          pop tosl
0038f9 919f          pop tosh
0038fa cf09          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
0038fb ff02          .dw $ff02
0038fc 723e          .db ">r"
0038fd 38f2          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
0038fe 38ff          .dw PFA_TO_R
                 PFA_TO_R:
0038ff 939f          push tosh
003900 938f          push tosl
003901 cfd7          jmp_ PFA_DROP
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
003902 ff02          .dw $ff02
003903 4072          .db "r@"
003904 38fb          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
003905 3906          .dw PFA_R_FETCH
                 PFA_R_FETCH:
003906 939a
003907 938a          savetos
003908 918f          pop tosl
003909 919f          pop tosh
00390a 939f          push tosh
00390b 938f          push tosl
00390c cef7          jmp_ DO_NEXT
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
00390d ff02          .dw $ff02
00390e 3e3c          .db "<>"
00390f 3902          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
003910 3800          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
003911 3bd5
003912 3917
003913 381f          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
003914 ff02          .dw $ff02
003915 3d30          .db "0="
003916 390d          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
003917 3918          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
003918 2b98          or tosh, tosl
003919 f5e1          brne PFA_ZERO1
00391a c032          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
00391b ff02          .dw $ff02
00391c 3c30          .db "0<"
00391d 3914          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
00391e 391f          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
00391f fd97          sbrc tosh,7
003920 c02c          rjmp PFA_TRUE1
003921 c034          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
003922 ff02          .dw $ff02
003923 3e30          .db "0>"
003924 391b          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
003925 3926          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
003926 1582          cp tosl, zerol
003927 0593          cpc tosh, zeroh
003928 f16c          brlt PFA_ZERO1
003929 f161          brbs 1, PFA_ZERO1
00392a c022          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
00392b ff03          .dw $ff03
00392c 3064
00392d 003e          .db "d0>",0
00392e 3922          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00392f 3930          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
003930 1593          cp tosh, zeroh
003931 f03c          brlt PFA_DGREATERZERO_FALSE ; if MSBit is set, d:arg is negative, we are done (false).
003932 0582          cpc tosl, zerol
003933 9189
003934 9199          loadtos
003935 0582          cpc tosl, zerol
003936 0593          cpc tosh, zeroh
003937 f0f1          brbs 1, PFA_ZERO1           ; if all 4 Bytes of d:arg are zero, we are done (false).
003938 c014          rjmp PFA_TRUE1              ; if we get this far, d:arg was positive! (true)
                 PFA_DGREATERZERO_FALSE:
003939 01c1          movw tosl, zerol            ; ZERO
00393a cfb5          rjmp PFA_NIP                ; NIP
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
00393b ff03          .dw $ff03
00393c 3064
00393d 003c          .db "d0<",0
00393e 392b          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
00393f 3940          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
003940 9622          adiw Y,2
003941 fd97          sbrc tosh,7
003942 940c 394d     jmp PFA_TRUE1
003944 940c 3956     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
003946 ff04          .dw $ff04
003947 7274
003948 6575          .db "true"
003949 393b          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
00394a 394b          .dw PFA_TRUE
                 PFA_TRUE:
00394b 939a
00394c 938a          savetos
                 PFA_TRUE1:
00394d ef8f          ser tosl
00394e ef9f          ser tosh
00394f ceb4          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
003950 ff01          .dw $ff01
003951 0030          .db "0",0
003952 3946          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
003953 3954          .dw PFA_ZERO
                 PFA_ZERO:
003954 939a
003955 938a          savetos
                 PFA_ZERO1:
003956 01c1          movw tosl, zerol
003957 ceac          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
003958 ff02          .dw $ff02
003959 3c75          .db "u<"
00395a 3950          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
00395b 395c          .dw PFA_ULESS
                 PFA_ULESS:
00395c 9129          ld temp2, Y+
00395d 9139          ld temp3, Y+
00395e 1782          cp tosl, temp2
00395f 0793          cpc tosh, temp3
003960 f3a8          brlo PFA_ZERO1
003961 f3a1          brbs 1, PFA_ZERO1
003962 cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
003963 ff02          .dw $ff02
003964 3e75          .db "u>"
003965 3958          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
003966 3800          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
003967 38c3          .DW XT_SWAP
003968 395b          .dw XT_ULESS
003969 381f          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
00396a ff01          .dw $ff01
00396b 003c          .db "<",0
00396c 3963          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
00396d 396e          .dw PFA_LESS
                 PFA_LESS:
00396e 9129          ld temp2, Y+
00396f 9139          ld temp3, Y+
003970 1728          cp temp2, tosl
003971 0739          cpc temp3, tosh
                 PFA_LESSDONE:
003972 f71c          brge PFA_ZERO1
003973 cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
003974 ff01          .dw $ff01
003975 003e          .db ">",0
003976 396a          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
003977 3978          .dw PFA_GREATER
                 PFA_GREATER:
003978 9129          ld temp2, Y+
003979 9139          ld temp3, Y+
00397a 1728          cp temp2, tosl
00397b 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
00397c f2cc          brlt PFA_ZERO1
00397d f2c1          brbs 1, PFA_ZERO1
00397e cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
00397f ff04          .dw $ff04
003980 6f6c
003981 3267          .db "log2"
003982 3974          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
003983 3984          .dw PFA_LOG2
                 PFA_LOG2:
003984 01fc          movw zl, tosl
003985 2799          clr tosh
003986 e180          ldi tosl, 16
                 PFA_LOG2_1:
003987 958a          dec tosl
003988 f022          brmi PFA_LOG2_2 ; wrong data
003989 0fee          lsl  zl
00398a 1fff          rol  zh
00398b f7d8          brcc PFA_LOG2_1
00398c ce77          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
00398d 959a          dec tosh
00398e ce75          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
00398f ff01          .dw $ff01
003990 002d          .db "-",0
003991 397f          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
003992 3993          .dw PFA_MINUS
                 PFA_MINUS:
003993 9109          ld temp0, Y+
003994 9119          ld temp1, Y+
003995 1b08          sub temp0, tosl
003996 0b19          sbc temp1, tosh
003997 01c8          movw tosl, temp0
003998 ce6b          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
003999 ff01          .dw $ff01
00399a 002b          .db "+",0
00399b 398f          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
00399c 399d          .dw PFA_PLUS
                 PFA_PLUS:
00399d 9109          ld temp0, Y+
00399e 9119          ld temp1, Y+
00399f 0f80          add tosl, temp0
0039a0 1f91          adc tosh, temp1
0039a1 ce62          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
0039a2 ff02          .dw $ff02
0039a3 2a6d          .db "m*"
0039a4 3999          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
0039a5 39a6          .dw PFA_MSTAR
                 PFA_MSTAR:
0039a6 018c          movw temp0, tosl
0039a7 9189
0039a8 9199          loadtos
0039a9 019c          movw temp2, tosl
                     ; high cell ah*bh
0039aa 0231          muls temp3, temp1
0039ab 0170          movw temp4, r0
                     ; low cell  al*bl
0039ac 9f20          mul  temp2, temp0
0039ad 01c0          movw tosl, r0
                     ; signed ah*bl
0039ae 0330          mulsu temp3, temp0
0039af 08f3          sbc   temp5, zeroh
0039b0 0d90          add   tosh,  r0
0039b1 1ce1          adc   temp4, r1
0039b2 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
0039b3 0312          mulsu temp1, temp2
0039b4 08f3          sbc   temp5, zeroh
0039b5 0d90          add   tosh,  r0
0039b6 1ce1          adc   temp4, r1
0039b7 1cf3          adc   temp5, zeroh
                 
0039b8 939a
0039b9 938a          savetos
0039ba 01c7          movw tosl, temp4
0039bb ce48          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
0039bc ff06          .dw $ff06
0039bd 6d75
0039be 6d2f
0039bf 646f          .db "um/mod"
0039c0 39a2          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
0039c1 39c2          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
0039c2 017c          movw temp4, tosl
                 
0039c3 9129          ld temp2, Y+
0039c4 9139          ld temp3, Y+
                   
0039c5 9109          ld temp0, Y+
0039c6 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
0039c7 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
0039c8 2755          clr temp7
0039c9 0f00          lsl temp0
0039ca 1f11          rol temp1
0039cb 1f22          rol temp2
0039cc 1f33          rol temp3
0039cd 1f55          rol temp7
                 
                   ; try subtracting divisor
0039ce 152e          cp temp2, temp4
0039cf 053f          cpc temp3, temp5
0039d0 0552          cpc temp7,zerol
                 
0039d1 f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
0039d2 9503          inc temp0
0039d3 192e          sub temp2, temp4
0039d4 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
0039d5 954a          dec  temp6
0039d6 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
0039d7 933a          st -Y,temp3
0039d8 932a          st -Y,temp2
                 
                     ; put quotient on stack
0039d9 01c8          movw tosl, temp0
0039da ce29          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
0039db ff03          .dw $ff03
0039dc 6d75
0039dd 002a          .db "um*",0
0039de 39bc          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
0039df 39e0          .dw PFA_UMSTAR
                 PFA_UMSTAR:
0039e0 018c          movw temp0, tosl
0039e1 9189
0039e2 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
0039e3 9f80          mul tosl,temp0
0039e4 01f0          movw zl, r0
0039e5 2722          clr temp2
0039e6 2733          clr temp3
                     ; middle bytes
0039e7 9f90          mul tosh, temp0
0039e8 0df0          add zh, r0
0039e9 1d21          adc temp2, r1
0039ea 1d33          adc temp3, zeroh
                         
0039eb 9f81          mul tosl, temp1
0039ec 0df0          add zh, r0
0039ed 1d21          adc temp2, r1
0039ee 1d33          adc temp3, zeroh
                     
0039ef 9f91          mul tosh, temp1
0039f0 0d20          add temp2, r0
0039f1 1d31          adc temp3, r1
0039f2 01cf          movw tosl, zl
0039f3 939a
0039f4 938a          savetos
0039f5 01c9          movw tosl, temp2
0039f6 ce0d          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
0039f7 ff06          .dw $ff06
0039f8 6e69
0039f9 6576
0039fa 7472          .db "invert"
0039fb 39db          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
0039fc 39fd          .dw PFA_INVERT
                 PFA_INVERT:
0039fd 9580          com tosl
0039fe 9590          com tosh
0039ff ce04          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
003a00 ff02          .dw $ff02
003a01 2f32          .db "2/"
003a02 39f7          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
003a03 3a04          .dw PFA_2SLASH
                 PFA_2SLASH:
003a04 9595          asr tosh
003a05 9587          ror tosl
003a06 cdfd          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
003a07 ff02          .dw $ff02
003a08 2a32          .db "2*"
003a09 3a00          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
003a0a 3a0b          .dw PFA_2STAR
                 PFA_2STAR:
003a0b 0f88          lsl tosl
003a0c 1f99          rol tosh
003a0d cdf6          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
003a0e ff03          .dw $ff03
003a0f 6e61
003a10 0064          .db "and",0
003a11 3a07          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
003a12 3a13          .dw PFA_AND
                 PFA_AND:
003a13 9109          ld temp0, Y+
003a14 9119          ld temp1, Y+
003a15 2380          and tosl, temp0
003a16 2391          and tosh, temp1
003a17 cdec          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
003a18 ff02          .dw $ff02
003a19 726f          .db "or"
003a1a 3a0e          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
003a1b 3a1c          .dw PFA_OR
                 PFA_OR:
003a1c 9109          ld temp0, Y+
003a1d 9119          ld temp1, Y+
003a1e 2b80          or tosl, temp0
003a1f 2b91          or tosh, temp1
003a20 cde3          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
003a21 ff03          .dw $ff03
003a22 6f78
003a23 0072          .db "xor",0
003a24 3a18          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
003a25 3a26          .dw PFA_XOR
                 PFA_XOR:
003a26 9109          ld temp0, Y+
003a27 9119          ld temp1, Y+
003a28 2780          eor tosl, temp0
003a29 2791          eor tosh, temp1
003a2a cdd9          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
003a2b ff02          .dw $ff02
003a2c 2b31          .db "1+"
003a2d 3a21          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
003a2e 3a2f          .dw PFA_1PLUS
                 PFA_1PLUS:
003a2f 9601          adiw tosl,1
003a30 cdd3          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
003a31 ff02          .dw $ff02 
003a32 2d31          .db "1-"
003a33 3a2b          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
003a34 3a35          .dw PFA_1MINUS
                 PFA_1MINUS:
003a35 9701          sbiw tosl, 1
003a36 cdcd          jmp_ DO_NEXT
                 .include "words/q-negate.asm"
                 
                 ;   0< IF NEGATE THEN ;        ...a common factor
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QNEGATE:
003a37 ff07          .dw $ff07
003a38 6e3f
003a39 6765
003a3a 7461
../../common\words/q-negate.asm(11): warning: .cseg .db misalignment - padding zero byte
003a3b 0065          .db "?negate"
003a3c 3a31          .dw VE_HEAD
                     .set VE_HEAD = VE_QNEGATE
                 XT_QNEGATE:
003a3d 3800          .dw DO_COLON
                 PFA_QNEGATE:
                 
                 .endif
003a3e 391e
003a3f 3835              .DW XT_ZEROLESS,XT_DOCONDBRANCH
003a40 3a42              DEST(QNEG1)
003a41 3e11              .DW XT_NEGATE
003a42 381f      QNEG1:  .DW XT_EXIT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
003a43 ff06          .dw $ff06
003a44 736c
003a45 6968
003a46 7466          .db "lshift"
003a47 3a37          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
003a48 3a49          .dw PFA_LSHIFT
                 PFA_LSHIFT:
003a49 01fc          movw zl, tosl
003a4a 9189
003a4b 9199          loadtos
                 PFA_LSHIFT1:
003a4c 9731          sbiw zl, 1
003a4d f01a          brmi PFA_LSHIFT2
003a4e 0f88          lsl tosl
003a4f 1f99          rol tosh
003a50 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
003a51 cdb2          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
003a52 ff06          .dw $ff06
003a53 7372
003a54 6968
003a55 7466          .db "rshift"
003a56 3a43          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
003a57 3a58          .dw PFA_RSHIFT
                 PFA_RSHIFT:
003a58 01fc          movw zl, tosl
003a59 9189
003a5a 9199          loadtos
                 PFA_RSHIFT1:
003a5b 9731          sbiw zl, 1
003a5c f01a          brmi PFA_RSHIFT2
003a5d 9596          lsr tosh
003a5e 9587          ror tosl
003a5f cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
003a60 cda3          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
003a61 ff02          .dw $ff02
003a62 212b          .db "+!"
003a63 3a52          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
003a64 3a65          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
003a65 01fc          movw zl, tosl
003a66 9189
003a67 9199          loadtos
003a68 8120          ldd temp2, Z+0
003a69 8131          ldd temp3, Z+1
003a6a 0f82          add tosl, temp2
003a6b 1f93          adc tosh, temp3
003a6c 8380          std Z+0, tosl
003a6d 8391          std Z+1, tosh
003a6e 9189
003a6f 9199          loadtos
003a70 cd93          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
003a71 ff03          .dw $ff03
003a72 7072
003a73 0040          .db "rp@",0
003a74 3a61          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
003a75 3a76          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
003a76 939a
003a77 938a          savetos
003a78 b78d          in tosl, SPL
003a79 b79e          in tosh, SPH
003a7a cd89          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
003a7b ff03          .dw $ff03
003a7c 7072
003a7d 0021          .db "rp!",0
003a7e 3a71          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
003a7f 3a80          .dw PFA_RP_STORE
                 PFA_RP_STORE:
003a80 b72f          in temp2, SREG
003a81 94f8          cli
003a82 bf8d          out SPL, tosl
003a83 bf9e          out SPH, tosh
003a84 bf2f          out SREG, temp2
003a85 9189
003a86 9199          loadtos
003a87 cd7c          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
003a88 ff03          .dw $ff03
003a89 7073
003a8a 0040          .db "sp@",0
003a8b 3a7b          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
003a8c 3a8d          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
003a8d 939a
003a8e 938a          savetos
003a8f 01ce          movw tosl, yl
003a90 cd73          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
003a91 ff03          .dw $ff03
003a92 7073
003a93 0021          .db "sp!",0
003a94 3a88          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
003a95 3a96          .dw PFA_SP_STORE
                 PFA_SP_STORE:
003a96 01ec          movw yl, tosl
003a97 9189
003a98 9199          loadtos
003a99 cd6a          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
003a9a 3a9b          .dw PFA_DODO
                 PFA_DODO:
003a9b 9129          ld temp2, Y+
003a9c 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
003a9d e8e0          ldi zl, $80
003a9e 0f3e          add temp3, zl
003a9f 1b82          sub  tosl, temp2
003aa0 0b93          sbc  tosh, temp3
                 
003aa1 933f          push temp3
003aa2 932f          push temp2    ; limit  ( --> limit + $8000)
003aa3 939f          push tosh
003aa4 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
003aa5 9189
003aa6 9199          loadtos
003aa7 cd5c          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
003aa8 ff01          .dw $FF01
003aa9 0069          .db "i",0
003aaa 3a91          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
003aab 3aac          .dw PFA_I
                 PFA_I:
003aac 939a
003aad 938a          savetos
003aae 918f          pop tosl
003aaf 919f          pop tosh  ; index
003ab0 91ef          pop zl
003ab1 91ff          pop zh    ; limit
003ab2 93ff          push zh
003ab3 93ef          push zl
003ab4 939f          push tosh
003ab5 938f          push tosl
003ab6 0f8e          add tosl, zl
003ab7 1f9f          adc tosh, zh
003ab8 cd4b          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
003ab9 3aba          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
003aba 91ef          pop zl
003abb 91ff          pop zh
003abc 0fe8          add zl, tosl
003abd 1ff9          adc zh, tosh
003abe 9189
003abf 9199          loadtos
003ac0 f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
003ac1 93ff          push zh
003ac2 93ef          push zl
003ac3 cd6b          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
003ac4 910f          pop  temp0
003ac5 911f          pop  temp1  ; remove limit
003ac6 9611          adiw xl, 1  ; skip branch-back address
003ac7 cd3c          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
003ac8 3ac9          .dw PFA_DOLOOP
                 PFA_DOLOOP:
003ac9 91ef          pop zl
003aca 91ff          pop zh
003acb 9631          adiw zl,1
003acc f3bb          brvs PFA_DOPLUSLOOP_LEAVE
003acd cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
003ace ff06          .dw $ff06
003acf 6e75
003ad0 6f6c
003ad1 706f          .db "unloop"
003ad2 3aa8          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
003ad3 3ad4          .dw PFA_UNLOOP
                 PFA_UNLOOP:
003ad4 911f          pop temp1
003ad5 910f          pop temp0
003ad6 911f          pop temp1
003ad7 910f          pop temp0
003ad8 cd2b          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
003ad9 ff06          .dw $ff06
003ada 6d63
003adb 766f
003adc 3e65          .db "cmove>"
003add 3ace          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
003ade 3adf          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
003adf 93bf          push xh
003ae0 93af          push xl
003ae1 91e9          ld zl, Y+
003ae2 91f9          ld zh, Y+ ; addr-to
003ae3 91a9          ld xl, Y+
003ae4 91b9          ld xh, Y+ ; addr-from
003ae5 2f09          mov temp0, tosh
003ae6 2b08          or temp0, tosl
003ae7 f041          brbs 1, PFA_CMOVE_G1
003ae8 0fe8          add zl, tosl
003ae9 1ff9          adc zh, tosh
003aea 0fa8          add xl, tosl
003aeb 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
003aec 911e          ld temp1, -X
003aed 9312          st -Z, temp1
003aee 9701          sbiw tosl, 1
003aef f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
003af0 91af          pop xl
003af1 91bf          pop xh
003af2 9189
003af3 9199          loadtos
003af4 cd0f          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
003af5 ff02          .dw $ff02
003af6 3c3e          .db "><"
003af7 3ad9          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
003af8 3af9          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
003af9 2f09          mov temp0, tosh
003afa 2f98          mov tosh, tosl
003afb 2f80          mov tosl, temp0
003afc cd07          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
003afd ff03          .dw $ff03
003afe 7075
003aff 0040          .db "up@",0
003b00 3af5          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
003b01 3b02          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
003b02 939a
003b03 938a          savetos
003b04 01c2          movw tosl, upl
003b05 ccfe          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
003b06 ff03          .dw $ff03
003b07 7075
003b08 0021          .db "up!",0
003b09 3afd          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
003b0a 3b0b          .dw PFA_UP_STORE
                 PFA_UP_STORE:
003b0b 012c          movw upl, tosl
003b0c 9189
003b0d 9199          loadtos
003b0e ccf5          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
003b0f ff03          .dw $ff03
003b10 3e32
003b11 0072          .db "2>r",0
003b12 3b06          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
003b13 3b14          .dw PFA_2TO_R
                 PFA_2TO_R:
003b14 01fc          movw zl, tosl
003b15 9189
003b16 9199          loadtos
003b17 939f          push tosh
003b18 938f          push tosl
003b19 93ff          push zh
003b1a 93ef          push zl
003b1b 9189
003b1c 9199          loadtos
003b1d cce6          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
003b1e ff03          .dw $ff03
003b1f 7232
003b20 003e          .db "2r>",0
003b21 3b0f          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
003b22 3b23          .dw PFA_2R_FROM
                 PFA_2R_FROM:
003b23 939a
003b24 938a          savetos
003b25 91ef          pop zl
003b26 91ff          pop zh
003b27 918f          pop tosl
003b28 919f          pop tosh
003b29 939a
003b2a 938a          savetos
003b2b 01cf          movw tosl, zl
003b2c ccd7          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
003b2d ff02          .dw $ff02
003b2e 6521          .db "!e"
003b2f 3b1e          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
003b30 3b31          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
003b31 01fc          movw zl, tosl
003b32 9189
003b33 9199          loadtos
003b34 b72f          in_ temp2, SREG
003b35 94f8          cli
003b36 d028          rcall PFA_FETCHE2
003b37 b500          in_  temp0, EEDR
003b38 1708          cp temp0,tosl
003b39 f009          breq PFA_STOREE3
003b3a d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
003b3b 9631          adiw zl,1
003b3c d022          rcall PFA_FETCHE2
003b3d b500          in_  temp0, EEDR
003b3e 1709          cp temp0,tosh
003b3f f011          breq PFA_STOREE4
003b40 2f89          mov tosl, tosh
003b41 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
003b42 bf2f          out_ SREG, temp2
003b43 9189
003b44 9199          loadtos
003b45 ccbe          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
003b46 99f9          sbic EECR, EEPE
003b47 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
003b48 b707          in_ temp0, SPMCSR
003b49 fd00          sbrc temp0,SPMEN
003b4a cffd          rjmp PFA_STOREE2
                 
003b4b bdf2          out_ EEARH,zh
003b4c bde1          out_ EEARL,zl
003b4d bd80          out_ EEDR, tosl
003b4e 9afa          sbi EECR,EEMPE
003b4f 9af9          sbi EECR,EEPE
                 
003b50 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
003b51 ff02          .dw $ff02
003b52 6540          .db "@e"
003b53 3b2d          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
003b54 3b55          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
003b55 b72f          in_ temp2, SREG
003b56 94f8          cli
003b57 01fc          movw zl, tosl
003b58 d006          rcall PFA_FETCHE2
003b59 b580          in_ tosl, EEDR
                 
003b5a 9631          adiw zl,1
                 
003b5b d003          rcall PFA_FETCHE2
003b5c b590          in_  tosh, EEDR
003b5d bf2f          out_ SREG, temp2
003b5e cca5          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
003b5f 99f9          sbic EECR, EEPE
003b60 cffe          rjmp PFA_FETCHE2
                 
003b61 bdf2          out_ EEARH,zh
003b62 bde1          out_ EEARL,zl
                 
003b63 9af8          sbi EECR,EERE
003b64 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
003b65 ff02          .dw $ff02
003b66 6921          .db "!i"
003b67 3b51          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
003b68 3de9          .dw PFA_DODEFER1
                 PFA_STOREI:
003b69 0088          .dw EE_STOREI
003b6a 3d8a          .dw XT_EDEFERFETCH
003b6b 3d94          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                 .else
                   .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
003b6c ff09          .dw $ff09
003b6d 2128
003b6e 2d69
003b6f 726e
003b70 7777
003b71 0029          .db "(!i-nrww)",0
003b72 3b65          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
003b73 3b74          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
003b74 b71f        in temp1,SREG
003b75 931f        push temp1
003b76 94f8        cli
                 
003b77 019c        movw temp2, tosl ; save the (word) address
003b78 9189
003b79 9199        loadtos          ; get the new value for the flash cell
003b7a 93af        push xl
003b7b 93bf        push xh
003b7c 93cf        push yl
003b7d 93df        push yh
003b7e d009        rcall DO_STOREI_atmega
003b7f 91df        pop yh
003b80 91cf        pop yl
003b81 91bf        pop xh
003b82 91af        pop xl
                   ; finally clear the stack
003b83 9189
003b84 9199        loadtos
003b85 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
003b86 bf1f        out SREG,temp1
                 
003b87 cc7c        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
003b88 d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
003b89 94e0        com temp4
003b8a 94f0        com temp5
003b8b 218e        and tosl, temp4
003b8c 219f        and tosh, temp5
003b8d 2b98        or tosh, tosl
003b8e f019        breq DO_STOREI_writepage 
003b8f 01f9          movw zl, temp2
003b90 e002          ldi temp0,(1<<PGERS)
003b91 d020          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
003b92 01f9        movw zl, temp2
003b93 e004        ldi temp0,(1<<PGWRT)
003b94 d01d        rcall dospm
                 
                   ; reenable RWW section
003b95 01f9        movw zl, temp2
003b96 e100        ldi temp0,(1<<RWWSRE)
003b97 d01a        rcall dospm
003b98 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
003b99 01f9        movw zl, temp2
                   ; get the beginning of page
003b9a 7ce0        andi zl,low(pagemask)
003b9b 7fff        andi zh,high(pagemask)
003b9c 01ef        movw y, z
                   ; loop counter (in words)
003b9d e4a0        ldi xl,low(pagesize)
003b9e e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
003b9f 01fe        movw z, y
003ba0 0fee
003ba1 1fff
003ba2 9145
003ba3 9155        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
003ba4 01fe        movw z, y
003ba5 17e2        cp zl, temp2
003ba6 07f3        cpc zh, temp3
003ba7 f011        breq pageload_newdata
003ba8 010a          movw r0, temp6
003ba9 c002          rjmp pageload_cont
                 pageload_newdata:
003baa 017a          movw temp4, temp6
003bab 010c          movw r0, tosl
                 pageload_cont:
003bac 2700        clr temp0
003bad d004        rcall dospm
003bae 9621        adiw y, 1
003baf 9711        sbiw x, 1
003bb0 f771        brne pageload_loop
                 
                 pageload_done:
003bb1 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
003bb2 99f9        sbic EECR, EEPE
003bb3 cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
003bb4 b717        in_  temp1, SPMCSR
003bb5 fd10        sbrc temp1, SPMEN
003bb6 cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
003bb7 0fee
003bb8 1fff        writeflashcell
                   ; execute spm
003bb9 6001        ori temp0, (1<<SPMEN)
003bba bf07        out_ SPMCSR,temp0
003bbb 95e8        spm
003bbc 9508        ret
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
003bbd ff02          .dw $ff02
003bbe 6940          .db "@i"
003bbf 3b6c          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
003bc0 3bc1          .dw PFA_FETCHI
                 PFA_FETCHI:
003bc1 01fc          movw zl, tosl
003bc2 0fee
003bc3 1fff
003bc4 9185
003bc5 9195          readflashcell tosl,tosh
003bc6 cc3d          jmp_ DO_NEXT
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2LITERAL:
003bc7 0008          .dw $0008
003bc8 6c32
003bc9 7469
003bca 7265
003bcb 6c61          .db "2literal"
003bcc 3bbd          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
003bcd 3800          .dw DO_COLON
                 PFA_2LITERAL:
                 .endif
003bce 38c3          .dw XT_SWAP
003bcf 0787          .dw XT_LITERAL
003bd0 0787          .dw XT_LITERAL
003bd1 381f          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
003bd2 ff01          .dw $ff01
003bd3 003d          .db "=",0
003bd4 3bc7          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
003bd5 3800          .dw DO_COLON
                 PFA_EQUAL:
003bd6 3992          .dw XT_MINUS
003bd7 3917          .dw XT_ZEROEQUAL
003bd8 381f          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
003bd9 ff01          .dw $ff01
003bda 0031          .db "1",0
003bdb 3bd2          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
003bdc 3847          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
003bdd 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
003bde ff01          .dw $ff01
003bdf 0032          .db "2",0
003be0 3bd9          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
003be1 3847          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
003be2 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
003be3 ff02          .dw $ff02
003be4 312d          .db "-1"
003be5 3bde          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
003be6 3847          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
003be7 ffff              .DW -1
                 
                 .if AMFORTH_NRWW_SIZE>8000
                 .elif AMFORTH_NRWW_SIZE>4000
                   .include "dict/core_4k.inc"
                 
                 ; in a short distance to DO_NEXT
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
003be8 ff03          .dw $ff03
003be9 3e6e
003bea 0072          .db "n>r",0
003beb 3be3          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
003bec 3bed          .dw PFA_N_TO_R
                 PFA_N_TO_R:
003bed 01fc          movw zl, tosl
003bee 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
003bef 9189
003bf0 9199          loadtos
003bf1 939f          push tosh
003bf2 938f          push tosl
003bf3 950a          dec temp0
003bf4 f7d1          brne PFA_N_TO_R1
003bf5 93ef          push zl
003bf6 93ff          push zh
003bf7 9189
003bf8 9199          loadtos
003bf9 cc0a          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
003bfa ff03          .dw $ff03
003bfb 726e
003bfc 003e          .db "nr>",0
003bfd 3be8          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
003bfe 3bff          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
003bff 939a
003c00 938a          savetos
003c01 91ff          pop zh
003c02 91ef          pop zl
003c03 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
003c04 918f          pop tosl
003c05 919f          pop tosh
003c06 939a
003c07 938a          savetos
003c08 950a          dec temp0
003c09 f7d1          brne PFA_N_R_FROM1
003c0a 01cf          movw tosl, zl
003c0b cbf8          jmp_ DO_NEXT
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
003c0c ff03          .dw $ff03
003c0d 3264
003c0e 002a          .db "d2*",0
003c0f 3bfa          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
003c10 3c11          .dw PFA_D2STAR
                 PFA_D2STAR:
003c11 9109          ld temp0, Y+
003c12 9119          ld temp1, Y+
003c13 0f00          lsl temp0
003c14 1f11          rol temp1
003c15 1f88          rol tosl
003c16 1f99          rol tosh
003c17 931a          st -Y, temp1
003c18 930a          st -Y, temp0
003c19 cbea          jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
003c1a ff03          .dw $ff03
003c1b 3264
003c1c 002f          .db "d2/",0
003c1d 3c0c          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
003c1e 3c1f          .dw PFA_D2SLASH
                 PFA_D2SLASH:
003c1f 9109          ld temp0, Y+
003c20 9119          ld temp1, Y+
003c21 9595          asr tosh
003c22 9587          ror tosl
003c23 9517          ror temp1
003c24 9507          ror temp0
003c25 931a          st -Y, temp1
003c26 930a          st -Y, temp0
003c27 cbdc          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
003c28 ff02          .dw $ff02
003c29 2b64          .db "d+"
003c2a 3c1a          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
003c2b 3c2c          .dw PFA_DPLUS
                 PFA_DPLUS:
003c2c 9129          ld temp2, Y+
003c2d 9139          ld temp3, Y+
                 
003c2e 90e9          ld temp4, Y+
003c2f 90f9          ld temp5, Y+
003c30 9149          ld temp6, Y+
003c31 9159          ld temp7, Y+
                 
003c32 0f24          add temp2, temp6
003c33 1f35          adc temp3, temp7
003c34 1d8e          adc tosl, temp4
003c35 1d9f          adc tosh, temp5
                     
003c36 933a          st -Y, temp3
003c37 932a          st -Y, temp2
003c38 cbcb          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
003c39 ff02          .dw $ff02
003c3a 2d64          .db "d-"
003c3b 3c28          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
003c3c 3c3d          .dw PFA_DMINUS
                 PFA_DMINUS:
003c3d 9129          ld temp2, Y+
003c3e 9139          ld temp3, Y+
                 
003c3f 90e9          ld temp4, Y+
003c40 90f9          ld temp5, Y+
003c41 9149          ld temp6, Y+
003c42 9159          ld temp7, Y+
                 
003c43 1b42          sub temp6, temp2
003c44 0b53          sbc temp7, temp3
003c45 0ae8          sbc temp4, tosl
003c46 0af9          sbc temp5, tosh
                 
003c47 935a          st -Y, temp7
003c48 934a          st -Y, temp6
003c49 01c7          movw tosl, temp4
003c4a cbb9          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
003c4b ff07          .dw $ff07
003c4c 6964
003c4d 766e
003c4e 7265
003c4f 0074          .db "dinvert",0
003c50 3c39          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
003c51 3c52          .dw PFA_DINVERT
                 PFA_DINVERT:
003c52 9109          ld temp0, Y+
003c53 9119          ld temp1, Y+
003c54 9580          com tosl
003c55 9590          com tosh
003c56 9500          com temp0
003c57 9510          com temp1
003c58 931a          st -Y, temp1
003c59 930a          st -Y, temp0
003c5a cba9          jmp_ DO_NEXT
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
003c5b ff04          .dw $ff04
003c5c 6d2f
003c5d 646f          .db "/mod"
003c5e 3c4b          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
003c5f 3c60          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
003c60 019c          movw temp2, tosl
                     
003c61 9109          ld temp0, Y+
003c62 9119          ld temp1, Y+
                 
003c63 2f41          mov	temp6,temp1	;move dividend High to sign register
003c64 2743          eor	temp6,temp3	;xor divisor High with sign register
003c65 ff17          sbrs	temp1,7	;if MSB in dividend set
003c66 c004          rjmp	PFA_SLASHMOD_1
003c67 9510          com	temp1		;    change sign of dividend
003c68 9500          com	temp0		
003c69 5f0f          subi	temp0,low(-1)
003c6a 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
003c6b ff37          sbrs	temp3,7	;if MSB in divisor set
003c6c c004          rjmp	PFA_SLASHMOD_2
003c6d 9530          com	temp3		;    change sign of divisor
003c6e 9520          com	temp2		
003c6f 5f2f          subi	temp2,low(-1)
003c70 4f3f          sbci	temp3,high(-1)
003c71 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
003c72 18ff          sub	temp5,temp5;clear remainder High byte and carry
003c73 e151          ldi	temp7,17	;init loop counter
                 
003c74 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
003c75 1f11          rol	temp1
003c76 955a          dec	temp7		;decrement counter
003c77 f439          brne	PFA_SLASHMOD_5		;if done
003c78 ff47          sbrs	temp6,7		;    if MSB in sign register set
003c79 c004          rjmp	PFA_SLASHMOD_4
003c7a 9510          com	temp1	;        change sign of result
003c7b 9500          com	temp0
003c7c 5f0f          subi	temp0,low(-1)
003c7d 4f1f          sbci	temp1,high(-1)
003c7e c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
003c7f 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
003c80 1cff          rol	temp5
003c81 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
003c82 0af3          sbc	temp5,temp3	;
003c83 f420          brcc	PFA_SLASHMOD_6		;if result negative
003c84 0ee2          add	temp4,temp2	;    restore remainder
003c85 1ef3          adc	temp5,temp3
003c86 9488          clc			;    clear carry to be shifted into result
003c87 cfec          rjmp	PFA_SLASHMOD_3		;else
003c88 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
003c89 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
003c8a 92fa          st -Y,temp5
003c8b 92ea          st -Y,temp4
                 
                     ; put quotient on stack
003c8c 01c8          movw tosl, temp0
003c8d cb76          jmp_ DO_NEXT
                 .include "words/abs.asm"
                 
                 ;   DUP ?NEGATE ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABS:
003c8e ff03          .dw $ff03
003c8f 6261
003c90 0073          .db "abs",0
003c91 3c5b          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
003c92 3800          .dw DO_COLON
                 PFA_ABS:
                 
                 .endif
                 
003c93 38b0
003c94 3a3d
003c95 381f          .DW XT_DUP,XT_QNEGATE,XT_EXIT
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
003c96 ff04          .dw $ff04
003c97 6970
003c98 6b63          .db "pick"
003c99 3c8e          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
003c9a 3800          .dw DO_COLON
                 PFA_PICK:
                 .endif
003c9b 3a2e          .dw XT_1PLUS
003c9c 3eae          .dw XT_CELLS
003c9d 3a8c          .dw XT_SP_FETCH
003c9e 399c          .dw XT_PLUS
003c9f 3878          .dw XT_FETCH
003ca0 381f          .dw XT_EXIT
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
003ca1 ff05          .dw $ff05
003ca2 6563
003ca3 6c6c
003ca4 002b          .db "cell+",0
003ca5 3c96          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
003ca6 3ca7          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
003ca7 9602          adiw tosl, CELLSIZE
003ca8 cb5b          jmp_ DO_NEXT
                 
                 ; now the relocatable colon words
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_DEFAULT_PROMPTOK:
003ca9 3800          .dw DO_COLON
                 PFA_DEFAULT_PROMPTOK:
003caa 03be          .dw XT_DOSLITERAL
003cab 0003          .dw 3
003cac 6f20
003cad 006b          .db " ok",0
                 .endif
003cae 03f1          .dw XT_ITYPE
003caf 381f          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTOK:
003cb0 ff03          .dw $FF03
003cb1 6f2e
../../common\words/prompt-ok.asm(43): warning: .cseg .db misalignment - padding zero byte
003cb2 006b          .db ".ok"
003cb3 3ca1          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
003cb4 3de9          .dw PFA_DODEFER1
                 PFA_PROMPTOK:
                 .endif
003cb5 001c          .dw USER_P_OK
003cb6 3db2          .dw XT_UDEFERFETCH
003cb7 3dbe          .dw XT_UDEFERSTORE
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_DEFAULT_PROMPTREADY:
003cb8 3800          .dw DO_COLON
                 PFA_DEFAULT_PROMPTREADY:
003cb9 03be          .dw XT_DOSLITERAL
003cba 0002          .dw 2
003cbb 203e          .db "> "
                 .endif
003cbc 3f8b          .dw XT_CR
003cbd 03f1          .dw XT_ITYPE
003cbe 381f          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTREADY:
003cbf ff06          .dw $FF06
003cc0 722e
003cc1 6165
003cc2 7964          .db ".ready"
003cc3 3cb0          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTREADY
                 XT_PROMPTREADY:
003cc4 3de9          .dw PFA_DODEFER1
                 PFA_PROMPTREADY:
                 .endif
003cc5 0020          .dw USER_P_RDY
003cc6 3db2          .dw XT_UDEFERFETCH
003cc7 3dbe          .dw XT_UDEFERSTORE
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_DEFAULT_PROMPTERROR:
003cc8 3800          .dw DO_COLON
                 PFA_DEFAULT_PROMPTERROR:
003cc9 03be      	.dw XT_DOSLITERAL
003cca 0004          .dw 4
003ccb 3f20
003ccc 203f          .db " ?? "
                 .endif
003ccd 03f1          .dw XT_ITYPE
003cce 3ea7          .dw XT_BASE
003ccf 3878          .dw XT_FETCH
003cd0 38fe          .dw XT_TO_R
003cd1 3f2b          .dw XT_DECIMAL
003cd2 0373          .dw XT_DOT
003cd3 3ecc          .dw XT_TO_IN
003cd4 3878          .dw XT_FETCH
003cd5 0373          .dw XT_DOT
003cd6 38f5          .dw XT_R_FROM
003cd7 3ea7          .dw XT_BASE
003cd8 3880          .dw XT_STORE
003cd9 381f          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTERROR:
003cda ff06          .dw $FF06
003cdb 652e
003cdc 7272
003cdd 726f          .db ".error"
003cde 3cbf          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
003cdf 3de9          .dw PFA_DODEFER1
                 PFA_PROMPTERROR:
                 .endif
003ce0 001e          .dw USER_P_ERR
003ce1 3db2          .dw XT_UDEFERFETCH
003ce2 3dbe          .dw XT_UDEFERSTORE
                 .include "words/prompt-input.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_DEFAULT_PROMPTINPUT:
003ce3 3800          .dw DO_COLON
                 PFA_DEFAULT_PROMPTINPUT:
                 .endif
003ce4 3f8b          .dw XT_CR
003ce5 381f          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTINPUT:
003ce6 ff06          .dw $FF06
003ce7 692e
003ce8 706e
003ce9 7475          .db ".input"
003cea 3cda          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTINPUT
                 XT_PROMPTINPUT:
003ceb 3de9          .dw PFA_DODEFER1
                 PFA_PROMPTINPUT:
                 .endif
003cec 0022          .dw USER_P_INPUT
003ced 3db2          .dw XT_UDEFERFETCH
003cee 3dbe          .dw XT_UDEFERSTORE
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
003cef ff04          .dw $ff04
003cf0 7571
003cf1 7469          .db "quit"
003cf2 3ce6          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
003cf3 3800          .dw DO_COLON
                 .endif
                 PFA_QUIT:
003cf4 0866
003cf5 086d
003cf6 3880          .dw XT_LP0,XT_LP,XT_STORE
003cf7 05d0          .dw XT_SP0
003cf8 3a95          .dw XT_SP_STORE
003cf9 05d8          .dw XT_RP0
003cfa 3a7f          .dw XT_RP_STORE
003cfb 08fb          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
003cfc 3ea1          .dw XT_STATE
003cfd 3878          .dw XT_FETCH
003cfe 3917          .dw XT_ZEROEQUAL
003cff 3835          .dw XT_DOCONDBRANCH
003d00 3d02          DEST(PFA_QUIT4)
003d01 3cc4          .dw XT_PROMPTREADY
                 PFA_QUIT4:
003d02 04df          .dw XT_REFILL
003d03 3ceb          .dw XT_PROMPTINPUT
003d04 3835          .dw XT_DOCONDBRANCH
003d05 3d15          DEST(PFA_QUIT3)
003d06 383c          .dw XT_DOLITERAL
003d07 0626          .dw XT_INTERPRET
003d08 3d5d          .dw XT_CATCH
003d09 38b8          .dw XT_QDUP
003d0a 3835          .dw XT_DOCONDBRANCH
003d0b 3d15          DEST(PFA_QUIT3)
003d0c 38b0      	.dw XT_DUP
003d0d 383c      	.dw XT_DOLITERAL
003d0e fffe      	.dw -2
003d0f 396d      	.dw XT_LESS
003d10 3835      	.dw XT_DOCONDBRANCH
003d11 3d13      	DEST(PFA_QUIT5)
003d12 3cdf      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
003d13 382e      	.dw XT_DOBRANCH
003d14 3cf4      	DEST(PFA_QUIT)
                 PFA_QUIT3:
003d15 3cb4          .dw XT_PROMPTOK
003d16 382e          .dw XT_DOBRANCH
003d17 3cfc          DEST(PFA_QUIT2)
                 ;    .dw XT_EXIT ; never reached
                 
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
003d18 ff05          .dw $ff05
003d19 6170
003d1a 7375
003d1b 0065          .db "pause",0
003d1c 3cef          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
003d1d 3de9          .dw PFA_DODEFER1
                 PFA_PAUSE:
003d1e 01a3          .dw ram_pause
003d1f 3d9e          .dw XT_RDEFERFETCH
003d20 3da8          .dw XT_RDEFERSTORE
                 
                 .dseg
0001a3           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
003d21 ff04          .dw $ff04
003d22 6f63
003d23 646c          .db "cold"
003d24 3d18          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
003d25 3d26          .dw PFA_COLD
                 PFA_COLD:
003d26 b6a4          in_ mcu_boot, MCUSR
003d27 2422          clr zerol
003d28 2433          clr zeroh
003d29 24bb          clr isrflag
003d2a be24          out_ MCUSR, zerol
                     ; clear RAM
003d2b e0e0          ldi zl, low(ramstart)
003d2c e0f1          ldi zh, high(ramstart)
                 clearloop:
003d2d 9221          st Z+, zerol
003d2e 30e0          cpi zl, low(sram_size+ramstart)
003d2f f7e9          brne clearloop
003d30 30fb          cpi zh, high(sram_size+ramstart)
003d31 f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
0001a5           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
003d32 eae5          ldi zl, low(ram_user1)
003d33 e0f1          ldi zh, high(ram_user1)
003d34 012f          movw upl, zl
                     ; init return stack pointer
003d35 ef0f          ldi temp0,low(rstackstart)
003d36 bf0d          out_ SPL,temp0
003d37 8304          std Z+4, temp0
003d38 e01a          ldi temp1,high(rstackstart)
003d39 bf1e          out_ SPH,temp1
003d3a 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
003d3b eacf          ldi yl,low(stackstart)
003d3c 83c6          std Z+6, yl
003d3d e0da          ldi yh,high(stackstart)
003d3e 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
003d3f e4a7          ldi XL, low(PFA_WARM)
003d40 e3bd          ldi XH, high(PFA_WARM)
                     ; its a far jump...
003d41 cac2          jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WARM:
003d42 ff04          .dw $ff04
003d43 6177
003d44 6d72          .db "warm"
003d45 3d21          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
003d46 3800          .dw DO_COLON
                 PFA_WARM:
                 .endif
003d47 0290          .dw XT_INIT_RAM
003d48 383c          .dw XT_DOLITERAL
003d49 3fbf          .dw XT_NOOP
003d4a 383c          .dw XT_DOLITERAL
003d4b 3d1d          .dw XT_PAUSE
003d4c 3dc9          .dw XT_DEFERSTORE
003d4d 08fb          .dw XT_LBRACKET
003d4e 3f46          .dw XT_TURNKEY
003d4f 3cf3          .dw XT_QUIT     ; never returns
                 
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
003d50 ff07          .dw $ff07
003d51 6168
003d52 646e
003d53 656c
003d54 0072          .db "handler",0
003d55 3d42          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
003d56 3857          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
003d57 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
003d58 ff05          .dw $ff05
003d59 6163
003d5a 6374
003d5b 0068          .db "catch",0
003d5c 3d50          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
003d5d 3800          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
003d5e 3a8c          .dw XT_SP_FETCH
003d5f 38fe          .dw XT_TO_R
                     ; handler @ >r
003d60 3d56          .dw XT_HANDLER
003d61 3878          .dw XT_FETCH
003d62 38fe          .dw XT_TO_R
                     ; rp@ handler !
003d63 3a75          .dw XT_RP_FETCH
003d64 3d56          .dw XT_HANDLER
003d65 3880          .dw XT_STORE
003d66 3829          .dw XT_EXECUTE
                     ; r> handler !
003d67 38f5          .dw XT_R_FROM
003d68 3d56          .dw XT_HANDLER
003d69 3880          .dw XT_STORE
003d6a 38f5          .dw XT_R_FROM
003d6b 38d8          .dw XT_DROP
003d6c 3953          .dw XT_ZERO
003d6d 381f          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
003d6e ff05          .dw $ff05
003d6f 6874
003d70 6f72
003d71 0077          .db "throw",0
003d72 3d58          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
003d73 3800          .dw DO_COLON
                 PFA_THROW:
                 .endif
003d74 38b8          .dw XT_QDUP
003d75 3835          .dw XT_DOCONDBRANCH
003d76 3d83          DEST(PFA_THROW1)
003d77 3d56            .dw XT_HANDLER
003d78 3878            .dw XT_FETCH
003d79 3a7f            .dw XT_RP_STORE
003d7a 38f5            .dw XT_R_FROM
003d7b 3d56            .dw XT_HANDLER
003d7c 3880            .dw XT_STORE
003d7d 38f5            .dw XT_R_FROM
003d7e 38c3            .dw XT_SWAP
003d7f 38fe            .dw XT_TO_R
003d80 3a95            .dw XT_SP_STORE
003d81 38d8            .dw XT_DROP
003d82 38f5            .dw XT_R_FROM    
                 PFA_THROW1:
003d83 381f          .dw XT_EXIT
                 
                 
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
003d84 ff07          .dw $ff07
003d85 6445
003d86 6665
003d87 7265
003d88 0040          .db "Edefer@",0
003d89 3d6e          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
003d8a 3800          .dw DO_COLON
                 PFA_EDEFERFETCH:
003d8b 3bc0          .dw XT_FETCHI
003d8c 3b54          .dw XT_FETCHE
003d8d 381f          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
003d8e ff07          .dw $ff07
003d8f 6445
003d90 6665
003d91 7265
003d92 0021          .db "Edefer!",0
003d93 3d84          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
003d94 3800          .dw DO_COLON
                 PFA_EDEFERSTORE:
003d95 3bc0          .dw XT_FETCHI
003d96 3b30          .dw XT_STOREE
003d97 381f          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
003d98 ff07          .dw $ff07
003d99 6452
003d9a 6665
003d9b 7265
003d9c 0040          .db "Rdefer@",0
003d9d 3d8e          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
003d9e 3800          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
003d9f 3bc0          .dw XT_FETCHI
003da0 3878          .dw XT_FETCH
003da1 381f          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
003da2 ff07          .dw $ff07
003da3 6452
003da4 6665
003da5 7265
003da6 0021          .db "Rdefer!",0
003da7 3d98          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
003da8 3800          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
003da9 3bc0          .dw XT_FETCHI
003daa 3880          .dw XT_STORE
003dab 381f          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
003dac ff07          .dw $ff07
003dad 6455
003dae 6665
003daf 7265
003db0 0040          .db "Udefer@",0
003db1 3da2          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
003db2 3800          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
003db3 3bc0          .dw XT_FETCHI
003db4 3b01          .dw XT_UP_FETCH
003db5 399c          .dw XT_PLUS
003db6 3878          .dw XT_FETCH
003db7 381f          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
003db8 ff07          .dw $ff07
003db9 6455
003dba 6665
003dbb 7265
003dbc 0021          .db "Udefer!",0
003dbd 3dac          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
003dbe 3800          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
003dbf 3bc0          .dw XT_FETCHI
003dc0 3b01          .dw XT_UP_FETCH
003dc1 399c          .dw XT_PLUS
003dc2 3880          .dw XT_STORE
003dc3 381f          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
003dc4 ff06          .dw $ff06
003dc5 6564
003dc6 6566
003dc7 2172          .db "defer!"
003dc8 3db8          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
003dc9 3800          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
003dca 3fba          .dw XT_TO_BODY
003dcb 38b0          .dw XT_DUP
003dcc 01ae          .dw XT_ICELLPLUS
003dcd 01ae          .dw XT_ICELLPLUS
003dce 3bc0          .dw XT_FETCHI
003dcf 3829          .dw XT_EXECUTE
003dd0 381f          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
003dd1 ff06          .dw $ff06
003dd2 6564
003dd3 6566
003dd4 4072          .db "defer@"
003dd5 3dc4          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
003dd6 3800          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
003dd7 3fba          .dw XT_TO_BODY 
003dd8 38b0          .dw XT_DUP
003dd9 01ae          .dw XT_ICELLPLUS
003dda 3bc0          .dw XT_FETCHI
003ddb 3829          .dw XT_EXECUTE
003ddc 381f          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
003ddd ff07          .dw $ff07
003dde 6428
003ddf 6665
003de0 7265
003de1 0029          .db "(defer)", 0
003de2 3dd1          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
003de3 3800          .dw DO_COLON
                 PFA_DODEFER:
003de4 0738          .dw XT_DOCREATE
003de5 08a3          .dw XT_REVEAL
003de6 0766          .dw XT_COMPILE
003de7 3de9          .dw PFA_DODEFER1
003de8 381f          .dw XT_EXIT
                 PFA_DODEFER1:
003de9 940e 08bc     call_ DO_DODOES
003deb 38b0          .dw XT_DUP
003dec 01ae          .dw XT_ICELLPLUS
003ded 3bc0          .dw XT_FETCHI
003dee 3829          .dw XT_EXECUTE 
003def 3829          .dw XT_EXECUTE
003df0 381f          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
003df1 ff02          .dw $ff02
003df2 2e75          .db "u."
003df3 3ddd          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
003df4 3800          .dw DO_COLON
                 PFA_UDOT:
                 .endif
003df5 3953          .dw XT_ZERO
003df6 037b          .dw XT_UDDOT
003df7 381f          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
003df8 ff03          .dw $ff03
003df9 2e75
003dfa 0072          .db "u.r",0
003dfb 3df1          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
003dfc 3800          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
003dfd 3953          .dw XT_ZERO
003dfe 38c3          .dw XT_SWAP
003dff 0384          .dw XT_UDDOTR
003e00 381f          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
003e01 ff05          .dw $ff05
003e02 2f75
003e03 6f6d
003e04 0064          .db "u/mod",0
003e05 3df8          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
003e06 3800          .dw DO_COLON
                 PFA_USLASHMOD:
003e07 38fe          .dw XT_TO_R
003e08 3953          .dw XT_ZERO
003e09 38f5          .dw XT_R_FROM
003e0a 39c1          .dw XT_UMSLASHMOD
003e0b 381f          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
003e0c ff06          .dw $ff06
003e0d 656e
003e0e 6167
003e0f 6574          .db "negate"
003e10 3e01          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
003e11 3800          .dw DO_COLON
                 PFA_NEGATE:
003e12 39fc          .dw XT_INVERT
003e13 3a2e          .dw XT_1PLUS
003e14 381f          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
003e15 ff01          .dw $ff01
003e16 002f          .db "/",0
003e17 3e0c          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
003e18 3800          .dw DO_COLON
                 PFA_SLASH:
                 .endif
003e19 3c5f          .dw XT_SLASHMOD
003e1a 38ef          .dw XT_NIP
003e1b 381f          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
003e1c ff03          .dw $ff03
003e1d 6f6d
003e1e 0064          .db "mod",0
003e1f 3e15          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
003e20 3800          .dw DO_COLON
                 PFA_MOD:
                 .endif
003e21 3c5f          .dw XT_SLASHMOD
003e22 38d8          .dw XT_DROP
003e23 381f          .dw XT_EXIT
                 
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
003e24 ff03          .dw $ff03
003e25 696d
003e26 006e          .db "min",0
003e27 3e1c          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
003e28 3800          .dw DO_COLON
                 PFA_MIN:
                 .endif
003e29 3eb3          .dw XT_2DUP
003e2a 3977          .dw XT_GREATER
003e2b 3835          .dw XT_DOCONDBRANCH
003e2c 3e2e          DEST(PFA_MIN1)
003e2d 38c3          .dw XT_SWAP
                 PFA_MIN1:
003e2e 38d8          .dw XT_DROP
003e2f 381f          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
003e30 ff03          .dw $ff03
003e31 616d
003e32 0078          .db "max",0
003e33 3e24          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
003e34 3800          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
003e35 3eb3          .dw XT_2DUP
003e36 396d          .dw XT_LESS
003e37 3835          .dw XT_DOCONDBRANCH
003e38 3e3a          DEST(PFA_MAX1)
003e39 38c3          .dw XT_SWAP
                 PFA_MAX1:
003e3a 38d8          .dw XT_DROP
003e3b 381f          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
003e3c ff06          .dw $ff06
003e3d 6977
003e3e 6874
003e3f 6e69          .db "within"
003e40 3e30          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
003e41 3800          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
003e42 38ce          .dw XT_OVER
003e43 3992          .dw XT_MINUS
003e44 38fe          .dw XT_TO_R
003e45 3992          .dw XT_MINUS
003e46 38f5          .dw XT_R_FROM
003e47 395b          .dw XT_ULESS
003e48 381f          .dw XT_EXIT
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
003e49 ff0d          .dw $ff0d
003e4a 6873
003e4b 776f
003e4c 772d
003e4d 726f
003e4e 6c64
003e4f 7369
003e50 0074          .db "show-wordlist",0
003e51 3e3c          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
003e52 3800          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
003e53 383c          .dw XT_DOLITERAL
003e54 3e58          .dw XT_SHOWWORD
003e55 38c3          .dw XT_SWAP
003e56 06d9          .dw XT_TRAVERSEWORDLIST
003e57 381f          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
003e58 3800          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
003e59 06f4          .dw XT_NAME2STRING
003e5a 03f1          .dw XT_ITYPE
003e5b 3f98          .dw XT_SPACE         ; ( -- addr n)
003e5c 394a          .dw XT_TRUE
003e5d 381f          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_WORDS:
003e5e ff05          .dw $ff05
003e5f 6f77
003e60 6472
003e61 0073          .db "words",0
003e62 3e49          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
003e63 3800          .dw DO_COLON
                 PFA_WORDS:
                 .endif
003e64 383c          .dw XT_DOLITERAL
003e65 006e          .dw CFG_ORDERLISTLEN+2
003e66 3b54          .dw XT_FETCHE
003e67 3e52          .dw XT_SHOWWORDLIST
003e68 381f          .dw XT_EXIT
                 
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
003e69 0002          .dw $0002
003e6a 222e          .db ".",$22
003e6b 3e5e          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
003e6c 3800          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
003e6d 3e74          .dw XT_SQUOTE
003e6e 0766          .dw XT_COMPILE
003e6f 03f1          .dw XT_ITYPE
003e70 381f          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
003e71 0002        .dw $0002
003e72 2273        .db "s",$22
003e73 3e69        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
003e74 3800          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
003e75 383c          .dw XT_DOLITERAL
003e76 0022          .dw 34   ; 0x22 
003e77 0589          .dw XT_PARSE       ; ( -- addr n)
003e78 3ea1          .dw XT_STATE
003e79 3878          .dw XT_FETCH
003e7a 3835          .dw XT_DOCONDBRANCH
003e7b 3e7d          DEST(PFA_SQUOTE1)
003e7c 0792            .dw XT_SLITERAL
                 PFA_SQUOTE1:
003e7d 381f          .dw XT_EXIT
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
003e7e ff04          .dw $ff04
003e7f 6966
003e80 6c6c          .db "fill"
003e81 3e71          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
003e82 3800          .dw DO_COLON
                 PFA_FILL:
003e83 38e0          .dw XT_ROT
003e84 38e0          .dw XT_ROT
003e85 38b8
003e86 3835          .dw XT_QDUP,XT_DOCONDBRANCH
003e87 3e8f          DEST(PFA_FILL2)
003e88 3f83          .dw XT_BOUNDS
003e89 3a9a          .dw XT_DODO
                 PFA_FILL1:
003e8a 38b0          .dw XT_DUP
003e8b 3aab          .dw XT_I
003e8c 388c          .dw XT_CSTORE  ; ( -- c c-addr)
003e8d 3ac8          .dw XT_DOLOOP
003e8e 3e8a          .dw PFA_FILL1
                 PFA_FILL2:
003e8f 38d8          .dw XT_DROP
003e90 381f          .dw XT_EXIT
                 
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
003e91 ff05          .dw $ff05
003e92 5f66
003e93 7063
003e94 0075          .db "f_cpu",0
003e95 3e7e          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
003e96 3800          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
003e97 383c          .dw XT_DOLITERAL
003e98 2400          .dw (F_CPU % 65536)
003e99 383c          .dw XT_DOLITERAL
003e9a 00f4          .dw (F_CPU / 65536)
003e9b 381f          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
003e9c ff05          .dw $ff05
003e9d 7473
003e9e 7461
003e9f 0065          .db "state",0
003ea0 3e91          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
003ea1 3847          .dw PFA_DOVARIABLE
                 PFA_STATE:
003ea2 01d3          .dw ram_state
                 
                 .dseg
0001d3           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
003ea3 ff04          .dw $ff04
003ea4 6162
003ea5 6573          .db "base"
003ea6 3e9c          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
003ea7 3857          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
003ea8 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
003ea9 ff05          .dw $ff05
003eaa 6563
003eab 6c6c
003eac 0073          .db "cells",0
003ead 3ea3          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
003eae 3a0b          .dw PFA_2STAR
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
003eaf ff04          .dw $ff04
003eb0 6432
003eb1 7075          .db "2dup"
003eb2 3ea9          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
003eb3 3800          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
003eb4 38ce          .dw XT_OVER
003eb5 38ce          .dw XT_OVER
003eb6 381f          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
003eb7 ff05          .dw $ff05
003eb8 6432
003eb9 6f72
003eba 0070          .db "2drop",0
003ebb 3eaf          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
003ebc 3800          .dw DO_COLON
                 PFA_2DROP:
                 .endif
003ebd 38d8          .dw XT_DROP
003ebe 38d8          .dw XT_DROP
003ebf 381f          .dw XT_EXIT
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
003ec0 ff04          .dw $ff04
003ec1 7574
003ec2 6b63          .db "tuck"
003ec3 3eb7          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
003ec4 3800          .dw DO_COLON
                 PFA_TUCK:
                 .endif
003ec5 38c3          .dw XT_SWAP
003ec6 38ce          .dw XT_OVER
003ec7 381f          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
003ec8 ff03          .dw $ff03
003ec9 693e
003eca 006e          .db ">in",0
003ecb 3ec0          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
003ecc 3857          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
003ecd 0018          .dw USER_TO_IN
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PAD:
003ece ff03          .dw $ff03
003ecf 6170
003ed0 0064          .db "pad",0
003ed1 3ec8          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
003ed2 3800          .dw DO_COLON
                 PFA_PAD:
                 .endif
003ed3 3f0d          .dw XT_HERE
003ed4 383c          .dw XT_DOLITERAL
003ed5 0028          .dw 40
003ed6 399c          .dw XT_PLUS
003ed7 381f          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMIT:
003ed8 ff04          .dw $ff04
003ed9 6d65
003eda 7469          .db "emit"
003edb 3ece          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
003edc 3de9          .dw PFA_DODEFER1
                 PFA_EMIT:
                 .endif
003edd 000e          .dw USER_EMIT
003ede 3db2          .dw XT_UDEFERFETCH
003edf 3dbe          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMITQ:
003ee0 ff05          .dw $ff05
003ee1 6d65
003ee2 7469
003ee3 003f          .db "emit?",0
003ee4 3ed8          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
003ee5 3de9          .dw PFA_DODEFER1
                 PFA_EMITQ:
                 .endif
003ee6 0010          .dw USER_EMITQ
003ee7 3db2          .dw XT_UDEFERFETCH
003ee8 3dbe          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEY:
003ee9 ff03          .dw $ff03
003eea 656b
003eeb 0079          .db "key",0
003eec 3ee0          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
003eed 3de9          .dw PFA_DODEFER1
                 PFA_KEY:
                 .endif
003eee 0012          .dw USER_KEY
003eef 3db2          .dw XT_UDEFERFETCH
003ef0 3dbe          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEYQ:
003ef1 ff04          .dw $ff04
003ef2 656b
003ef3 3f79          .db "key?"
003ef4 3ee9          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
003ef5 3de9          .dw PFA_DODEFER1
                 PFA_KEYQ:
                 .endif
003ef6 0014          .dw USER_KEYQ
003ef7 3db2          .dw XT_UDEFERFETCH
003ef8 3dbe          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
003ef9 ff02          .dw $ff02
003efa 7064          .db "dp"
003efb 3ef1          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
003efc 386e          .dw PFA_DOVALUE1
                 PFA_DP:
003efd 0058          .dw CFG_DP
003efe 3d8a          .dw XT_EDEFERFETCH
003eff 3d94          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
003f00 ff05          .dw $ff05
003f01 6865
003f02 7265
003f03 0065          .db "ehere",0
003f04 3ef9          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
003f05 386e          .dw PFA_DOVALUE1
                 PFA_EHERE:
003f06 005c          .dw EE_EHERE
003f07 3d8a          .dw XT_EDEFERFETCH
003f08 3d94          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
003f09 ff04          .dw $ff04
003f0a 6568
003f0b 6572          .db "here"
003f0c 3f00          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
003f0d 386e          .dw PFA_DOVALUE1
                 PFA_HERE:
003f0e 005a          .dw EE_HERE
003f0f 3d8a          .dw XT_EDEFERFETCH
003f10 3d94          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
003f11 ff05          .dw $ff05
003f12 6c61
003f13 6f6c
003f14 0074          .db "allot",0
003f15 3f09          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
003f16 3800          .dw DO_COLON
                 PFA_ALLOT:
003f17 3f0d          .dw XT_HERE
003f18 399c          .dw XT_PLUS
003f19 019c          .dw XT_DOTO
003f1a 3f0e          .dw PFA_HERE
003f1b 381f          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
003f1c ff03          .dw $ff03
003f1d 6962
003f1e 006e          .db "bin",0
003f1f 3f11          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
003f20 3800          .dw DO_COLON
                 PFA_BIN:
                 .endif
003f21 3be1          .dw XT_TWO
003f22 3ea7          .dw XT_BASE
003f23 3880          .dw XT_STORE
003f24 381f          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
003f25 ff07          .dw $ff07
003f26 6564
003f27 6963
003f28 616d
003f29 006c          .db "decimal",0
003f2a 3f1c          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
003f2b 3800          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
003f2c 383c          .dw XT_DOLITERAL
003f2d 000a          .dw 10
003f2e 3ea7          .dw XT_BASE
003f2f 3880          .dw XT_STORE
003f30 381f          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
003f31 ff03          .dw $ff03
003f32 6568
003f33 0078          .db "hex",0
003f34 3f25          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
003f35 3800          .dw DO_COLON
                 PFA_HEX:
                 .endif
003f36 383c          .dw XT_DOLITERAL
003f37 0010          .dw 16
003f38 3ea7          .dw XT_BASE
003f39 3880          .dw XT_STORE
003f3a 381f          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
003f3b ff02          .dw $ff02
003f3c 6c62          .db "bl"
003f3d 3f31          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
003f3e 3847          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
003f3f 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
003f40 ff07          .dw $ff07
003f41 7574
003f42 6e72
003f43 656b
003f44 0079          .db "turnkey",0
003f45 3f3b          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
003f46 3de9          .dw PFA_DODEFER1
                 PFA_TURNKEY:
003f47 0064          .dw CFG_TURNKEY
003f48 3d8a          .dw XT_EDEFERFETCH
003f49 3d94          .dw XT_EDEFERSTORE
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
003f4a ff07          .dw $ff07 
003f4b 6f74
003f4c 7075
003f4d 6570
003f4e 0072          .db "toupper",0
003f4f 3f40          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
003f50 3800          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
003f51 38b0          .dw XT_DUP 
003f52 383c          .dw XT_DOLITERAL 
003f53 0061          .dw 'a' 
003f54 383c          .dw XT_DOLITERAL 
003f55 007b          .dw 'z'+1
003f56 3e41          .dw XT_WITHIN 
003f57 3835          .dw XT_DOCONDBRANCH
003f58 3f5c          DEST(PFA_TOUPPER0)
003f59 383c          .dw XT_DOLITERAL
003f5a 00df          .dw 223 ; inverse of 0x20: 0xdf
003f5b 3a12          .dw XT_AND 
                 PFA_TOUPPER0:
003f5c 381f          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
003f5d ff07          .dw $ff07
003f5e 6f74
003f5f 6f6c
003f60 6577
003f61 0072          .db "tolower",0
003f62 3f4a          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
003f63 3800          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
003f64 38b0          .dw XT_DUP
003f65 383c          .dw XT_DOLITERAL
003f66 0041          .dw 'A'
003f67 383c          .dw XT_DOLITERAL
003f68 005b          .dw 'Z'+1
003f69 3e41          .dw XT_WITHIN
003f6a 3835          .dw XT_DOCONDBRANCH
003f6b 3f6f          DEST(PFA_TOLOWER0)
003f6c 383c          .dw XT_DOLITERAL
003f6d 0020          .dw 32
003f6e 3a1b          .dw XT_OR 
                 PFA_TOLOWER0:
003f6f 381f          .dw XT_EXIT 
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
003f70 ff06          .dw $ff06
003f71 733f
003f72 6174
003f73 6b63          .db "?stack"
003f74 3f5d          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
003f75 3800          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
003f76 05e3          .dw XT_DEPTH
003f77 391e          .dw XT_ZEROLESS
003f78 3835          .dw XT_DOCONDBRANCH
003f79 3f7d          DEST(PFA_QSTACK1)
003f7a 383c            .dw XT_DOLITERAL
003f7b fffc            .dw -4
003f7c 3d73            .dw XT_THROW
                 PFA_QSTACK1:
003f7d 381f          .dw XT_EXIT
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
003f7e ff06          .dw $ff06
003f7f 6f62
003f80 6e75
003f81 7364          .db "bounds"
003f82 3f70          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
003f83 3800          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
003f84 38ce          .dw XT_OVER
003f85 399c          .dw XT_PLUS
003f86 38c3          .dw XT_SWAP
003f87 381f          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
003f88 ff02          .dw 0xff02
003f89 7263          .db "cr"
003f8a 3f7e          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
003f8b 3800          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
003f8c 383c          .dw XT_DOLITERAL
003f8d 000d          .dw 13
003f8e 3edc          .dw XT_EMIT
003f8f 383c          .dw XT_DOLITERAL
003f90 000a          .dw 10
003f91 3edc          .dw XT_EMIT
003f92 381f          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
003f93 ff05          .dw $ff05
003f94 7073
003f95 6361
003f96 0065          .db "space",0
003f97 3f88          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
003f98 3800          .dw DO_COLON
                 PFA_SPACE:
                 .endif
003f99 3f3e          .dw XT_BL
003f9a 3edc          .dw XT_EMIT
003f9b 381f          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
003f9c ff06          .dw $ff06
003f9d 7073
003f9e 6361
003f9f 7365          .db "spaces"
003fa0 3f93          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
003fa1 3800          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
003fa2 3953
003fa3 3e34      	.DW XT_ZERO, XT_MAX
003fa4 38b0
003fa5 3835      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
003fa6 3fab              DEST(SPCS2)
003fa7 3f98
003fa8 3a34
003fa9 382e              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
003faa 3fa4              DEST(SPCS1)
003fab 38d8
003fac 381f      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
003fad ff03          .dw $ff03
003fae 3e73
003faf 0064          .db "s>d",0
003fb0 3f9c          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
003fb1 3800          .dw DO_COLON
                 PFA_S2D:
                 .endif
003fb2 38b0          .dw XT_DUP
003fb3 391e          .dw XT_ZEROLESS
003fb4 381f          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
003fb5 ff05          .dw $ff05
003fb6 623e
003fb7 646f
003fb8 0079          .db ">body",0
003fb9 3fad          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
003fba 3a2f          .dw PFA_1PLUS
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOOP:
003fbb ff04          .dw $ff04
003fbc 6f6e
003fbd 706f          .db "noop"
003fbe 3fb5          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
003fbf 3800          .dw DO_COLON
                 PFA_NOOP:
                 .endif
003fc0 381f         .DW XT_EXIT
                 .elif AMFORTH_NRWW_SIZE>2000
                 .else
                 .endif
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000056 ff ff     
                 ; some configs
000058 e0 0a     CFG_DP:      .dw DPSTART         ; Dictionary Pointer
00005a d5 01     EE_HERE:     .dw HERESTART       ; Memory Allocation
00005c b2 00     EE_EHERE:    .dw EHERESTART      ; EEProm Memory Allocation
00005e d8 09     CFG_WLSCOPE: .dw XT_GET_CURRENT  ; default wordlist scope
000060 7e 00     CFG_FORTHRECOGNIZER: .dw CFG_RECOGNIZERLISTLEN ; Recognizer word set
                 ; LEAVE stack is between data stack and return stack.
000062 b0 0a     CFG_LP0:     .dw stackstart+1
000064 d2 0a     CFG_TURNKEY: .dw XT_APPLTURNKEY    ; TURNKEY
000066 ed 02     CFG_ENVIRONMENT:.dw VE_ENVHEAD     ; environmental queries
000068 6a 00     CFG_CURRENT: .dw CFG_FORTHWORDLIST ; forth-wordlist
00006a bb 3f     CFG_FORTHWORDLIST:.dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
00006c 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
00006e 6a 00         .dw CFG_FORTHWORDLIST      ; get/set-order
000070               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
00007e 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
000080 6b 06         .dw XT_REC_FIND
000082 57 06         .dw XT_REC_NUM
000084               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_STOREI:
000088 73 3b         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
00008a 8a 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
00008c 00 00         .dw 0  ; USER_STATE
00008e 00 00         .dw 0  ; USER_FOLLOWER
000090 ff 0a         .dw rstackstart  ; USER_RP
000092 af 0a         .dw stackstart   ; USER_SP0
000094 af 0a         .dw stackstart   ; USER_SP
                     
000096 00 00         .dw 0  ; USER_HANDLER
000098 0a 00         .dw 10 ; USER_BASE
                     
00009a c5 00         .dw XT_TX  ; USER_EMIT
00009c d3 00         .dw XT_TXQ ; USER_EMITQ
00009e 9a 00         .dw XT_RX  ; USER_KEY
0000a0 b5 00         .dw XT_RXQ ; USER_KEYQ
0000a2 65 02         .dw XT_SOURCETIB ; USER_SOURCE
0000a4 00 00         .dw 0            ; USER_G_IN
0000a6 52 02         .dw XT_REFILLTIB ; USER_REFILL  
0000a8 a9 3c         .dw XT_DEFAULT_PROMPTOK
0000aa c8 3c         .dw XT_DEFAULT_PROMPTERROR
0000ac b8 3c         .dw XT_DEFAULT_PROMPTREADY
0000ae e3 3c         .dw XT_DEFAULT_PROMPTINPUT
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
0000b0 19 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega32U4" register use summary:
r0 :  25 r1 :   5 r2 :  10 r3 :  12 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   7 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  78 r17:  57 r18:  52 r19:  37 r20:  13 r21:  11 r22:  11 r23:   3 
r24: 187 r25: 132 r26:  28 r27:  17 r28:   7 r29:   4 r30:  78 r31:  40 
x  :   4 y  : 201 z  :  41 
Registers used: 29 out of 35 (82.9%)

"ATmega32U4" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  22 add   :  17 adiw  :  17 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   2 brcs  :   1 break :   0 breq  :   7 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  13 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   0 cbr   :   0 
clc   :   1 clh   :   0 cli   :   5 cln   :   0 clr   :  13 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  14 cp    :  11 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :  10 eor   :   3 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :  14 inc   :   3 jmp   :  12 
ld    : 134 ldd   :   4 ldi   :  27 lds   :   1 lpm   :  16 lsl   :  14 
lsr   :   2 mov   :  15 movw  :  66 mul   :   5 muls  :   1 mulsu :   2 
neg   :   0 nop   :   0 or    :   9 ori   :   1 out   :  16 pop   :  45 
push  :  39 rcall :  55 ret   :   6 reti  :   1 rjmp  :  99 rol   :  23 
ror   :   5 sbc   :   9 sbci  :   3 sbi   :   3 sbic  :   3 sbis  :   0 
sbiw  :   7 sbr   :   0 sbrc  :   4 sbrs  :   3 sec   :   1 seh   :   0 
sei   :   1 sen   :   0 ser   :   3 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   2 st    :  74 std   :   8 sts   :   1 
sub   :   6 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 
Instructions used: 71 out of 113 (62.8%)

"ATmega32U4" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x007f82   1882  11544  13426   32768  41.0%
[.dseg] 0x000100 0x0001d5      0    213    213    2560   8.3%
[.eseg] 0x000000 0x0000b2      0    178    178    1024  17.4%

Assembly complete, 0 errors, 8 warnings
