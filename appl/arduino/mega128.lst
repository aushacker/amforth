
AVRASM ver. 2.1.52  mega128.asm Sun Oct 18 18:22:40 2020

mega128.asm(5): Including file '../../avr8\preamble.inc'
../../avr8\preamble.inc(2): Including file '../../avr8\macros.asm'
../../avr8\macros.asm(6): Including file '../../avr8\user.inc'
../../avr8\preamble.inc(6): Including file '../../avr8/devices/atmega1280\device.asm'
../../avr8/devices/atmega1280\device.asm(5): Including file '../../avr8/Atmel/Appnotes2\m1280def.inc'
mega128.asm(10): Including file '../../avr8\drivers/usart_0.asm'
../../avr8\drivers/usart_0.asm(32): Including file '../../avr8\drivers/usart_common.asm'
../../avr8\drivers/usart_common.asm(11): Including file '../../avr8\drivers/usart-rx-buffer.asm'
../../avr8\drivers/usart_common.asm(24): Including file '../../avr8\words/usart-tx-poll.asm'
../../avr8\drivers/usart_common.asm(29): Including file '../../avr8\words/ubrr.asm'
../../avr8\drivers/usart_common.asm(30): Including file '../../avr8\words/usart.asm'
mega128.asm(15): Including file '../../avr8\drivers/1wire.asm'
mega128.asm(18): Including file '../../avr8\amforth.asm'
../../avr8\amforth.asm(12): Including file '../../avr8\drivers/generic-isr.asm'
../../avr8\amforth.asm(14): Including file '../../avr8\dict/rww.inc'
../../avr8\dict/rww.inc(1): Including file '../../avr8\words/mplus.asm'
../../avr8\dict/rww.inc(2): Including file '../../common\words/ud-star.asm'
../../avr8\dict/rww.inc(3): Including file '../../common\words/umax.asm'
../../avr8\dict/rww.inc(4): Including file '../../common\words/umin.asm'
../../avr8\dict/rww.inc(5): Including file '../../avr8\words/immediate-q.asm'
../../avr8\dict/rww.inc(6): Including file '../../avr8\words/name2flags.asm'
../../avr8\dict/rww.inc(7): Including file '../../avr8\words/1ms.asm'
../../avr8\dict/rww.inc(10): Including file '../../avr8\dict/appl_8k.inc'
../../avr8\dict/appl_8k.inc(1): Including file '../../avr8\dict/compiler1.inc'
../../avr8\dict/compiler1.inc(2): Including file '../../avr8\words/newest.asm'
../../avr8\dict/compiler1.inc(3): Including file '../../avr8\words/latest.asm'
../../avr8\dict/compiler1.inc(4): Including file '../../common\words/do-create.asm'
../../avr8\dict/compiler1.inc(5): Including file '../../common\words/backslash.asm'
../../avr8\dict/compiler1.inc(6): Including file '../../common\words/l-paren.asm'
../../avr8\dict/compiler1.inc(8): Including file '../../common\words/compile.asm'
../../avr8\dict/compiler1.inc(9): Including file '../../avr8\words/comma.asm'
../../avr8\dict/compiler1.inc(10): Including file '../../common\words/brackettick.asm'
../../avr8\dict/compiler1.inc(13): Including file '../../common\words/literal.asm'
../../avr8\dict/compiler1.inc(14): Including file '../../common\words/sliteral.asm'
../../avr8\dict/compiler1.inc(15): Including file '../../avr8\words/g-mark.asm'
../../avr8\dict/compiler1.inc(16): Including file '../../avr8\words/g-resolve.asm'
../../avr8\dict/compiler1.inc(17): Including file '../../avr8\words/l_mark.asm'
../../avr8\dict/compiler1.inc(18): Including file '../../avr8\words/l_resolve.asm'
../../avr8\dict/compiler1.inc(20): Including file '../../common\words/ahead.asm'
../../avr8\dict/compiler1.inc(21): Including file '../../common\words/if.asm'
../../avr8\dict/compiler1.inc(22): Including file '../../common\words/else.asm'
../../avr8\dict/compiler1.inc(23): Including file '../../common\words/then.asm'
../../avr8\dict/compiler1.inc(24): Including file '../../common\words/begin.asm'
../../avr8\dict/compiler1.inc(25): Including file '../../common\words/while.asm'
../../avr8\dict/compiler1.inc(26): Including file '../../common\words/repeat.asm'
../../avr8\dict/compiler1.inc(27): Including file '../../common\words/until.asm'
../../avr8\dict/compiler1.inc(28): Including file '../../common\words/again.asm'
../../avr8\dict/compiler1.inc(29): Including file '../../common\words/do.asm'
../../avr8\dict/compiler1.inc(30): Including file '../../common\words/loop.asm'
../../avr8\dict/compiler1.inc(31): Including file '../../common\words/plusloop.asm'
../../avr8\dict/compiler1.inc(32): Including file '../../common\words/leave.asm'
../../avr8\dict/compiler1.inc(33): Including file '../../common\words/qdo.asm'
../../avr8\dict/compiler1.inc(34): Including file '../../common\words/endloop.asm'
../../avr8\dict/compiler1.inc(36): Including file '../../common\words/l-from.asm'
../../avr8\dict/compiler1.inc(37): Including file '../../common\words/to-l.asm'
../../avr8\dict/compiler1.inc(38): Including file '../../avr8\words/lp0.asm'
../../avr8\dict/compiler1.inc(39): Including file '../../avr8\words/lp.asm'
../../avr8\dict/compiler1.inc(41): Including file '../../common\words/create.asm'
../../avr8\dict/compiler1.inc(42): Including file '../../avr8\words/header.asm'
../../avr8\dict/compiler1.inc(43): Including file '../../avr8\words/wlscope.asm'
../../avr8\dict/compiler1.inc(44): Including file '../../common\words/reveal.asm'
../../avr8\dict/compiler1.inc(45): Including file '../../avr8\words/does.asm'
../../avr8\dict/compiler1.inc(46): Including file '../../common\words/colon.asm'
../../avr8\dict/compiler1.inc(47): Including file '../../avr8\words/colon-noname.asm'
../../avr8\dict/compiler1.inc(48): Including file '../../common\words/semicolon.asm'
../../avr8\dict/compiler1.inc(49): Including file '../../common\words/right-bracket.asm'
../../avr8\dict/compiler1.inc(50): Including file '../../common\words/left-bracket.asm'
../../avr8\dict/compiler1.inc(51): Including file '../../common\words/variable.asm'
../../avr8\dict/compiler1.inc(52): Including file '../../common\words/constant.asm'
../../avr8\dict/compiler1.inc(53): Including file '../../avr8\words/user.asm'
../../avr8\dict/compiler1.inc(55): Including file '../../common\words/recurse.asm'
../../avr8\dict/compiler1.inc(56): Including file '../../avr8\words/immediate.asm'
../../avr8\dict/compiler1.inc(58): Including file '../../common\words/bracketchar.asm'
../../avr8\dict/compiler1.inc(59): Including file '../../common\words/abort-string.asm'
../../avr8\dict/compiler1.inc(60): Including file '../../common\words/abort.asm'
../../avr8\dict/compiler1.inc(61): Including file '../../common\words/q-abort.asm'
../../avr8\dict/compiler1.inc(63): Including file '../../common\words/get-stack.asm'
../../avr8\dict/compiler1.inc(64): Including file '../../common\words/set-stack.asm'
../../avr8\dict/compiler1.inc(65): Including file '../../common\words/map-stack.asm'
../../avr8\dict/compiler1.inc(66): Including file '../../avr8\words/get-current.asm'
../../avr8\dict/compiler1.inc(67): Including file '../../common\words/cfg-order.asm'
../../avr8\dict/compiler1.inc(68): Including file '../../common\words/cfg-recognizer.asm'
../../avr8\dict/compiler1.inc(69): Including file '../../avr8\words/compare.asm'
../../avr8\dict/compiler1.inc(70): Including file '../../avr8\words/nfa2lfa.asm'
../../avr8\amforth.asm(15): Including file 'dict_appl.inc'
dict_appl.inc(4): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/compiler2.inc(8): Including file '../../avr8\words/set-current.asm'
../../avr8\dict/compiler2.inc(9): Including file '../../avr8\words/wordlist.asm'
../../avr8\dict/compiler2.inc(11): Including file '../../avr8\words/forth-wordlist.asm'
../../avr8\dict/compiler2.inc(12): Including file '../../avr8\words/code.asm'
../../avr8\dict/compiler2.inc(13): Including file '../../avr8\words/end-code.asm'
../../avr8\dict/compiler2.inc(14): Including file '../../avr8\words/marker.asm'
../../avr8\dict/compiler2.inc(15): Including file '../../common\words/postpone.asm'
dict_appl.inc(6): Including file 'words/applturnkey.asm'
../../avr8\amforth.asm(23): Including file '../../avr8\amforth-interpreter.asm'
../../avr8\amforth.asm(24): Including file '../../avr8\dict/nrww.inc'
../../avr8\dict/nrww.inc(4): Including file '../../avr8\words/exit.asm'
../../avr8\dict/nrww.inc(5): Including file '../../avr8\words/execute.asm'
../../avr8\dict/nrww.inc(6): Including file '../../avr8\words/dobranch.asm'
../../avr8\dict/nrww.inc(7): Including file '../../avr8\words/docondbranch.asm'
../../avr8\dict/nrww.inc(10): Including file '../../avr8\words/doliteral.asm'
../../avr8\dict/nrww.inc(11): Including file '../../avr8\words/dovariable.asm'
../../avr8\dict/nrww.inc(12): Including file '../../avr8\words/doconstant.asm'
../../avr8\dict/nrww.inc(13): Including file '../../avr8\words/douser.asm'
../../avr8\dict/nrww.inc(14): Including file '../../avr8\words/do-value.asm'
../../avr8\dict/nrww.inc(15): Including file '../../avr8\words/fetch.asm'
../../avr8\dict/nrww.inc(16): Including file '../../avr8\words/store.asm'
../../avr8\dict/nrww.inc(17): Including file '../../avr8\words/cstore.asm'
../../avr8\dict/nrww.inc(18): Including file '../../avr8\words/cfetch.asm'
../../avr8\dict/nrww.inc(19): Including file '../../avr8\words/fetch-u.asm'
../../avr8\dict/nrww.inc(20): Including file '../../avr8\words/store-u.asm'
../../avr8\dict/nrww.inc(23): Including file '../../avr8\words/dup.asm'
../../avr8\dict/nrww.inc(24): Including file '../../avr8\words/qdup.asm'
../../avr8\dict/nrww.inc(25): Including file '../../avr8\words/swap.asm'
../../avr8\dict/nrww.inc(26): Including file '../../avr8\words/over.asm'
../../avr8\dict/nrww.inc(27): Including file '../../avr8\words/drop.asm'
../../avr8\dict/nrww.inc(28): Including file '../../avr8\words/rot.asm'
../../avr8\dict/nrww.inc(29): Including file '../../avr8\words/nip.asm'
../../avr8\dict/nrww.inc(31): Including file '../../avr8\words/r_from.asm'
../../avr8\dict/nrww.inc(32): Including file '../../avr8\words/to_r.asm'
../../avr8\dict/nrww.inc(33): Including file '../../avr8\words/r_fetch.asm'
../../avr8\dict/nrww.inc(35): Including file '../../common\words/not-equal.asm'
../../avr8\dict/nrww.inc(36): Including file '../../avr8\words/equalzero.asm'
../../avr8\dict/nrww.inc(37): Including file '../../avr8\words/lesszero.asm'
../../avr8\dict/nrww.inc(38): Including file '../../avr8\words/greaterzero.asm'
../../avr8\dict/nrww.inc(39): Including file '../../avr8\words/d-greaterzero.asm'
../../avr8\dict/nrww.inc(40): Including file '../../avr8\words/d-lesszero.asm'
../../avr8\dict/nrww.inc(42): Including file '../../avr8\words/true.asm'
../../avr8\dict/nrww.inc(43): Including file '../../avr8\words/zero.asm'
../../avr8\dict/nrww.inc(44): Including file '../../avr8\words/uless.asm'
../../avr8\dict/nrww.inc(45): Including file '../../common\words/u-greater.asm'
../../avr8\dict/nrww.inc(46): Including file '../../avr8\words/less.asm'
../../avr8\dict/nrww.inc(47): Including file '../../avr8\words/greater.asm'
../../avr8\dict/nrww.inc(49): Including file '../../avr8\words/log2.asm'
../../avr8\dict/nrww.inc(50): Including file '../../avr8\words/minus.asm'
../../avr8\dict/nrww.inc(51): Including file '../../avr8\words/plus.asm'
../../avr8\dict/nrww.inc(52): Including file '../../avr8\words/mstar.asm'
../../avr8\dict/nrww.inc(53): Including file '../../avr8\words/umslashmod.asm'
../../avr8\dict/nrww.inc(54): Including file '../../avr8\words/umstar.asm'
../../avr8\dict/nrww.inc(56): Including file '../../avr8\words/invert.asm'
../../avr8\dict/nrww.inc(57): Including file '../../avr8\words/2slash.asm'
../../avr8\dict/nrww.inc(58): Including file '../../avr8\words/2star.asm'
../../avr8\dict/nrww.inc(59): Including file '../../avr8\words/and.asm'
../../avr8\dict/nrww.inc(60): Including file '../../avr8\words/or.asm'
../../avr8\dict/nrww.inc(61): Including file '../../avr8\words/xor.asm'
../../avr8\dict/nrww.inc(63): Including file '../../avr8\words/1plus.asm'
../../avr8\dict/nrww.inc(64): Including file '../../avr8\words/1minus.asm'
../../avr8\dict/nrww.inc(65): Including file '../../common\words/q-negate.asm'
../../avr8\dict/nrww.inc(66): Including file '../../avr8\words/lshift.asm'
../../avr8\dict/nrww.inc(67): Including file '../../avr8\words/rshift.asm'
../../avr8\dict/nrww.inc(68): Including file '../../avr8\words/plusstore.asm'
../../avr8\dict/nrww.inc(70): Including file '../../avr8\words/rpfetch.asm'
../../avr8\dict/nrww.inc(71): Including file '../../avr8\words/rpstore.asm'
../../avr8\dict/nrww.inc(72): Including file '../../avr8\words/spfetch.asm'
../../avr8\dict/nrww.inc(73): Including file '../../avr8\words/spstore.asm'
../../avr8\dict/nrww.inc(75): Including file '../../avr8\words/dodo.asm'
../../avr8\dict/nrww.inc(76): Including file '../../avr8\words/i.asm'
../../avr8\dict/nrww.inc(77): Including file '../../avr8\words/doplusloop.asm'
../../avr8\dict/nrww.inc(78): Including file '../../avr8\words/doloop.asm'
../../avr8\dict/nrww.inc(79): Including file '../../avr8\words/unloop.asm'
../../avr8\dict/nrww.inc(83): Including file '../../avr8\words/cmove_g.asm'
../../avr8\dict/nrww.inc(84): Including file '../../avr8\words/byteswap.asm'
../../avr8\dict/nrww.inc(85): Including file '../../avr8\words/up.asm'
../../avr8\dict/nrww.inc(86): Including file '../../avr8\words/2to_r.asm'
../../avr8\dict/nrww.inc(87): Including file '../../avr8\words/2r_from.asm'
../../avr8\dict/nrww.inc(89): Including file '../../avr8\words/store-e.asm'
../../avr8\dict/nrww.inc(90): Including file '../../avr8\words/fetch-e.asm'
../../avr8\dict/nrww.inc(91): Including file '../../avr8\words/store-i.asm'
../../avr8\dict/nrww.inc(95): Including file '../../avr8\words/store-i_nrww.asm'
../../avr8\dict/nrww.inc(97): Including file '../../avr8\words/fetch-i.asm'
../../avr8\dict/nrww.inc(98): Including file '../../common\words/2literal.asm'
../../avr8\dict/nrww.inc(99): Including file '../../avr8\words/equal.asm'
../../avr8\dict/nrww.inc(100): Including file '../../common\words/num-constants.asm'
../../avr8\dict/nrww.inc(103): Including file '../../avr8\dict/core_8k.inc'
../../avr8\dict/core_8k.inc(2): Including file '../../avr8\words/n_to_r.asm'
../../avr8\dict/core_8k.inc(3): Including file '../../avr8\words/n_r_from.asm'
../../avr8\dict/core_8k.inc(5): Including file '../../avr8\words/d-2star.asm'
../../avr8\dict/core_8k.inc(6): Including file '../../avr8\words/d-2slash.asm'
../../avr8\dict/core_8k.inc(7): Including file '../../avr8\words/d-plus.asm'
../../avr8\dict/core_8k.inc(8): Including file '../../avr8\words/d-minus.asm'
../../avr8\dict/core_8k.inc(9): Including file '../../avr8\words/d-invert.asm'
../../avr8\dict/core_8k.inc(10): Including file '../../common\words/u-dot.asm'
../../avr8\dict/core_8k.inc(11): Including file '../../common\words/u-dot-r.asm'
../../avr8\dict/core_8k.inc(13): Including file '../../common\words/show-wordlist.asm'
../../avr8\dict/core_8k.inc(14): Including file '../../common\words/words.asm'
../../avr8\dict/core_8k.inc(17): Including file '../../common\words/pick.asm'
../../avr8\dict/core_8k.inc(18): Including file '../../common\words/dot-quote.asm'
../../avr8\dict/core_8k.inc(19): Including file '../../common\words/squote.asm'
../../avr8\dict/core_8k.inc(21): Including file '../../avr8\words/fill.asm'
../../avr8\dict/core_8k.inc(23): Including file '../../avr8\words/environment.asm'
../../avr8\dict/core_8k.inc(24): Including file '../../avr8\words/env-wordlists.asm'
../../avr8\dict/core_8k.inc(25): Including file '../../avr8\words/env-slashpad.asm'
../../avr8\dict/core_8k.inc(26): Including file '../../common\words/env-slashhold.asm'
../../avr8\dict/core_8k.inc(27): Including file '../../common\words/env-forthname.asm'
../../avr8\dict/core_8k.inc(28): Including file '../../common\words/env-forthversion.asm'
../../avr8\dict/core_8k.inc(29): Including file '../../common\words/env-cpu.asm'
../../avr8\dict/core_8k.inc(30): Including file '../../avr8\words/env-mcuinfo.asm'
../../avr8\dict/core_8k.inc(31): Including file '../../common\words/env-usersize.asm'
../../avr8\dict/core_8k.inc(33): Including file '../../common\words/f_cpu.asm'
../../avr8\dict/core_8k.inc(34): Including file '../../avr8\words/state.asm'
../../avr8\dict/core_8k.inc(35): Including file '../../common\words/base.asm'
../../avr8\dict/core_8k.inc(37): Including file '../../avr8\words/cells.asm'
../../avr8\dict/core_8k.inc(38): Including file '../../avr8\words/cellplus.asm'
../../avr8\dict/core_8k.inc(40): Including file '../../common\words/2dup.asm'
../../avr8\dict/core_8k.inc(41): Including file '../../common\words/2drop.asm'
../../avr8\dict/core_8k.inc(43): Including file '../../common\words/tuck.asm'
../../avr8\dict/core_8k.inc(45): Including file '../../common\words/to-in.asm'
../../avr8\dict/core_8k.inc(46): Including file '../../common\words/pad.asm'
../../avr8\dict/core_8k.inc(47): Including file '../../common\words/emit.asm'
../../avr8\dict/core_8k.inc(48): Including file '../../common\words/emitq.asm'
../../avr8\dict/core_8k.inc(49): Including file '../../common\words/key.asm'
../../avr8\dict/core_8k.inc(50): Including file '../../common\words/keyq.asm'
../../avr8\dict/core_8k.inc(52): Including file '../../avr8\words/dp.asm'
../../avr8\dict/core_8k.inc(53): Including file '../../avr8\words/ehere.asm'
../../avr8\dict/core_8k.inc(54): Including file '../../avr8\words/here.asm'
../../avr8\dict/core_8k.inc(55): Including file '../../avr8\words/allot.asm'
../../avr8\dict/core_8k.inc(57): Including file '../../common\words/bin.asm'
../../avr8\dict/core_8k.inc(58): Including file '../../common\words/decimal.asm'
../../avr8\dict/core_8k.inc(59): Including file '../../common\words/hex.asm'
../../avr8\dict/core_8k.inc(60): Including file '../../common\words/bl.asm'
../../avr8\dict/core_8k.inc(62): Including file '../../avr8\words/turnkey.asm'
../../avr8\dict/core_8k.inc(64): Including file '../../avr8\words/slashmod.asm'
../../avr8\dict/core_8k.inc(65): Including file '../../avr8\words/uslashmod.asm'
../../avr8\dict/core_8k.inc(66): Including file '../../avr8\words/negate.asm'
../../avr8\dict/core_8k.inc(67): Including file '../../common\words/slash.asm'
../../avr8\dict/core_8k.inc(68): Including file '../../common\words/mod.asm'
../../avr8\dict/core_8k.inc(69): Including file '../../common\words/abs.asm'
../../avr8\dict/core_8k.inc(70): Including file '../../common\words/min.asm'
../../avr8\dict/core_8k.inc(71): Including file '../../common\words/max.asm'
../../avr8\dict/core_8k.inc(72): Including file '../../common\words/within.asm'
../../avr8\dict/core_8k.inc(74): Including file '../../common\words/to-upper.asm'
../../avr8\dict/core_8k.inc(75): Including file '../../common\words/to-lower.asm'
../../avr8\dict/core_8k.inc(77): Including file '../../avr8\words/hld.asm'
../../avr8\dict/core_8k.inc(78): Including file '../../common\words/hold.asm'
../../avr8\dict/core_8k.inc(79): Including file '../../common\words/less-sharp.asm'
../../avr8\dict/core_8k.inc(80): Including file '../../common\words/sharp.asm'
../../avr8\dict/core_8k.inc(81): Including file '../../common\words/sharp-s.asm'
../../avr8\dict/core_8k.inc(82): Including file '../../common\words/sharp-greater.asm'
../../avr8\dict/core_8k.inc(83): Including file '../../common\words/sign.asm'
../../avr8\dict/core_8k.inc(84): Including file '../../common\words/d-dot-r.asm'
../../avr8\dict/core_8k.inc(85): Including file '../../common\words/dot-r.asm'
../../avr8\dict/core_8k.inc(86): Including file '../../common\words/d-dot.asm'
../../avr8\dict/core_8k.inc(87): Including file '../../common\words/dot.asm'
../../avr8\dict/core_8k.inc(88): Including file '../../common\words/ud-dot.asm'
../../avr8\dict/core_8k.inc(89): Including file '../../common\words/ud-dot-r.asm'
../../avr8\dict/core_8k.inc(90): Including file '../../common\words/ud-slash-mod.asm'
../../avr8\dict/core_8k.inc(91): Including file '../../common\words/digit-q.asm'
../../avr8\dict/core_8k.inc(93): Including file '../../avr8\words/do-sliteral.asm'
../../avr8\dict/core_8k.inc(94): Including file '../../avr8\words/scomma.asm'
../../avr8\dict/core_8k.inc(95): Including file '../../avr8\words/itype.asm'
../../avr8\dict/core_8k.inc(96): Including file '../../avr8\words/icount.asm'
../../avr8\dict/core_8k.inc(97): Including file '../../common\words/cr.asm'
../../avr8\dict/core_8k.inc(98): Including file '../../common\words/space.asm'
../../avr8\dict/core_8k.inc(99): Including file '../../common\words/spaces.asm'
../../avr8\dict/core_8k.inc(100): Including file '../../common\words/type.asm'
../../avr8\dict/core_8k.inc(101): Including file '../../common\words/tick.asm'
../../avr8\dict/core_8k.inc(103): Including file '../../common\words/handler.asm'
../../avr8\dict/core_8k.inc(104): Including file '../../common\words/catch.asm'
../../avr8\dict/core_8k.inc(105): Including file '../../common\words/throw.asm'
../../avr8\dict/core_8k.inc(107): Including file '../../common\words/cskip.asm'
../../avr8\dict/core_8k.inc(108): Including file '../../common\words/cscan.asm'
../../avr8\dict/core_8k.inc(109): Including file '../../common\words/accept.asm'
../../avr8\dict/core_8k.inc(110): Including file '../../common\words/refill.asm'
../../avr8\dict/core_8k.inc(111): Including file '../../common\words/char.asm'
../../avr8\dict/core_8k.inc(112): Including file '../../common\words/number.asm'
../../avr8\dict/core_8k.inc(113): Including file '../../common\words/q-sign.asm'
../../avr8\dict/core_8k.inc(114): Including file '../../common\words/set-base.asm'
../../avr8\dict/core_8k.inc(115): Including file '../../common\words/to-number.asm'
../../avr8\dict/core_8k.inc(116): Including file '../../common\words/parse.asm'
../../avr8\dict/core_8k.inc(117): Including file '../../common\words/source.asm'
../../avr8\dict/core_8k.inc(118): Including file '../../common\words/slash-string.asm'
../../avr8\dict/core_8k.inc(119): Including file '../../common\words/parse-name.asm'
../../avr8\dict/core_8k.inc(120): Including file '../../common\words/find-xt.asm'
../../avr8\dict/core_8k.inc(122): Including file '../../common\words/prompt-ok.asm'
../../avr8\dict/core_8k.inc(123): Including file '../../common\words/prompt-ready.asm'
../../avr8\dict/core_8k.inc(124): Including file '../../common\words/prompt-error.asm'
../../avr8\dict/core_8k.inc(125): Including file '../../common\words/prompt-input.asm'
../../avr8\dict/core_8k.inc(126): Including file '../../common\words/quit.asm'
../../avr8\dict/core_8k.inc(127): Including file '../../avr8\words/pause.asm'
../../avr8\dict/core_8k.inc(128): Including file '../../avr8\words/cold.asm'
../../avr8\dict/core_8k.inc(129): Including file '../../common\words/warm.asm'
../../avr8\dict/core_8k.inc(131): Including file '../../avr8\words/sp0.asm'
../../avr8\dict/core_8k.inc(132): Including file '../../avr8\words/rp0.asm'
../../avr8\dict/core_8k.inc(133): Including file '../../common\words/depth.asm'
../../avr8\dict/core_8k.inc(134): Including file '../../common\words/interpret.asm'
../../avr8\dict/core_8k.inc(135): Including file '../../avr8\words/forth-recognizer.asm'
../../avr8\dict/core_8k.inc(136): Including file '../../common\words/recognize.asm'
../../avr8\dict/core_8k.inc(137): Including file '../../common\words/rec-intnum.asm'
../../avr8\dict/core_8k.inc(138): Including file '../../common\words/rec-find.asm'
../../avr8\dict/core_8k.inc(139): Including file '../../common\words/rec-null.asm'
../../avr8\dict/core_8k.inc(141): Including file '../../common\words/q-stack.asm'
../../avr8\dict/core_8k.inc(142): Including file '../../common\words/ver.asm'
../../avr8\dict/core_8k.inc(144): Including file '../../common\words/noop.asm'
../../avr8\dict/core_8k.inc(145): Including file '../../avr8\words/unused.asm'
../../avr8\dict/core_8k.inc(147): Including file '../../common\words/to.asm'
../../avr8\dict/core_8k.inc(148): Including file '../../avr8\words/i-cellplus.asm'
../../avr8\dict/core_8k.inc(150): Including file '../../avr8\words/edefer-fetch.asm'
../../avr8\dict/core_8k.inc(151): Including file '../../avr8\words/edefer-store.asm'
../../avr8\dict/core_8k.inc(152): Including file '../../common\words/rdefer-fetch.asm'
../../avr8\dict/core_8k.inc(153): Including file '../../common\words/rdefer-store.asm'
../../avr8\dict/core_8k.inc(154): Including file '../../common\words/udefer-fetch.asm'
../../avr8\dict/core_8k.inc(155): Including file '../../common\words/udefer-store.asm'
../../avr8\dict/core_8k.inc(156): Including file '../../common\words/defer-store.asm'
../../avr8\dict/core_8k.inc(157): Including file '../../common\words/defer-fetch.asm'
../../avr8\dict/core_8k.inc(158): Including file '../../avr8\words/do-defer.asm'
../../avr8\dict/core_8k.inc(160): Including file '../../common\words/search-wordlist.asm'
../../avr8\dict/core_8k.inc(161): Including file '../../common\words/traverse-wordlist.asm'
../../avr8\dict/core_8k.inc(162): Including file '../../common\words/name2string.asm'
../../avr8\dict/core_8k.inc(163): Including file '../../avr8\words/nfa2cfa.asm'
../../avr8\dict/core_8k.inc(164): Including file '../../avr8\words/icompare.asm'
../../avr8\dict/core_8k.inc(166): Including file '../../common\words/star.asm'
../../avr8\dict/core_8k.inc(167): Including file '../../avr8\words/j.asm'
../../avr8\dict/core_8k.inc(169): Including file '../../avr8\words/dabs.asm'
../../avr8\dict/core_8k.inc(170): Including file '../../avr8\words/dnegate.asm'
../../avr8\dict/core_8k.inc(171): Including file '../../avr8\words/cmove.asm'
../../avr8\dict/core_8k.inc(172): Including file '../../common\words/2swap.asm'
../../avr8\dict/core_8k.inc(174): Including file '../../common\words/tib.asm'
../../avr8\dict/core_8k.inc(176): Including file '../../avr8\words/init-ram.asm'
../../avr8\dict/core_8k.inc(178): Including file '../../common\words/bounds.asm'
../../avr8\dict/core_8k.inc(179): Including file '../../common\words/s-to-d.asm'
../../avr8\dict/core_8k.inc(180): Including file '../../avr8\words/to-body.asm'
../../avr8\dict/core_8k.inc(182): Including file '../../avr8\dict/compiler2.inc'
../../avr8\dict/core_8k.inc(183): Including file '../../avr8\dict/interrupt.inc'
../../avr8\dict/interrupt.inc(5): Including file '../../avr8\words/irqcnt.asm'
../../avr8\dict/interrupt.inc(6): Including file '../../avr8\words/int-num.asm'
../../avr8\dict/interrupt.inc(9): Including file '../../avr8\words/int-on.asm'
../../avr8\dict/interrupt.inc(10): Including file '../../avr8\words/int-off.asm'
../../avr8\dict/interrupt.inc(11): Including file '../../avr8\words/int-store.asm'
../../avr8\dict/interrupt.inc(12): Including file '../../avr8\words/int-fetch.asm'
../../avr8\dict/interrupt.inc(13): Including file '../../avr8\words/int-trap.asm'
../../avr8\dict/interrupt.inc(15): Including file '../../avr8\words/isr-exec.asm'
../../avr8\dict/interrupt.inc(16): Including file '../../avr8\words/isr-end.asm'
../../avr8\amforth.asm(25): Including file 'dict_appl_core.inc'
../../avr8\amforth.asm(36): Including file '../../avr8\amforth-eeprom.inc'
                 
                 
                 ; file see ../template/template.asm. You may want to
                 ; copy that file to this one and edit it afterwards.
                 
                 .include "preamble.inc"
                 
                 .include "macros.asm"
                 
                 .set DICT_COMPILER2 = 0 ;
                 .set cpu_msp430 = 0
                 .set cpu_avr8   = 1
                 
                 .include "user.inc"
                 
                 ; 
                 
                 ; used by the multitasker
                 .set USER_STATE    = 0
                 .set USER_FOLLOWER = 2
                 
                 ; stackpointer, used by mulitasker
                 .set USER_RP      = 4
                 .set USER_SP0     = 6
                 .set USER_SP      = 8
                 
                 ; excpection handling
                 .set USER_HANDLER = 10
                 
                 ; numeric IO
                 .set USER_BASE  = 12
                 
                 ; character IO 
                 .set USER_EMIT  = 14
                 .set USER_EMITQ = 16
                 .set USER_KEY   = 18
                 .set USER_KEYQ  = 20
                 
                 .set USER_SOURCE  = 22
                 .set USER_TO_IN   = 24
                 .set USER_REFILL  = 26
                 
                 .set USER_P_OK    = 28
                 .set USER_P_ERR   = 30
                 .set USER_P_RDY   = 32
                 .set USER_P_INPUT = 34
                 
                 .set SYSUSERSIZE = 36
                 ; 
                 
                   .def zerol = r2
                   .def zeroh = r3
                   .def upl = r4
                   .def uph = r5
                 
                   .def al  = r6
                   .def ah  = r7
                   .def bl  = r8
                   .def bh  = r9
                 
                 ; internal
                   .def mcu_boot = r10
                   .def isrflag  = r11
                 
                   .def temp4 = r14
                   .def temp5 = r15
                 
                   .def temp0 = r16
                   .def temp1 = r17
                   .def temp2 = r18
                   .def temp3 = r19
                 
                   .def temp6 = r20
                   .def temp7 = r21
                 
                   .def tosl = r24
                   .def tosh = r25
                 
                   .def wl = r22
                   .def wh = r23
                 
                 .macro loadtos
                     ld tosl, Y+
                     ld tosh, Y+
                 .endmacro
                 
                 .macro savetos
                     st -Y, tosh
                     st -Y, tosl
                 .endmacro
                 
                 .macro in_
                 .if (@1 < $40)
                   in @0,@1
                 .else
                   lds @0,@1
                 .endif
                 .endmacro
                 
                 .macro out_
                 .if (@0 < $40)
                   out @0,@1
                 .else
                   sts @0,@1
                 .endif
                 .endmacro
                 
                 .macro sbi_
                 .if (@0 < $40)
                   sbi @0,@1
                 .else
                   in_ @2,@0
                   ori @2,exp2(@1)
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro cbi_
                 .if (@0 < $40)
                   cbi @0,@1
                 .else
                   in_ @2,@0
                   andi @2,~(exp2(@1))
                   out_ @0,@2
                 .endif
                 .endmacro
                 
                 .macro jmp_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	jmp @0
                 	.else
                 	rjmp @0
                 	.endif
                 	.else
                 	jmp @0
                 	.endif
                 .endmacro
                 .macro call_
                 	; a more flexible macro
                     .ifdef @0
                     .if (@0-pc > 2040) || (pc-@0>2040)
                 	call @0
                 	.else
                 	rcall @0
                 	.endif
                 	.else
                 	call @0
                 	.endif
                 .endmacro
                 
                 ;               F_CPU
                 ;    µsec   16000000   14745600    8000000  1000000
                 ;    1            16      14,74          8        1
                 ;    10          160     147,45         80       10
                 ;    100        1600    1474,56        800      100
                 ;    1000      16000   14745,6        8000     1000
                 ;
                 ; cycles = µsec * f_cpu / 1e6
                 ; n_loops=cycles/5
                 ;
                 ;     cycles already used will be subtracted from the delay
                 ;     the waittime resolution is 1 cycle (delay from exact to +1 cycle)
                 ;     the maximum delay at 20MHz (50ns/clock) is 38350ns
                 ;     waitcount register must specify an immediate register
                 ;
                 ; busy waits a specfied amount of microseconds
                 .macro   delay
                       .set cycles = ( ( @0 * F_CPU ) / 1000000 )
                       .if (cycles > ( 256 * 255 * 4 + 2))
                         .error "MACRO delay - too many cycles to burn"
                       .else
                         .if (cycles > 6)
                           .set  loop_cycles = (cycles / 4)      
                           ldi   zl,low(loop_cycles)
                           ldi   zh,high(loop_cycles)
                           sbiw  Z, 1
                           brne  pc-1
                           .set  cycles = (cycles - (loop_cycles * 4))
                         .endif
                         .if (cycles > 0)
                           .if   (cycles & 4)
                             rjmp  pc+1
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 2)
                             rjmp  pc+1
                           .endif
                           .if   (cycles & 1)
                             nop
                           .endif
                         .endif
                       .endif
                 .endmacro
                 
                 ; portability macros, they come from the msp430 branches
                 
                 .macro DEST
                     .dw @0
                 .endm
                 
                 ; controller specific file selected via include
                 ; directory definition when calling the assembler (-I)
                 .include "device.asm"
                 
                 ; generated automatically, do not edit
                 
                 .list
                 
                 .equ ramstart =  512
                 .equ CELLSIZE = 2
                 .macro readflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 	elpm @0, Z+
                 	elpm @1, Z+
                 .endmacro
                 .macro writeflashcell
                 	clr temp7
                 	lsl zl
                 	rol zh
                 	rol temp7
                 	out_ RAMPZ, temp7
                 .endmacro
                 .set WANT_ANALOG_COMPARATOR = 0
                 .set WANT_USART0 = 0
                 .set WANT_TWI = 0
                 .set WANT_SPI = 0
                 .set WANT_PORTA = 0
                 .set WANT_PORTB = 0
                 .set WANT_PORTC = 0
                 .set WANT_PORTD = 0
                 .set WANT_PORTE = 0
                 .set WANT_PORTF = 0
                 .set WANT_PORTG = 0
                 .set WANT_PORTH = 0
                 .set WANT_PORTJ = 0
                 .set WANT_PORTK = 0
                 .set WANT_PORTL = 0
                 .set WANT_TIMER_COUNTER_0 = 0
                 .set WANT_TIMER_COUNTER_2 = 0
                 .set WANT_WATCHDOG = 0
                 .set WANT_USART1 = 0
                 .set WANT_EEPROM = 0
                 .set WANT_TIMER_COUNTER_5 = 0
                 .set WANT_TIMER_COUNTER_4 = 0
                 .set WANT_TIMER_COUNTER_3 = 0
                 .set WANT_TIMER_COUNTER_1 = 0
                 .set WANT_JTAG = 0
                 .set WANT_EXTERNAL_INTERRUPT = 0
                 .set WANT_CPU = 0
                 .set WANT_AD_CONVERTER = 0
                 .set WANT_BOOT_LOAD = 0
                 .set WANT_USART2 = 0
                 .set WANT_USART3 = 0
                 .equ intvecsize = 2 ; please verify; flash size: 131072 bytes
                 .equ pclen = 2 ; please verify
                 .overlap
                 .org 2
000002 d164      	 rcall isr ; External Interrupt Request 0
                 .org 4
000004 d162      	 rcall isr ; External Interrupt Request 1
                 .org 6
000006 d160      	 rcall isr ; External Interrupt Request 2
                 .org 8
000008 d15e      	 rcall isr ; External Interrupt Request 3
                 .org 10
00000a d15c      	 rcall isr ; External Interrupt Request 4
                 .org 12
00000c d15a      	 rcall isr ; External Interrupt Request 5
                 .org 14
00000e d158      	 rcall isr ; External Interrupt Request 6
                 .org 16
000010 d156      	 rcall isr ; External Interrupt Request 7
                 .org 18
000012 d154      	 rcall isr ; Pin Change Interrupt Request 0
                 .org 20
000014 d152      	 rcall isr ; Pin Change Interrupt Request 1
                 .org 22
000016 d150      	 rcall isr ; Pin Change Interrupt Request 2
                 .org 24
000018 d14e      	 rcall isr ; Watchdog Time-out Interrupt
                 .org 26
00001a d14c      	 rcall isr ; Timer/Counter2 Compare Match A
                 .org 28
00001c d14a      	 rcall isr ; Timer/Counter2 Compare Match B
                 .org 30
00001e d148      	 rcall isr ; Timer/Counter2 Overflow
                 .org 32
000020 d146      	 rcall isr ; Timer/Counter1 Capture Event
                 .org 34
000022 d144      	 rcall isr ; Timer/Counter1 Compare Match A
                 .org 36
000024 d142      	 rcall isr ; Timer/Counter1 Compare Match B
                 .org 38
000026 d140      	 rcall isr ; Timer/Counter1 Compare Match C
                 .org 40
000028 d13e      	 rcall isr ; Timer/Counter1 Overflow
                 .org 42
00002a d13c      	 rcall isr ; Timer/Counter0 Compare Match A
                 .org 44
00002c d13a      	 rcall isr ; Timer/Counter0 Compare Match B
                 .org 46
00002e d138      	 rcall isr ; Timer/Counter0 Overflow
                 .org 48
000030 d136      	 rcall isr ; SPI Serial Transfer Complete
                 .org 50
000032 d134      	 rcall isr ; USART0, Rx Complete
                 .org 52
000034 d132      	 rcall isr ; USART0 Data register Empty
                 .org 54
000036 d130      	 rcall isr ; USART0, Tx Complete
                 .org 56
000038 d12e      	 rcall isr ; Analog Comparator
                 .org 58
00003a d12c      	 rcall isr ; ADC Conversion Complete
                 .org 60
00003c d12a      	 rcall isr ; EEPROM Ready
                 .org 62
00003e d128      	 rcall isr ; Timer/Counter3 Capture Event
                 .org 64
000040 d126      	 rcall isr ; Timer/Counter3 Compare Match A
                 .org 66
000042 d124      	 rcall isr ; Timer/Counter3 Compare Match B
                 .org 68
000044 d122      	 rcall isr ; Timer/Counter3 Compare Match C
                 .org 70
000046 d120      	 rcall isr ; Timer/Counter3 Overflow
                 .org 72
000048 d11e      	 rcall isr ; USART1, Rx Complete
                 .org 74
00004a d11c      	 rcall isr ; USART1 Data register Empty
                 .org 76
00004c d11a      	 rcall isr ; USART1, Tx Complete
                 .org 78
00004e d118      	 rcall isr ; 2-wire Serial Interface
                 .org 80
000050 d116      	 rcall isr ; Store Program Memory Read
                 .org 82
000052 d114      	 rcall isr ; Timer/Counter4 Capture Event
                 .org 84
000054 d112      	 rcall isr ; Timer/Counter4 Compare Match A
                 .org 86
000056 d110      	 rcall isr ; Timer/Counter4 Compare Match B
                 .org 88
000058 d10e      	 rcall isr ; Timer/Counter4 Compare Match C
                 .org 90
00005a d10c      	 rcall isr ; Timer/Counter4 Overflow
                 .org 92
00005c d10a      	 rcall isr ; Timer/Counter5 Capture Event
                 .org 94
00005e d108      	 rcall isr ; Timer/Counter5 Compare Match A
                 .org 96
000060 d106      	 rcall isr ; Timer/Counter5 Compare Match B
                 .org 98
000062 d104      	 rcall isr ; Timer/Counter5 Compare Match C
                 .org 100
000064 d102      	 rcall isr ; Timer/Counter5 Overflow
                 .org 102
000066 d100      	 rcall isr ; USART2, Rx Complete
                 .org 104
000068 d0fe      	 rcall isr ; USART2 Data register Empty
                 .org 106
00006a d0fc      	 rcall isr ; USART2, Tx Complete
                 .org 108
00006c d0fa      	 rcall isr ; USART3, Rx Complete
                 .org 110
00006e d0f8      	 rcall isr ; USART3 Data register Empty
                 .org 112
000070 d0f6      	 rcall isr ; USART3, Tx Complete
                 .equ INTVECTORS = 57
                 .nooverlap
                 
                 ; compatability layer (maybe empty)
                 
                 ; controller data area, environment query mcu-info
                 mcu_info:
                 mcu_ramsize:
000071 2000      	.dw 8192
                 mcu_eepromsize:
000072 1000      	.dw 4096
                 mcu_maxdp:
000073 ffff      	.dw 65535 
                 mcu_numints:
000074 0039      	.dw 57
                 mcu_name:
000075 000a      	.dw 10
000076 5441
000077 656d
000078 6167
000079 3231
00007a 3038      	.db "ATmega1280"
                 .set codestart=pc
                 
                 ; some defaults, change them in your application master file
                 ; see template.asm for an example
                 
                 ; enabling Interrupts, disabling them affects
                 ; other settings as well. 
                 .set WANT_INTERRUPTS = 1
                 
                 ; count the number of interrupts individually.
                 ; requires a lot of RAM (one byte per interrupt)
                 ; disabled by default.
                 .set WANT_INTERRUPT_COUNTERS = 1
                 
                 ; receiving is asynchronously, so an interrupt queue is useful.
                 .set WANT_ISR_RX = 1
                 
                 ; case insensitve dictionary lookup.
                 .set WANT_IGNORECASE = 0
                 
                 ; map all memories to one address space. Details in the
                 ; technical guide
                 .set WANT_UNIFIED = 0
                 
                 ; terminal input buffer
                 .set TIB_SIZE  = 90    ; ANS94 needs at least 80 characters per line
                 
                 ; USER variables *in addition* to system ones
                 .set APPUSERSIZE = 10  ; size of application specific user area in bytes
                 
                 ; addresses of various data segments
                 .set rstackstart = RAMEND      ; start address of return stack, grows downward
                 .set stackstart  = RAMEND - 80 ; start address of data stack, grows downward
                 ; change only if you know what to you do
                 .set NUMWORDLISTS = 8 ; number of word lists in the searh order, at least 8
                 .set NUMRECOGNIZERS = 4 ; total number of recognizers, two are always used.
                 
                 ; 10 per mille (1 per cent) is ok.
                 .set BAUD = 38400
                 .set BAUD_MAXERROR = 10
                 
                 ; Dictionary setup
                 .set VE_HEAD = $0000
                 .set VE_ENVHEAD = $0000
                 
                 .set WANT_IGNORECASE = 1
                 
                 .equ F_CPU = 16000000
                 .include "drivers/usart_0.asm"
                 
                   .equ BAUDRATE_HIGH = UBRR0H
                   .equ USART_C = UCSR0C
                   .equ USART_B = UCSR0B
                   .equ USART_A = UCSR0A
                   .equ USART_DATA = UDR0
                   .ifndef URXCaddr
                   .equ URXCaddr = URXC0addr
                   .equ UDREaddr = UDRE0addr
                   .endif
                 
                 .equ bm_USART_RXRD = 1 << RXC0
                 .equ bm_USART_TXRD = 1 << UDRE0
                 .equ bm_ENABLE_TX  = 1 << TXEN0
                 .equ bm_ENABLE_RX  = 1 << RXEN0
                 .equ bm_ENABLE_INT_RX = 1<<RXCIE0
                 .equ bm_ENABLE_INT_TX = 1<<UDRIE0
                 
                 .equ bm_USARTC_en   = 0
                 .equ bm_ASYNC       = 0 << 6
                 .equ bm_SYNC        = 1 << 6
                 .equ bm_NO_PARITY   = 0 << 4
                 .equ bm_EVEN_PARITY = 2 << 4
                 .equ bm_ODD_PARITY  = 3 << 4
                 .equ bm_1STOPBIT    = 0 << 3
                 .equ bm_2STOPBIT    = 1 << 3
                 .equ bm_5BIT        = 0 << 1
                 .equ bm_6BIT        = 1 << 1
                 .equ bm_7BIT        = 2 << 1
                 .equ bm_8BIT        = 3 << 1
                 
                 .include "drivers/usart_common.asm"
                 
                 .set USART_C_VALUE = bm_ASYNC | bm_NO_PARITY | bm_1STOPBIT | bm_8BIT
                 .if WANT_INTERRUPTS == 0
                   .if WANT_ISR_RX == 1
                   .endif
                 .endif
                 
                 .if WANT_ISR_RX == 1
                   .set USART_B_VALUE = bm_ENABLE_TX | bm_ENABLE_RX | bm_ENABLE_INT_RX
                   .include "drivers/usart-rx-buffer.asm"
                 
                 
                 ; sizes have to be powers of 2!
                 .equ usart_rx_size = $10
                 .equ usart_rx_mask = usart_rx_size - 1
                 .dseg
000200            usart_rx_data: .byte usart_rx_size
000210            usart_rx_in:   .byte 1
000211            usart_rx_out:  .byte 1
                 .cseg
                 
                 VE_TO_RXBUF:
00007b ff07          .dw $ff07
00007c 723e
00007d 2d78
00007e 7562
00007f 0066          .db ">rx-buf",0
000080 0000          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_RXBUF
                 XT_TO_RXBUF:
000081 0082          .dw PFA_rx_tobuf
                 PFA_rx_tobuf:
000082 2f08          mov temp0, tosl
000083 9110 0210     lds temp1, usart_rx_in
000085 e0e0          ldi zl, low(usart_rx_data)
000086 e0f2          ldi zh, high(usart_rx_data)
000087 0fe1          add zl, temp1
000088 1df3          adc zh, zeroh
000089 8300          st Z, temp0
00008a 9513          inc temp1
00008b 701f          andi temp1,usart_rx_mask
00008c 9310 0210     sts usart_rx_in, temp1
00008e 9189
00008f 9199          loadtos
000090 940c f004     jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 ; setup with
                 ; ' isr-rx URXCaddr int!
                 VE_ISR_RX:
000092 ff06          .dw $ff06
000093 7369
000094 2d72
000095 7872          .db "isr-rx"
000096 007b          .dw VE_HEAD
                     .set VE_HEAD = VE_ISR_RX
                 XT_ISR_RX:
000097 f000          .dw DO_COLON
                 usart_rx_isr:
000098 f045        .dw XT_DOLITERAL
000099 00c6        .dw usart_data
00009a f0a9        .dw XT_CFETCH
00009b f0c2        .dw XT_DUP
00009c f045        .dw XT_DOLITERAL
00009d 0003        .dw 3
00009e f3f0        .dw XT_EQUAL
00009f f03e        .dw XT_DOCONDBRANCH
0000a0 00a2        .dw usart_rx_isr1
0000a1 fa6b        .dw XT_COLD
                 usart_rx_isr1:
0000a2 0081        .dw XT_TO_RXBUF
0000a3 f025        .dw XT_EXIT
                 
                 ; ( -- ) Hardware Access
                 ; R( --)
                 ; initialize usart
                 ;VE_USART_INIT_RXBUFFER:
                 ;  .dw $ff0x
                 ;  .db "+usart-buffer"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_USART_INIT_RXBUFFER
                 XT_USART_INIT_RX_BUFFER:
0000a4 f000        .dw DO_COLON
                 PFA_USART_INIT_RX_BUFFER:          ; ( -- )
0000a5 f045
0000a6 0097        .dw XT_DOLITERAL, XT_ISR_RX
0000a7 f045
0000a8 0032        .dw XT_DOLITERAL, URXCaddr
0000a9 fdbc        .dw XT_INTSTORE
                 
0000aa f045        .dw XT_DOLITERAL
0000ab 0200        .dw usart_rx_data
0000ac f045        .dw XT_DOLITERAL
0000ad 0016        .dw usart_rx_size + 6
0000ae f165        .dw XT_ZERO
0000af f4ca        .dw XT_FILL
0000b0 f025        .dw XT_EXIT
                 
                 ; ( -- c)
                 ; MCU
                 ; get 1 character from input queue, wait if needed using interrupt driver
                 VE_RX_BUFFER:
0000b1 ff06          .dw $ff06
0000b2 7872
0000b3 622d
0000b4 6675          .db "rx-buf"
0000b5 0092          .dw VE_HEAD
                     .set VE_HEAD = VE_RX_BUFFER
                 XT_RX_BUFFER:
0000b6 f000          .dw DO_COLON
                 PFA_RX_BUFFER:
0000b7 00d1        .dw XT_RXQ_BUFFER
0000b8 f03e        .dw XT_DOCONDBRANCH
0000b9 00b7        .dw PFA_RX_BUFFER
0000ba f045        .dw XT_DOLITERAL
0000bb 0211        .dw usart_rx_out
0000bc f0a9        .dw XT_CFETCH
0000bd f0c2        .dw XT_DUP
0000be f045        .dw XT_DOLITERAL
0000bf 0200        .dw usart_rx_data
0000c0 f1ae        .dw XT_PLUS
0000c1 f0a9        .dw XT_CFETCH
0000c2 f0d5        .dw XT_SWAP
0000c3 f240        .dw XT_1PLUS
0000c4 f045        .dw XT_DOLITERAL
0000c5 000f        .dw usart_rx_mask
0000c6 f224        .dw XT_AND
0000c7 f045        .dw XT_DOLITERAL
0000c8 0211        .dw usart_rx_out
0000c9 f09e        .dw XT_CSTORE
0000ca f025        .dw XT_EXIT
                 
                 ; ( -- f)  
                 ; MCU
                 ; check if unread characters are in the input queue
                 VE_RXQ_BUFFER:
0000cb ff07          .dw $ff07
0000cc 7872
0000cd 2d3f
0000ce 7562
0000cf 0066          .db "rx?-buf",0
0000d0 00b1          .dw VE_HEAD
                     .set VE_HEAD = VE_RXQ_BUFFER
                 XT_RXQ_BUFFER:
0000d1 f000          .dw DO_COLON
                 PFA_RXQ_BUFFER:
0000d2 fa63        .dw XT_PAUSE
0000d3 f045        .dw XT_DOLITERAL
0000d4 0211        .dw usart_rx_out
0000d5 f0a9        .dw XT_CFETCH
0000d6 f045        .dw XT_DOLITERAL
0000d7 0210        .dw usart_rx_in
0000d8 f0a9        .dw XT_CFETCH
0000d9 f122        .dw XT_NOTEQUAL
0000da f025        .dw XT_EXIT
                 ;  .include "drivers/timer-usart-isr.asm"
                   .set XT_RX  = XT_RX_BUFFER
                   .set XT_RXQ = XT_RXQ_BUFFER
                   .set XT_USART_INIT_RX = XT_USART_INIT_RX_BUFFER
                 .else
                 .endif
                 
                 .include "words/usart-tx-poll.asm"
                 
                 ; MCU
                 ; check availability and send one character to the terminal using register poll
                 VE_TX_POLL:
0000db ff07          .dw $ff07
0000dc 7874
0000dd 702d
0000de 6c6f
0000df 006c          .db "tx-poll",0
0000e0 00cb          .dw VE_HEAD
                     .set VE_HEAD = VE_TX_POLL
                 XT_TX_POLL:
0000e1 f000          .dw DO_COLON
                 PFA_TX_POLL:
                   ; wait for data ready
0000e2 00ef        .dw XT_TXQ_POLL
0000e3 f03e        .dw XT_DOCONDBRANCH
0000e4 00e2        .dw PFA_TX_POLL
                   ; send to usart
0000e5 f045        .dw XT_DOLITERAL
0000e6 00c6        .dw USART_DATA
0000e7 f09e        .dw XT_CSTORE
0000e8 f025        .dw XT_EXIT
                 
                 ; ( -- f) MCU
                 ; MCU
                 ; check if a character can be send using register poll
                 VE_TXQ_POLL:
0000e9 ff08          .dw $ff08
0000ea 7874
0000eb 2d3f
0000ec 6f70
0000ed 6c6c          .db "tx?-poll"
0000ee 00db          .dw VE_HEAD
                     .set VE_HEAD = VE_TXQ_POLL
                 XT_TXQ_POLL:
0000ef f000          .dw DO_COLON
                 PFA_TXQ_POLL:
0000f0 fa63        .dw XT_PAUSE
0000f1 f045        .dw XT_DOLITERAL
0000f2 00c0        .dw USART_A
0000f3 f0a9        .dw XT_CFETCH
0000f4 f045        .dw XT_DOLITERAL
0000f5 0020        .dw bm_USART_TXRD
0000f6 f224        .dw XT_AND
0000f7 f025        .dw XT_EXIT
                 .set XT_TX  = XT_TX_POLL
                 .set XT_TXQ = XT_TXQ_POLL
                 .set XT_USART_INIT_TX = 0
                 
                 .include "words/ubrr.asm"
                 
                 ; MCU
                 ; returns usart UBRR settings
                 VE_UBRR:
0000f8 ff04        .dw $ff04
0000f9 6275
0000fa 7272        .db "ubrr"
0000fb 00e9        .dw VE_HEAD
                   .set VE_HEAD = VE_UBRR
                 XT_UBRR:
0000fc f080        .dw PFA_DOVALUE1
                 PFA_UBRR:          ; ( -- )
0000fd 00cc        .dw EE_UBRRVAL
0000fe fbca        .dw XT_EDEFERFETCH
0000ff fbd4        .dw XT_EDEFERSTORE
                 .include "words/usart.asm"
                 
                 ; MCU
                 ; initialize usart
                 VE_USART:
000100 ff06        .dw $ff06
000101 752b
000102 6173
000103 7472        .db "+usart"
000104 00f8        .dw VE_HEAD
                   .set VE_HEAD = VE_USART
                 XT_USART:
000105 f000        .dw DO_COLON
                 PFA_USART:          ; ( -- )
                 
000106 f045        .dw XT_DOLITERAL
000107 0098        .dw USART_B_VALUE
000108 f045        .dw XT_DOLITERAL
000109 00c1        .dw USART_B
00010a f09e        .dw XT_CSTORE
                 
00010b f045        .dw XT_DOLITERAL
00010c 0006        .dw USART_C_VALUE
00010d f045        .dw XT_DOLITERAL
00010e 00c2        .dw USART_C | bm_USARTC_en
00010f f09e        .dw XT_CSTORE
                 
000110 00fc        .dw XT_UBRR
000111 f0c2        .dw XT_DUP
000112 f30a        .dw XT_BYTESWAP
000113 f045        .dw XT_DOLITERAL
000114 00c5        .dw BAUDRATE_HIGH
000115 f09e        .dw XT_CSTORE
000116 f045        .dw XT_DOLITERAL
000117 00c4        .dw BAUDRATE_LOW
000118 f09e        .dw XT_CSTORE
                 .if XT_USART_INIT_RX!=0
000119 00a4        .dw XT_USART_INIT_RX
                 .endif
                 .if XT_USART_INIT_TX!=0
                 .endif
                 
00011a f025        .dw XT_EXIT
                 
                 ; settings for 1wire interface, if desired
                 .equ OW_PORT=PORTE
                 .EQU OW_BIT=4
                 .include "drivers/1wire.asm"
                 
                 ;   B. J. Rodriguez (MSP 430)
                 ;   Matthias Trute (AVR Atmega)
                 ; COPYRIGHT
                 ;   (c) 2012 Bradford J. Rodriguez for the 430 code and API
                 
                 ;  adapted 430 assembly code to AVR
                 ;  wishlist: 
                 ;     use a configurable pin at runtime, compatible with bitnames.frt
                 ;     no external pull up, no external power supply for devices
                 ;     ???
                 ;
                 ;.EQU OW_BIT=4
                 ;.equ OW_PORT=PORTE
                 .set OW_DDR=(OW_PORT-1)
                 .set OW_PIN=(OW_DDR-1)
                 
                 ;****f* 1W.RESET
                 ; NAME
                 ;   1W.RESET
                 ; SYNOPSIS
                 ;   1W.RESET ( -- f )  Initialize 1-wire devices; return true if present
                 ; DESCRIPTION
                 ;   This configures the port pin used by the 1-wire interface, and then
                 ;   sends an "initialize" sequence to the 1-wire devices.  If any device
                 ;   is present, it will be detected.
                 ;
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" (drive output low) for >480 usec.
                 ;   b) Output "1" (let output float).
                 ;   c) After 15 to 60 usec, device will drive pin low for 60 to 240 usec.
                 ;      So, wait 75 usec and sample input.
                 ;   d) Leave output high (floating) for at least 480 usec.
                 ;******
                 ; ( -- f )
                 ; Hardware
                 ; Initialize 1-wire devices; return true if present
                 VE_OW_RESET:
00011b ff08          .dw $ff08
00011c 7731
00011d 722e
00011e 7365
00011f 7465          .db "1w.reset"
000120 0100          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_RESET
                 XT_OW_RESET:
000121 0122          .dw PFA_OW_RESET
                 PFA_OW_RESET:
000122 939a
000123 938a          savetos
                     ; setup to output
000124 9a6c          sbi OW_DDR, OW_BIT
                     ; Pull output low
000125 9874          cbi OW_PORT, OW_BIT
                     ; Delay >480 usec        
000126 e8e0
000127 e0f7
000128 9731
000129 f7f1          DELAY   480
                     ; Critical timing period, disable interrupts.
00012a b71f          in temp1, SREG
00012b 94f8          cli
                     ; Pull output high
00012c 9a74          sbi OW_PORT, OW_BIT
                     ; make pin input, sends "1"
00012d 986c          cbi OW_DDR, OW_BIT 
00012e e0e0
00012f e0f1
000130 9731
000131 f7f1          DELAY   64 ; delayB
                     ; Sample input pin, set TOS if input is zero
000132 b18c          in tosl, OW_PIN
000133 ff84          sbrs tosl, OW_BIT
000134 ef9f          ser  tosh
                     ; End critical timing period, enable interrupts
000135 bf1f          out SREG, temp1
                     ; release bus
000136 986c          cbi OW_DDR, OW_BIT
000137 9874          cbi OW_PORT, OW_BIT
                 
                     ; Delay rest of 480 usec 
000138 e8e0
000139 e0f6
00013a 9731
00013b f7f1          DELAY   416
                     ; we now have the result flag in TOS        
00013c 2f89          mov tosl, tosh
00013d 940c f004     jmp_ DO_NEXT
                     
                 ;****f* 1W.SLOT
                 ; NAME
                 ;   1W.SLOT
                 ; SYNOPSIS
                 ;   1W.SLOT ( c -- c' ) Write and read one bit to/from 1-wire.
                 ; DESCRIPTION
                 ;   The "touch byte" function is described in Dallas App Note 74.
                 ;   It outputs a byte to the 1-wire pin, LSB first, and reads back
                 ;   the state of the 1-wire pin after a suitable delay.
                 ;   To read a byte, output $FF and read the reply data.
                 ;   To write a byte, output that byte and discard the reply.
                 ;
                 ;   This function performs one bit of the "touch" operation --
                 ;   one read/write "slot" in Dallas jargon.  Perform this eight
                 ;   times in a row to get the "touch byte" function.
                 ;
                 ; PARAMETERS
                 ;   The input parameter is xxxxxxxxbbbbbbbo where
                 ;   'xxxxxxxx' are don't cares,
                 ;   'bbbbbbb' are bits to be shifted down, and
                 ;   'o' is the bit to be output in the slot.  This must be 1
                 ;   to create a read slot.
                 ;
                 ;   The returned value is xxxxxxxxibbbbbbb where
                 ;   'xxxxxxxx' are not known (the input shifted down 1 position),
                 ;   'i' is the bit read during the slot.  This has no meaning
                 ;   if it was a write slot.
                 ;   'bbbbbbb' are the 7 input bits, shifted down one position.
                 ;
                 ;   This peculiar parameter usage allows OWTOUCH to be written as
                 ;     OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT OWSLOT 
                 ;
                 ; NOTES 
                 ;   Interrupts are disabled during each bit.
                 
                 ;   Timing, per DS18B20 data sheet:
                 ;   a) Output "0" for start period.  (> 1 us, < 15 us, typ. 6 us*)
                 ;   b) Output data bit (0 or 1), open drain 
                 ;   c) After MS from start of cycle, sample input (15 to 60 us, typ. 25 us*)
                 ;   d) After write-0 period from start of cycle, output "1" (>60 us)
                 ;   e) After recovery period, loop or return. (> 1 us)
                 ;   For writes, DS18B20 samples input 15 to 60 usec from start of cycle.
                 ;   * "Typical" values are per App Note 132 for a 300m cable length.
                 
                 ;   ---------        -------------------------------
                 ;            \      /                        /
                 ;             ------------------------------- 
                 ;            a      b          c             d     e
                 ;            |  6us |   19us   |    35us     | 2us |
                 ;******
                 ; ( c -- c' )
                 ; Hardware
                 ; Write and read one bit to/from 1-wire.
                 VE_OW_SLOT:
00013f ff07          .dw $ff07
000140 7731
000141 732e
000142 6f6c
000143 0074          .db "1w.slot",0
000144 011b          .dw VE_HEAD
                     .set VE_HEAD = VE_OW_SLOT
                 XT_OW_SLOT:
000145 0146          .dw PFA_OW_SLOT
                 PFA_OW_SLOT:
                     ; pull low
000146 9874          cbi OW_PORT, OW_BIT
000147 9a6c          sbi OW_DDR, OW_BIT
                     ; disable interrupts
000148 b71f          in temp1, SREG
000149 94f8          cli
00014a e1e8
00014b e0f0
00014c 9731
00014d f7f1          DELAY   6 ; DELAY A
                     ; check bit
00014e 9488          clc
00014f 9587          ror tosl
000150 f410          brcc PFA_OW_SLOT0 ; a 0 keeps the bus low
                       ; release bus, a 1 is written
000151 9a74            sbi OW_PORT, OW_BIT
000152 986c            cbi OW_DDR, OW_BIT
                 PFA_OW_SLOT0:
                     ; sample the input (no action required if zero)
000153 e2e4
000154 e0f0
000155 9731
000156 f7f1          DELAY 9   ; wait DELAY E to sample
000157 b10c          in temp0, OW_PIN
000158 fd04          sbrc temp0, OW_BIT
000159 6880          ori tosl, $80
                 
00015a ecec
00015b e0f0
00015c 9731
00015d f7f1          DELAY   51 ; DELAY B
00015e 9a74          sbi OW_PORT, OW_BIT ; release bus
00015f 986c          cbi OW_DDR, OW_BIT
000160 e0e8
000161 e0f0
000162 9731
000163 f7f1          delay 2
                     ; re-enable interrupts
000164 bf1f          out SREG, temp1
000165 940c f004     jmp_ DO_NEXT
                 
                 ;  include the whole source tree.
                 .include "amforth.asm"
                 
                 ;;;;
                 ;;;; GPL V2 (only)
                 
                 .set AMFORTH_NRWW_SIZE=(FLASHEND-AMFORTH_RO_SEG)*2
                 
                 .set corepc = pc
                 .org $0000
000000 940c fa6c   jmp_ PFA_COLD
                 
                 .org corepc
                 .include "drivers/generic-isr.asm"
                 
                 .eseg
000000           intvec: .byte INTVECTORS * CELLSIZE
                 .if WANT_INTERRUPT_COUNTERS==1
                 .dseg
000212           intcnt: .byte INTVECTORS
                 .endif
                 .cseg
                 
                 ; interrupt routine gets called (again) by rcall! This gives the
                 ; address of the int-vector on the stack.
                 isr:
000167 920a          st -Y, r0
000168 b60f          in r0, SREG
000169 920a          st -Y, r0
                 .if (pclen==3)
                 .endif
00016a 900f          pop r0
00016b 900f          pop r0          ; = intnum * intvectorsize + 1 (address following the rcall)
00016c 940a          dec r0
                 .if intvecsize == 1 ;
                 .endif
                     ; check whether isrflag is zero. if not,
                     ; there is an still unhandled interrupt pending.
00016d 20bb          tst isrflag
00016e f001          breq isr_clean
                     ; there is a collision. the previous interrupt is not yet
                     ; handled by the forth inner interpreter
                 isr_clean:
00016f 2cb0          mov isrflag, r0
                 .if WANT_INTERRUPT_COUNTERS==1
000170 93ff          push zh
000171 93ef          push zl
000172 e1e2          ldi zl, low(intcnt)
000173 e0f2          ldi zh, high(intcnt)
000174 9406          lsr r0 ; we use byte addresses in the counter array, not words
000175 0de0          add zl, r0
000176 1df3          adc zh, zeroh
000177 8000          ld r0, Z
000178 9403          inc r0
000179 8200          st Z, r0
00017a 91ef          pop zl
00017b 91ff          pop zh
                 .endif
00017c 9009          ld r0, Y+
00017d be0f          out SREG, r0
00017e 9009          ld r0, Y+
00017f 9508          ret ; returns the interrupt, the rcall stack frame is removed!
                     ; no reti here, see words/isr-end.asm
                 ; lower part of the dictionary
                 .include "dict/rww.inc"
                 
                 
                 ; Arithmetics
                 ; add a number to a double cell
                 VE_MPLUS:
000180 ff02          .dw $ff02
000181 2b6d          .db "m+"
000182 013f          .dw VE_HEAD
                     .set VE_HEAD = VE_MPLUS
                 XT_MPLUS:
000183 f000          .dw DO_COLON
                 PFA_MPLUS:
000184 fd8e          .dw XT_S2D
000185 f446          .dw XT_DPLUS
000186 f025          .dw XT_EXIT
                 .include "words/ud-star.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSTAR:
000187 ff03          .dw $ff03
000188 6475
../../common\words/ud-star.asm(9): warning: .cseg .db misalignment - padding zero byte
000189 002a          .db "ud*"
00018a 0180          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSTAR
                 XT_UDSTAR:
00018b f000          .dw DO_COLON
                 PFA_UDSTAR:
                 
                 .endif
                 ;Z UD*      ud1 d2 -- ud3      32*16->32 multiply
                 ;   XT_DUP >R UM* DROP  XT_SWAP R> UM* ROT + ;
                 
00018c f0c2
00018d f110
00018e f1f1
00018f f0ea              .DW XT_DUP,XT_TO_R,XT_UMSTAR,XT_DROP
000190 f0d5
000191 f107
000192 f1f1
000193 f0f2
000194 f1ae
000195 f025              .DW XT_SWAP,XT_R_FROM,XT_UMSTAR,XT_ROT,XT_PLUS,XT_EXIT
                 .include "words/umax.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMAX:
000196 ff04          .dw $ff04
000197 6d75
000198 7861          .db "umax"
000199 0187          .dw VE_HEAD
                     .set VE_HEAD = VE_UMAX
                 XT_UMAX:
00019a f000          .dw DO_COLON
                 PFA_UMAX:
                 .endif
                 
00019b f560
00019c f16d              .DW XT_2DUP,XT_ULESS
00019d f03e      	.dw XT_DOCONDBRANCH
00019e 01a0      	 DEST(UMAX1)
00019f f0d5              .DW XT_SWAP
0001a0 f0ea      UMAX1:  .DW XT_DROP
0001a1 f025      	.dw XT_EXIT
                 .include "words/umin.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UMIN:
0001a2 ff04          .dw $ff04
0001a3 6d75
0001a4 6e69          .db "umin"
0001a5 0196          .dw VE_HEAD
                     .set VE_HEAD = VE_UMIN
                 XT_UMIN:
0001a6 f000          .dw DO_COLON
                 PFA_UMIN:
                 .endif
0001a7 f560
0001a8 f178              .DW XT_2DUP,XT_UGREATER
0001a9 f03e      	.dw XT_DOCONDBRANCH
0001aa 01ac      	DEST(UMIN1)
0001ab f0d5              .DW XT_SWAP
0001ac f0ea      UMIN1:  .DW XT_DROP
0001ad f025      	.dw XT_EXIT
                 .include "words/immediate-q.asm"
                 
                 ; Tools
                 ; return +1 if immediate, -1 otherwise, flag from name>flags
                 ;VE_IMMEDIATEQ:
                 ;    .dw $ff06
                 ;    .db "immediate?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_IMMEDIATEQ
                 XT_IMMEDIATEQ:
0001ae f000          .dw DO_COLON
                 PFA_IMMEDIATEQ:
0001af f045          .dw XT_DOLITERAL
0001b0 8000          .dw $8000
0001b1 f224          .dw XT_AND
0001b2 f129          .dw XT_ZEROEQUAL
0001b3 f03e          .dw XT_DOCONDBRANCH
0001b4 01b7          DEST(IMMEDIATEQ1)
0001b5 f3f7           .dw XT_ONE
0001b6 f025           .dw XT_EXIT
                 IMMEDIATEQ1:
                     ; not immediate
0001b7 f15c          .dw XT_TRUE
0001b8 f025          .dw XT_EXIT
                 .include "words/name2flags.asm"
                 
                 ; Tools
                 ; get the flags from a name token
                 VE_NAME2FLAGS:
0001b9 ff0a          .dw $ff0a
0001ba 616e
0001bb 656d
0001bc 663e
0001bd 616c
0001be 7367          .db "name>flags"
0001bf 01a2          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2FLAGS
                 XT_NAME2FLAGS:
0001c0 f000          .dw DO_COLON
                 PFA_NAME2FLAGS:
0001c1 f3d8          .dw XT_FETCHI ; skip to link field
0001c2 f045          .dw XT_DOLITERAL
0001c3 ff00          .dw $ff00
0001c4 f224          .dw XT_AND
0001c5 f025          .dw XT_EXIT
                 .include "words/1ms.asm"
                 
                 ; Time
                 ; busy waits (almost) exactly 1 millisecond
                 VE_1MS:
0001c6 ff03          .dw $ff03
0001c7 6d31
0001c8 0073          .db "1ms",0
0001c9 01b9          .dw VE_HEAD
                     .set VE_HEAD = VE_1MS
                 XT_1MS:
0001ca 01cb          .dw PFA_1MS
                 PFA_1MS:
0001cb eae0
0001cc e0ff
0001cd 9731
0001ce f7f1          delay 1000
0001cf 940c f004     jmp_ DO_NEXT
                 
                 .if AMFORTH_NRWW_SIZE > 8000
                 .include "dict/appl_8k.inc"
                 
                 
                 .include "words/newest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_NEWEST:
0001d1 ff06          .dw $ff06
0001d2 656e
0001d3 6577
0001d4 7473          .db "newest"
0001d5 01c6          .dw VE_HEAD
                     .set VE_HEAD = VE_NEWEST
                 XT_NEWEST:
0001d6 f053          .dw PFA_DOVARIABLE
                 PFA_NEWEST:
0001d7 024b          .dw ram_newest
                 
                 .dseg
00024b           ram_newest: .byte 4
                 .include "words/latest.asm"
                 
                 ; System Variable
                 ; system state
                 VE_LATEST:
0001d8 ff06          .dw $ff06
0001d9 616c
0001da 6574
0001db 7473          .db "latest"
0001dc 01d1          .dw VE_HEAD
                     .set VE_HEAD = VE_LATEST
                 XT_LATEST:
0001dd f053          .dw PFA_DOVARIABLE
                 PFA_LATEST:
0001de 024f          .dw ram_latest
                 
                 .dseg
00024f           ram_latest: .byte 2
                 .include "words/do-create.asm"
                 
                 ; Compiler
                 ; parse the input and create an empty vocabulary entry without XT and data field (PF)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE:
0001df ff08          .dw $ff08
0001e0 6328
0001e1 6572
0001e2 7461
0001e3 2965          .db "(create)"
0001e4 01d8          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE
                 XT_DOCREATE:
0001e5 f000          .dw DO_COLON
                 PFA_DOCREATE:
                 .endif
0001e6 f9b9
0001e7 0347          .DW XT_PARSENAME,XT_WLSCOPE  ; ( -- addr len wid)
0001e8 01f2          .DW XT_DOCREATE_IN           ; ( addr len wid -- )
0001e9 f025          .DW XT_EXIT
                 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOCREATE_IN:
0001ea ff0b          .dw $ff0b
0001eb 6328
0001ec 6572
0001ed 7461
0001ee 2d65
0001ef 6e69
../../common\words/do-create.asm(31): warning: .cseg .db misalignment - padding zero byte
0001f0 0029          .db "(create-in)"
0001f1 01df          .dw VE_HEAD
                     .set VE_HEAD = VE_DOCREATE_IN
                 XT_DOCREATE_IN:
0001f2 f000          .dw DO_COLON
                 PFA_DOCREATE_IN:
                 .endif
0001f3 f0c2
0001f4 01d6
0001f5 f559
0001f6 f092          .DW XT_DUP,XT_NEWEST,XT_CELLPLUS,XT_STORE ; save the wid
0001f7 032c
0001f8 01d6
0001f9 f092          .DW XT_HEADER,XT_NEWEST,XT_STORE          ; save the nt
0001fa f025          .DW XT_EXIT
                 .include "words/backslash.asm"
                 
                 ; Compiler
                 ; everything up to the end of the current line is a comment
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BACKSLASH:
0001fb 0001          .dw $0001
0001fc 005c          .db $5c,0
0001fd 01ea          .dw VE_HEAD
                     .set VE_HEAD = VE_BACKSLASH
                 XT_BACKSLASH:
0001fe f000          .dw DO_COLON
                 PFA_BACKSLASH:
                 .endif
0001ff f9a0          .dw XT_SOURCE
000200 f101          .dw XT_NIP
000201 f579          .dw XT_TO_IN
000202 f092          .dw XT_STORE
000203 f025          .dw XT_EXIT
                 .include "words/l-paren.asm"
                 
                 ; Compiler
                 ; skip everything up to the closing bracket on the same line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LPAREN:
000204 0001          .dw $0001
000205 0028          .db "(" ,0
000206 01fb          .dw VE_HEAD
                     .set VE_HEAD = VE_LPAREN
                 XT_LPAREN:
000207 f000          .dw DO_COLON
                 PFA_LPAREN:
                 .endif
000208 f045          .dw XT_DOLITERAL
000209 0029          .dw ')'
00020a f98c          .dw XT_PARSE
00020b f569          .dw XT_2DROP
00020c f025          .dw XT_EXIT
                 
                 .include "words/compile.asm"
                 
                 ; Dictionary
                 ; read the following cell from the dictionary and append it to the current dictionary position.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COMPILE:
00020d ff07          .dw $ff07
00020e 6f63
00020f 706d
000210 6c69
000211 0065          .db "compile",0
000212 0204          .dw  VE_HEAD
                     .set VE_HEAD = VE_COMPILE
                 XT_COMPILE:
000213 f000          .dw DO_COLON
                 PFA_COMPILE:
                 .endif
000214 f107          .dw XT_R_FROM
000215 f0c2          .dw XT_DUP
000216 fbc1          .dw XT_ICELLPLUS
000217 f110          .dw XT_TO_R
000218 f3d8          .dw XT_FETCHI
000219 021e          .dw XT_COMMA
00021a f025          .dw XT_EXIT
                 .include "words/comma.asm"
                 
                 ; Dictionary
                 ; compile 16 bit into flash at DP
                 VE_COMMA:
00021b ff01          .dw $ff01
00021c 002c          .db ',',0 ; ,
00021d 020d          .dw VE_HEAD
                     .set VE_HEAD = VE_COMMA
                 XT_COMMA:
00021e f000          .dw DO_COLON
                 PFA_COMMA:
00021f f5a9          .dw XT_DP
000220 f37a          .dw XT_STOREI
000221 f5a9          .dw XT_DP
000222 f240          .dw XT_1PLUS
000223 fbaf          .dw XT_DOTO
000224 f5aa          .dw PFA_DP
000225 f025          .dw XT_EXIT
                 .include "words/brackettick.asm"
                 
                 ; Compiler
                 ; what ' does in the interpreter mode, do in colon definitions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETTICK:
000226 0003          .dw $0003
000227 275b
000228 005d          .db "[']",0
000229 021b          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETTICK
                 XT_BRACKETTICK:
00022a f000          .dw DO_COLON
                 PFA_BRACKETTICK:
                 .endif
00022b f805          .dw XT_TICK
00022c 0234          .dw XT_LITERAL
00022d f025          .dw XT_EXIT
                 
                 
                 .include "words/literal.asm"
                 
                 ; Compiler
                 ; compile a literal in colon defintions
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LITERAL:
00022e 0007          .dw $0007
00022f 696c
000230 6574
000231 6172
000232 006c          .db "literal",0
000233 0226          .dw VE_HEAD
                     .set VE_HEAD = VE_LITERAL
                 XT_LITERAL:
000234 f000          .dw DO_COLON
                 PFA_LITERAL:
                 .endif
000235 0213              .DW XT_COMPILE
000236 f045              .DW XT_DOLITERAL
000237 021e              .DW XT_COMMA
000238 f025              .DW XT_EXIT
                 .include "words/sliteral.asm"
                 
                 ; String
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLITERAL:
000239 0008        .dw $0008
00023a 6c73
00023b 7469
00023c 7265
00023d 6c61        .db "sliteral"
00023e 022e        .dw VE_HEAD
                   .set VE_HEAD = VE_SLITERAL
                 XT_SLITERAL:
00023f f000          .dw DO_COLON
                 PFA_SLITERAL:
                 .endif
000240 0213          .dw XT_COMPILE
000241 f768          .dw XT_DOSLITERAL    ; ( -- addr n)
000242 f776          .dw XT_SCOMMA
000243 f025          .dw XT_EXIT
                 .include "words/g-mark.asm"
                 
                 ; Compiler
                 ; places current dictionary position for backward resolves
                 ;VE_GMARK:
                 ;    .dw $ff05
                 ;    .db ">mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GMARK
                 XT_GMARK:
000244 f000          .dw DO_COLON
                 PFA_GMARK:
000245 f5a9          .dw XT_DP
000246 0213          .dw XT_COMPILE
000247 ffff          .dw -1           ; ffff does not erase flash
000248 f025          .dw XT_EXIT
                 .include "words/g-resolve.asm"
                 
                 ; Compiler
                 ; resolve backward jumps
                 ;VE_GRESOLVE:
                 ;    .dw $ff08
                 ;    .db ">resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_GRESOLVE
                 XT_GRESOLVE:
000249 f000          .dw DO_COLON
                 PFA_GRESOLVE:
00024a fb6d          .dw XT_QSTACK
00024b f5a9          .dw XT_DP
00024c f0d5          .dw XT_SWAP
00024d f37a          .dw XT_STOREI
00024e f025          .dw XT_EXIT
                 .include "words/l_mark.asm"
                 
                 ; Compiler
                 ; place destination for backward branch
                 ;VE_LMARK:
                 ;    .dw $ff05
                 ;    .db "<mark"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LMARK
                 XT_LMARK:
00024f f000          .dw DO_COLON
                 PFA_LMARK:
000250 f5a9          .dw XT_DP
000251 f025          .dw XT_EXIT
                 .include "words/l_resolve.asm"
                 
                 ; Compiler
                 ; resolve backward branch
                 ;VE_LRESOLVE:
                 ;    .dw $ff08
                 ;    .db "<resolve"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LRESOLVE
                 XT_LRESOLVE:
000252 f000          .dw DO_COLON
                 PFA_LRESOLVE:
000253 fb6d          .dw XT_QSTACK
000254 021e          .dw XT_COMMA
000255 f025          .dw XT_EXIT
                 
                 .include "words/ahead.asm"
                 
                 ; Compiler
                 ; do a unconditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AHEAD:
000256 0005          .dw $0005
000257 6861
000258 6165
000259 0064          .db "ahead",0
00025a 0239          .dw VE_HEAD
                     .set VE_HEAD = VE_AHEAD
                 XT_AHEAD:
00025b f000          .dw DO_COLON
                 PFA_AHEAD:
                 .endif
00025c 0213          .dw XT_COMPILE
00025d f034          .dw XT_DOBRANCH
00025e 0244          .dw XT_GMARK
00025f f025          .dw XT_EXIT
                 .include "words/if.asm"
                 
                 ; Compiler
                 ; start conditional branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_IF:
000260 0002          .dw $0002
000261 6669          .db "if"
000262 0256          .dw VE_HEAD
                     .set VE_HEAD = VE_IF
                 XT_IF:
000263 f000          .dw DO_COLON
                 PFA_IF:
                 .endif
000264 0213          .dw XT_COMPILE
000265 f03e          .dw XT_DOCONDBRANCH
000266 0244          .dw XT_GMARK
000267 f025          .dw XT_EXIT
                 .include "words/else.asm"
                 
                 ; Compiler
                 ; resolve the forward reference and place a new unresolved forward reference
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ELSE:
000268 0004          .dw $0004
000269 6c65
00026a 6573          .db "else"
00026b 0260          .dw VE_HEAD
                     .set VE_HEAD = VE_ELSE
                 XT_ELSE:
00026c f000          .dw DO_COLON
                 PFA_ELSE:
                 .endif
00026d 0213          .dw XT_COMPILE
00026e f034          .dw XT_DOBRANCH
00026f 0244          .dw XT_GMARK
000270 f0d5          .dw XT_SWAP
000271 0249          .dw XT_GRESOLVE
000272 f025          .dw XT_EXIT
                 .include "words/then.asm"
                 
                 ; Compiler
                 ; finish if
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THEN:
000273 0004          .dw $0004
000274 6874
000275 6e65          .db "then"
000276 0268          .dw VE_HEAD
                     .set VE_HEAD = VE_THEN
                 XT_THEN:
000277 f000          .dw DO_COLON
                 PFA_THEN:
                 .endif
000278 0249          .dw XT_GRESOLVE
000279 f025          .dw XT_EXIT
                 .include "words/begin.asm"
                 
                 ; Compiler
                 ; put the next location for a transfer of control onto the control flow stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BEGIN:
00027a 0005          .dw $0005
00027b 6562
00027c 6967
00027d 006e          .db "begin",0
00027e 0273          .dw VE_HEAD
                     .set VE_HEAD = VE_BEGIN
                 XT_BEGIN:
00027f f000          .dw DO_COLON
                 PFA_BEGIN:
                 .endif
000280 024f          .dw XT_LMARK
000281 f025          .dw XT_EXIT
                 .include "words/while.asm"
                 
                 ; Compiler
                 ; at runtime skip until repeat if non-true
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WHILE:
000282 0005          .dw $0005
000283 6877
000284 6c69
000285 0065          .db "while",0
000286 027a          .dw VE_HEAD
                     .set VE_HEAD = VE_WHILE
                 XT_WHILE:
000287 f000          .dw DO_COLON
                 PFA_WHILE:
                 .endif
000288 0263          .dw XT_IF
000289 f0d5          .dw XT_SWAP
00028a f025          .dw XT_EXIT
                 .include "words/repeat.asm"
                 
                 ; Compiler
                 ; continue execution at dest, resolve orig
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REPEAT:
00028b 0006          .dw $0006
00028c 6572
00028d 6570
00028e 7461          .db "repeat"
00028f 0282          .dw VE_HEAD
                     .set VE_HEAD = VE_REPEAT
                 XT_REPEAT:
000290 f000          .dw DO_COLON
                 PFA_REPEAT:
                 .endif
000291 02a4          .dw XT_AGAIN
000292 0277          .dw XT_THEN
000293 f025          .dw XT_EXIT
                 .include "words/until.asm"
                 
                 ; Compiler
                 ; finish begin with conditional branch, leaves the loop if true flag at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UNTIL:
000294 0005          .dw $0005
000295 6e75
000296 6974
000297 006c          .db "until",0
000298 028b          .dw VE_HEAD
                     .set VE_HEAD = VE_UNTIL
                 XT_UNTIL:
000299 f000          .dw DO_COLON
                 PFA_UNTIL:
                 .endif
00029a f045          .dw XT_DOLITERAL
00029b f03e          .dw XT_DOCONDBRANCH
00029c 021e          .dw XT_COMMA
                 
00029d 0252          .dw XT_LRESOLVE
00029e f025          .dw XT_EXIT
                 .include "words/again.asm"
                 
                 ; Compiler
                 ; compile a jump back to dest
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_AGAIN:
00029f 0005          .dw $0005
0002a0 6761
0002a1 6961
0002a2 006e          .db "again",0
0002a3 0294          .dw VE_HEAD
                     .set VE_HEAD = VE_AGAIN
                 XT_AGAIN:
0002a4 f000          .dw DO_COLON
                 PFA_AGAIN:
                 .endif
0002a5 0213          .dw XT_COMPILE
0002a6 f034          .dw XT_DOBRANCH
0002a7 0252          .dw XT_LRESOLVE
0002a8 f025          .dw XT_EXIT
                 .include "words/do.asm"
                 
                 ; Compiler
                 ; start do .. [+]loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DO:
0002a9 0002          .dw $0002
0002aa 6f64          .db "do"
0002ab 029f          .dw VE_HEAD
                     .set VE_HEAD = VE_DO
                 XT_DO:
0002ac f000          .dw DO_COLON
                 PFA_DO:
                 
                 .endif
0002ad 0213          .dw XT_COMPILE
0002ae f2ac          .dw XT_DODO
0002af 024f          .dw XT_LMARK
0002b0 f165          .dw XT_ZERO
0002b1 0307          .dw XT_TO_L
0002b2 f025          .dw XT_EXIT
                 .include "words/loop.asm"
                 
                 ; Compiler
                 ; compile (loop) and resolve the backward branch
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LOOP:
0002b3 0004          .dw $0004
0002b4 6f6c
0002b5 706f          .db "loop"
0002b6 02a9          .dw VE_HEAD
                     .set VE_HEAD = VE_LOOP
                 XT_LOOP:
0002b7 f000          .dw DO_COLON
                 PFA_LOOP:
                 .endif
0002b8 0213          .dw XT_COMPILE
0002b9 f2da          .dw XT_DOLOOP
0002ba 02ee          .dw XT_ENDLOOP
0002bb f025          .dw XT_EXIT
                 .include "words/plusloop.asm"
                 
                 ; Compiler
                 ; compile (+loop) and resolve branches
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PLUSLOOP:
0002bc 0005          .dw $0005
0002bd 6c2b
0002be 6f6f
0002bf 0070          .db "+loop",0
0002c0 02b3          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSLOOP
                 XT_PLUSLOOP:
0002c1 f000          .dw DO_COLON
                 PFA_PLUSLOOP:
                 .endif
0002c2 0213          .dw XT_COMPILE
0002c3 f2cb          .dw XT_DOPLUSLOOP
0002c4 02ee          .dw XT_ENDLOOP
0002c5 f025          .dw XT_EXIT
                 .include "words/leave.asm"
                 
                 ; Compiler
                 ; immediatly leave the current DO..LOOP
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LEAVE:
0002c6 0005         .dw $0005
0002c7 656c
0002c8 7661
0002c9 0065         .db "leave",0
0002ca 02bc         .dw VE_HEAD
                    .set VE_HEAD = VE_LEAVE
                 XT_LEAVE:
0002cb f000          .dw DO_COLON
                 PFA_LEAVE:
                 .endif
0002cc 0213
0002cd f2e5          .DW XT_COMPILE,XT_UNLOOP
0002ce 025b
0002cf 0307
0002d0 f025          .DW XT_AHEAD,XT_TO_L,XT_EXIT
                 .include "words/qdo.asm"
                 
                 ; Compiler
                 ; start a ?do .. [+]loop control structure
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_QDO:
0002d1 0003          .dw $0003
0002d2 643f
0002d3 006f          .db "?do",0
0002d4 02c6          .dw VE_HEAD
                     .set VE_HEAD = VE_QDO
                 XT_QDO:
0002d5 f000          .dw DO_COLON
                 PFA_QDO:
                 .endif
0002d6 0213          .dw XT_COMPILE
0002d7 02dd          .dw XT_QDOCHECK
0002d8 0263          .dw XT_IF
0002d9 02ac          .dw XT_DO
0002da f0d5          .dw XT_SWAP    ; DO sets a 0 marker on the leave stack
0002db 0307          .dw XT_TO_L    ; then follows at the end.
0002dc f025          .dw XT_EXIT
                 
                 ; there is no special runtime for ?do, the do runtime
                 ; gets wrapped with the sequence
                 ; ... ?do-check if do ..... loop then
                 ; with
                 ; : ?do-check ( n1 n2 -- n1 n2 true | false )
                 ;   2dup = dup >r if 2drop then r> invert ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QDOCHECK:
0002dd f000          .dw DO_COLON
                 PFA_QDOCHECK:
                 .endif
0002de f560          .dw XT_2DUP
0002df f3f0          .dw XT_EQUAL
0002e0 f0c2          .dw XT_DUP
0002e1 f110          .dw XT_TO_R
0002e2 f03e          .dw XT_DOCONDBRANCH
0002e3 02e5          DEST(PFA_QDOCHECK1)
0002e4 f569          .dw XT_2DROP
                 PFA_QDOCHECK1:
0002e5 f107          .dw XT_R_FROM
0002e6 f20e          .dw XT_INVERT
0002e7 f025          .dw XT_EXIT
                 .include "words/endloop.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENDLOOP:
0002e8 ff07          .dw $ff07
0002e9 6e65
0002ea 6c64
0002eb 6f6f
0002ec 0070          .db "endloop",0
0002ed 02d1          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDLOOP
                 XT_ENDLOOP:
0002ee f000          .dw DO_COLON
                 PFA_ENDLOOP:
                 .endif
                 ;Z ENDLOOP   adrs xt --   L: 0 a1 a2 .. aN --
                 ;   <resolve                backward loop
                 ;   BEGIN L> ?DUP WHILE POSTPONE THEN REPEAT ;
                 ;                                 resolve LEAVEs
                 ; This is a common factor of LOOP and +LOOP.
                 
0002ef 0252              .DW XT_LRESOLVE
0002f0 02fb
0002f1 f0ca
0002f2 f03e      LOOP1:  .DW XT_L_FROM,XT_QDUP,XT_DOCONDBRANCH
0002f3 02f7               DEST(LOOP2)
0002f4 0277              .DW XT_THEN
0002f5 f034      	.dw XT_DOBRANCH
0002f6 02f0               DEST(LOOP1)
0002f7 f025      LOOP2:  .DW XT_EXIT
                 ; leave address stack
                 .include "words/l-from.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_FROM:
0002f8 ff02          .dw $ff02
0002f9 3e6c          .db "l>"
0002fa 02e8          .dw VE_HEAD
                     .set VE_HEAD = VE_L_FROM
                 XT_L_FROM:
0002fb f000          .dw DO_COLON
                 PFA_L_FROM:
                 
                 .endif
                 ;Z L>   -- x   L: x --      move from leave stack
                 ;   LP @ @  -2 LP +! ;
                 
0002fc 031a          .dw XT_LP
0002fd f08a          .dw XT_FETCH
0002fe f08a          .dw XT_FETCH
0002ff f045          .dw XT_DOLITERAL
000300 fffe          .dw -2
000301 031a          .dw XT_LP
000302 f276          .dw XT_PLUSSTORE
000303 f025          .dw XT_EXIT
                 .include "words/to-l.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_L:
000304 ff02          .dw $ff02
000305 6c3e          .db ">l"
000306 02f8          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_L
                 XT_TO_L:
000307 f000          .dw DO_COLON
                 PFA_TO_L:
                 .endif
                 ;Z >L   x --   L: -- x        move to leave stack
                 ;   CELL LP +!  LP @ ! ;      (L stack grows up)
                 
000308 f3fc              .dw XT_TWO
000309 031a      	.dw XT_LP
00030a f276      	.dw XT_PLUSSTORE
00030b 031a      	.dw XT_LP
00030c f08a      	.dw XT_FETCH
00030d f092      	.dw XT_STORE
00030e f025      	.dw XT_EXIT
                 .include "words/lp0.asm"
                 
                 ; Stack
                 ; start address of leave stack
                 VE_LP0:
00030f ff03          .dw $ff03
000310 706c
000311 0030          .db "lp0",0
000312 0304          .dw VE_HEAD
                     .set VE_HEAD = VE_LP0
                 XT_LP0:
000313 f080          .dw PFA_DOVALUE1
                 PFA_LP0:
000314 007e          .dw CFG_LP0
000315 fbca          .dw XT_EDEFERFETCH
000316 fbd4          .dw XT_EDEFERSTORE
                 .include "words/lp.asm"
                 
                 ; System Variable
                 ; leave stack pointer
                 VE_LP:
000317 ff02          .dw $ff02
000318 706c          .db "lp"
000319 030f          .dw VE_HEAD
                     .set VE_HEAD = VE_LP
                 XT_LP:
00031a f053          .dw PFA_DOVARIABLE
                 PFA_LP:
00031b 0251          .dw ram_lp
                 
                 .dseg
000251           ram_lp: .byte 2
                 .cseg
                 
                 
                 .include "words/create.asm"
                 
                 ; Dictionary
                 ; create a dictionary header. XT is (constant), with the address of the data field of name
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CREATE:
00031c ff06          .dw $ff06
00031d 7263
00031e 6165
00031f 6574          .db "create"
000320 0317          .dw VE_HEAD
                     .set VE_HEAD = VE_CREATE
                 XT_CREATE:
000321 f000          .dw DO_COLON
                 PFA_CREATE:
                 .endif
000322 01e5          .dw XT_DOCREATE
000323 0350          .dw XT_REVEAL
000324 0213          .dw XT_COMPILE
000325 f060          .dw PFA_DOCONSTANT
000326 f025          .dw XT_EXIT
                 .include "words/header.asm"
                 
                 ; Compiler
                 ; creates the vocabulary header without XT and data field (PF) in the wordlist wid
                 VE_HEADER:
000327 ff06          .dw $ff06
000328 6568
000329 6461
00032a 7265          .db "header"
00032b 031c          .dw VE_HEAD
                     .set VE_HEAD = VE_HEADER
                 XT_HEADER:
00032c f000          .dw DO_COLON
                 PFA_HEADER:
00032d f5a9          .dw XT_DP           ; the new Name Field
00032e f110          .dw XT_TO_R
00032f f110          .dw XT_TO_R		; ( R: NFA WID )
000330 f0c2          .dw XT_DUP    
000331 f137          .dw XT_GREATERZERO 
000332 f03e          .dw XT_DOCONDBRANCH
000333 033e          .dw PFA_HEADER1
000334 f0c2          .dw XT_DUP
000335 f045          .dw XT_DOLITERAL
000336 ff00          .dw $ff00           ; all flags are off (e.g. immediate)
000337 f22d          .dw XT_OR
000338 f77a          .dw XT_DOSCOMMA
                     ; make the link to the previous entry in this wordlist
000339 f107          .dw XT_R_FROM
00033a f366          .dw XT_FETCHE
00033b 021e          .dw XT_COMMA
00033c f107          .dw XT_R_FROM
00033d f025          .dw XT_EXIT
                 
                 PFA_HEADER1:
                     ; -16: attempt to use zero length string as a name
00033e f045          .dw XT_DOLITERAL
00033f fff0          .dw -16
000340 f83c          .dw XT_THROW
                 
                 .include "words/wlscope.asm"
                 
                 ; Compiler
                 ; dynamically place a word in a wordlist. The word name may be changed.
                 VE_WLSCOPE:
000341 ff07          .dw $ff07
000342 6c77
000343 6373
000344 706f
000345 0065          .db "wlscope",0
000346 0327          .dw VE_HEAD
                     .set VE_HEAD = VE_WLSCOPE
                 XT_WLSCOPE:
000347 fc29          .dw PFA_DODEFER1
                 PFA_WLSCOPE:
000348 007a          .dw CFG_WLSCOPE
000349 fbca          .dw XT_EDEFERFETCH
00034a fbd4          .dw XT_EDEFERSTORE
                 
                 ; wlscope, "wordlist scope" ( addr len -- addr' len' wid ), is a deferred word
                 ; which enables the AmForth application to choose the wordlist ( wid ) for the
                 ; new voc entry based on the input ( addr len ) string. The name of the new voc
                 ; entry ( addr' len' ) may be different from the input string. Note that all
                 ; created voc entry types pass through the wlscope mechanism. The default
                 ; wlscope action passes the input string to the output without modification and
                 ; uses get-current to select the wid.
                 .include "words/reveal.asm"
                 
                 ; Dictionary
                 ; makes an entry in a wordlist visible, if not already done.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REVEAL:
00034b ff06          .dw $ff06
00034c 6572
00034d 6576
00034e 6c61          .db "reveal"
00034f 0341          .dw VE_HEAD
                     .set VE_HEAD = VE_REVEAL
                 XT_REVEAL:
000350 f000          .dw DO_COLON
                 PFA_REVEAL:
                 .endif
000351 01d6
000352 f559
000353 f08a          .DW XT_NEWEST,XT_CELLPLUS,XT_FETCH ; only if wordlist is in use
000354 f0ca
000355 f03e          .DW XT_QDUP,XT_DOCONDBRANCH
000356 035b          DEST(REVEAL1)
000357 01d6
000358 f08a
000359 f0d5
00035a f342          .DW XT_NEWEST,XT_FETCH,XT_SWAP,XT_STOREE
                 ;    .DW XT_ZERO,XT_NEWEST,XT_CELLPLUS,XT_STORE ; clean wordlist entry
                 REVEAL1:
00035b f025          .DW XT_EXIT
                 .include "words/does.asm"
                 
                 ; Compiler
                 ; organize the XT replacement to call other colon code
                 VE_DOES:
00035c 0005          .dw $0005
00035d 6f64
00035e 7365
00035f 003e          .db "does>",0
000360 034b          .dw VE_HEAD
                     .set VE_HEAD = VE_DOES
                 XT_DOES:
000361 f000          .dw DO_COLON
                 PFA_DOES:
000362 0213          .dw XT_COMPILE
000363 0374          .dw XT_DODOES
000364 0213          .dw XT_COMPILE  ; create a code snippet to be used in an embedded XT
000365 940e          .dw $940e       ; the address of this compiled
000366 0213          .dw XT_COMPILE  ; code will replace the XT of the 
000367 0369          .dw DO_DODOES   ; word that CREATE created
000368 f025          .dw XT_EXIT     ; 
                 
                 DO_DODOES: ; ( -- PFA )
000369 939a
00036a 938a          savetos
00036b 01cb          movw tosl, wl
00036c 9601          adiw tosl, 1
                     ; the following takes the address from a real uC-call
                 .if (pclen==3)
                 .endif
00036d 917f          pop wh
00036e 916f          pop wl
                 
00036f 93bf          push XH
000370 93af          push XL
000371 01db          movw XL, wl
000372 940c f004     jmp_ DO_NEXT
                 
                 ; ( -- )
                 ; System
                 ; replace the XT written by CREATE to call the code that follows does>
                 ;VE_DODOES:
                 ;   .dw $ff07
                 ;   .db "(does>)"
                 ;   .set VE_HEAD = VE_DODOES
                 XT_DODOES:
000374 f000          .dw DO_COLON
                 PFA_DODOES:
000375 f107          .dw XT_R_FROM
000376 01d6          .dw XT_NEWEST
000377 f559          .dw XT_CELLPLUS
000378 f08a          .dw XT_FETCH
000379 f366          .dw XT_FETCHE
00037a fc94          .dw XT_NFA2CFA
00037b f37a          .dw XT_STOREI
00037c f025          .dw XT_EXIT
                 .include "words/colon.asm"
                 
                 ; Compiler
                 ; create a named entry in the dictionary, XT is DO_COLON
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_COLON:
00037d ff01          .dw $ff01
00037e 003a          .db ":",0
00037f 035c          .dw VE_HEAD
                     .set VE_HEAD = VE_COLON
                 XT_COLON:
000380 f000          .dw DO_COLON
                 PFA_COLON:
                 .endif
000381 01e5          .dw XT_DOCREATE
000382 038b          .dw XT_COLONNONAME
000383 f0ea          .dw XT_DROP
000384 f025          .dw XT_EXIT
                 .include "words/colon-noname.asm"
                 
                 ; Compiler
                 ; create an unnamed entry in the dictionary, XT is DO_COLON
                 VE_COLONNONAME:
000385 ff07          .dw $ff07
000386 6e3a
000387 6e6f
000388 6d61
000389 0065          .db ":noname",0
00038a 037d          .dw VE_HEAD
                     .set VE_HEAD = VE_COLONNONAME
                 XT_COLONNONAME:
00038b f000          .dw DO_COLON
                 PFA_COLONNONAME:
00038c f5a9          .dw XT_DP
00038d f0c2          .dw XT_DUP
00038e 01dd          .dw XT_LATEST
00038f f092          .dw XT_STORE
                 
000390 0213          .dw XT_COMPILE
000391 f000          .dw DO_COLON
                 
000392 03a0          .dw XT_RBRACKET
000393 f025          .dw XT_EXIT
                 .include "words/semicolon.asm"
                 
                 ; Compiler
                 ; finish colon defintion, compiles (exit) and returns to interpret state 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SEMICOLON:
000394 0001          .dw $0001
000395 003b          .db $3b,0
000396 0385          .dw VE_HEAD
                     .set VE_HEAD = VE_SEMICOLON
                 XT_SEMICOLON:
000397 f000          .dw DO_COLON
                 PFA_SEMICOLON:
                 .endif
000398 0213          .dw XT_COMPILE
000399 f025          .dw XT_EXIT
00039a 03a8          .dw XT_LBRACKET
00039b 0350          .dw XT_REVEAL
00039c f025          .dw XT_EXIT
                 .include "words/right-bracket.asm"
                 
                 ; Compiler
                 ; enter compiler mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RBRACKET:
00039d ff01          .dw $ff01
00039e 005d          .db "]",0
00039f 0394          .dw VE_HEAD
                     .set VE_HEAD = VE_RBRACKET
                 XT_RBRACKET:
0003a0 f000          .dw DO_COLON
                 PFA_RBRACKET:
                 .endif
0003a1 f3f7          .dw XT_ONE
0003a2 f546          .dw XT_STATE
0003a3 f092          .dw XT_STORE
0003a4 f025          .dw XT_EXIT
                 .include "words/left-bracket.asm"
                 
                 ; Compiler
                 ; enter interpreter mode
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_LBRACKET:
0003a5 0001          .dw $0001
0003a6 005b          .db "[",0
0003a7 039d          .dw VE_HEAD
                     .set VE_HEAD = VE_LBRACKET
                 XT_LBRACKET:
0003a8 f000          .dw DO_COLON
                 PFA_LBRACKET:
                 .endif
0003a9 f165          .dw XT_ZERO
0003aa f546          .dw XT_STATE
0003ab f092          .dw XT_STORE
0003ac f025          .dw XT_EXIT
                 .include "words/variable.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a variable and allocate 1 cell RAM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_VARIABLE:
0003ad ff08          .dw $ff08
0003ae 6176
0003af 6972
0003b0 6261
0003b1 656c          .db "variable"
0003b2 03a5          .dw VE_HEAD
                     .set VE_HEAD = VE_VARIABLE
                 XT_VARIABLE:
0003b3 f000          .dw DO_COLON
                 PFA_VARIABLE:
                 .endif
0003b4 f5ba          .dw XT_HERE
0003b5 03bf          .dw XT_CONSTANT
0003b6 f3fc          .dw XT_TWO
0003b7 f5c3          .dw XT_ALLOT
0003b8 f025          .dw XT_EXIT
                 .include "words/constant.asm"
                 
                 ; Compiler
                 ; create a constant in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_CONSTANT:
0003b9 ff08          .dw $ff08
0003ba 6f63
0003bb 736e
0003bc 6174
0003bd 746e          .db "constant"
0003be 03ad          .dw VE_HEAD
                     .set VE_HEAD = VE_CONSTANT
                 XT_CONSTANT:
0003bf f000          .dw DO_COLON
                 PFA_CONSTANT:
                 .endif
0003c0 01e5          .dw XT_DOCREATE
0003c1 0350          .dw XT_REVEAL
0003c2 0213          .dw XT_COMPILE
0003c3 f053          .dw PFA_DOVARIABLE
0003c4 021e          .dw XT_COMMA
0003c5 f025          .dw XT_EXIT
                 .include "words/user.asm"
                 
                 ; Compiler
                 ; create a dictionary entry for a user variable at offset n
                 VE_USER:
0003c6 ff04          .dw $ff04
0003c7 7375
0003c8 7265          .db "user"
0003c9 03b9          .dw VE_HEAD
                     .set VE_HEAD = VE_USER
                 XT_USER:
0003ca f000          .dw DO_COLON
                 PFA_USER:
0003cb 01e5          .dw XT_DOCREATE
0003cc 0350          .dw XT_REVEAL
                 
0003cd 0213          .dw XT_COMPILE
0003ce f066          .dw PFA_DOUSER
0003cf 021e          .dw XT_COMMA
0003d0 f025          .dw XT_EXIT
                 
                 .include "words/recurse.asm"
                 
                 ; Compiler
                 ; compile the XT of the word currently being defined into the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECURSE:
0003d1 0007          .dw $0007
0003d2 6572
0003d3 7563
0003d4 7372
0003d5 0065          .db "recurse",0
0003d6 03c6          .dw VE_HEAD
                     .set VE_HEAD = VE_RECURSE
                 XT_RECURSE:
0003d7 f000          .dw DO_COLON
                 PFA_RECURSE:
                 .endif
0003d8 01dd          .dw XT_LATEST
0003d9 f08a          .dw XT_FETCH
0003da 021e          .dw XT_COMMA
0003db f025          .dw XT_EXIT
                 .include "words/immediate.asm"
                 
                 ; Compiler
                 ; set immediate flag for the most recent word definition
                 VE_IMMEDIATE:
0003dc ff09          .dw $ff09
0003dd 6d69
0003de 656d
0003df 6964
0003e0 7461
0003e1 0065          .db "immediate",0
0003e2 03d1          .dw VE_HEAD
                     .set VE_HEAD = VE_IMMEDIATE
                 XT_IMMEDIATE:
0003e3 f000          .dw DO_COLON
                 PFA_IMMEDIATE:
0003e4 0485          .dw XT_GET_CURRENT
0003e5 f366          .dw XT_FETCHE
0003e6 f0c2          .dw XT_DUP
0003e7 f3d8          .dw XT_FETCHI
0003e8 f045          .dw XT_DOLITERAL
0003e9 7fff          .dw $7fff
0003ea f224          .dw XT_AND
0003eb f0d5          .dw XT_SWAP
0003ec f37a          .dw XT_STOREI
0003ed f025          .dw XT_EXIT
                 
                 .include "words/bracketchar.asm"
                 
                 ; Tools
                 ; skip leading space delimites, place the first character of the word on the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BRACKETCHAR:
0003ee 0006          .dw $0006
0003ef 635b
0003f0 6168
0003f1 5d72          .db "[char]"
0003f2 03dc          .dw VE_HEAD
                     .set VE_HEAD = VE_BRACKETCHAR
                 XT_BRACKETCHAR:
0003f3 f000          .dw DO_COLON
                 PFA_BRACKETCHAR:
                 .endif
0003f4 0213          .dw XT_COMPILE
0003f5 f045          .dw XT_DOLITERAL
0003f6 f8ea          .dw XT_CHAR
0003f7 021e          .dw XT_COMMA
0003f8 f025          .dw XT_EXIT
                 .include "words/abort-string.asm"
                 
                 ;C         i*x x1 --       R: j*x --      x1<>0
                 ;   POSTPONE IS" POSTPONE ?ABORT ; IMMEDIATE
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORTQUOTE:
0003f9 0006          .dw $0006
0003fa 6261
0003fb 726f
0003fc 2274          .db "abort",'"'
0003fd 03ee          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORTQUOTE
                 XT_ABORTQUOTE:
0003fe f000          .dw DO_COLON
                 PFA_ABORTQUOTE:
                 .endif
0003ff f4bc          .dw XT_SQUOTE
000400 0213          .dw XT_COMPILE
000401 0410          .dw XT_QABORT
000402 f025          .DW XT_EXIT
                 .include "words/abort.asm"
                 
                 ; Exceptions
                 ; send an exception -1
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABORT:
000403 ff05          .dw $ff05
000404 6261
000405 726f
000406 0074          .db "abort",0
000407 03f9          .dw VE_HEAD
                     .set VE_HEAD = VE_ABORT
                 XT_ABORT:
000408 f000          .dw DO_COLON
                 PFA_ABORT:
                 .endif
000409 f15c          .dw XT_TRUE
00040a f83c          .dw XT_THROW
                 .include "words/q-abort.asm"
                 
                 ;   ROT IF ITYPE ABORT THEN 2DROP ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QABORT:
00040b ff06          .dw $ff06
00040c 613f
00040d 6f62
00040e 7472          .db "?abort"
00040f 0403          .dw VE_HEAD
                     .set VE_HEAD = VE_QABORT
                 XT_QABORT:
000410 f000          .dw DO_COLON
                 PFA_QABORT:
                 
                 .endif
000411 f0f2
000412 f03e              .DW XT_ROT,XT_DOCONDBRANCH
000413 0416              DEST(QABO1)
000414 f79b
000415 0408              .DW XT_ITYPE,XT_ABORT
000416 f569
000417 f025      QABO1:  .DW XT_2DROP,XT_EXIT
                 
                 .include "words/get-stack.asm"
                 
                 ; Tools
                 ; Get a stack from EEPROM
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_GET_STACK:
000418 ff09          .dw $ff09
000419 6567
00041a 2d74
00041b 7473
00041c 6361
00041d 006b          .db "get-stack",0
00041e 040b          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_STACK
                 XT_GET_STACK:
00041f f000          .dw DO_COLON
                 .endif
000420 f0c2          .dw XT_DUP
000421 f559          .dw XT_CELLPLUS
000422 f0d5          .dw XT_SWAP
000423 f366          .dw XT_FETCHE
000424 f0c2          .dw XT_DUP
000425 f110          .dw XT_TO_R
000426 f165          .dw XT_ZERO
000427 f0d5          .dw XT_SWAP    ; go from bigger to smaller addresses
000428 02dd          .dw XT_QDOCHECK
000429 f03e          .dw XT_DOCONDBRANCH
00042a 0436          DEST(PFA_N_FETCH_E2)
00042b f2ac          .dw XT_DODO
                 PFA_N_FETCH_E1:
                     ; ( ee-addr )
00042c f2bd          .dw XT_I
00042d f246          .dw XT_1MINUS
00042e f553          .dw XT_CELLS ; ( -- ee-addr i*2 )
00042f f0e0          .dw XT_OVER  ; ( -- ee-addr i*2 ee-addr )
000430 f1ae          .dw XT_PLUS  ; ( -- ee-addr ee-addr+i
000431 f366          .dw XT_FETCHE ;( -- ee-addr item_i )
000432 f0d5          .dw XT_SWAP   ;( -- item_i ee-addr )
000433 f15c          .dw XT_TRUE  ; shortcut for -1
000434 f2cb          .dw XT_DOPLUSLOOP
000435 042c          DEST(PFA_N_FETCH_E1)
                 PFA_N_FETCH_E2:
000436 f569          .dw XT_2DROP
000437 f107          .dw XT_R_FROM
000438 f025          .dw XT_EXIT
                 
                 .include "words/set-stack.asm"
                 
                 ; Tools
                 ; Write a stack to EEPROM
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SET_STACK:
000439 ff09          .dw $ff09
00043a 6573
00043b 2d74
00043c 7473
00043d 6361
00043e 006b          .db "set-stack",0
00043f 0418          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_STACK
                 XT_SET_STACK:
000440 f000          .dw DO_COLON
                 PFA_SET_STACK:
                 .endif
000441 f0e0          .dw XT_OVER
000442 f130          .dw XT_ZEROLESS
000443 f03e          .dw XT_DOCONDBRANCH
000444 0448          DEST(PFA_SET_STACK0)
000445 f045          .dw XT_DOLITERAL
000446 fffc          .dw -4
000447 f83c          .dw XT_THROW
                 PFA_SET_STACK0:
000448 f560          .dw XT_2DUP
000449 f342          .dw XT_STOREE ; ( -- i_n .. i_0 n e-addr )
00044a f0d5          .dw XT_SWAP    
00044b f165          .dw XT_ZERO
00044c 02dd          .dw XT_QDOCHECK
00044d f03e          .dw XT_DOCONDBRANCH
00044e 0455          DEST(PFA_SET_STACK2)
00044f f2ac          .dw XT_DODO
                 PFA_SET_STACK1:
000450 f559          .dw XT_CELLPLUS ; ( -- i_x e-addr )
000451 f571          .dw XT_TUCK      ; ( -- e-addr i_x e-addr
000452 f342          .dw XT_STOREE
000453 f2da          .dw XT_DOLOOP
000454 0450          DEST(PFA_SET_STACK1)
                 PFA_SET_STACK2:
000455 f0ea          .dw XT_DROP
000456 f025          .dw XT_EXIT
                 
                 .include "words/map-stack.asm"
                 
                 ; Tools
                 ; Iterate over a stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAPSTACK:
000457 ff09          .dw $ff09
000458 616d
000459 2d70
00045a 7473
00045b 6361
00045c 006b          .db "map-stack",0
00045d 0439          .dw VE_HEAD
                     .set VE_HEAD = VE_MAPSTACK
                 XT_MAPSTACK:
00045e f000          .dw DO_COLON
                 PFA_MAPSTACK:
                 .endif
00045f f0c2          .dw XT_DUP
000460 f559          .dw XT_CELLPLUS
000461 f0d5          .dw XT_SWAP
000462 f366          .dw XT_FETCHE
000463 f553          .dw XT_CELLS
000464 fd85          .dw XT_BOUNDS
000465 02dd          .dw XT_QDOCHECK
000466 f03e          .dw XT_DOCONDBRANCH
000467 047a          DEST(PFA_MAPSTACK3)
000468 f2ac          .dw XT_DODO
                 PFA_MAPSTACK1:
000469 f2bd            .dw XT_I
00046a f366            .dw XT_FETCHE   ; -- i*x XT id
00046b f0d5            .dw XT_SWAP
00046c f110            .dw XT_TO_R
00046d f117            .dw XT_R_FETCH
00046e f02f            .dw XT_EXECUTE  ; i*x id -- j*y true | i*x false
00046f f0ca            .dw XT_QDUP
000470 f03e            .dw XT_DOCONDBRANCH
000471 0476            DEST(PFA_MAPSTACK2)
000472 f107               .dw XT_R_FROM
000473 f0ea               .dw XT_DROP
000474 f2e5               .dw XT_UNLOOP
000475 f025               .dw XT_EXIT
                 PFA_MAPSTACK2:
000476 f107            .dw XT_R_FROM
000477 f3fc            .dw XT_TWO
000478 f2cb            .dw XT_DOPLUSLOOP
000479 0469            DEST(PFA_MAPSTACK1)
                 PFA_MAPSTACK3:
00047a f0ea          .dw XT_DROP
00047b f165          .dw XT_ZERO
00047c f025          .dw XT_EXIT
                 
                 ;
                 ; : map-stack ( i*x XT e-addr -- j*y )
                 ;     dup cell+ swap @e cells bounds ?do 
                 ;       ( -- i*x XT )
                 ;       i @e swap >r r@ execute
                 ;       ?dup if r> drop unloop exit then
                 ;       r>
                 ;     2 +loop drop 0
                 ; ;
                 .include "words/get-current.asm"
                 
                 ; Search Order
                 ; get the wid of the current compilation word list
                 VE_GET_CURRENT:
00047d ff0b          .dw $ff0b
00047e 6567
00047f 2d74
000480 7563
000481 7272
000482 6e65
000483 0074          .db "get-current",0
000484 0457          .dw VE_HEAD
                     .set VE_HEAD = VE_GET_CURRENT
                 XT_GET_CURRENT:
000485 f000          .dw DO_COLON
                 PFA_GET_CURRENT:
000486 f045          .dw XT_DOLITERAL
000487 0084          .dw CFG_CURRENT
000488 f366          .dw XT_FETCHE
000489 f025          .dw XT_EXIT
                 .include "words/cfg-order.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CFG_ORDER:
00048a ff09          .dw $ff09
00048b 6663
00048c 2d67
00048d 726f
00048e 6564
00048f 0072          .db "cfg-order",0
000490 047d          .dw VE_HEAD
                     .set VE_HEAD = VE_CFG_ORDER
                 XT_CFG_ORDER:
000491 f053          .dw PFA_DOVARIABLE
                 PFA_CFG_ORDER:
                 .endif
000492 0088          .dw CFG_ORDERLISTLEN
                 .include "words/cfg-recognizer.asm"
                 
                 ; Search Order
                 ; Get the current search order word list
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CFG_RECOGNIZER:
000493 ff08          .dw $ff08
000494 6663
000495 2d67
000496 6572
000497 7363          .db "cfg-recs"
000498 048a          .dw VE_HEAD
                     .set VE_HEAD = VE_CFG_RECOGNIZER
                 XT_CFG_RECOGNIZER:
000499 f053          .dw PFA_DOVARIABLE
                 PFA_CFG_RECOGNIZER:
                 .endif
00049a 009a          .dw CFG_RECOGNIZERLISTLEN
                 .include "words/compare.asm"
                 
                 ; String
                 ; compares two strings in RAM
                 VE_COMPARE:
00049b ff07          .dw $ff07
00049c 6f63
00049d 706d
00049e 7261
00049f 0065          .db "compare",0
0004a0 0493          .dw VE_HEAD
                     .set VE_HEAD = VE_COMPARE
                 XT_COMPARE:
0004a1 04a2          .dw PFA_COMPARE
                 PFA_COMPARE:
0004a2 93bf          push xh
0004a3 93af          push xl
0004a4 018c          movw temp0, tosl
0004a5 9189
0004a6 9199          loadtos
0004a7 01dc          movw xl, tosl
0004a8 9189
0004a9 9199          loadtos
0004aa 019c          movw temp2, tosl
0004ab 9189
0004ac 9199          loadtos
0004ad 01fc          movw zl, tosl
                 PFA_COMPARE_LOOP:
0004ae 90ed          ld temp4, X+
0004af 90f1          ld temp5, Z+
0004b0 14ef          cp temp4, temp5
0004b1 f451          brne PFA_COMPARE_NOTEQUAL
0004b2 950a          dec temp0
0004b3 f019          breq PFA_COMPARE_ENDREACHED2
0004b4 952a          dec temp2
0004b5 f7c1          brne PFA_COMPARE_LOOP
0004b6 c001          rjmp PFA_COMPARE_ENDREACHED
                 PFA_COMPARE_ENDREACHED2:
0004b7 952a          dec temp2
                 PFA_COMPARE_ENDREACHED:
0004b8 2b02          or temp0, temp2
0004b9 f411          brne PFA_COMPARE_CHECKLASTCHAR
0004ba 2788          clr tosl
0004bb c002          rjmp PFA_COMPARE_DONE
                 PFA_COMPARE_CHECKLASTCHAR:
                 PFA_COMPARE_NOTEQUAL:
0004bc ef8f          ser tosl
0004bd c000          rjmp PFA_COMPARE_DONE
                 
                 PFA_COMPARE_DONE:
0004be 2f98          mov tosh, tosl
0004bf 91af          pop xl
0004c0 91bf          pop xh
0004c1 940c f004     jmp_ DO_NEXT
                 .include "words/nfa2lfa.asm"
                 
                 ; System
                 ; get the link field address from the name field address
                 VE_NFA2LFA:
0004c3 ff07         .dw $ff07
0004c4 666e
0004c5 3e61
0004c6 666c
0004c7 0061         .db "nfa>lfa",0
0004c8 049b         .dw VE_HEAD
                    .set VE_HEAD = VE_NFA2LFA
                 XT_NFA2LFA:
0004c9 f000          .dw DO_COLON
                 PFA_NFA2LFA:
0004ca fc88          .dw XT_NAME2STRING
0004cb f240          .dw XT_1PLUS
0004cc f215          .dw XT_2SLASH
0004cd f1ae          .dw XT_PLUS
0004ce f025          .dw XT_EXIT
                 .elif AMFORTH_NRWW_SIZE > 4000
                 .elif AMFORTH_NRWW_SIZE > 2000
                 .else
                 .endif
                 .include "dict_appl.inc"
                 
                 ; they may be moved to the core dictionary if needed
                 
                 .include "dict/compiler2.inc" ; additional words for the compiler
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .set DICT_COMPILER2 = 1
                 
                 .include "words/set-current.asm"
                 
                 ; Search Order
                 ; set current word list to the given word list wid
                 VE_SET_CURRENT:
0004cf ff0b          .dw $ff0b
0004d0 6573
0004d1 2d74
0004d2 7563
0004d3 7272
0004d4 6e65
0004d5 0074          .db "set-current",0
0004d6 04c3          .dw VE_HEAD
                     .set VE_HEAD = VE_SET_CURRENT
                 XT_SET_CURRENT:
0004d7 f000          .dw DO_COLON
                 PFA_SET_CURRENT:
0004d8 f045          .dw XT_DOLITERAL
0004d9 0084          .dw CFG_CURRENT
0004da f342          .dw XT_STOREE
0004db f025          .dw XT_EXIT
                 .include "words/wordlist.asm"
                 
                 ; Search Order
                 ; create a new, empty wordlist
                 VE_WORDLIST:
0004dc ff08          .dw $ff08
0004dd 6f77
0004de 6472
0004df 696c
0004e0 7473          .db "wordlist"
0004e1 04cf          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDLIST
                 XT_WORDLIST:
0004e2 f000          .dw DO_COLON
                 PFA_WORDLIST:
0004e3 f5b2          .dw XT_EHERE
0004e4 f165          .dw XT_ZERO
0004e5 f0e0          .dw XT_OVER
0004e6 f342          .dw XT_STOREE
0004e7 f0c2          .dw XT_DUP
0004e8 f559          .dw XT_CELLPLUS
0004e9 fbaf          .dw XT_DOTO
0004ea f5b3          .dw PFA_EHERE
0004eb f025          .dw XT_EXIT
                 
                 .include "words/forth-wordlist.asm"
                 
                 ; Search Order
                 ; get the system default word list
                 VE_FORTHWORDLIST:
0004ec ff0e          .dw $ff0e
0004ed 6f66
0004ee 7472
0004ef 2d68
0004f0 6f77
0004f1 6472
0004f2 696c
0004f3 7473          .db "forth-wordlist"
0004f4 04dc          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHWORDLIST
                 XT_FORTHWORDLIST:
0004f5 f053          .dw PFA_DOVARIABLE
                 PFA_FORTHWORDLIST:
0004f6 0086          .dw CFG_FORTHWORDLIST
                 .include "words/code.asm"
                 
                 ; Compiler
                 ; create named entry in the dictionary, XT is the data field
                 VE_CODE:
0004f7 ff04          .dw $ff04
0004f8 6f63
0004f9 6564          .db "code"
0004fa 04ec          .dw VE_HEAD
                     .set VE_HEAD = VE_CODE
                 XT_CODE:
0004fb f000          .dw DO_COLON
                 PFA_CODE:
0004fc 01e5          .dw XT_DOCREATE
0004fd 0350          .dw XT_REVEAL
0004fe f5a9          .dw XT_DP
0004ff fbc1          .dw XT_ICELLPLUS
000500 021e          .dw XT_COMMA
000501 f025          .dw XT_EXIT
                 .include "words/end-code.asm"
                 
                 ; Compiler
                 ; finish a code definition
                 VE_ENDCODE:
000502 ff08          .dw $ff08
000503 6e65
000504 2d64
000505 6f63
000506 6564          .db "end-code"
000507 04f7          .dw VE_HEAD
                     .set VE_HEAD = VE_ENDCODE
                 XT_ENDCODE:
000508 f000          .dw DO_COLON
                 PFA_ENDCODE:
000509 0213          .dw XT_COMPILE
00050a 940c          .dw $940c
00050b 0213          .dw XT_COMPILE
00050c f004          .dw DO_NEXT
00050d f025          .dw XT_EXIT
                 .include "words/marker.asm"
                 
                 ; System Value
                 ; The eeprom address until which MARKER saves and restores the eeprom data.
                 VE_MARKER:
00050e ff08          .dw $ff08
00050f 6d28
000510 7261
000511 656b
000512 2972          .db "(marker)"
000513 0502          .dw VE_HEAD
                     .set VE_HEAD = VE_MARKER
                 XT_MARKER:
000514 f080          .dw PFA_DOVALUE1
                 PFA_MARKER:
000515 00a6          .dw EE_MARKER
000516 fbca          .dw XT_EDEFERFETCH
000517 fbd4          .dw XT_EDEFERSTORE
                 .include "words/postpone.asm"
                 
                 ; Compiler
                 ; Append the compilation semantics of "name" to the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_POSTPONE:
000518 0008          .dw $0008
000519 6f70
00051a 7473
00051b 6f70
00051c 656e          .db "postpone"
00051d 050e          .dw VE_HEAD
                     .set VE_HEAD = VE_POSTPONE
                 XT_POSTPONE:
00051e f000          .dw DO_COLON
                 PFA_POSTPONE:
                 .endif
00051f f9b9          .dw XT_PARSENAME
000520 fad9          .dw XT_FORTHRECOGNIZER
000521 fae4          .dw XT_RECOGNIZE
000522 f0c2          .dw XT_DUP
000523 f110          .dw XT_TO_R
000524 fbc1          .dw XT_ICELLPLUS
000525 fbc1          .dw XT_ICELLPLUS
000526 f3d8          .dw XT_FETCHI
000527 f02f          .dw XT_EXECUTE
000528 f107          .dw XT_R_FROM
000529 fbc1          .dw XT_ICELLPLUS
00052a f3d8          .dw XT_FETCHI
00052b 021e          .dw XT_COMMA
00052c f025          .dw XT_EXIT
                 .endif
                 
                 .include "words/applturnkey.asm"
                 
                 ; R( -- )
                 ; application specific turnkey action
                 VE_APPLTURNKEY:
00052d ff0b          .dw $ff0b
00052e 7061
00052f 6c70
000530 7574
000531 6e72
000532 656b
000533 0079          .db "applturnkey",0
000534 0518          .dw VE_HEAD
                     .set VE_HEAD = VE_APPLTURNKEY
                 XT_APPLTURNKEY:
000535 f000          .dw DO_COLON
                 PFA_APPLTURNKEY:
000536 0105          .dw XT_USART
                 
                 .if WANT_INTERRUPTS == 1
000537 fdac          .dw XT_INTON
                 .endif
                 
000538 fb7a          .dw XT_DOT_VER
000539 f7dd          .dw XT_SPACE
00053a f768          .dw XT_DOSLITERAL
00053b 000a          .dw 10
00053c 6f46
00053d 7472
00053e 6468
00053f 6975
000540 6f6e          .db "Forthduino"
000541 f79b          .dw XT_ITYPE
                 
000542 f025          .dw XT_EXIT
                 
                 
                 .set DPSTART = pc
                 .if(pc>AMFORTH_RO_SEG)
                 .endif
                 
                 .org AMFORTH_RO_SEG
                 .include "amforth-interpreter.asm"
                 
                 
                 DO_COLON:
00f000 93bf          push XH
00f001 93af          push XL          ; PUSH IP
00f002 01db          movw XL, wl
00f003 9611          adiw xl, 1
                 DO_NEXT:
                 .if WANT_INTERRUPTS == 1
00f004 14b2          cp isrflag, zerol
00f005 f499          brne DO_INTERRUPT
                 .endif
00f006 01fd          movw zl, XL        ; READ IP
00f007 2755
00f008 0fee
00f009 1fff
00f00a 1f55
00f00b bf5b
00f00c 9167
00f00d 9177          readflashcell wl, wh
00f00e 9611          adiw XL, 1        ; INC IP
                 
                 DO_EXECUTE:
00f00f 01fb          movw zl, wl
00f010 2755
00f011 0fee
00f012 1fff
00f013 1f55
00f014 bf5b
00f015 9107
00f016 9117          readflashcell temp0,temp1
00f017 01f8          movw zl, temp0
00f018 9409          ijmp
                 
                 .if WANT_INTERRUPTS == 1
                 DO_INTERRUPT:
                     ; here we deal with interrupts the forth way
00f019 939a
00f01a 938a          savetos
00f01b 2d8b          mov tosl, isrflag
00f01c 24bb          clr isrflag
00f01d 2799          clr tosh
00f01e ed68          ldi wl, LOW(XT_ISREXEC)
00f01f ef7d          ldi wh, HIGH(XT_ISREXEC)
00f020 cfee          rjmp DO_EXECUTE
                 .endif
                 .include "dict/nrww.inc"
                 
                 ; section together with the forth inner interpreter
                 
                 .include "words/exit.asm"
                 
                 ; Compiler
                 ; end of current colon word
                 VE_EXIT:
00f021 ff04          .dw $ff04
00f022 7865
00f023 7469          .db "exit"
00f024 052d          .dw VE_HEAD
                     .set VE_HEAD = VE_EXIT
                 XT_EXIT:
00f025 f026          .dw PFA_EXIT
                 PFA_EXIT:
00f026 91af          pop XL
00f027 91bf          pop XH
00f028 cfdb          jmp_ DO_NEXT
                 .include "words/execute.asm"
                 
                 ; System
                 ; execute XT
                 VE_EXECUTE:
00f029 ff07          .dw $ff07
00f02a 7865
00f02b 6365
00f02c 7475
00f02d 0065          .db "execute",0
00f02e f021          .dw VE_HEAD
                     .set VE_HEAD = VE_EXECUTE
                 XT_EXECUTE:
00f02f f030          .dw PFA_EXECUTE
                 PFA_EXECUTE:
00f030 01bc          movw wl, tosl
00f031 9189
00f032 9199          loadtos
00f033 cfdb          jmp_ DO_EXECUTE
                 .include "words/dobranch.asm"
                 
                 ; System
                 ; runtime of branch
                 ;VE_DOBRANCH:
                 ;    .dw $ff08
                 ;    .db "(branch)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOBRANCH
                 XT_DOBRANCH:
00f034 f035          .dw PFA_DOBRANCH
                 PFA_DOBRANCH:
00f035 01fd          movw zl, XL
00f036 2755
00f037 0fee
00f038 1fff
00f039 1f55
00f03a bf5b
00f03b 91a7
00f03c 91b7          readflashcell XL,XH
00f03d cfc6          jmp_ DO_NEXT
                 .include "words/docondbranch.asm"
                 
                 ; System
                 ; runtime of ?branch
                 ;VE_DOCONDBRANCH:
                 ;    .dw $ff09
                 ;    .db "(?branch)"
                 ;    .dw  VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONDBRANCH
                 XT_DOCONDBRANCH:
00f03e f03f          .dw PFA_DOCONDBRANCH
                 PFA_DOCONDBRANCH:
00f03f 2b98          or tosh, tosl
00f040 9189
00f041 9199          loadtos
00f042 f391          brbs 1, PFA_DOBRANCH ; 1 is z flag; if tos is zero (false), do the branch
00f043 9611          adiw XL, 1
00f044 cfbf          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/doliteral.asm"
                 
                 ; System
                 ; runtime of literal
                 ;VE_DOLITERAL:
                 ;    .dw $ff09
                 ;    .db "(literal)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLITERAL
                 XT_DOLITERAL:
00f045 f046          .dw PFA_DOLITERAL
                 PFA_DOLITERAL:
00f046 939a
00f047 938a          savetos
00f048 01fd          movw zl, xl
00f049 2755
00f04a 0fee
00f04b 1fff
00f04c 1f55
00f04d bf5b
00f04e 9187
00f04f 9197          readflashcell tosl,tosh
00f050 9611          adiw xl, 1
00f051 cfb2          jmp_ DO_NEXT
                 
                 .include "words/dovariable.asm"
                 
                 ; System
                 ; puts content of parameter field (1 cell) to TOS
                 ;VE_DOVARIABLE:
                 ;    .dw $ff0a
                 ;    .db "(variable)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOVARIABLE
                 XT_DOVARIABLE:
00f052 f053          .dw PFA_DOVARIABLE
                 PFA_DOVARIABLE:
00f053 939a
00f054 938a          savetos
00f055 01fb          movw zl, wl
00f056 9631          adiw zl,1
00f057 2755
00f058 0fee
00f059 1fff
00f05a 1f55
00f05b bf5b
00f05c 9187
00f05d 9197          readflashcell tosl,tosh
00f05e cfa5          jmp_ DO_NEXT
                 .include "words/doconstant.asm"
                 
                 ; System
                 ; place data field address on TOS
                 ;VE_DOCONSTANT:
                 ;    .dw $ff0a
                 ;    .db "(constant)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOCONSTANT
                 XT_DOCONSTANT:
00f05f f060          .dw PFA_DOCONSTANT
                 PFA_DOCONSTANT:
00f060 939a
00f061 938a          savetos
00f062 01cb          movw tosl, wl
00f063 9601          adiw tosl, 1
00f064 cf9f          jmp_ DO_NEXT
                 .include "words/douser.asm"
                 
                 ; System
                 ; runtime part of user
                 ;VE_DOUSER:
                 ;    .dw $ff06
                 ;    .db "(user)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOUSER
                 XT_DOUSER:
00f065 f066          .dw PFA_DOUSER
                 PFA_DOUSER:
00f066 939a
00f067 938a          savetos
00f068 01fb          movw zl, wl
00f069 9631          adiw zl, 1
00f06a 2755
00f06b 0fee
00f06c 1fff
00f06d 1f55
00f06e bf5b
00f06f 9187
00f070 9197          readflashcell tosl,tosh
00f071 0d84          add tosl, upl
00f072 1d95          adc tosh, uph
00f073 cf90          jmp_ DO_NEXT
                 .include "words/do-value.asm"
                 
                 ; System
                 ; runtime of value
                 VE_DOVALUE:
00f074 ff07          .dw $ff07
00f075 7628
00f076 6c61
00f077 6575
00f078 0029          .db "(value)", 0
00f079 f029          .dw VE_HEAD
                     .set VE_HEAD = VE_DOVALUE
                 XT_DOVALUE:
00f07a f000          .dw DO_COLON
                 PFA_DOVALUE:
00f07b 01e5          .dw XT_DOCREATE
00f07c 0350          .dw XT_REVEAL
00f07d 0213          .dw XT_COMPILE
00f07e f080          .dw PFA_DOVALUE1
00f07f f025          .dw XT_EXIT
                 PFA_DOVALUE1:
00f080 940e 0369     call_ DO_DODOES
00f082 f0c2          .dw XT_DUP
00f083 fbc1          .dw XT_ICELLPLUS
00f084 f3d8          .dw XT_FETCHI
00f085 f02f          .dw XT_EXECUTE
00f086 f025          .dw XT_EXIT
                 
                 ; : (value) <builds does> dup icell+ @i execute ;
                 .include "words/fetch.asm"
                 
                 ; Memory
                 ; read 1 cell from RAM address
                 VE_FETCH:
00f087 ff01          .dw $ff01
00f088 0040          .db "@",0
00f089 f074          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCH
                 XT_FETCH:
00f08a f08b          .dw PFA_FETCH
                 PFA_FETCH:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHRAM:
00f08b 01fc          movw zl, tosl
                     ; low byte is read before the high byte
00f08c 9181          ld tosl, z+
00f08d 9191          ld tosh, z+
00f08e cf75          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store.asm"
                 
                 ; Memory
                 ; write n to RAM memory at addr, low byte first
                 VE_STORE:
00f08f ff01          .dw $ff01
00f090 0021          .db "!",0
00f091 f087          .dw VE_HEAD
                     .set VE_HEAD = VE_STORE
                 XT_STORE:
00f092 f093          .dw PFA_STORE
                 PFA_STORE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STORERAM:
00f093 01fc          movw zl, tosl
00f094 9189
00f095 9199          loadtos
                     ; the high byte is written before the low byte
00f096 8391          std Z+1, tosh
00f097 8380          std Z+0, tosl
00f098 9189
00f099 9199          loadtos
00f09a cf69          jmp_ DO_NEXT
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/cstore.asm"
                 
                 ; Memory
                 ; store a single byte to RAM address
                 VE_CSTORE:
00f09b ff02          .dw $ff02
00f09c 2163          .db "c!"
00f09d f08f          .dw VE_HEAD
                     .set VE_HEAD = VE_CSTORE
                 XT_CSTORE:
00f09e f09f          .dw PFA_CSTORE
                 PFA_CSTORE:
00f09f 01fc          movw zl, tosl
00f0a0 9189
00f0a1 9199          loadtos
00f0a2 8380          st Z, tosl
00f0a3 9189
00f0a4 9199          loadtos
00f0a5 cf5e          jmp_ DO_NEXT
                 .include "words/cfetch.asm"
                 
                 ; Memory
                 ; fetch a single byte from memory mapped locations
                 VE_CFETCH:
00f0a6 ff02          .dw $ff02
00f0a7 4063          .db "c@"
00f0a8 f09b          .dw VE_HEAD
                     .set VE_HEAD  = VE_CFETCH
                 XT_CFETCH:
00f0a9 f0aa          .dw PFA_CFETCH
                 PFA_CFETCH:
00f0aa 01fc          movw zl, tosl
00f0ab 2799          clr tosh
00f0ac 8180          ld tosl, Z
00f0ad cf56          jmp_ DO_NEXT
                 .include "words/fetch-u.asm"
                 
                 ; Memory
                 ; read 1 cell from USER area
                 VE_FETCHU:
00f0ae ff02          .dw $ff02
00f0af 7540          .db "@u"
00f0b0 f0a6          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHU
                 XT_FETCHU:
00f0b1 f000          .dw DO_COLON
                 PFA_FETCHU:
00f0b2 f313          .dw XT_UP_FETCH
00f0b3 f1ae          .dw XT_PLUS
00f0b4 f08a          .dw XT_FETCH
00f0b5 f025          .dw XT_EXIT
                 .include "words/store-u.asm"
                 
                 ; Memory
                 ; write n to USER area at offset
                 VE_STOREU:
00f0b6 ff02          .dw $ff02
00f0b7 7521          .db "!u"
00f0b8 f0ae          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREU
                 XT_STOREU:
00f0b9 f000          .dw DO_COLON
                 PFA_STOREU:
00f0ba f313          .dw XT_UP_FETCH
00f0bb f1ae          .dw XT_PLUS
00f0bc f092          .dw XT_STORE
00f0bd f025          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/dup.asm"
                 
                 ; Stack
                 ; duplicate TOS
                 VE_DUP:
00f0be ff03          .dw $ff03
00f0bf 7564
00f0c0 0070          .db "dup",0
00f0c1 f0b6          .dw VE_HEAD
                     .set VE_HEAD = VE_DUP
                 XT_DUP:
00f0c2 f0c3          .dw PFA_DUP
                 PFA_DUP:
00f0c3 939a
00f0c4 938a          savetos
00f0c5 cf3e          jmp_ DO_NEXT
                 .include "words/qdup.asm"
                 
                 ; Stack
                 ; duplicate TOS if non-zero
                 VE_QDUP:
00f0c6 ff04          .dw $ff04
00f0c7 643f
00f0c8 7075          .db "?dup"
00f0c9 f0be          .dw VE_HEAD
                     .set VE_HEAD = VE_QDUP
                 XT_QDUP:
00f0ca f0cb          .dw PFA_QDUP
                 PFA_QDUP:
00f0cb 2f08          mov temp0, tosl
00f0cc 2b09          or temp0, tosh
00f0cd f011          breq PFA_QDUP1
00f0ce 939a
00f0cf 938a          savetos
                 PFA_QDUP1:
00f0d0 cf33          jmp_ DO_NEXT
                 .include "words/swap.asm"
                 
                 ; Stack
                 ; swaps the two top level stack cells
                 VE_SWAP:
00f0d1 ff04          .dw $ff04
00f0d2 7773
00f0d3 7061          .db "swap"
00f0d4 f0c6          .dw VE_HEAD
                     .set VE_HEAD = VE_SWAP
                 XT_SWAP:
00f0d5 f0d6          .dw PFA_SWAP
                 PFA_SWAP:
00f0d6 018c          movw temp0, tosl
00f0d7 9189
00f0d8 9199          loadtos
00f0d9 931a          st -Y, temp1
00f0da 930a          st -Y, temp0
00f0db cf28          jmp_ DO_NEXT
                 .include "words/over.asm"
                 
                 ; Stack
                 ; Place a copy of x1 on top of the stack
                 VE_OVER:
00f0dc ff04          .dw $ff04
00f0dd 766f
00f0de 7265          .db "over"
00f0df f0d1          .dw VE_HEAD
                     .set VE_HEAD = VE_OVER
                 XT_OVER:
00f0e0 f0e1          .dw PFA_OVER
                 PFA_OVER:
00f0e1 939a
00f0e2 938a          savetos
00f0e3 818a          ldd tosl, Y+2
00f0e4 819b          ldd tosh, Y+3
                 
00f0e5 cf1e          jmp_ DO_NEXT
                 .include "words/drop.asm"
                 
                 ; Stack
                 ; drop TOS
                 VE_DROP:
00f0e6 ff04          .dw $ff04
00f0e7 7264
00f0e8 706f          .db "drop"
00f0e9 f0dc          .dw VE_HEAD
                     .set VE_HEAD = VE_DROP
                 XT_DROP:
00f0ea f0eb          .dw PFA_DROP
                 PFA_DROP:
00f0eb 9189
00f0ec 9199          loadtos
00f0ed cf16          jmp_ DO_NEXT
                 .include "words/rot.asm"
                 
                 ; Stack
                 ; rotate the three top level cells
                 VE_ROT:
00f0ee ff03          .dw $ff03
00f0ef 6f72
00f0f0 0074          .db "rot",0
00f0f1 f0e6          .dw VE_HEAD
                     .set VE_HEAD = VE_ROT
                 XT_ROT:
00f0f2 f0f3          .dw PFA_ROT
                 PFA_ROT:
00f0f3 018c          movw temp0, tosl
00f0f4 9129          ld temp2, Y+
00f0f5 9139          ld temp3, Y+ 
00f0f6 9189
00f0f7 9199          loadtos
                         
00f0f8 933a          st -Y, temp3
00f0f9 932a          st -Y, temp2
00f0fa 931a          st -Y, temp1
00f0fb 930a          st -Y, temp0
                 
00f0fc cf07          jmp_ DO_NEXT
                 .include "words/nip.asm"
                 
                 ; Stack
                 ; Remove Second of Stack
                 VE_NIP:
00f0fd ff03          .dw $ff03
00f0fe 696e
00f0ff 0070          .db "nip",0
00f100 f0ee          .dw VE_HEAD
                     .set VE_HEAD = VE_NIP
                 XT_NIP:
00f101 f102          .dw PFA_NIP
                 PFA_NIP:
00f102 9622          adiw yl, 2
00f103 cf00          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/r_from.asm"
                 
                 ; Stack
                 ; move TOR to TOS
                 VE_R_FROM:
00f104 ff02          .dw $ff02
00f105 3e72          .db "r>"
00f106 f0fd          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FROM
                 XT_R_FROM:
00f107 f108          .dw PFA_R_FROM
                 PFA_R_FROM:
00f108 939a
00f109 938a          savetos
00f10a 918f          pop tosl
00f10b 919f          pop tosh
00f10c cef7          jmp_ DO_NEXT
                 .include "words/to_r.asm"
                 
                 ; Stack
                 ; move TOS to TOR
                 VE_TO_R:
00f10d ff02          .dw $ff02
00f10e 723e          .db ">r"
00f10f f104          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_R
                 XT_TO_R:
00f110 f111          .dw PFA_TO_R
                 PFA_TO_R:
00f111 939f          push tosh
00f112 938f          push tosl
00f113 cfd7          jmp_ PFA_DROP
                 .include "words/r_fetch.asm"
                 
                 ; Stack
                 ; fetch content of TOR
                 VE_R_FETCH:
00f114 ff02          .dw $ff02
00f115 4072          .db "r@"
00f116 f10d          .dw VE_HEAD
                     .set VE_HEAD = VE_R_FETCH
                 XT_R_FETCH:
00f117 f118          .dw PFA_R_FETCH
                 PFA_R_FETCH:
00f118 939a
00f119 938a          savetos
00f11a 918f          pop tosl
00f11b 919f          pop tosh
00f11c 939f          push tosh
00f11d 938f          push tosl
00f11e cee5          jmp_ DO_NEXT
                 
                 .include "words/not-equal.asm"
                 
                 ; Compare
                 ; true if n1 is not equal to n2
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOTEQUAL:
00f11f ff02          .dw $ff02
00f120 3e3c          .db "<>"
00f121 f114          .dw VE_HEAD
                     .set VE_HEAD = VE_NOTEQUAL
                 XT_NOTEQUAL:
00f122 f000          .dw DO_COLON
                 PFA_NOTEQUAL:
                 .endif
                 
00f123 f3f0
00f124 f129
00f125 f025          .DW XT_EQUAL,XT_ZEROEQUAL,XT_EXIT
                 .include "words/equalzero.asm"
                 
                 ; Compare
                 ; compare with 0 (zero)
                 VE_ZEROEQUAL:
00f126 ff02          .dw $ff02
00f127 3d30          .db "0="
00f128 f11f          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROEQUAL
                 XT_ZEROEQUAL:
00f129 f12a          .dw PFA_ZEROEQUAL
                 PFA_ZEROEQUAL:
00f12a 2b98          or tosh, tosl
00f12b f5e1          brne PFA_ZERO1
00f12c c032          rjmp PFA_TRUE1
                 .include "words/lesszero.asm"
                 
                 ; Compare
                 ; compare with zero
                 VE_ZEROLESS:
00f12d ff02          .dw $ff02
00f12e 3c30          .db "0<"
00f12f f126          .dw VE_HEAD
                     .set VE_HEAD = VE_ZEROLESS
                 XT_ZEROLESS:
00f130 f131          .dw PFA_ZEROLESS
                 PFA_ZEROLESS:
00f131 fd97          sbrc tosh,7
00f132 c02c          rjmp PFA_TRUE1
00f133 c034          rjmp PFA_ZERO1
                 .include "words/greaterzero.asm"
                 
                 ; Compare
                 ; true if n1 is greater than 0
                 VE_GREATERZERO:
00f134 ff02          .dw $ff02
00f135 3e30          .db "0>"
00f136 f12d          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATERZERO
                 XT_GREATERZERO:
00f137 f138          .dw PFA_GREATERZERO
                 PFA_GREATERZERO:
00f138 1582          cp tosl, zerol
00f139 0593          cpc tosh, zeroh
00f13a f16c          brlt PFA_ZERO1
00f13b f161          brbs 1, PFA_ZERO1
00f13c c022          rjmp PFA_TRUE1
                 .include "words/d-greaterzero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is greater 0
                 VE_DGREATERZERO:
00f13d ff03          .dw $ff03
00f13e 3064
00f13f 003e          .db "d0>",0
00f140 f134          .dw VE_HEAD
                     .set VE_HEAD = VE_DGREATERZERO
                 XT_DGREATERZERO:
00f141 f142          .dw PFA_DGREATERZERO
                 PFA_DGREATERZERO:
00f142 1593          cp tosh, zeroh
00f143 f03c          brlt PFA_DGREATERZERO_FALSE ; if MSBit is set, d:arg is negative, we are done (false).
00f144 0582          cpc tosl, zerol
00f145 9189
00f146 9199          loadtos
00f147 0582          cpc tosl, zerol
00f148 0593          cpc tosh, zeroh
00f149 f0f1          brbs 1, PFA_ZERO1           ; if all 4 Bytes of d:arg are zero, we are done (false).
00f14a c014          rjmp PFA_TRUE1              ; if we get this far, d:arg was positive! (true)
                 PFA_DGREATERZERO_FALSE:
00f14b 01c1          movw tosl, zerol            ; ZERO
00f14c cfb5          rjmp PFA_NIP                ; NIP
                 .include "words/d-lesszero.asm"
                 
                 ; Compare
                 ; compares if a double double cell number is less than 0
                 VE_DXT_ZEROLESS:
00f14d ff03          .dw $ff03
00f14e 3064
00f14f 003c          .db "d0<",0
00f150 f13d          .dw VE_HEAD
                     .set VE_HEAD = VE_DXT_ZEROLESS
                 XT_DXT_ZEROLESS:
00f151 f152          .dw PFA_DXT_ZEROLESS
                 PFA_DXT_ZEROLESS:
00f152 9622          adiw Y,2
00f153 fd97          sbrc tosh,7
00f154 940c f15f     jmp PFA_TRUE1
00f156 940c f168     jmp PFA_ZERO1
                 
                 .include "words/true.asm"
                 
                 ; Arithmetics
                 ; leaves the value -1 (true) on TOS
                 VE_TRUE:
00f158 ff04          .dw $ff04
00f159 7274
00f15a 6575          .db "true"
00f15b f14d          .dw VE_HEAD
                     .set VE_HEAD = VE_TRUE
                 XT_TRUE:
00f15c f15d          .dw PFA_TRUE
                 PFA_TRUE:
00f15d 939a
00f15e 938a          savetos
                 PFA_TRUE1:
00f15f ef8f          ser tosl
00f160 ef9f          ser tosh
00f161 cea2          jmp_ DO_NEXT
                 .include "words/zero.asm"
                 
                 ; Arithmetics
                 ; place a value 0 on TOS
                 VE_ZERO:
00f162 ff01          .dw $ff01
00f163 0030          .db "0",0
00f164 f158          .dw VE_HEAD
                     .set VE_HEAD = VE_ZERO
                 XT_ZERO:
00f165 f166          .dw PFA_ZERO
                 PFA_ZERO:
00f166 939a
00f167 938a          savetos
                 PFA_ZERO1:
00f168 01c1          movw tosl, zerol
00f169 ce9a          jmp_ DO_NEXT
                 .include "words/uless.asm"
                 
                 ; Compare
                 ; true if u1 < u2 (unsigned)
                 VE_ULESS:
00f16a ff02          .dw $ff02
00f16b 3c75          .db "u<"
00f16c f162          .dw VE_HEAD
                     .set VE_HEAD = VE_ULESS
                 XT_ULESS:
00f16d f16e          .dw PFA_ULESS
                 PFA_ULESS:
00f16e 9129          ld temp2, Y+
00f16f 9139          ld temp3, Y+
00f170 1782          cp tosl, temp2
00f171 0793          cpc tosh, temp3
00f172 f3a8          brlo PFA_ZERO1
00f173 f3a1          brbs 1, PFA_ZERO1
00f174 cfea          jmp_ PFA_TRUE1
                 .include "words/u-greater.asm"
                 
                 ; Compare
                 ; true if u1 > u2 (unsigned)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UGREATER:
00f175 ff02          .dw $ff02
00f176 3e75          .db "u>"
00f177 f16a          .dw VE_HEAD
                     .set VE_HEAD = VE_UGREATER
                 XT_UGREATER:
00f178 f000          .dw DO_COLON
                 PFA_UGREATER:
                 .endif
00f179 f0d5          .DW XT_SWAP
00f17a f16d          .dw XT_ULESS
00f17b f025          .dw XT_EXIT
                 .include "words/less.asm"
                 
                 ; Compare
                 ; true if n1 is less than n2
                     VE_LESS:
00f17c ff01          .dw $ff01
00f17d 003c          .db "<",0
00f17e f175          .dw VE_HEAD
                     .set VE_HEAD = VE_LESS
                 XT_LESS:
00f17f f180          .dw PFA_LESS
                 PFA_LESS:
00f180 9129          ld temp2, Y+
00f181 9139          ld temp3, Y+
00f182 1728          cp temp2, tosl
00f183 0739          cpc temp3, tosh
                 PFA_LESSDONE:
00f184 f71c          brge PFA_ZERO1
00f185 cfd9          rjmp PFA_TRUE1
                 .include "words/greater.asm"
                 
                 ; Compare
                 ; flag is true if n1 is greater than n2
                 VE_GREATER:
00f186 ff01          .dw $ff01
00f187 003e          .db ">",0
00f188 f17c          .dw VE_HEAD
                     .set VE_HEAD = VE_GREATER
                 XT_GREATER:
00f189 f18a          .dw PFA_GREATER
                 PFA_GREATER:
00f18a 9129          ld temp2, Y+
00f18b 9139          ld temp3, Y+
00f18c 1728          cp temp2, tosl
00f18d 0739          cpc temp3, tosh
                 PFA_GREATERDONE:
00f18e f2cc          brlt PFA_ZERO1
00f18f f2c1          brbs 1, PFA_ZERO1
00f190 cfce          rjmp PFA_TRUE1
                 
                 .include "words/log2.asm"
                 
                 ; Arithmetics
                 ; logarithm to base 2 or highest set bitnumber
                 VE_LOG2:
00f191 ff04          .dw $ff04
00f192 6f6c
00f193 3267          .db "log2"
00f194 f186          .dw VE_HEAD
                     .set VE_HEAD = VE_LOG2
                 XT_LOG2:
00f195 f196          .dw PFA_LOG2
                 PFA_LOG2:
00f196 01fc          movw zl, tosl
00f197 2799          clr tosh
00f198 e180          ldi tosl, 16
                 PFA_LOG2_1:
00f199 958a          dec tosl
00f19a f022          brmi PFA_LOG2_2 ; wrong data
00f19b 0fee          lsl  zl
00f19c 1fff          rol  zh
00f19d f7d8          brcc PFA_LOG2_1
00f19e ce65          jmp_ DO_NEXT
                 
                 PFA_LOG2_2:
00f19f 959a          dec tosh
00f1a0 ce63          jmp_ DO_NEXT
                 .include "words/minus.asm"
                 
                 ; Arithmetics
                 ; subtract n2 from n1
                 VE_MINUS:
00f1a1 ff01          .dw $ff01
00f1a2 002d          .db "-",0
00f1a3 f191          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUS
                 XT_MINUS:
00f1a4 f1a5          .dw PFA_MINUS
                 PFA_MINUS:
00f1a5 9109          ld temp0, Y+
00f1a6 9119          ld temp1, Y+
00f1a7 1b08          sub temp0, tosl
00f1a8 0b19          sbc temp1, tosh
00f1a9 01c8          movw tosl, temp0
00f1aa ce59          jmp_ DO_NEXT
                 .include "words/plus.asm"
                 
                 ; Arithmetics
                 ; add n1 and n2
                 VE_PLUS:
00f1ab ff01          .dw $ff01
00f1ac 002b          .db "+",0
00f1ad f1a1          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUS
                 XT_PLUS:
00f1ae f1af          .dw PFA_PLUS
                 PFA_PLUS:
00f1af 9109          ld temp0, Y+
00f1b0 9119          ld temp1, Y+
00f1b1 0f80          add tosl, temp0
00f1b2 1f91          adc tosh, temp1
00f1b3 ce50          jmp_ DO_NEXT
                 .include "words/mstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 cells to a double cell
                 VE_MSTAR:
00f1b4 ff02          .dw $ff02
00f1b5 2a6d          .db "m*"
00f1b6 f1ab          .dw VE_HEAD
                     .set VE_HEAD = VE_MSTAR
                 XT_MSTAR:
00f1b7 f1b8          .dw PFA_MSTAR
                 PFA_MSTAR:
00f1b8 018c          movw temp0, tosl
00f1b9 9189
00f1ba 9199          loadtos
00f1bb 019c          movw temp2, tosl
                     ; high cell ah*bh
00f1bc 0231          muls temp3, temp1
00f1bd 0170          movw temp4, r0
                     ; low cell  al*bl
00f1be 9f20          mul  temp2, temp0
00f1bf 01c0          movw tosl, r0
                     ; signed ah*bl
00f1c0 0330          mulsu temp3, temp0
00f1c1 08f3          sbc   temp5, zeroh
00f1c2 0d90          add   tosh,  r0
00f1c3 1ce1          adc   temp4, r1
00f1c4 1cf3          adc   temp5, zeroh
                     
                     ; signed al*bh
00f1c5 0312          mulsu temp1, temp2
00f1c6 08f3          sbc   temp5, zeroh
00f1c7 0d90          add   tosh,  r0
00f1c8 1ce1          adc   temp4, r1
00f1c9 1cf3          adc   temp5, zeroh
                 
00f1ca 939a
00f1cb 938a          savetos
00f1cc 01c7          movw tosl, temp4
00f1cd ce36          jmp_ DO_NEXT
                 .include "words/umslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division ud / u2 with remainder
                 VE_UMSLASHMOD:
00f1ce ff06          .dw $ff06
00f1cf 6d75
00f1d0 6d2f
00f1d1 646f          .db "um/mod"
00f1d2 f1b4          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSLASHMOD
                 XT_UMSLASHMOD:
00f1d3 f1d4          .dw PFA_UMSLASHMOD
                 PFA_UMSLASHMOD:
00f1d4 017c          movw temp4, tosl
                 
00f1d5 9129          ld temp2, Y+
00f1d6 9139          ld temp3, Y+
                   
00f1d7 9109          ld temp0, Y+
00f1d8 9119          ld temp1, Y+
                 
                 ;; unsigned 32/16 -> 16r16 divide
                 
                 PFA_UMSLASHMODmod:
                 
                   ; set loop counter
00f1d9 e140          ldi temp6,$10
                 
                 PFA_UMSLASHMODmod_loop:
                     ; shift left, saving high bit
00f1da 2755          clr temp7
00f1db 0f00          lsl temp0
00f1dc 1f11          rol temp1
00f1dd 1f22          rol temp2
00f1de 1f33          rol temp3
00f1df 1f55          rol temp7
                 
                   ; try subtracting divisor
00f1e0 152e          cp temp2, temp4
00f1e1 053f          cpc temp3, temp5
00f1e2 0552          cpc temp7,zerol
                 
00f1e3 f018          brcs PFA_UMSLASHMODmod_loop_control
                 
                 PFA_UMSLASHMODmod_subtract:
                     ; dividend is large enough
                     ; do the subtraction for real
                     ; and set lowest bit
00f1e4 9503          inc temp0
00f1e5 192e          sub temp2, temp4
00f1e6 093f          sbc temp3, temp5
                 
                 PFA_UMSLASHMODmod_loop_control:
00f1e7 954a          dec  temp6
00f1e8 f789          brne PFA_UMSLASHMODmod_loop
                 
                 PFA_UMSLASHMODmod_done:
                     ; put remainder on stack
00f1e9 933a          st -Y,temp3
00f1ea 932a          st -Y,temp2
                 
                     ; put quotient on stack
00f1eb 01c8          movw tosl, temp0
00f1ec ce17          jmp_ DO_NEXT
                 .include "words/umstar.asm"
                 
                 ; Arithmetics
                 ; multiply 2 unsigned cells to a double cell
                 VE_UMSTAR:
00f1ed ff03          .dw $ff03
00f1ee 6d75
00f1ef 002a          .db "um*",0
00f1f0 f1ce          .dw VE_HEAD
                     .set VE_HEAD = VE_UMSTAR
                 XT_UMSTAR:
00f1f1 f1f2          .dw PFA_UMSTAR
                 PFA_UMSTAR:
00f1f2 018c          movw temp0, tosl
00f1f3 9189
00f1f4 9199          loadtos
                     ; result: (temp3*temp1)* 65536 + (temp3*temp0 + temp1*temp2) * 256 + (temp0 * temp2)
                     ; low bytes
00f1f5 9f80          mul tosl,temp0
00f1f6 01f0          movw zl, r0
00f1f7 2722          clr temp2
00f1f8 2733          clr temp3
                     ; middle bytes
00f1f9 9f90          mul tosh, temp0
00f1fa 0df0          add zh, r0
00f1fb 1d21          adc temp2, r1
00f1fc 1d33          adc temp3, zeroh
                         
00f1fd 9f81          mul tosl, temp1
00f1fe 0df0          add zh, r0
00f1ff 1d21          adc temp2, r1
00f200 1d33          adc temp3, zeroh
                     
00f201 9f91          mul tosh, temp1
00f202 0d20          add temp2, r0
00f203 1d31          adc temp3, r1
00f204 01cf          movw tosl, zl
00f205 939a
00f206 938a          savetos
00f207 01c9          movw tosl, temp2
00f208 cdfb          jmp_ DO_NEXT
                 
                 .include "words/invert.asm"
                 
                 ; Arithmetics
                 ; 1-complement of TOS
                 VE_INVERT:
00f209 ff06          .dw $ff06
00f20a 6e69
00f20b 6576
00f20c 7472          .db "invert"
00f20d f1ed          .dw VE_HEAD
                     .set VE_HEAD = VE_INVERT
                 XT_INVERT:
00f20e f20f          .dw PFA_INVERT
                 PFA_INVERT:
00f20f 9580          com tosl
00f210 9590          com tosh
00f211 cdf2          jmp_ DO_NEXT
                 .include "words/2slash.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift right
                 VE_2SLASH:
00f212 ff02          .dw $ff02
00f213 2f32          .db "2/"
00f214 f209          .dw VE_HEAD
                     .set VE_HEAD = VE_2SLASH
                 XT_2SLASH:
00f215 f216          .dw PFA_2SLASH
                 PFA_2SLASH:
00f216 9595          asr tosh
00f217 9587          ror tosl
00f218 cdeb          jmp_ DO_NEXT
                 .include "words/2star.asm"
                 
                 ; Arithmetics
                 ; arithmetic shift left, filling with zero
                 VE_2STAR:
00f219 ff02          .dw $ff02
00f21a 2a32          .db "2*"
00f21b f212          .dw VE_HEAD
                     .set VE_HEAD = VE_2STAR
                 XT_2STAR:
00f21c f21d          .dw PFA_2STAR
                 PFA_2STAR:
00f21d 0f88          lsl tosl
00f21e 1f99          rol tosh
00f21f cde4          jmp_ DO_NEXT
                 .include "words/and.asm"
                 
                 ; Logic
                 ; bitwise and
                 VE_AND:
00f220 ff03          .dw $ff03
00f221 6e61
00f222 0064          .db "and",0
00f223 f219          .dw VE_HEAD
                     .set VE_HEAD = VE_AND
                 XT_AND:
00f224 f225          .dw PFA_AND
                 PFA_AND:
00f225 9109          ld temp0, Y+
00f226 9119          ld temp1, Y+
00f227 2380          and tosl, temp0
00f228 2391          and tosh, temp1
00f229 cdda          jmp_ DO_NEXT
                 .include "words/or.asm"
                 
                 ; Logic
                 ; logical or
                 VE_OR:
00f22a ff02          .dw $ff02
00f22b 726f          .db "or"
00f22c f220          .dw VE_HEAD
                     .set VE_HEAD = VE_OR
                 XT_OR:
00f22d f22e          .dw PFA_OR
                 PFA_OR:
00f22e 9109          ld temp0, Y+
00f22f 9119          ld temp1, Y+
00f230 2b80          or tosl, temp0
00f231 2b91          or tosh, temp1
00f232 cdd1          jmp_ DO_NEXT
                 
                 .include "words/xor.asm"
                 
                 ; Logic
                 ; exclusive or
                 VE_XOR:
00f233 ff03          .dw $ff03
00f234 6f78
00f235 0072          .db "xor",0
00f236 f22a          .dw VE_HEAD
                     .set VE_HEAD = VE_XOR
                 XT_XOR:
00f237 f238          .dw PFA_XOR
                 PFA_XOR:
00f238 9109          ld temp0, Y+
00f239 9119          ld temp1, Y+
00f23a 2780          eor tosl, temp0
00f23b 2791          eor tosh, temp1
00f23c cdc7          jmp_ DO_NEXT
                 
                 .include "words/1plus.asm"
                 
                 ; Arithmetics
                 ; optimized increment
                 VE_1PLUS:
00f23d ff02          .dw $ff02
00f23e 2b31          .db "1+"
00f23f f233          .dw VE_HEAD
                     .set VE_HEAD = VE_1PLUS
                 XT_1PLUS:
00f240 f241          .dw PFA_1PLUS
                 PFA_1PLUS:
00f241 9601          adiw tosl,1
00f242 cdc1          jmp_ DO_NEXT
                 .include "words/1minus.asm"
                 
                 ; Arithmetics
                 ; optimized decrement
                 VE_1MINUS:
00f243 ff02          .dw $ff02 
00f244 2d31          .db "1-"
00f245 f23d          .dw VE_HEAD
                     .set VE_HEAD = VE_1MINUS
                 XT_1MINUS:
00f246 f247          .dw PFA_1MINUS
                 PFA_1MINUS:
00f247 9701          sbiw tosl, 1
00f248 cdbb          jmp_ DO_NEXT
                 .include "words/q-negate.asm"
                 
                 ;   0< IF NEGATE THEN ;        ...a common factor
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QNEGATE:
00f249 ff07          .dw $ff07
00f24a 6e3f
00f24b 6765
00f24c 7461
../../common\words/q-negate.asm(11): warning: .cseg .db misalignment - padding zero byte
00f24d 0065          .db "?negate"
00f24e f243          .dw VE_HEAD
                     .set VE_HEAD = VE_QNEGATE
                 XT_QNEGATE:
00f24f f000          .dw DO_COLON
                 PFA_QNEGATE:
                 
                 .endif
00f250 f130
00f251 f03e              .DW XT_ZEROLESS,XT_DOCONDBRANCH
00f252 f254              DEST(QNEG1)
00f253 f63a              .DW XT_NEGATE
00f254 f025      QNEG1:  .DW XT_EXIT
                 .include "words/lshift.asm"
                 
                 ; Arithmetics
                 ; logically shift n1 left n2 times
                 VE_LSHIFT:
00f255 ff06          .dw $ff06
00f256 736c
00f257 6968
00f258 7466          .db "lshift"
00f259 f249          .dw VE_HEAD
                     .set VE_HEAD = VE_LSHIFT
                 XT_LSHIFT:
00f25a f25b          .dw PFA_LSHIFT
                 PFA_LSHIFT:
00f25b 01fc          movw zl, tosl
00f25c 9189
00f25d 9199          loadtos
                 PFA_LSHIFT1:
00f25e 9731          sbiw zl, 1
00f25f f01a          brmi PFA_LSHIFT2
00f260 0f88          lsl tosl
00f261 1f99          rol tosh
00f262 cffb          rjmp PFA_LSHIFT1
                 PFA_LSHIFT2:
00f263 cda0          jmp_ DO_NEXT
                 
                 .include "words/rshift.asm"
                 
                 ; Arithmetics
                 ; shift n1 n2-times logically right
                 VE_RSHIFT:
00f264 ff06          .dw $ff06
00f265 7372
00f266 6968
00f267 7466          .db "rshift"
00f268 f255          .dw VE_HEAD
                     .set VE_HEAD = VE_RSHIFT
                 XT_RSHIFT:
00f269 f26a          .dw PFA_RSHIFT
                 PFA_RSHIFT:
00f26a 01fc          movw zl, tosl
00f26b 9189
00f26c 9199          loadtos
                 PFA_RSHIFT1:
00f26d 9731          sbiw zl, 1
00f26e f01a          brmi PFA_RSHIFT2
00f26f 9596          lsr tosh
00f270 9587          ror tosl
00f271 cffb          rjmp PFA_RSHIFT1
                 PFA_RSHIFT2:
00f272 cd91          jmp_ DO_NEXT
                 
                 .include "words/plusstore.asm"
                 
                 ; Arithmetics
                 ; add n to content of RAM address a-addr
                 VE_PLUSSTORE:
00f273 ff02          .dw $ff02
00f274 212b          .db "+!"
00f275 f264          .dw VE_HEAD
                     .set VE_HEAD = VE_PLUSSTORE
                 XT_PLUSSTORE:
00f276 f277          .dw PFA_PLUSSTORE
                 PFA_PLUSSTORE:
00f277 01fc          movw zl, tosl
00f278 9189
00f279 9199          loadtos
00f27a 8120          ldd temp2, Z+0
00f27b 8131          ldd temp3, Z+1
00f27c 0f82          add tosl, temp2
00f27d 1f93          adc tosh, temp3
00f27e 8380          std Z+0, tosl
00f27f 8391          std Z+1, tosh
00f280 9189
00f281 9199          loadtos
00f282 cd81          jmp_ DO_NEXT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/rpfetch.asm"
                 
                 ; Stack
                 ; current return stack pointer address
                 VE_RP_FETCH:
00f283 ff03          .dw $ff03
00f284 7072
00f285 0040          .db "rp@",0
00f286 f273          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_FETCH
                 XT_RP_FETCH:
00f287 f288          .dw PFA_RP_FETCH
                 PFA_RP_FETCH:
00f288 939a
00f289 938a          savetos
00f28a b78d          in tosl, SPL
00f28b b79e          in tosh, SPH
00f28c cd77          jmp_ DO_NEXT
                 .include "words/rpstore.asm"
                 
                 ; Stack
                 ; set return stack pointer
                 VE_RP_STORE:
00f28d ff03          .dw $ff03
00f28e 7072
00f28f 0021          .db "rp!",0
00f290 f283          .dw VE_HEAD
                     .set VE_HEAD = VE_RP_STORE
                 XT_RP_STORE:
00f291 f292          .dw PFA_RP_STORE
                 PFA_RP_STORE:
00f292 b72f          in temp2, SREG
00f293 94f8          cli
00f294 bf8d          out SPL, tosl
00f295 bf9e          out SPH, tosh
00f296 bf2f          out SREG, temp2
00f297 9189
00f298 9199          loadtos
00f299 cd6a          jmp_ DO_NEXT
                 .include "words/spfetch.asm"
                 
                 ; Stack
                 ; current data stack pointer
                 VE_SP_FETCH:
00f29a ff03          .dw $ff03
00f29b 7073
00f29c 0040          .db "sp@",0
00f29d f28d          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_FETCH
                 XT_SP_FETCH:
00f29e f29f          .dw PFA_SP_FETCH
                 PFA_SP_FETCH:
00f29f 939a
00f2a0 938a          savetos
00f2a1 01ce          movw tosl, yl
00f2a2 cd61          jmp_ DO_NEXT
                 .include "words/spstore.asm"
                 
                 ; Stack
                 ; set data stack pointer to addr
                 VE_SP_STORE:
00f2a3 ff03          .dw $ff03
00f2a4 7073
00f2a5 0021          .db "sp!",0
00f2a6 f29a          .dw VE_HEAD
                     .set VE_HEAD = VE_SP_STORE
                 XT_SP_STORE:
00f2a7 f2a8          .dw PFA_SP_STORE
                 PFA_SP_STORE:
00f2a8 01ec          movw yl, tosl
00f2a9 9189
00f2aa 9199          loadtos
00f2ab cd58          jmp_ DO_NEXT
                 
                 .include "words/dodo.asm"
                 
                 ; System
                 ; runtime of do
                 ;VE_DODO:
                 ;    .dw $ff04
                 ;    .db "(do)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DODO
                 XT_DODO:
00f2ac f2ad          .dw PFA_DODO
                 PFA_DODO:
00f2ad 9129          ld temp2, Y+
00f2ae 9139          ld temp3, Y+  ; limit
                 PFA_DODO1:
00f2af e8e0          ldi zl, $80
00f2b0 0f3e          add temp3, zl
00f2b1 1b82          sub  tosl, temp2
00f2b2 0b93          sbc  tosh, temp3
                 
00f2b3 933f          push temp3
00f2b4 932f          push temp2    ; limit  ( --> limit + $8000)
00f2b5 939f          push tosh
00f2b6 938f          push tosl     ; start -> index ( --> index - (limit - $8000)
00f2b7 9189
00f2b8 9199          loadtos
00f2b9 cd4a          jmp_ DO_NEXT
                 .include "words/i.asm"
                 
                 ; Compiler
                 ; current loop counter
                 VE_I:
00f2ba ff01          .dw $FF01
00f2bb 0069          .db "i",0
00f2bc f2a3          .dw VE_HEAD
                     .set VE_HEAD = VE_I
                 XT_I:
00f2bd f2be          .dw PFA_I
                 PFA_I:
00f2be 939a
00f2bf 938a          savetos
00f2c0 918f          pop tosl
00f2c1 919f          pop tosh  ; index
00f2c2 91ef          pop zl
00f2c3 91ff          pop zh    ; limit
00f2c4 93ff          push zh
00f2c5 93ef          push zl
00f2c6 939f          push tosh
00f2c7 938f          push tosl
00f2c8 0f8e          add tosl, zl
00f2c9 1f9f          adc tosh, zh
00f2ca cd39          jmp_ DO_NEXT
                 .include "words/doplusloop.asm"
                 
                 ; System
                 ; runtime of +loop
                 ;VE_DOPLUSLOOP:
                 ;    .dw $ff07
                 ;    .db "(+loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOPLUSLOOP
                 XT_DOPLUSLOOP:
00f2cb f2cc          .dw PFA_DOPLUSLOOP
                 PFA_DOPLUSLOOP:
00f2cc 91ef          pop zl
00f2cd 91ff          pop zh
00f2ce 0fe8          add zl, tosl
00f2cf 1ff9          adc zh, tosh
00f2d0 9189
00f2d1 9199          loadtos
00f2d2 f01b          brvs PFA_DOPLUSLOOP_LEAVE
                     ; next cycle
                 PFA_DOPLUSLOOP_NEXT:
                     ; next iteration
00f2d3 93ff          push zh
00f2d4 93ef          push zl
00f2d5 cd5f          rjmp PFA_DOBRANCH ; read next cell from dictionary and jump to its destination
                 PFA_DOPLUSLOOP_LEAVE:
00f2d6 910f          pop  temp0
00f2d7 911f          pop  temp1  ; remove limit
00f2d8 9611          adiw xl, 1  ; skip branch-back address
00f2d9 cd2a          jmp_ DO_NEXT
                 .include "words/doloop.asm"
                 
                 ; System
                 ; runtime of loop
                 ;VE_DOLOOP:
                 ;    .dw $ff06
                 ;    .db "(loop)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOLOOP
                 XT_DOLOOP:
00f2da f2db          .dw PFA_DOLOOP
                 PFA_DOLOOP:
00f2db 91ef          pop zl
00f2dc 91ff          pop zh
00f2dd 9631          adiw zl,1
00f2de f3bb          brvs PFA_DOPLUSLOOP_LEAVE
00f2df cff3          jmp_ PFA_DOPLUSLOOP_NEXT
                 .include "words/unloop.asm"
                 
                 ; Compiler
                 ; remove loop-sys, exit the loop and continue execution after it
                 VE_UNLOOP:
00f2e0 ff06          .dw $ff06
00f2e1 6e75
00f2e2 6f6c
00f2e3 706f          .db "unloop"
00f2e4 f2ba          .dw VE_HEAD
                     .set VE_HEAD = VE_UNLOOP
                 XT_UNLOOP:
00f2e5 f2e6          .dw PFA_UNLOOP
                 PFA_UNLOOP:
00f2e6 911f          pop temp1
00f2e7 910f          pop temp0
00f2e8 911f          pop temp1
00f2e9 910f          pop temp0
00f2ea cd19          jmp_ DO_NEXT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 
                 .include "words/cmove_g.asm"
                 
                 ; Memory
                 ; copy data in RAM from higher to lower addresses.
                 VE_CMOVE_G:
00f2eb ff06          .dw $ff06
00f2ec 6d63
00f2ed 766f
00f2ee 3e65          .db "cmove>"
00f2ef f2e0          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE_G
                 XT_CMOVE_G:
00f2f0 f2f1          .dw PFA_CMOVE_G
                 PFA_CMOVE_G:
00f2f1 93bf          push xh
00f2f2 93af          push xl
00f2f3 91e9          ld zl, Y+
00f2f4 91f9          ld zh, Y+ ; addr-to
00f2f5 91a9          ld xl, Y+
00f2f6 91b9          ld xh, Y+ ; addr-from
00f2f7 2f09          mov temp0, tosh
00f2f8 2b08          or temp0, tosl
00f2f9 f041          brbs 1, PFA_CMOVE_G1
00f2fa 0fe8          add zl, tosl
00f2fb 1ff9          adc zh, tosh
00f2fc 0fa8          add xl, tosl
00f2fd 1fb9          adc xh, tosh
                 PFA_CMOVE_G2:
00f2fe 911e          ld temp1, -X
00f2ff 9312          st -Z, temp1
00f300 9701          sbiw tosl, 1
00f301 f7e1          brbc 1, PFA_CMOVE_G2
                 PFA_CMOVE_G1:
00f302 91af          pop xl
00f303 91bf          pop xh
00f304 9189
00f305 9199          loadtos
00f306 ccfd          jmp_ DO_NEXT
                 .include "words/byteswap.asm"
                 
                 ; Arithmetics
                 ; exchange the bytes of the TOS
                 VE_BYTESWAP:
00f307 ff02          .dw $ff02
00f308 3c3e          .db "><"
00f309 f2eb          .dw VE_HEAD
                     .set VE_HEAD = VE_BYTESWAP
                 XT_BYTESWAP:
00f30a f30b          .dw PFA_BYTESWAP
                 PFA_BYTESWAP:
00f30b 2f09          mov temp0, tosh
00f30c 2f98          mov tosh, tosl
00f30d 2f80          mov tosl, temp0
00f30e ccf5          jmp_ DO_NEXT
                 .include "words/up.asm"
                 
                 ; System Variable
                 ; get user area pointer
                 VE_UP_FETCH:
00f30f ff03          .dw $ff03
00f310 7075
00f311 0040          .db "up@",0
00f312 f307          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_FETCH
                 XT_UP_FETCH:
00f313 f314          .dw PFA_UP_FETCH
                 PFA_UP_FETCH:
00f314 939a
00f315 938a          savetos
00f316 01c2          movw tosl, upl
00f317 ccec          jmp_ DO_NEXT
                 
                 ; ( addr -- ) 
                 ; System Variable
                 ; set user area pointer
                 VE_UP_STORE:
00f318 ff03          .dw $ff03
00f319 7075
00f31a 0021          .db "up!",0
00f31b f30f          .dw VE_HEAD
                     .set VE_HEAD = VE_UP_STORE
                 XT_UP_STORE:
00f31c f31d          .dw PFA_UP_STORE
                 PFA_UP_STORE:
00f31d 012c          movw upl, tosl
00f31e 9189
00f31f 9199          loadtos
00f320 cce3          jmp_ DO_NEXT
                 .include "words/2to_r.asm"
                 
                 ; Stack
                 ; move DTOS to TOR
                 VE_2TO_R:
00f321 ff03          .dw $ff03
00f322 3e32
00f323 0072          .db "2>r",0
00f324 f318          .dw VE_HEAD
                     .set VE_HEAD = VE_2TO_R
                 XT_2TO_R:
00f325 f326          .dw PFA_2TO_R
                 PFA_2TO_R:
00f326 01fc          movw zl, tosl
00f327 9189
00f328 9199          loadtos
00f329 939f          push tosh
00f32a 938f          push tosl
00f32b 93ff          push zh
00f32c 93ef          push zl
00f32d 9189
00f32e 9199          loadtos
00f32f ccd4          jmp_ DO_NEXT
                 .include "words/2r_from.asm"
                 
                 ; Stack
                 ; move DTOR to TOS
                 VE_2R_FROM:
00f330 ff03          .dw $ff03
00f331 7232
00f332 003e          .db "2r>",0
00f333 f321          .dw VE_HEAD
                     .set VE_HEAD = VE_2R_FROM
                 XT_2R_FROM:
00f334 f335          .dw PFA_2R_FROM
                 PFA_2R_FROM:
00f335 939a
00f336 938a          savetos
00f337 91ef          pop zl
00f338 91ff          pop zh
00f339 918f          pop tosl
00f33a 919f          pop tosh
00f33b 939a
00f33c 938a          savetos
00f33d 01cf          movw tosl, zl
00f33e ccc5          jmp_ DO_NEXT
                 
                 .include "words/store-e.asm"
                 
                 ; Memory
                 ; write n (2bytes) to eeprom address
                 VE_STOREE:
00f33f ff02          .dw $ff02
00f340 6521          .db "!e"
00f341 f330          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREE
                 XT_STOREE:
00f342 f343          .dw PFA_STOREE
                 PFA_STOREE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_STOREE0:
00f343 01fc          movw zl, tosl
00f344 9189
00f345 9199          loadtos
00f346 b72f          in_ temp2, SREG
00f347 94f8          cli
00f348 d028          rcall PFA_FETCHE2
00f349 b500          in_  temp0, EEDR
00f34a 1708          cp temp0,tosl
00f34b f009          breq PFA_STOREE3
00f34c d00b          rcall PFA_STOREE1
                 PFA_STOREE3:
00f34d 9631          adiw zl,1
00f34e d022          rcall PFA_FETCHE2
00f34f b500          in_  temp0, EEDR
00f350 1709          cp temp0,tosh
00f351 f011          breq PFA_STOREE4
00f352 2f89          mov tosl, tosh
00f353 d004          rcall PFA_STOREE1
                 PFA_STOREE4:
00f354 bf2f          out_ SREG, temp2
00f355 9189
00f356 9199          loadtos
00f357 ccac          jmp_ DO_NEXT
                     
                 PFA_STOREE1:
00f358 99f9          sbic EECR, EEPE
00f359 cffe          rjmp PFA_STOREE1
                 
                 PFA_STOREE2: ; estore_wait_low_spm:
00f35a b707          in_ temp0, SPMCSR
00f35b fd00          sbrc temp0,SPMEN
00f35c cffd          rjmp PFA_STOREE2
                 
00f35d bdf2          out_ EEARH,zh
00f35e bde1          out_ EEARL,zl
00f35f bd80          out_ EEDR, tosl
00f360 9afa          sbi EECR,EEMPE
00f361 9af9          sbi EECR,EEPE
                 
00f362 9508          ret
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/fetch-e.asm"
                 
                 ; Memory
                 ; read 1 cell from eeprom
                 VE_FETCHE:
00f363 ff02          .dw $ff02
00f364 6540          .db "@e"
00f365 f33f          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHE
                 XT_FETCHE:
00f366 f367          .dw PFA_FETCHE
                 PFA_FETCHE:
                 .if WANT_UNIFIED == 1
                 .endif
                 PFA_FETCHE1:
00f367 b72f          in_ temp2, SREG
00f368 94f8          cli
00f369 01fc          movw zl, tosl
00f36a d006          rcall PFA_FETCHE2
00f36b b580          in_ tosl, EEDR
                 
00f36c 9631          adiw zl,1
                 
00f36d d003          rcall PFA_FETCHE2
00f36e b590          in_  tosh, EEDR
00f36f bf2f          out_ SREG, temp2
00f370 cc93          jmp_ DO_NEXT
                 
                 PFA_FETCHE2:
00f371 99f9          sbic EECR, EEPE
00f372 cffe          rjmp PFA_FETCHE2
                 
00f373 bdf2          out_ EEARH,zh
00f374 bde1          out_ EEARL,zl
                 
00f375 9af8          sbi EECR,EERE
00f376 9508          ret
                 
                 .if WANT_UNIFIED == 1
                 .endif
                 .include "words/store-i.asm"
                 
                 ; System Value
                 ; Deferred action to write a single 16bit cell to flash
                 VE_STOREI:
00f377 ff02          .dw $ff02
00f378 6921          .db "!i"
00f379 f363          .dw VE_HEAD
                     .set VE_HEAD = VE_STOREI
                 XT_STOREI:
00f37a fc29          .dw PFA_DODEFER1
                 PFA_STOREI:
00f37b 00a4          .dw EE_STOREI
00f37c fbca          .dw XT_EDEFERFETCH
00f37d fbd4          .dw XT_EDEFERSTORE
                 .if FLASHEND > $10000
                 .else
                   .include "words/store-i_nrww.asm"
                 
                 ; Memory
                 ; writes n to flash memory using assembly code (code to be placed in boot loader section)
                 VE_DO_STOREI_NRWW:
00f37e ff09          .dw $ff09
00f37f 2128
00f380 2d69
00f381 726e
00f382 7777
00f383 0029          .db "(!i-nrww)",0
00f384 f377          .dw VE_HEAD
                     .set VE_HEAD = VE_DO_STOREI_NRWW
                 XT_DO_STOREI:
00f385 f386          .dw PFA_DO_STOREI_NRWW
                 PFA_DO_STOREI_NRWW:
                   ; store status register
00f386 b71f        in temp1,SREG
00f387 931f        push temp1
00f388 94f8        cli
                 
00f389 019c        movw temp2, tosl ; save the (word) address
00f38a 9189
00f38b 9199        loadtos          ; get the new value for the flash cell
00f38c 93af        push xl
00f38d 93bf        push xh
00f38e 93cf        push yl
00f38f 93df        push yh
00f390 d009        rcall DO_STOREI_atmega
00f391 91df        pop yh
00f392 91cf        pop yl
00f393 91bf        pop xh
00f394 91af        pop xl
                   ; finally clear the stack
00f395 9189
00f396 9199        loadtos
00f397 911f        pop temp1
                   ; restore status register (and interrupt enable flag)
00f398 bf1f        out SREG,temp1
                 
00f399 cc6a        jmp_ DO_NEXT
                 
                 ; 
                 DO_STOREI_atmega:
                   ; write data to temp page buffer
                   ; use the values in tosl/tosh at the
                   ; appropiate place
00f39a d010        rcall pageload
                 
                   ; erase page if needed
                   ; it is needed if a bit goes from 0 to 1
00f39b 94e0        com temp4
00f39c 94f0        com temp5
00f39d 218e        and tosl, temp4
00f39e 219f        and tosh, temp5
00f39f 2b98        or tosh, tosl
00f3a0 f019        breq DO_STOREI_writepage 
00f3a1 01f9          movw zl, temp2
00f3a2 e002          ldi temp0,(1<<PGERS)
00f3a3 d023          rcall dospm
                 
                 DO_STOREI_writepage:
                   ; write page
00f3a4 01f9        movw zl, temp2
00f3a5 e004        ldi temp0,(1<<PGWRT)
00f3a6 d020        rcall dospm
                 
                   ; reenable RWW section
00f3a7 01f9        movw zl, temp2
00f3a8 e100        ldi temp0,(1<<RWWSRE)
00f3a9 d01d        rcall dospm
00f3aa 9508        ret
                 
                 ; load the desired page
                 .equ pagemask = ~ ( PAGESIZE - 1 )
                 pageload:
00f3ab 01f9        movw zl, temp2
                   ; get the beginning of page
00f3ac 78e0        andi zl,low(pagemask)
00f3ad 7fff        andi zh,high(pagemask)
00f3ae 01ef        movw y, z
                   ; loop counter (in words)
00f3af e8a0        ldi xl,low(pagesize)
00f3b0 e0b0        ldi xh,high(pagesize)
                 pageload_loop:
                   ; we need the current flash value anyways
00f3b1 01fe        movw z, y
00f3b2 2755
00f3b3 0fee
00f3b4 1fff
00f3b5 1f55
00f3b6 bf5b
00f3b7 9147
00f3b8 9157        readflashcell temp6, temp7 ; destroys Z
                   ; now check: if Z points to the same cell as temp2/3, we want the new data
00f3b9 01fe        movw z, y
00f3ba 17e2        cp zl, temp2
00f3bb 07f3        cpc zh, temp3
00f3bc f011        breq pageload_newdata
00f3bd 010a          movw r0, temp6
00f3be c002          rjmp pageload_cont
                 pageload_newdata:
00f3bf 017a          movw temp4, temp6
00f3c0 010c          movw r0, tosl
                 pageload_cont:
00f3c1 2700        clr temp0
00f3c2 d004        rcall dospm
00f3c3 9621        adiw y, 1
00f3c4 9711        sbiw x, 1
00f3c5 f759        brne pageload_loop
                 
                 pageload_done:
00f3c6 9508        ret
                 
                 
                 ;; dospm
                 ;;
                 ;; execute spm instruction
                 ;;   temp0 holds the value for SPMCR
                 
                 dospm:
                 dospm_wait_ee:
00f3c7 99f9        sbic EECR, EEPE
00f3c8 cffe        rjmp dospm_wait_ee
                 dospm_wait_spm:
00f3c9 b717        in_  temp1, SPMCSR
00f3ca fd10        sbrc temp1, SPMEN
00f3cb cffd        rjmp dospm_wait_spm
                 
                   ; turn the word addres into a byte address
00f3cc 2755
00f3cd 0fee
00f3ce 1fff
00f3cf 1f55
00f3d0 bf5b        writeflashcell
                   ; execute spm
00f3d1 6001        ori temp0, (1<<SPMEN)
00f3d2 bf07        out_ SPMCSR,temp0
00f3d3 95e8        spm
00f3d4 9508        ret
                 .endif
                 .include "words/fetch-i.asm"
                 
                 ; Memory
                 ; read 1 cell from flash
                 VE_FETCHI:
00f3d5 ff02          .dw $ff02
00f3d6 6940          .db "@i"
00f3d7 f37e          .dw VE_HEAD
                     .set VE_HEAD = VE_FETCHI
                 XT_FETCHI:
00f3d8 f3d9          .dw PFA_FETCHI
                 PFA_FETCHI:
00f3d9 01fc          movw zl, tosl
00f3da 2755
00f3db 0fee
00f3dc 1fff
00f3dd 1f55
00f3de bf5b
00f3df 9187
00f3e0 9197          readflashcell tosl,tosh
00f3e1 cc22          jmp_ DO_NEXT
                 .include "words/2literal.asm"
                 
                 ; Compiler
                 ; compile a cell pair literal in colon definitions
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2LITERAL:
00f3e2 0008          .dw $0008
00f3e3 6c32
00f3e4 7469
00f3e5 7265
00f3e6 6c61          .db "2literal"
00f3e7 f3d5          .dw VE_HEAD
                     .set VE_HEAD = VE_2LITERAL
                 XT_2LITERAL:
00f3e8 f000          .dw DO_COLON
                 PFA_2LITERAL:
                 .endif
00f3e9 f0d5          .dw XT_SWAP
00f3ea 0234          .dw XT_LITERAL
00f3eb 0234          .dw XT_LITERAL
00f3ec f025          .dw XT_EXIT
                 .include "words/equal.asm"
                 
                 ; Compare
                 ; compares two values for equality
                 VE_EQUAL:
00f3ed ff01          .dw $ff01
00f3ee 003d          .db "=",0
00f3ef f3e2          .dw VE_HEAD
                     .set VE_HEAD = VE_EQUAL
                 XT_EQUAL:
00f3f0 f000          .dw DO_COLON
                 PFA_EQUAL:
00f3f1 f1a4          .dw XT_MINUS
00f3f2 f129          .dw XT_ZEROEQUAL
00f3f3 f025          .dw XT_EXIT
                 .include "words/num-constants.asm"
                 
                 .endif
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ONE:
00f3f4 ff01          .dw $ff01
00f3f5 0031          .db "1",0
00f3f6 f3ed          .dw VE_HEAD
                     .set VE_HEAD = VE_ONE
                 XT_ONE:
00f3f7 f053          .dw PFA_DOVARIABLE
                 PFA_ONE:
                 .endif
00f3f8 0001              .DW 1
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TWO:
00f3f9 ff01          .dw $ff01
00f3fa 0032          .db "2",0
00f3fb f3f4          .dw VE_HEAD
                     .set VE_HEAD = VE_TWO
                 XT_TWO:
00f3fc f053          .dw PFA_DOVARIABLE
                 PFA_TWO:
                 .endif
00f3fd 0002              .DW 2
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MINUSONE:
00f3fe ff02          .dw $ff02
00f3ff 312d          .db "-1"
00f400 f3f9          .dw VE_HEAD
                     .set VE_HEAD = VE_MINUSONE
                 XT_MINUSONE:
00f401 f053          .dw PFA_DOVARIABLE
                 PFA_MINUSONE:
                 .endif
00f402 ffff              .DW -1
                 
                 .if AMFORTH_NRWW_SIZE>8000
                   .include "dict/core_8k.inc"
                 
                 .include "words/n_to_r.asm"
                 
                 ; Stack
                 ; move n items from data stack to return stack
                 VE_N_TO_R:
00f403 ff03          .dw $ff03
00f404 3e6e
00f405 0072          .db "n>r",0
00f406 f3fe          .dw VE_HEAD
                     .set VE_HEAD = VE_N_TO_R
                 XT_N_TO_R:
00f407 f408          .dw PFA_N_TO_R
                 PFA_N_TO_R:
00f408 01fc          movw zl, tosl
00f409 2f08          mov  temp0, tosl
                 PFA_N_TO_R1:
00f40a 9189
00f40b 9199          loadtos
00f40c 939f          push tosh
00f40d 938f          push tosl
00f40e 950a          dec temp0
00f40f f7d1          brne PFA_N_TO_R1
00f410 93ef          push zl
00f411 93ff          push zh
00f412 9189
00f413 9199          loadtos
00f414 cbef          jmp_ DO_NEXT
                 .include "words/n_r_from.asm"
                 
                 ; Stack
                 ; move n items from return stack to data stack
                 VE_N_R_FROM:
00f415 ff03          .dw $ff03
00f416 726e
00f417 003e          .db "nr>",0
00f418 f403          .dw VE_HEAD
                     .set VE_HEAD = VE_N_R_FROM
                 XT_N_R_FROM:
00f419 f41a          .dw PFA_N_R_FROM
                 PFA_N_R_FROM:
00f41a 939a
00f41b 938a          savetos
00f41c 91ff          pop zh
00f41d 91ef          pop zl
00f41e 2f0e          mov  temp0, zl
                 PFA_N_R_FROM1:
00f41f 918f          pop tosl
00f420 919f          pop tosh
00f421 939a
00f422 938a          savetos
00f423 950a          dec temp0
00f424 f7d1          brne PFA_N_R_FROM1
00f425 01cf          movw tosl, zl
00f426 cbdd          jmp_ DO_NEXT
                 
                 .include "words/d-2star.asm"
                 
                 ; Arithmetics
                 ; shift a double cell left
                 VE_D2STAR:
00f427 ff03          .dw $ff03
00f428 3264
00f429 002a          .db "d2*",0
00f42a f415          .dw VE_HEAD
                     .set VE_HEAD = VE_D2STAR
                 XT_D2STAR:
00f42b f42c          .dw PFA_D2STAR
                 PFA_D2STAR:
00f42c 9109          ld temp0, Y+
00f42d 9119          ld temp1, Y+
00f42e 0f00          lsl temp0
00f42f 1f11          rol temp1
00f430 1f88          rol tosl
00f431 1f99          rol tosh
00f432 931a          st -Y, temp1
00f433 930a          st -Y, temp0
00f434 cbcf          jmp_ DO_NEXT
                 .include "words/d-2slash.asm"
                 
                 ; Arithmetics
                 ; shift a double cell value right
                 VE_D2SLASH:
00f435 ff03          .dw $ff03
00f436 3264
00f437 002f          .db "d2/",0
00f438 f427          .dw VE_HEAD
                     .set VE_HEAD = VE_D2SLASH
                 XT_D2SLASH:
00f439 f43a          .dw PFA_D2SLASH
                 PFA_D2SLASH:
00f43a 9109          ld temp0, Y+
00f43b 9119          ld temp1, Y+
00f43c 9595          asr tosh
00f43d 9587          ror tosl
00f43e 9517          ror temp1
00f43f 9507          ror temp0
00f440 931a          st -Y, temp1
00f441 930a          st -Y, temp0
00f442 cbc1          jmp_ DO_NEXT
                 .include "words/d-plus.asm"
                 
                 ; Arithmetics
                 ; add 2 double cell values
                 VE_DPLUS:
00f443 ff02          .dw $ff02
00f444 2b64          .db "d+"
00f445 f435          .dw VE_HEAD
                     .set VE_HEAD = VE_DPLUS
                 XT_DPLUS:
00f446 f447          .dw PFA_DPLUS
                 PFA_DPLUS:
00f447 9129          ld temp2, Y+
00f448 9139          ld temp3, Y+
                 
00f449 90e9          ld temp4, Y+
00f44a 90f9          ld temp5, Y+
00f44b 9149          ld temp6, Y+
00f44c 9159          ld temp7, Y+
                 
00f44d 0f24          add temp2, temp6
00f44e 1f35          adc temp3, temp7
00f44f 1d8e          adc tosl, temp4
00f450 1d9f          adc tosh, temp5
                     
00f451 933a          st -Y, temp3
00f452 932a          st -Y, temp2
00f453 cbb0          jmp_ DO_NEXT
                 .include "words/d-minus.asm"
                 
                 ; Arithmetics
                 ; subtract d2 from d1 
                 VE_DMINUS:
00f454 ff02          .dw $ff02
00f455 2d64          .db "d-"
00f456 f443          .dw VE_HEAD
                     .set VE_HEAD = VE_DMINUS
                 XT_DMINUS:
00f457 f458          .dw PFA_DMINUS
                 PFA_DMINUS:
00f458 9129          ld temp2, Y+
00f459 9139          ld temp3, Y+
                 
00f45a 90e9          ld temp4, Y+
00f45b 90f9          ld temp5, Y+
00f45c 9149          ld temp6, Y+
00f45d 9159          ld temp7, Y+
                 
00f45e 1b42          sub temp6, temp2
00f45f 0b53          sbc temp7, temp3
00f460 0ae8          sbc temp4, tosl
00f461 0af9          sbc temp5, tosh
                 
00f462 935a          st -Y, temp7
00f463 934a          st -Y, temp6
00f464 01c7          movw tosl, temp4
00f465 cb9e          jmp_ DO_NEXT
                 .include "words/d-invert.asm"
                 
                 ; Arithmetics
                 ; invert all bits in the double cell value
                 VE_DINVERT:
00f466 ff07          .dw $ff07
00f467 6964
00f468 766e
00f469 7265
00f46a 0074          .db "dinvert",0
00f46b f454          .dw VE_HEAD
                     .set VE_HEAD = VE_DINVERT
                 XT_DINVERT:
00f46c f46d          .dw PFA_DINVERT
                 PFA_DINVERT:
00f46d 9109          ld temp0, Y+
00f46e 9119          ld temp1, Y+
00f46f 9580          com tosl
00f470 9590          com tosh
00f471 9500          com temp0
00f472 9510          com temp1
00f473 931a          st -Y, temp1
00f474 930a          st -Y, temp0
00f475 cb8e          jmp_ DO_NEXT
                 .include "words/u-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDOT:
00f476 ff02          .dw $ff02
00f477 2e75          .db "u."
00f478 f466          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOT
                 XT_UDOT:
00f479 f000          .dw DO_COLON
                 PFA_UDOT:
                 .endif
00f47a f165          .dw XT_ZERO
00f47b f725          .dw XT_UDDOT
00f47c f025          .dw XT_EXIT
                 ; : u.        ( us -- )    0 ud. ;
                 .include "words/u-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with single cells numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDOTR:
00f47d ff03          .dw $ff03
00f47e 2e75
00f47f 0072          .db "u.r",0
00f480 f476          .dw VE_HEAD
                     .set VE_HEAD = VE_UDOTR
                 XT_UDOTR:
00f481 f000          .dw DO_COLON
                 PFA_UDOTR:
                 .endif
00f482 f165          .dw XT_ZERO
00f483 f0d5          .dw XT_SWAP
00f484 f72e          .dw XT_UDDOTR
00f485 f025          .dw XT_EXIT
                 ; : u.r       ( s n -- )   0 swap ud.r ;
                 
                 .include "words/show-wordlist.asm"
                 
                 ; Tools
                 ; prints the name of the words in a wordlist
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHOWWORDLIST:
00f486 ff0d          .dw $ff0d
00f487 6873
00f488 776f
00f489 772d
00f48a 726f
00f48b 6c64
00f48c 7369
00f48d 0074          .db "show-wordlist",0
00f48e f47d          .dw VE_HEAD
                     .set VE_HEAD = VE_SHOWWORDLIST
                 XT_SHOWWORDLIST:
00f48f f000          .dw DO_COLON
                 PFA_SHOWWORDLIST:
                 .endif
00f490 f045          .dw XT_DOLITERAL
00f491 f495          .dw XT_SHOWWORD
00f492 f0d5          .dw XT_SWAP
00f493 fc6d          .dw XT_TRAVERSEWORDLIST
00f494 f025          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SHOWWORD:
00f495 f000          .dw DO_COLON
                 PFA_SHOWWORD:
                 .endif
00f496 fc88          .dw XT_NAME2STRING
00f497 f79b          .dw XT_ITYPE
00f498 f7dd          .dw XT_SPACE         ; ( -- addr n)
00f499 f15c          .dw XT_TRUE
00f49a f025          .dw XT_EXIT
                 .include "words/words.asm"
                 
                 ; Tools
                 ; prints a list of all (visible) words in the dictionary
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_WORDS:
00f49b ff05          .dw $ff05
00f49c 6f77
00f49d 6472
00f49e 0073          .db "words",0
00f49f f486          .dw VE_HEAD
                     .set VE_HEAD = VE_WORDS
                 XT_WORDS:
00f4a0 f000          .dw DO_COLON
                 PFA_WORDS:
                 .endif
00f4a1 f045          .dw XT_DOLITERAL
00f4a2 008a          .dw CFG_ORDERLISTLEN+2
00f4a3 f366          .dw XT_FETCHE
00f4a4 f48f          .dw XT_SHOWWORDLIST
00f4a5 f025          .dw XT_EXIT
                 
                 
                 .include "words/pick.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PICK:
00f4a6 ff04          .dw $ff04
00f4a7 6970
00f4a8 6b63          .db "pick"
00f4a9 f49b          .dw VE_HEAD
                     .set VE_HEAD = VE_PICK
                 XT_PICK:
00f4aa f000          .dw DO_COLON
                 PFA_PICK:
                 .endif
00f4ab f240          .dw XT_1PLUS
00f4ac f553          .dw XT_CELLS
00f4ad f29e          .dw XT_SP_FETCH
00f4ae f1ae          .dw XT_PLUS
00f4af f08a          .dw XT_FETCH
00f4b0 f025          .dw XT_EXIT
                 .include "words/dot-quote.asm"
                 
                 ; Compiler
                 ; compiles string into dictionary to be printed at runtime
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOTSTRING:
00f4b1 0002          .dw $0002
00f4b2 222e          .db ".",$22
00f4b3 f4a6          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTSTRING
                 XT_DOTSTRING:
00f4b4 f000          .dw DO_COLON
                 PFA_DOTSTRING:
                 .endif
00f4b5 f4bc          .dw XT_SQUOTE
00f4b6 0213          .dw XT_COMPILE
00f4b7 f79b          .dw XT_ITYPE
00f4b8 f025          .dw XT_EXIT
                 .include "words/squote.asm"
                 
                 ; Compiler
                 ; compiles a string to flash, at runtime leaves ( -- flash-addr count) on stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SQUOTE:
00f4b9 0002        .dw $0002
00f4ba 2273        .db "s",$22
00f4bb f4b1        .dw VE_HEAD
                   .set VE_HEAD = VE_SQUOTE
                 XT_SQUOTE:
00f4bc f000          .dw DO_COLON
                 PFA_SQUOTE:
                 .endif
00f4bd f045          .dw XT_DOLITERAL
00f4be 0022          .dw 34   ; 0x22 
00f4bf f98c          .dw XT_PARSE       ; ( -- addr n)
00f4c0 f546          .dw XT_STATE
00f4c1 f08a          .dw XT_FETCH
00f4c2 f03e          .dw XT_DOCONDBRANCH
00f4c3 f4c5          DEST(PFA_SQUOTE1)
00f4c4 023f            .dw XT_SLITERAL
                 PFA_SQUOTE1:
00f4c5 f025          .dw XT_EXIT
                 
                 .include "words/fill.asm"
                 
                 ; Memory
                 ; fill u bytes memory beginning at a-addr with character c
                 VE_FILL:
00f4c6 ff04          .dw $ff04
00f4c7 6966
00f4c8 6c6c          .db "fill"
00f4c9 f4b9          .dw VE_HEAD
                     .set VE_HEAD = VE_FILL
                 XT_FILL:
00f4ca f000          .dw DO_COLON
                 PFA_FILL:
00f4cb f0f2          .dw XT_ROT
00f4cc f0f2          .dw XT_ROT
00f4cd f0ca
00f4ce f03e          .dw XT_QDUP,XT_DOCONDBRANCH
00f4cf f4d7          DEST(PFA_FILL2)
00f4d0 fd85          .dw XT_BOUNDS
00f4d1 f2ac          .dw XT_DODO
                 PFA_FILL1:
00f4d2 f0c2          .dw XT_DUP
00f4d3 f2bd          .dw XT_I
00f4d4 f09e          .dw XT_CSTORE  ; ( -- c c-addr)
00f4d5 f2da          .dw XT_DOLOOP
00f4d6 f4d2          .dw PFA_FILL1
                 PFA_FILL2:
00f4d7 f0ea          .dw XT_DROP
00f4d8 f025          .dw XT_EXIT
                 
                 .include "words/environment.asm"
                 
                 ; System Value
                 ; word list identifier of the environmental search list
                 VE_ENVIRONMENT:
00f4d9 ff0b          .dw $ff0b
00f4da 6e65
00f4db 6976
00f4dc 6f72
00f4dd 6d6e
00f4de 6e65
00f4df 0074          .db "environment",0
00f4e0 f4c6          .dw VE_HEAD
                     .set VE_HEAD = VE_ENVIRONMENT
                 XT_ENVIRONMENT:
00f4e1 f053          .dw PFA_DOVARIABLE
                 PFA_ENVIRONMENT:
00f4e2 0082          .dw CFG_ENVIRONMENT
                 .include "words/env-wordlists.asm"
                 
                 ; Environment
                 ; maximum number of wordlists in the dictionary search order
                 VE_ENVWORDLISTS:
00f4e3 ff09          .dw $ff09
00f4e4 6f77
00f4e5 6472
00f4e6 696c
00f4e7 7473
00f4e8 0073          .db "wordlists",0
00f4e9 0000          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVWORDLISTS
                 XT_ENVWORDLISTS:
00f4ea f000          .dw DO_COLON
                 PFA_ENVWORDLISTS:
00f4eb f045          .dw XT_DOLITERAL
00f4ec 0008          .dw NUMWORDLISTS
00f4ed f025          .dw XT_EXIT
                 .include "words/env-slashpad.asm"
                 
                 ; Environment
                 ; Size of the PAD buffer in bytes
                 VE_ENVSLASHPAD:
00f4ee ff04          .dw $ff04
00f4ef 702f
00f4f0 6461          .db "/pad"
00f4f1 f4e3          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHPAD
                 XT_ENVSLASHPAD:
00f4f2 f000          .dw DO_COLON
                 PFA_ENVSLASHPAD:
00f4f3 f29e          .dw XT_SP_FETCH
00f4f4 f57f          .dw XT_PAD
00f4f5 f1a4          .dw XT_MINUS
00f4f6 f025          .dw XT_EXIT
                 .include "words/env-slashhold.asm"
                 
                 ; Environment
                 ; size of the pictured numeric output buffer in bytes
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENVSLASHHOLD:
00f4f7 ff05          .dw $ff05
00f4f8 682f
00f4f9 6c6f
00f4fa 0064          .db "/hold",0
00f4fb f4ee          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVSLASHHOLD
                 XT_ENVSLASHHOLD:
00f4fc f000          .dw DO_COLON
                 PFA_ENVSLASHHOLD:
                 .endif
00f4fd f57f          .dw XT_PAD
00f4fe f5ba          .dw XT_HERE
00f4ff f1a4          .dw XT_MINUS
00f500 f025          .dw XT_EXIT
                 .include "words/env-forthname.asm"
                 
                 ; Environment
                 ; flash address of the amforth name string
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHNAME:
00f501 ff0a          .dw $ff0a
00f502 6f66
00f503 7472
00f504 2d68
00f505 616e
00f506 656d          .db "forth-name"
00f507 f4f7          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHNAME
                 XT_ENV_FORTHNAME:
00f508 f000          .dw DO_COLON
                 PFA_EN_FORTHNAME:
00f509 f768          .dw XT_DOSLITERAL
00f50a 0007          .dw 7
                 .endif
00f50b 6d61
00f50c 6f66
00f50d 7472
../../common\words/env-forthname.asm(22): warning: .cseg .db misalignment - padding zero byte
00f50e 0068          .db "amforth"
                 .if cpu_msp430==1
                 .endif
00f50f f025          .dw XT_EXIT
                 .include "words/env-forthversion.asm"
                 
                 ; Environment
                 ; version number of amforth
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_FORTHVERSION:
00f510 ff07          .dw $ff07
00f511 6576
00f512 7372
00f513 6f69
00f514 006e          .db "version",0
00f515 f501          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_FORTHVERSION
                 XT_ENV_FORTHVERSION:
00f516 f000          .dw DO_COLON
                 PFA_EN_FORTHVERSION:
                 .endif
00f517 f045          .dw XT_DOLITERAL
00f518 0045          .dw 69
00f519 f025          .dw XT_EXIT
                 .include "words/env-cpu.asm"
                 
                 ; Environment
                 ; flash address of the CPU identification string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ENV_CPU:
00f51a ff03          .dw $ff03
00f51b 7063
00f51c 0075          .db "cpu",0
00f51d f510          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_CPU
                 XT_ENV_CPU:
00f51e f000          .dw DO_COLON
                 PFA_EN_CPU:
                 .endif
00f51f f045          .dw XT_DOLITERAL
00f520 0075          .dw mcu_name
00f521 f7c7          .dw XT_ICOUNT
00f522 f025          .dw XT_EXIT
                 .include "words/env-mcuinfo.asm"
                 
                 ; Environment
                 ; flash address of some CPU specific parameters
                 VE_ENV_MCUINFO:
00f523 ff08          .dw $ff08
00f524 636d
00f525 2d75
00f526 6e69
00f527 6f66          .db "mcu-info"
00f528 f51a          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENV_MCUINFO
                 XT_ENV_MCUINFO:
00f529 f000          .dw DO_COLON
                 PFA_EN_MCUINFO:
00f52a f045          .dw XT_DOLITERAL
00f52b 0071          .dw mcu_info
00f52c f025          .dw XT_EXIT
                 .include "words/env-usersize.asm"
                 
                 ; Environment
                 ; size of the USER area in bytes
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_ENVUSERSIZE:
00f52d ff05          .dw $ff05
00f52e 752f
00f52f 6573
00f530 0072          .db "/user",0
00f531 f523          .dw VE_ENVHEAD
                     .set VE_ENVHEAD = VE_ENVUSERSIZE
                 XT_ENVUSERSIZE:
00f532 f000          .dw DO_COLON
                 PFA_ENVUSERSIZE:
                 .endif
00f533 f045          .dw XT_DOLITERAL
00f534 002e          .dw SYSUSERSIZE + APPUSERSIZE
00f535 f025          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/f_cpu.asm"
                 
                 ; System
                 ; put the cpu frequency in Hz on stack
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_F_CPU:
00f536 ff05          .dw $ff05
00f537 5f66
00f538 7063
00f539 0075          .db "f_cpu",0
00f53a f4d9          .dw VE_HEAD
                     .set VE_HEAD = VE_F_CPU
                 XT_F_CPU:
00f53b f000          .dw DO_COLON
                 PFA_F_CPU:
                 .endif
00f53c f045          .dw XT_DOLITERAL
00f53d 2400          .dw (F_CPU % 65536)
00f53e f045          .dw XT_DOLITERAL
00f53f 00f4          .dw (F_CPU / 65536)
00f540 f025          .dw XT_EXIT
                 .include "words/state.asm"
                 
                 ; System Variable
                 ; system state
                 VE_STATE:
00f541 ff05          .dw $ff05
00f542 7473
00f543 7461
00f544 0065          .db "state",0
00f545 f536          .dw VE_HEAD
                     .set VE_HEAD = VE_STATE
                 XT_STATE:
00f546 f053          .dw PFA_DOVARIABLE
                 PFA_STATE:
00f547 0253          .dw ram_state
                 
                 .dseg
000253           ram_state: .byte 2
                 .include "words/base.asm"
                 
                 ; Numeric IO
                 ; location of the cell containing the number conversion radix
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BASE:
00f548 ff04          .dw $ff04
00f549 6162
00f54a 6573          .db "base"
00f54b f541          .dw VE_HEAD
                     .set VE_HEAD = VE_BASE
                 XT_BASE:
00f54c f066          .dw PFA_DOUSER
                 PFA_BASE:
                 .endif
00f54d 000c          .dw USER_BASE
                 
                 .include "words/cells.asm"
                 
                 ; Arithmetics
                 ; n2 is the size in address units of n1 cells
                 VE_CELLS:
00f54e ff05          .dw $ff05
00f54f 6563
00f550 6c6c
00f551 0073          .db "cells",0
00f552 f548          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLS
                 XT_CELLS:
00f553 f21d          .dw PFA_2STAR
                 .include "words/cellplus.asm"
                 
                 ; Arithmetics
                 ; add the size of an address-unit to a-addr1
                 VE_CELLPLUS:
00f554 ff05          .dw $ff05
00f555 6563
00f556 6c6c
00f557 002b          .db "cell+",0
00f558 f54e          .dw VE_HEAD
                     .set VE_HEAD = VE_CELLPLUS
                 XT_CELLPLUS:
00f559 f55a          .dw PFA_CELLPLUS
                 PFA_CELLPLUS:
00f55a 9602          adiw tosl, CELLSIZE
00f55b caa8          jmp_ DO_NEXT
                 
                 .include "words/2dup.asm"
                 
                 ; Stack
                 ; Duplicate the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DUP:
00f55c ff04          .dw $ff04
00f55d 6432
00f55e 7075          .db "2dup"
00f55f f554          .dw VE_HEAD
                     .set VE_HEAD = VE_2DUP
                 XT_2DUP:
00f560 f000          .dw DO_COLON
                 PFA_2DUP:
                 .endif
                 
00f561 f0e0          .dw XT_OVER
00f562 f0e0          .dw XT_OVER
00f563 f025          .dw XT_EXIT
                 .include "words/2drop.asm"
                 
                 ; Stack
                 ; Remove the 2 top elements
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2DROP:
00f564 ff05          .dw $ff05
00f565 6432
00f566 6f72
00f567 0070          .db "2drop",0
00f568 f55c          .dw VE_HEAD
                     .set VE_HEAD = VE_2DROP
                 XT_2DROP:
00f569 f000          .dw DO_COLON
                 PFA_2DROP:
                 .endif
00f56a f0ea          .dw XT_DROP
00f56b f0ea          .dw XT_DROP
00f56c f025          .dw XT_EXIT
                 
                 .include "words/tuck.asm"
                 
                 ; Stack
                 ; Copy the first (top) stack item below the second stack item. 
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TUCK:
00f56d ff04          .dw $ff04
00f56e 7574
00f56f 6b63          .db "tuck"
00f570 f564          .dw VE_HEAD
                     .set VE_HEAD = VE_TUCK
                 XT_TUCK:
00f571 f000          .dw DO_COLON
                 PFA_TUCK:
                 .endif
00f572 f0d5          .dw XT_SWAP
00f573 f0e0          .dw XT_OVER
00f574 f025          .dw XT_EXIT
                 
                 .include "words/to-in.asm"
                 
                 ; System Variable
                 ; pointer to current read position in input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_IN:
00f575 ff03          .dw $ff03
00f576 693e
00f577 006e          .db ">in",0
00f578 f56d          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_IN
                 XT_TO_IN:
00f579 f066          .dw PFA_DOUSER
                 PFA_TO_IN:
                 .endif
00f57a 0018          .dw USER_TO_IN
                 .include "words/pad.asm"
                 
                 ; System Variable
                 ; Address of the temporary scratch buffer.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PAD:
00f57b ff03          .dw $ff03
00f57c 6170
00f57d 0064          .db "pad",0
00f57e f575          .dw VE_HEAD
                     .set VE_HEAD = VE_PAD
                 XT_PAD:
00f57f f000          .dw DO_COLON
                 PFA_PAD:
                 .endif
00f580 f5ba          .dw XT_HERE
00f581 f045          .dw XT_DOLITERAL
00f582 0028          .dw 40
00f583 f1ae          .dw XT_PLUS
00f584 f025          .dw XT_EXIT
                 .include "words/emit.asm"
                 
                 ; Character IO
                 ; fetch the emit vector and execute it. should emit a character from TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMIT:
00f585 ff04          .dw $ff04
00f586 6d65
00f587 7469          .db "emit"
00f588 f57b          .dw VE_HEAD
                     .set VE_HEAD = VE_EMIT
                 XT_EMIT:
00f589 fc29          .dw PFA_DODEFER1
                 PFA_EMIT:
                 .endif
00f58a 000e          .dw USER_EMIT
00f58b fbf2          .dw XT_UDEFERFETCH
00f58c fbfe          .dw XT_UDEFERSTORE
                 .include "words/emitq.asm"
                 
                 ; Character IO
                 ; fetch emit? vector and execute it. should return the ready-to-send condition
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_EMITQ:
00f58d ff05          .dw $ff05
00f58e 6d65
00f58f 7469
00f590 003f          .db "emit?",0
00f591 f585          .dw VE_HEAD
                     .set VE_HEAD = VE_EMITQ
                 XT_EMITQ:
00f592 fc29          .dw PFA_DODEFER1
                 PFA_EMITQ:
                 .endif
00f593 0010          .dw USER_EMITQ
00f594 fbf2          .dw XT_UDEFERFETCH
00f595 fbfe          .dw XT_UDEFERSTORE
                 .include "words/key.asm"
                 
                 ; Character IO
                 ; fetch key vector and execute it, should leave a single character on TOS
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEY:
00f596 ff03          .dw $ff03
00f597 656b
00f598 0079          .db "key",0
00f599 f58d          .dw VE_HEAD
                     .set VE_HEAD = VE_KEY
                 XT_KEY:
00f59a fc29          .dw PFA_DODEFER1
                 PFA_KEY:
                 .endif
00f59b 0012          .dw USER_KEY
00f59c fbf2          .dw XT_UDEFERFETCH
00f59d fbfe          .dw XT_UDEFERSTORE
                 .include "words/keyq.asm"
                 
                 ; Character IO
                 ; fetch key? vector and execute it. should turn on key sender, if it is disabled/stopped
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_KEYQ:
00f59e ff04          .dw $ff04
00f59f 656b
00f5a0 3f79          .db "key?"
00f5a1 f596          .dw VE_HEAD
                     .set VE_HEAD = VE_KEYQ
                 XT_KEYQ:
00f5a2 fc29          .dw PFA_DODEFER1
                 PFA_KEYQ:
                 .endif
00f5a3 0014          .dw USER_KEYQ
00f5a4 fbf2          .dw XT_UDEFERFETCH
00f5a5 fbfe          .dw XT_UDEFERSTORE
                 
                 .include "words/dp.asm"
                 
                 ; System Value
                 ; address of the next free dictionary cell
                 VE_DP:
00f5a6 ff02          .dw $ff02
00f5a7 7064          .db "dp"
00f5a8 f59e          .dw VE_HEAD
                     .set VE_HEAD = VE_DP
                 XT_DP:
00f5a9 f080          .dw PFA_DOVALUE1
                 PFA_DP:
00f5aa 0074          .dw CFG_DP
00f5ab fbca          .dw XT_EDEFERFETCH
00f5ac fbd4          .dw XT_EDEFERSTORE
                 .include "words/ehere.asm"
                 
                 ; System Value
                 ; address of the next free address in eeprom
                 VE_EHERE:
00f5ad ff05          .dw $ff05
00f5ae 6865
00f5af 7265
00f5b0 0065          .db "ehere",0
00f5b1 f5a6          .dw VE_HEAD
                     .set VE_HEAD = VE_EHERE
                 XT_EHERE:
00f5b2 f080          .dw PFA_DOVALUE1
                 PFA_EHERE:
00f5b3 0078          .dw EE_EHERE
00f5b4 fbca          .dw XT_EDEFERFETCH
00f5b5 fbd4          .dw XT_EDEFERSTORE
                 .include "words/here.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_HERE:
00f5b6 ff04          .dw $ff04
00f5b7 6568
00f5b8 6572          .db "here"
00f5b9 f5ad          .dw VE_HEAD
                     .set VE_HEAD = VE_HERE
                 XT_HERE:
00f5ba f080          .dw PFA_DOVALUE1
                 PFA_HERE:
00f5bb 0076          .dw EE_HERE
00f5bc fbca          .dw XT_EDEFERFETCH
00f5bd fbd4          .dw XT_EDEFERSTORE
                 .include "words/allot.asm"
                 
                 ; System
                 ; allocate or release memory in RAM
                 VE_ALLOT:
00f5be ff05          .dw $ff05
00f5bf 6c61
00f5c0 6f6c
00f5c1 0074          .db "allot",0
00f5c2 f5b6          .dw VE_HEAD
                     .set VE_HEAD = VE_ALLOT
                 XT_ALLOT:
00f5c3 f000          .dw DO_COLON
                 PFA_ALLOT:
00f5c4 f5ba          .dw XT_HERE
00f5c5 f1ae          .dw XT_PLUS
00f5c6 fbaf          .dw XT_DOTO
00f5c7 f5bb          .dw PFA_HERE
00f5c8 f025          .dw XT_EXIT
                 
                 .include "words/bin.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BIN:
00f5c9 ff03          .dw $ff03
00f5ca 6962
00f5cb 006e          .db "bin",0
00f5cc f5be          .dw VE_HEAD
                     .set VE_HEAD = VE_BIN
                 XT_BIN:
00f5cd f000          .dw DO_COLON
                 PFA_BIN:
                 .endif
00f5ce f3fc          .dw XT_TWO
00f5cf f54c          .dw XT_BASE
00f5d0 f092          .dw XT_STORE
00f5d1 f025          .dw XT_EXIT
                 .include "words/decimal.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DECIMAL:
00f5d2 ff07          .dw $ff07
00f5d3 6564
00f5d4 6963
00f5d5 616d
00f5d6 006c          .db "decimal",0
00f5d7 f5c9          .dw VE_HEAD
                     .set VE_HEAD = VE_DECIMAL
                 XT_DECIMAL:
00f5d8 f000          .dw DO_COLON
                 PFA_DECIMAL:
                 .endif
00f5d9 f045          .dw XT_DOLITERAL
00f5da 000a          .dw 10
00f5db f54c          .dw XT_BASE
00f5dc f092          .dw XT_STORE
00f5dd f025          .dw XT_EXIT
                 .include "words/hex.asm"
                 
                 ; Numeric IO
                 ; set base for numeric conversion to 10
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HEX:
00f5de ff03          .dw $ff03
00f5df 6568
00f5e0 0078          .db "hex",0
00f5e1 f5d2          .dw VE_HEAD
                     .set VE_HEAD = VE_HEX
                 XT_HEX:
00f5e2 f000          .dw DO_COLON
                 PFA_HEX:
                 .endif
00f5e3 f045          .dw XT_DOLITERAL
00f5e4 0010          .dw 16
00f5e5 f54c          .dw XT_BASE
00f5e6 f092          .dw XT_STORE
00f5e7 f025          .dw XT_EXIT
                 .include "words/bl.asm"
                 
                 ; Character IO
                 ; put ascii code of the blank to the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BL:
00f5e8 ff02          .dw $ff02
00f5e9 6c62          .db "bl"
00f5ea f5de          .dw VE_HEAD
                     .set VE_HEAD = VE_BL
                 XT_BL:
00f5eb f053          .dw PFA_DOVARIABLE
                 PFA_BL:
                 .endif
00f5ec 0020          .dw 32
                 
                 .include "words/turnkey.asm"
                 
                 ; System Value
                 ; Deferred action during startup/reset
                 VE_TURNKEY:
00f5ed ff07          .dw $ff07
00f5ee 7574
00f5ef 6e72
00f5f0 656b
00f5f1 0079          .db "turnkey",0
00f5f2 f5e8          .dw VE_HEAD
                     .set VE_HEAD = VE_TURNKEY
                 XT_TURNKEY:
00f5f3 fc29          .dw PFA_DODEFER1
                 PFA_TURNKEY:
00f5f4 0080          .dw CFG_TURNKEY
00f5f5 fbca          .dw XT_EDEFERFETCH
00f5f6 fbd4          .dw XT_EDEFERSTORE
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/slashmod.asm"
                 
                 ; Arithmetics
                 ; signed division n1/n2 with remainder and quotient
                 VE_SLASHMOD:
00f5f7 ff04          .dw $ff04
00f5f8 6d2f
00f5f9 646f          .db "/mod"
00f5fa f5ed          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHMOD
                 XT_SLASHMOD:
00f5fb f5fc          .dw PFA_SLASHMOD
                 PFA_SLASHMOD:
00f5fc 019c          movw temp2, tosl
                     
00f5fd 9109          ld temp0, Y+
00f5fe 9119          ld temp1, Y+
                 
00f5ff 2f41          mov	temp6,temp1	;move dividend High to sign register
00f600 2743          eor	temp6,temp3	;xor divisor High with sign register
00f601 ff17          sbrs	temp1,7	;if MSB in dividend set
00f602 c004          rjmp	PFA_SLASHMOD_1
00f603 9510          com	temp1		;    change sign of dividend
00f604 9500          com	temp0		
00f605 5f0f          subi	temp0,low(-1)
00f606 4f1f          sbci	temp1,high(-1)
                 PFA_SLASHMOD_1:	
00f607 ff37          sbrs	temp3,7	;if MSB in divisor set
00f608 c004          rjmp	PFA_SLASHMOD_2
00f609 9530          com	temp3		;    change sign of divisor
00f60a 9520          com	temp2		
00f60b 5f2f          subi	temp2,low(-1)
00f60c 4f3f          sbci	temp3,high(-1)
00f60d 24ee      PFA_SLASHMOD_2:	clr	temp4	;clear remainder Low byte
00f60e 18ff          sub	temp5,temp5;clear remainder High byte and carry
00f60f e151          ldi	temp7,17	;init loop counter
                 
00f610 1f00      PFA_SLASHMOD_3:	rol	temp0		;shift left dividend
00f611 1f11          rol	temp1
00f612 955a          dec	temp7		;decrement counter
00f613 f439          brne	PFA_SLASHMOD_5		;if done
00f614 ff47          sbrs	temp6,7		;    if MSB in sign register set
00f615 c004          rjmp	PFA_SLASHMOD_4
00f616 9510          com	temp1	;        change sign of result
00f617 9500          com	temp0
00f618 5f0f          subi	temp0,low(-1)
00f619 4f1f          sbci	temp1,high(-1)
00f61a c00b      PFA_SLASHMOD_4:	rjmp PFA_SLASHMODmod_done			;    return
00f61b 1cee      PFA_SLASHMOD_5:	rol	temp4	;shift dividend into remainder
00f61c 1cff          rol	temp5
00f61d 1ae2          sub	temp4,temp2	;remainder = remainder - divisor
00f61e 0af3          sbc	temp5,temp3	;
00f61f f420          brcc	PFA_SLASHMOD_6		;if result negative
00f620 0ee2          add	temp4,temp2	;    restore remainder
00f621 1ef3          adc	temp5,temp3
00f622 9488          clc			;    clear carry to be shifted into result
00f623 cfec          rjmp	PFA_SLASHMOD_3		;else
00f624 9408      PFA_SLASHMOD_6:	sec			;    set carry to be shifted into result
00f625 cfea          rjmp	PFA_SLASHMOD_3
                 
                 PFA_SLASHMODmod_done:
                     ; put remainder on stack
00f626 92fa          st -Y,temp5
00f627 92ea          st -Y,temp4
                 
                     ; put quotient on stack
00f628 01c8          movw tosl, temp0
00f629 c9da          jmp_ DO_NEXT
                 .include "words/uslashmod.asm"
                 
                 ; Arithmetics
                 ; unsigned division with remainder
                 VE_USLASHMOD:
00f62a ff05          .dw $ff05
00f62b 2f75
00f62c 6f6d
00f62d 0064          .db "u/mod",0
00f62e f5f7          .dw VE_HEAD
                     .set VE_HEAD = VE_USLASHMOD
                 XT_USLASHMOD:
00f62f f000          .dw DO_COLON
                 PFA_USLASHMOD:
00f630 f110          .dw XT_TO_R
00f631 f165          .dw XT_ZERO
00f632 f107          .dw XT_R_FROM
00f633 f1d3          .dw XT_UMSLASHMOD
00f634 f025          .dw XT_EXIT
                 .include "words/negate.asm"
                 
                 ; Logic
                 ; 2-complement
                 VE_NEGATE:
00f635 ff06          .dw $ff06
00f636 656e
00f637 6167
00f638 6574          .db "negate"
00f639 f62a          .dw VE_HEAD
                     .set VE_HEAD = VE_NEGATE
                 XT_NEGATE:
00f63a f000          .dw DO_COLON
                 PFA_NEGATE:
00f63b f20e          .dw XT_INVERT
00f63c f240          .dw XT_1PLUS
00f63d f025          .dw XT_EXIT
                 .include "words/slash.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2. giving the quotient
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SLASH:
00f63e ff01          .dw $ff01
00f63f 002f          .db "/",0
00f640 f635          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASH
                 XT_SLASH:
00f641 f000          .dw DO_COLON
                 PFA_SLASH:
                 .endif
00f642 f5fb          .dw XT_SLASHMOD
00f643 f101          .dw XT_NIP
00f644 f025          .dw XT_EXIT
                 
                 .include "words/mod.asm"
                 
                 ; Arithmetics
                 ; divide n1 by n2 giving the remainder n3
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MOD:
00f645 ff03          .dw $ff03
00f646 6f6d
00f647 0064          .db "mod",0
00f648 f63e          .dw VE_HEAD
                     .set VE_HEAD = VE_MOD
                 XT_MOD:
00f649 f000          .dw DO_COLON
                 PFA_MOD:
                 .endif
00f64a f5fb          .dw XT_SLASHMOD
00f64b f0ea          .dw XT_DROP
00f64c f025          .dw XT_EXIT
                 .include "words/abs.asm"
                 
                 ;   DUP ?NEGATE ;
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ABS:
00f64d ff03          .dw $ff03
00f64e 6261
00f64f 0073          .db "abs",0
00f650 f645          .dw VE_HEAD
                     .set VE_HEAD = VE_ABS
                 XT_ABS:
00f651 f000          .dw DO_COLON
                 PFA_ABS:
                 
                 .endif
                 
00f652 f0c2
00f653 f24f
00f654 f025          .DW XT_DUP,XT_QNEGATE,XT_EXIT
                 .include "words/min.asm"
                 
                 ; Compare
                 ; compare two values leave the smaller one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_MIN:
00f655 ff03          .dw $ff03
00f656 696d
00f657 006e          .db "min",0
00f658 f64d          .dw VE_HEAD
                     .set VE_HEAD = VE_MIN
                 XT_MIN:
00f659 f000          .dw DO_COLON
                 PFA_MIN:
                 .endif
00f65a f560          .dw XT_2DUP
00f65b f189          .dw XT_GREATER
00f65c f03e          .dw XT_DOCONDBRANCH
00f65d f65f          DEST(PFA_MIN1)
00f65e f0d5          .dw XT_SWAP
                 PFA_MIN1:
00f65f f0ea          .dw XT_DROP
00f660 f025          .dw XT_EXIT
                 .include "words/max.asm"
                 
                 ; Compare
                 ; compare two values, leave the bigger one
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_MAX:
00f661 ff03          .dw $ff03
00f662 616d
00f663 0078          .db "max",0
00f664 f655          .dw VE_HEAD
                     .set VE_HEAD = VE_MAX
                 XT_MAX:
00f665 f000          .dw DO_COLON
                 PFA_MAX:
                 
                 .endif
00f666 f560          .dw XT_2DUP
00f667 f17f          .dw XT_LESS
00f668 f03e          .dw XT_DOCONDBRANCH
00f669 f66b          DEST(PFA_MAX1)
00f66a f0d5          .dw XT_SWAP
                 PFA_MAX1:
00f66b f0ea          .dw XT_DROP
00f66c f025          .dw XT_EXIT
                 .include "words/within.asm"
                 
                 ; Compare
                 ; check if n is within min..max
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WITHIN:
00f66d ff06          .dw $ff06
00f66e 6977
00f66f 6874
00f670 6e69          .db "within"
00f671 f661          .dw VE_HEAD
                     .set VE_HEAD = VE_WITHIN
                 XT_WITHIN:
00f672 f000          .dw DO_COLON
                 PFA_WITHIN:
                 .endif
00f673 f0e0          .dw XT_OVER
00f674 f1a4          .dw XT_MINUS
00f675 f110          .dw XT_TO_R
00f676 f1a4          .dw XT_MINUS
00f677 f107          .dw XT_R_FROM
00f678 f16d          .dw XT_ULESS
00f679 f025          .dw XT_EXIT
                 
                 .include "words/to-upper.asm"
                 
                 ; String
                 ; if c is a lowercase letter convert it to uppercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TOUPPER:
00f67a ff07          .dw $ff07 
00f67b 6f74
00f67c 7075
00f67d 6570
00f67e 0072          .db "toupper",0
00f67f f66d          .dw VE_HEAD
                     .set VE_HEAD = VE_TOUPPER
                 XT_TOUPPER:
00f680 f000          .dw DO_COLON 
                 PFA_TOUPPER:
                 .endif
00f681 f0c2          .dw XT_DUP 
00f682 f045          .dw XT_DOLITERAL 
00f683 0061          .dw 'a' 
00f684 f045          .dw XT_DOLITERAL 
00f685 007b          .dw 'z'+1
00f686 f672          .dw XT_WITHIN 
00f687 f03e          .dw XT_DOCONDBRANCH
00f688 f68c          DEST(PFA_TOUPPER0)
00f689 f045          .dw XT_DOLITERAL
00f68a 00df          .dw 223 ; inverse of 0x20: 0xdf
00f68b f224          .dw XT_AND 
                 PFA_TOUPPER0:
00f68c f025          .dw XT_EXIT 
                 .include "words/to-lower.asm"
                 
                 ; String
                 ; if C is an uppercase letter convert it to lowercase
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_TOLOWER:
00f68d ff07          .dw $ff07
00f68e 6f74
00f68f 6f6c
00f690 6577
00f691 0072          .db "tolower",0
00f692 f67a          .dw VE_HEAD
                     .set VE_HEAD = VE_TOLOWER
                 XT_TOLOWER:
00f693 f000          .dw DO_COLON
                 PFA_TOLOWER:
                 .endif
00f694 f0c2          .dw XT_DUP
00f695 f045          .dw XT_DOLITERAL
00f696 0041          .dw 'A'
00f697 f045          .dw XT_DOLITERAL
00f698 005b          .dw 'Z'+1
00f699 f672          .dw XT_WITHIN
00f69a f03e          .dw XT_DOCONDBRANCH
00f69b f69f          DEST(PFA_TOLOWER0)
00f69c f045          .dw XT_DOLITERAL
00f69d 0020          .dw 32
00f69e f22d          .dw XT_OR 
                 PFA_TOLOWER0:
00f69f f025          .dw XT_EXIT 
                 ;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/hld.asm"
                 
                 ; Numeric IO
                 ; pointer to current write position in the Pictured Numeric Output buffer
                 VE_HLD:
00f6a0 ff03          .dw $ff03
00f6a1 6c68
00f6a2 0064          .db "hld",0
00f6a3 f68d          .dw VE_HEAD
                     .set VE_HEAD = VE_HLD
                 XT_HLD:
00f6a4 f053          .dw PFA_DOVARIABLE
                 PFA_HLD:
00f6a5 0255          .dw ram_hld
                 
                 .dseg
000255           ram_hld: .byte 2
                 .cseg
                 .include "words/hold.asm"
                 
                 ; Numeric IO
                 ; prepend character to pictured numeric output buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HOLD:
00f6a6 ff04          .dw $ff04
00f6a7 6f68
00f6a8 646c          .db "hold"
00f6a9 f6a0          .dw VE_HEAD
                     .set VE_HEAD = VE_HOLD
                 XT_HOLD:
00f6aa f000          .dw DO_COLON
                 PFA_HOLD:
                 .endif
00f6ab f6a4          .dw XT_HLD
00f6ac f0c2          .dw XT_DUP
00f6ad f08a          .dw XT_FETCH
00f6ae f246          .dw XT_1MINUS
00f6af f0c2          .dw XT_DUP
00f6b0 f110          .dw XT_TO_R
00f6b1 f0d5          .dw XT_SWAP
00f6b2 f092          .dw XT_STORE
00f6b3 f107          .dw XT_R_FROM
00f6b4 f09e          .dw XT_CSTORE
00f6b5 f025          .dw XT_EXIT
                 .include "words/less-sharp.asm" ; <#
                 
                 ; Numeric IO
                 ; initialize the pictured numeric output conversion process
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_L_SHARP:
00f6b6 ff02          .dw $ff02
00f6b7 233c          .db "<#"
00f6b8 f6a6          .dw VE_HEAD
                     .set VE_HEAD = VE_L_SHARP
                 XT_L_SHARP:
00f6b9 f000          .dw DO_COLON
                 PFA_L_SHARP:
                 .endif
00f6ba f57f          .dw XT_PAD
00f6bb f6a4          .dw XT_HLD
00f6bc f092          .dw XT_STORE
00f6bd f025          .dw XT_EXIT
                 .include "words/sharp.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert one digit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_SHARP:
00f6be ff01          .dw $ff01
00f6bf 0023          .db "#",0
00f6c0 f6b6          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP
                 XT_SHARP:
00f6c1 f000          .dw DO_COLON
                 PFA_SHARP:
                 .endif
00f6c2 f54c          .dw XT_BASE
00f6c3 f08a          .dw XT_FETCH
00f6c4 f73e          .dw XT_UDSLASHMOD
00f6c5 f0f2          .dw XT_ROT
00f6c6 f045          .dw XT_DOLITERAL
00f6c7 0009          .dw 9
00f6c8 f0e0          .dw XT_OVER
00f6c9 f17f          .dw XT_LESS
00f6ca f03e          .dw XT_DOCONDBRANCH
00f6cb f6cf          DEST(PFA_SHARP1)
00f6cc f045          .dw XT_DOLITERAL
00f6cd 0007          .dw 7
00f6ce f1ae          .dw XT_PLUS
                 PFA_SHARP1:
00f6cf f045          .dw XT_DOLITERAL
00f6d0 0030          .dw 48 ; ASCII 0
00f6d1 f1ae          .dw XT_PLUS
00f6d2 f6aa          .dw XT_HOLD
00f6d3 f025          .dw XT_EXIT
                 ; : #    ( ud1 -- ud2 ) 
                 ;        base @ ud/mod rot 9 over < if 7 + then 30 + hold ; 
                 .include "words/sharp-s.asm"
                 
                 ; Numeric IO
                 ; pictured numeric output: convert all digits until 0 (zero) is reached
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_S:
00f6d4 ff02          .dw $ff02
00f6d5 7323          .db "#s"
00f6d6 f6be          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_S
                 XT_SHARP_S:
00f6d7 f000          .dw DO_COLON
                 PFA_SHARP_S:
                 .endif
                 NUMS1:
00f6d8 f6c1          .dw XT_SHARP
00f6d9 f560          .dw XT_2DUP
00f6da f22d          .dw XT_OR
00f6db f129          .dw XT_ZEROEQUAL
00f6dc f03e          .dw XT_DOCONDBRANCH
00f6dd f6d8          DEST(NUMS1) ; PFA_SHARP_S
00f6de f025          .dw XT_EXIT
                 .include "words/sharp-greater.asm" ; #>
                 
                 ; Numeric IO
                 ; Pictured Numeric Output: convert PNO buffer into an string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SHARP_G:
00f6df ff02          .dw $ff02
00f6e0 3e23          .db "#>"
00f6e1 f6d4          .dw VE_HEAD
                     .set VE_HEAD = VE_SHARP_G
                 XT_SHARP_G:
00f6e2 f000          .dw DO_COLON
                 PFA_SHARP_G:
                 .endif
00f6e3 f569          .dw XT_2DROP
00f6e4 f6a4          .dw XT_HLD
00f6e5 f08a          .dw XT_FETCH
00f6e6 f57f          .dw XT_PAD
00f6e7 f0e0          .dw XT_OVER
00f6e8 f1a4          .dw XT_MINUS
00f6e9 f025          .dw XT_EXIT
                 .include "words/sign.asm"
                 
                 ; Numeric IO
                 ; place a - in HLD if n is negative
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SIGN:
00f6ea ff04          .dw $ff04
00f6eb 6973
00f6ec 6e67          .db "sign"
00f6ed f6df          .dw VE_HEAD
                     .set VE_HEAD = VE_SIGN
                 XT_SIGN:
00f6ee f000          .dw DO_COLON
                 PFA_SIGN:
                 .endif
00f6ef f130          .dw XT_ZEROLESS
00f6f0 f03e          .dw XT_DOCONDBRANCH
00f6f1 f6f5          DEST(PFA_SIGN1)
00f6f2 f045          .dw XT_DOLITERAL
00f6f3 002d          .dw 45 ; ascii -
00f6f4 f6aa          .dw XT_HOLD
                 PFA_SIGN1:
00f6f5 f025          .dw XT_EXIT
                 .include "words/d-dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOTR:
00f6f6 ff03          .dw $ff03
00f6f7 2e64
00f6f8 0072          .db "d.r",0
00f6f9 f6ea          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOTR
                 XT_DDOTR:
00f6fa f000          .dw DO_COLON
                 PFA_DDOTR:
                 
                 .endif
00f6fb f110          .dw XT_TO_R
00f6fc f571          .dw XT_TUCK
00f6fd fcfb          .dw XT_DABS
00f6fe f6b9          .dw XT_L_SHARP
00f6ff f6d7          .dw XT_SHARP_S
00f700 f0f2          .dw XT_ROT
00f701 f6ee          .dw XT_SIGN
00f702 f6e2          .dw XT_SHARP_G
00f703 f107          .dw XT_R_FROM
00f704 f0e0          .dw XT_OVER
00f705 f1a4          .dw XT_MINUS
00f706 f7e6          .dw XT_SPACES
00f707 f7f6          .dw XT_TYPE
00f708 f025          .dw XT_EXIT
                 ; : d.r       ( d n -- )
                 ;             >r swap over dabs <# #s rot sign #> r> over - spaces type ;
                 .include "words/dot-r.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOTR:
00f709 ff02          .dw $ff02
00f70a 722e          .db ".r"
00f70b f6f6          .dw VE_HEAD
                     .set VE_HEAD = VE_DOTR
                 XT_DOTR:
00f70c f000          .dw DO_COLON
                 PFA_DOTR:
                 
                 .endif
00f70d f110          .dw XT_TO_R
00f70e fd8e          .dw XT_S2D
00f70f f107          .dw XT_R_FROM
00f710 f6fa          .dw XT_DDOTR
00f711 f025          .dw XT_EXIT
                 ; : .r        ( s n -- )  >r s>d r> d.r ;
                 .include "words/d-dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DDOT:
00f712 ff02          .dw $ff02
00f713 2e64          .db "d."
00f714 f709          .dw VE_HEAD
                     .set VE_HEAD = VE_DDOT
                 XT_DDOT:
00f715 f000          .dw DO_COLON
                 PFA_DDOT:
                 
                 .endif
00f716 f165          .dw XT_ZERO
00f717 f6fa          .dw XT_DDOTR
00f718 f7dd          .dw XT_SPACE
00f719 f025          .dw XT_EXIT
                 ; : d.        ( d -- )    0 d.r space ;
                 .include "words/dot.asm"
                 
                 ; Numeric IO
                 ; singed PNO with single cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_DOT:
00f71a ff01          .dw $ff01
00f71b 002e          .db ".",0
00f71c f712          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT
                 XT_DOT:
00f71d f000          .dw DO_COLON
                 PFA_DOT:
                 .endif
00f71e fd8e          .dw XT_S2D
00f71f f715          .dw XT_DDOT
00f720 f025          .dw XT_EXIT
                 ; : .         ( s -- )    s>d d. ; 
                 .include "words/ud-dot.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDDOT:
00f721 ff03          .dw $ff03
00f722 6475
00f723 002e          .db "ud.",0
00f724 f71a          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOT
                 XT_UDDOT:
00f725 f000          .dw DO_COLON
                 PFA_UDDOT:
                 .endif
00f726 f165          .dw XT_ZERO
00f727 f72e          .dw XT_UDDOTR
00f728 f7dd          .dw XT_SPACE
00f729 f025          .dw XT_EXIT
                 .include "words/ud-dot-r.asm"
                 
                 ; Numeric IO
                 ; unsigned PNO with double cell numbers, right aligned in width w
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 
                 VE_UDDOTR:
00f72a ff04          .dw $ff04
00f72b 6475
00f72c 722e          .db "ud.r"
00f72d f721          .dw VE_HEAD
                     .set VE_HEAD = VE_UDDOTR
                 XT_UDDOTR:
00f72e f000          .dw DO_COLON
                 PFA_UDDOTR:
                 .endif
00f72f f110          .dw XT_TO_R
00f730 f6b9          .dw XT_L_SHARP
00f731 f6d7          .dw XT_SHARP_S
00f732 f6e2          .dw XT_SHARP_G
00f733 f107          .dw XT_R_FROM
00f734 f0e0          .dw XT_OVER
00f735 f1a4          .dw XT_MINUS
00f736 f7e6          .dw XT_SPACES
00f737 f7f6          .dw XT_TYPE
00f738 f025          .dw XT_EXIT
                 .include "words/ud-slash-mod.asm"
                 
                 ; Arithmetics
                 ; unsigned double cell division with remainder
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDSLASHMOD:
00f739 ff06          .dw $ff06
00f73a 6475
00f73b 6d2f
00f73c 646f          .db "ud/mod"
00f73d f72a          .dw VE_HEAD
                     .set VE_HEAD = VE_UDSLASHMOD
                 XT_UDSLASHMOD:
00f73e f000          .dw DO_COLON
                 PFA_UDSLASHMOD:
                 .endif
00f73f f110          .dw XT_TO_R
00f740 f165          .dw XT_ZERO
00f741 f117          .dw XT_R_FETCH
00f742 f1d3          .dw XT_UMSLASHMOD
00f743 f107          .dw XT_R_FROM
00f744 f0d5          .dw XT_SWAP
00f745 f110          .dw XT_TO_R
00f746 f1d3          .dw XT_UMSLASHMOD
00f747 f107          .dw XT_R_FROM
00f748 f025          .dw XT_EXIT
                 .include "words/digit-q.asm"
                 
                 ; Numeric IO
                 ; tries to convert a character to a number, set flag accordingly
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DIGITQ:
00f749 ff06          .dw $ff06 
00f74a 6964
00f74b 6967
00f74c 3f74          .db "digit?"
00f74d f739          .dw VE_HEAD
                     .set VE_HEAD = VE_DIGITQ
                 XT_DIGITQ:
00f74e f000          .dw DO_COLON 
                 PFA_DIGITQ:
                 .endif
00f74f f680          .dw XT_TOUPPER
00f750 f0c2
00f751 f045
00f752 0039
00f753 f189
00f754 f045
00f755 0100          .DW XT_DUP,XT_DOLITERAL,57,XT_GREATER,XT_DOLITERAL,256
00f756 f224
00f757 f1ae
00f758 f0c2
00f759 f045
00f75a 0140
00f75b f189          .DW XT_AND,XT_PLUS,XT_DUP,XT_DOLITERAL,320,XT_GREATER
00f75c f045
00f75d 0107
00f75e f224
00f75f f1a4
00f760 f045
00f761 0030          .DW XT_DOLITERAL,263,XT_AND,XT_MINUS,XT_DOLITERAL,48
00f762 f1a4
00f763 f0c2
00f764 f54c
00f765 f08a
00f766 f16d          .DW XT_MINUS,XT_DUP,XT_BASE,XT_FETCH,XT_ULESS
00f767 f025          .DW XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/do-sliteral.asm"
                 
                 ; String
                 ; runtime portion of sliteral
                 ;VE_DOSLITERAL:
                 ;  .dw $ff0a
                 ;  .db "(sliteral)"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSLITERAL
                 XT_DOSLITERAL:
00f768 f000        .dw DO_COLON
                 PFA_DOSLITERAL:
00f769 f117        .dw XT_R_FETCH   ; ( -- addr )
00f76a f7c7        .dw XT_ICOUNT
00f76b f107        .dw XT_R_FROM
00f76c f0e0        .dw XT_OVER     ; ( -- addr' n addr n)
00f76d f240        .dw XT_1PLUS
00f76e f215        .dw XT_2SLASH   ; ( -- addr' n addr k )
00f76f f1ae        .dw XT_PLUS     ; ( -- addr' n addr'' )
00f770 f240        .dw XT_1PLUS
00f771 f110        .dw XT_TO_R     ; ( -- )
00f772 f025        .dw XT_EXIT
                 .include "words/scomma.asm"
                 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 VE_SCOMMA:
00f773 ff02        .dw $ff02
00f774 2c73        .db "s",$2c
00f775 f749        .dw VE_HEAD
                   .set VE_HEAD = VE_SCOMMA
                 XT_SCOMMA:
00f776 f000          .dw DO_COLON
                 PFA_SCOMMA:
00f777 f0c2          .dw XT_DUP
00f778 f77a          .dw XT_DOSCOMMA
00f779 f025          .dw XT_EXIT
                 
                 ; ( addr len len' -- ) 
                 ; Compiler
                 ; compiles a string from RAM to Flash
                 ;VE_DOSCOMMA:
                 ;  .dw $ff04
                 ;  .db "(s",$2c,")"
                 ;  .dw VE_HEAD
                 ;  .set VE_HEAD = VE_DOSCOMMA
                 XT_DOSCOMMA:
00f77a f000          .dw DO_COLON
                 PFA_DOSCOMMA:
00f77b 021e          .dw XT_COMMA
00f77c f0c2          .dw XT_DUP   ; ( --addr len len)
00f77d f215          .dw XT_2SLASH ; ( -- addr len len/2
00f77e f571          .dw XT_TUCK   ; ( -- addr len/2 len len/2
00f77f f21c          .dw XT_2STAR  ; ( -- addr len/2 len len'
00f780 f1a4          .dw XT_MINUS  ; ( -- addr len/2 rem
00f781 f110          .dw XT_TO_R
00f782 f165          .dw XT_ZERO
00f783 02dd          .dw XT_QDOCHECK
00f784 f03e          .dw XT_DOCONDBRANCH
00f785 f78d          .dw PFA_SCOMMA2
00f786 f2ac          .dw XT_DODO
                 PFA_SCOMMA1:
00f787 f0c2          .dw XT_DUP         ; ( -- addr addr )
00f788 f08a          .dw XT_FETCH       ; ( -- addr c1c2 )
00f789 021e          .dw XT_COMMA       ; ( -- addr )
00f78a f559          .dw XT_CELLPLUS    ; ( -- addr+cell )
00f78b f2da          .dw XT_DOLOOP
00f78c f787          .dw PFA_SCOMMA1
                 PFA_SCOMMA2:
00f78d f107          .dw XT_R_FROM
00f78e f137          .dw XT_GREATERZERO
00f78f f03e          .dw XT_DOCONDBRANCH
00f790 f794          .dw PFA_SCOMMA3
00f791 f0c2            .dw XT_DUP     ; well, tricky
00f792 f0a9            .dw XT_CFETCH
00f793 021e            .dw XT_COMMA
                 PFA_SCOMMA3:
00f794 f0ea          .dw XT_DROP        ; ( -- )
00f795 f025          .dw XT_EXIT
                 .include "words/itype.asm"
                 
                 ; Tools
                 ; reads string from flash and prints it
                 VE_ITYPE:
00f796 ff05          .dw $ff05
00f797 7469
00f798 7079
00f799 0065          .db "itype",0
00f79a f773          .dw VE_HEAD
                     .set VE_HEAD = VE_ITYPE
                 XT_ITYPE:
00f79b f000          .dw DO_COLON
                 PFA_ITYPE:
00f79c f0c2          .dw XT_DUP    ; ( --addr len len)
00f79d f215          .dw XT_2SLASH ; ( -- addr len len/2
00f79e f571          .dw XT_TUCK   ; ( -- addr len/2 len len/2
00f79f f21c          .dw XT_2STAR  ; ( -- addr len/2 len len'
00f7a0 f1a4          .dw XT_MINUS  ; ( -- addr len/2 rem
00f7a1 f110          .dw XT_TO_R
00f7a2 f165          .dw XT_ZERO
00f7a3 02dd          .dw XT_QDOCHECK
00f7a4 f03e          .dw XT_DOCONDBRANCH
00f7a5 f7af          .dw PFA_ITYPE2
00f7a6 f2ac          .dw XT_DODO
                 PFA_ITYPE1:
00f7a7 f0c2          .dw XT_DUP         ; ( -- addr addr )
00f7a8 f3d8          .dw XT_FETCHI      ; ( -- addr c1c2 )
00f7a9 f0c2          .dw XT_DUP
00f7aa f7bc          .dw XT_LOWEMIT
00f7ab f7b8          .dw XT_HIEMIT
00f7ac f240          .dw XT_1PLUS    ; ( -- addr+cell )
00f7ad f2da          .dw XT_DOLOOP
00f7ae f7a7          .dw PFA_ITYPE1
                 PFA_ITYPE2:
00f7af f107          .dw XT_R_FROM
00f7b0 f137          .dw XT_GREATERZERO
00f7b1 f03e          .dw XT_DOCONDBRANCH
00f7b2 f7b6          .dw PFA_ITYPE3
00f7b3 f0c2            .dw XT_DUP     ; make sure the drop below has always something to do
00f7b4 f3d8            .dw XT_FETCHI
00f7b5 f7bc            .dw XT_LOWEMIT
                 PFA_ITYPE3:
00f7b6 f0ea          .dw XT_DROP
00f7b7 f025          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_HIEMIT:
                 ;    .dw $ff06
                 ;    .db "hiemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_HIEMIT
                 XT_HIEMIT:
00f7b8 f000          .dw DO_COLON
                 PFA_HIEMIT:
00f7b9 f30a          .dw XT_BYTESWAP
00f7ba f7bc          .dw XT_LOWEMIT
00f7bb f025          .dw XT_EXIT
                 
                 ; ( w -- )
                 ; R( -- )
                 ; content of cell fetched on stack.
                 ;VE_LOWEMIT:
                 ;    .dw $ff07
                 ;    .db "lowemit"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_LOWEMIT
                 XT_LOWEMIT:
00f7bc f000          .dw DO_COLON
                 PFA_LOWEMIT:
00f7bd f045          .dw XT_DOLITERAL
00f7be 00ff          .dw $00ff
00f7bf f224          .dw XT_AND
00f7c0 f589          .dw XT_EMIT
00f7c1 f025          .dw XT_EXIT
                 .include "words/icount.asm"
                 
                 ; Tools
                 ; get count information out of a counted string in flash
                 VE_ICOUNT:
00f7c2 ff06          .dw $ff06
00f7c3 6369
00f7c4 756f
00f7c5 746e          .db "icount"
00f7c6 f796          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOUNT
                 XT_ICOUNT:
00f7c7 f000          .dw DO_COLON
                 PFA_ICOUNT:
00f7c8 f0c2          .dw XT_DUP
00f7c9 f240          .dw XT_1PLUS
00f7ca f0d5          .dw XT_SWAP
00f7cb f3d8          .dw XT_FETCHI
00f7cc f025          .dw XT_EXIT
                 .include "words/cr.asm"
                 
                 ; Character IO
                 ; cause subsequent output appear at the beginning of the next line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CR:
00f7cd ff02          .dw 0xff02
00f7ce 7263          .db "cr"
00f7cf f7c2          .dw VE_HEAD
                     .set VE_HEAD = VE_CR
                 XT_CR:
00f7d0 f000          .dw DO_COLON
                 PFA_CR:
                 .endif
                 
00f7d1 f045          .dw XT_DOLITERAL
00f7d2 000d          .dw 13
00f7d3 f589          .dw XT_EMIT
00f7d4 f045          .dw XT_DOLITERAL
00f7d5 000a          .dw 10
00f7d6 f589          .dw XT_EMIT
00f7d7 f025          .dw XT_EXIT
                 .include "words/space.asm"
                 
                 ; Character IO
                 ; emits a space (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACE:
00f7d8 ff05          .dw $ff05
00f7d9 7073
00f7da 6361
00f7db 0065          .db "space",0
00f7dc f7cd          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACE
                 XT_SPACE:
00f7dd f000          .dw DO_COLON
                 PFA_SPACE:
                 .endif
00f7de f5eb          .dw XT_BL
00f7df f589          .dw XT_EMIT
00f7e0 f025          .dw XT_EXIT
                 .include "words/spaces.asm"
                 
                 ; Character IO
                 ; emits n space(s) (bl)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SPACES:
00f7e1 ff06          .dw $ff06
00f7e2 7073
00f7e3 6361
00f7e4 7365          .db "spaces"
00f7e5 f7d8          .dw VE_HEAD
                     .set VE_HEAD = VE_SPACES
                 XT_SPACES:
00f7e6 f000          .dw DO_COLON
                 PFA_SPACES:
                 
                 .endif
                 ;C SPACES   n --            output n spaces
                 ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
00f7e7 f165
00f7e8 f665      	.DW XT_ZERO, XT_MAX
00f7e9 f0c2
00f7ea f03e      SPCS1:  .DW XT_DUP,XT_DOCONDBRANCH
00f7eb f7f0              DEST(SPCS2)
00f7ec f7dd
00f7ed f246
00f7ee f034              .DW XT_SPACE,XT_1MINUS,XT_DOBRANCH
00f7ef f7e9              DEST(SPCS1)
00f7f0 f0ea
00f7f1 f025      SPCS2:  .DW XT_DROP,XT_EXIT
                 .include "words/type.asm"
                 
                 ; Character IO
                 ; print a RAM based string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TYPE:
00f7f2 ff04          .dw $ff04
00f7f3 7974
00f7f4 6570          .db "type"
00f7f5 f7e1          .dw VE_HEAD
                     .set VE_HEAD = VE_TYPE
                 XT_TYPE:
00f7f6 f000          .dw DO_COLON
                 PFA_TYPE:
                 
                 .endif
00f7f7 fd85          .dw XT_BOUNDS
00f7f8 02dd          .dw XT_QDOCHECK
00f7f9 f03e          .dw XT_DOCONDBRANCH
00f7fa f801          DEST(PFA_TYPE2)
00f7fb f2ac          .dw XT_DODO
                 PFA_TYPE1:
00f7fc f2bd          .dw XT_I
00f7fd f0a9          .dw XT_CFETCH
00f7fe f589          .dw XT_EMIT
00f7ff f2da          .dw XT_DOLOOP
00f800 f7fc          DEST(PFA_TYPE1)
                 PFA_TYPE2:
00f801 f025          .dw XT_EXIT
                 .include "words/tick.asm"
                 
                 ; Dictionary
                 ; search dictionary for name, return XT or throw an exception -13
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TICK:
00f802 ff01          .dw $ff01
00f803 0027          .db "'",0
00f804 f7f2          .dw VE_HEAD
                     .set VE_HEAD = VE_TICK
                 XT_TICK:
00f805 f000          .dw DO_COLON
                 PFA_TICK:
                 .endif
00f806 f9b9          .dw XT_PARSENAME
00f807 fad9          .dw XT_FORTHRECOGNIZER
00f808 fae4          .dw XT_RECOGNIZE
                     ; a word is tickable unless RECTYPE-TOKEN is RECTYPE-NULL or 
                     ; the interpret action is a NOOP
00f809 f0c2          .dw XT_DUP
00f80a fb60          .dw XT_RECTYPE_NULL
00f80b f3f0          .dw XT_EQUAL
00f80c f0d5          .dw XT_SWAP
00f80d f3d8          .dw XT_FETCHI
00f80e f045          .dw XT_DOLITERAL
00f80f fb95          .dw XT_NOOP
00f810 f3f0          .dw XT_EQUAL
00f811 f22d          .dw XT_OR
00f812 f03e          .dw XT_DOCONDBRANCH
00f813 f817          DEST(PFA_TICK1)
00f814 f045            .dw XT_DOLITERAL
00f815 fff3            .dw -13
00f816 f83c            .dw XT_THROW
                 PFA_TICK1:
00f817 f0ea          .dw XT_DROP
00f818 f025          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/handler.asm"
                 
                 ; Exceptions
                 ; USER variable used by catch/throw
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_HANDLER:
00f819 ff07          .dw $ff07
00f81a 6168
00f81b 646e
00f81c 656c
00f81d 0072          .db "handler",0
00f81e f802          .dw VE_HEAD
                     .set VE_HEAD = VE_HANDLER
                 XT_HANDLER:
00f81f f066          .dw PFA_DOUSER
                 PFA_HANDLER:
                 .endif
00f820 000a          .dw USER_HANDLER
                 .include "words/catch.asm"
                 
                 ; Exceptions
                 ; execute XT and check for exceptions.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CATCH:
00f821 ff05          .dw $ff05
00f822 6163
00f823 6374
00f824 0068          .db "catch",0
00f825 f819          .dw VE_HEAD
                     .set VE_HEAD = VE_CATCH
                 XT_CATCH:
00f826 f000          .dw DO_COLON
                 PFA_CATCH:
                 .endif
                 
                     ; sp@ >r
00f827 f29e          .dw XT_SP_FETCH
00f828 f110          .dw XT_TO_R
                     ; handler @ >r
00f829 f81f          .dw XT_HANDLER
00f82a f08a          .dw XT_FETCH
00f82b f110          .dw XT_TO_R
                     ; rp@ handler !
00f82c f287          .dw XT_RP_FETCH
00f82d f81f          .dw XT_HANDLER
00f82e f092          .dw XT_STORE
00f82f f02f          .dw XT_EXECUTE
                     ; r> handler !
00f830 f107          .dw XT_R_FROM
00f831 f81f          .dw XT_HANDLER
00f832 f092          .dw XT_STORE
00f833 f107          .dw XT_R_FROM
00f834 f0ea          .dw XT_DROP
00f835 f165          .dw XT_ZERO
00f836 f025          .dw XT_EXIT
                 .include "words/throw.asm"
                 
                 ; Exceptions
                 ; throw an exception
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_THROW:
00f837 ff05          .dw $ff05
00f838 6874
00f839 6f72
00f83a 0077          .db "throw",0
00f83b f821          .dw VE_HEAD
                     .set VE_HEAD = VE_THROW
                 XT_THROW:
00f83c f000          .dw DO_COLON
                 PFA_THROW:
                 .endif
00f83d f0ca          .dw XT_QDUP
00f83e f03e          .dw XT_DOCONDBRANCH
00f83f f84c          DEST(PFA_THROW1)
00f840 f81f            .dw XT_HANDLER
00f841 f08a            .dw XT_FETCH
00f842 f291            .dw XT_RP_STORE
00f843 f107            .dw XT_R_FROM
00f844 f81f            .dw XT_HANDLER
00f845 f092            .dw XT_STORE
00f846 f107            .dw XT_R_FROM
00f847 f0d5            .dw XT_SWAP
00f848 f110            .dw XT_TO_R
00f849 f2a7            .dw XT_SP_STORE
00f84a f0ea            .dw XT_DROP
00f84b f107            .dw XT_R_FROM    
                 PFA_THROW1:
00f84c f025          .dw XT_EXIT
                 
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/cskip.asm"
                 
                 ; String
                 ; skips leading occurancies in string at addr1/n1 leaving addr2/n2 pointing to the 1st non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSKIP:
00f84d ff05          .dw $ff05
00f84e 7363
00f84f 696b
00f850 0070          .db "cskip",0
00f851 f837          .dw VE_HEAD
                     .set VE_HEAD = VE_CSKIP
                 XT_CSKIP:
00f852 f000          .dw DO_COLON
                 PFA_CSKIP:
                 .endif
00f853 f110          .dw XT_TO_R           ; ( -- addr1 n1 )
                 PFA_CSKIP1:
00f854 f0c2          .dw XT_DUP            ; ( -- addr' n' n' )
00f855 f03e          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00f856 f861          DEST(PFA_CSKIP2)
00f857 f0e0          .dw XT_OVER           ; ( -- addr' n' addr' )
00f858 f0a9          .dw XT_CFETCH         ; ( -- addr' n' c' )
00f859 f117          .dw XT_R_FETCH        ; ( -- addr' n' c' c )
00f85a f3f0          .dw XT_EQUAL          ; ( -- addr' n' f )
00f85b f03e          .dw XT_DOCONDBRANCH   ; ( -- addr' n')
00f85c f861          DEST(PFA_CSKIP2)
00f85d f3f7          .dw XT_ONE
00f85e f9aa          .dw XT_SLASHSTRING
00f85f f034          .dw XT_DOBRANCH
00f860 f854          DEST(PFA_CSKIP1)
                 PFA_CSKIP2:
00f861 f107          .dw XT_R_FROM
00f862 f0ea          .dw XT_DROP           ; ( -- addr2 n2)
00f863 f025          .dw XT_EXIT
                 .include "words/cscan.asm"
                 
                 ; String
                 ; Scan string at addr1/n1 for the first occurance of c, leaving addr1/n2, char at n2 is first non-c character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CSCAN:
00f864 ff05          .dw $ff05
00f865 7363
00f866 6163
../../common\words/cscan.asm(12): warning: .cseg .db misalignment - padding zero byte
00f867 006e          .db "cscan"
00f868 f84d          .dw VE_HEAD
                     .set VE_HEAD = VE_CSCAN
                 XT_CSCAN:
00f869 f000          .dw DO_COLON
                 PFA_CSCAN:
                 .endif
00f86a f110          .dw XT_TO_R
00f86b f0e0          .dw XT_OVER
                 PFA_CSCAN1:
00f86c f0c2          .dw XT_DUP
00f86d f0a9          .dw XT_CFETCH
00f86e f117          .dw XT_R_FETCH
00f86f f3f0          .dw XT_EQUAL
00f870 f129          .dw XT_ZEROEQUAL
00f871 f03e          .dw XT_DOCONDBRANCH
00f872 f87e          DEST(PFA_CSCAN2)
00f873 f0d5            .dw XT_SWAP
00f874 f246            .dw XT_1MINUS
00f875 f0d5            .dw XT_SWAP
00f876 f0e0            .dw XT_OVER
00f877 f130            .dw XT_ZEROLESS ; not negative
00f878 f129            .dw XT_ZEROEQUAL
00f879 f03e            .dw XT_DOCONDBRANCH
00f87a f87e            DEST(PFA_CSCAN2)
00f87b f240              .dw XT_1PLUS
00f87c f034              .dw XT_DOBRANCH
00f87d f86c              DEST(PFA_CSCAN1)
                 PFA_CSCAN2:
00f87e f101          .dw XT_NIP
00f87f f0e0          .dw XT_OVER
00f880 f1a4          .dw XT_MINUS
00f881 f107          .dw XT_R_FROM
00f882 f0ea          .dw XT_DROP
00f883 f025          .dw XT_EXIT
                 
                 ; : my-cscan ( addr len c -- addr len' )
                 ;    >r over ( -- addr len addr )
                 ;    begin
                 ;      dup c@ r@ <> while
                 ;       swap 1- swap over 0 >=  while
                 ;        1+ 
                 ;     repeat then
                 ;     nip over - r> drop 
                 ; ;
                 .include "words/accept.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_ACCEPT:
00f884 ff06          .dw $ff06
00f885 6361
00f886 6563
00f887 7470          .db "accept"
00f888 f864          .dw VE_HEAD
                     .set VE_HEAD = VE_ACCEPT
                 XT_ACCEPT:
00f889 f000          .dw DO_COLON
                 PFA_ACCEPT:
                 
                 .endif
00f88a f0e0
00f88b f1ae
00f88c f0e0              .DW XT_OVER,XT_PLUS,XT_OVER
00f88d f59a
00f88e f0c2
00f88f f8d2
00f890 f129
00f891 f03e      ACC1:   .DW XT_KEY,XT_DUP,XT_CRLFQ,XT_ZEROEQUAL,XT_DOCONDBRANCH
00f892 f8c5              DEST(ACC5)
00f893 f0c2
00f894 f045
00f895 0008
00f896 f3f0
00f897 f03e              .DW XT_DUP,XT_DOLITERAL,8,XT_EQUAL,XT_DOCONDBRANCH
00f898 f8ab              DEST(ACC3)
00f899 f0ea
00f89a f0f2
00f89b f560
00f89c f189
00f89d f110
00f89e f0f2
00f89f f0f2
00f8a0 f107
00f8a1 f03e              .DW XT_DROP,XT_ROT,XT_2DUP,XT_GREATER,XT_TO_R,XT_ROT,XT_ROT,XT_R_FROM,XT_DOCONDBRANCH
00f8a2 f8a9      	DEST(ACC6)
00f8a3 f8ca
00f8a4 f246
00f8a5 f110
00f8a6 f0e0
00f8a7 f107
00f8a8 019a      	.DW XT_BS,XT_1MINUS,XT_TO_R,XT_OVER,XT_R_FROM,XT_UMAX
00f8a9 f034      ACC6:   .DW XT_DOBRANCH
00f8aa f8c3              DEST(ACC4)
                     
                 
                 ACC3:    ; check for remaining control characters, replace them with blank
00f8ab f0c2      	.dw XT_DUP            ; ( -- addr k k )
00f8ac f5eb              .dw XT_BL
00f8ad f17f              .dw XT_LESS
00f8ae f03e              .dw XT_DOCONDBRANCH
00f8af f8b2              DEST(PFA_ACCEPT6)
00f8b0 f0ea              .dw XT_DROP
00f8b1 f5eb              .dw XT_BL
                 PFA_ACCEPT6:
00f8b2 f110
00f8b3 f560
00f8b4 f189
00f8b5 f107
00f8b6 f0d5
00f8b7 f03e      	.DW XT_TO_R,XT_2DUP,XT_GREATER,XT_R_FROM,XT_SWAP,XT_DOCONDBRANCH
00f8b8 f8c2              DEST(ACC7)
00f8b9 f0c2
00f8ba f589
00f8bb f0e0
00f8bc f09e
00f8bd f240
00f8be f0e0
00f8bf 01a6                  .DW XT_DUP,XT_EMIT,XT_OVER,XT_CSTORE,XT_1PLUS,XT_OVER,XT_UMIN
00f8c0 f034      	    .DW XT_DOBRANCH
00f8c1 f8c3      	    DEST(ACC4)
00f8c2 f0ea      ACC7:   .DW XT_DROP
00f8c3 f034      ACC4:   .DW XT_DOBRANCH
00f8c4 f88d              DEST(ACC1)
00f8c5 f0ea
00f8c6 f101
00f8c7 f0d5
00f8c8 f1a4
00f8c9 f025      ACC5:   .DW XT_DROP,XT_NIP,XT_SWAP,XT_MINUS,XT_EXIT
                 
                 
                 ; ( --  ) 
                 ; System
                 ; send a backspace character to overwrite the current char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 ;VE_BS:
                 ;    .dw $ff02
                 ;    .db "bs"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_BS
                 XT_BS:
00f8ca f000          .dw DO_COLON
                 .endif
00f8cb f045          .dw XT_DOLITERAL
00f8cc 0008          .dw 8
00f8cd f0c2          .dw XT_DUP
00f8ce f589          .dw XT_EMIT
00f8cf f7dd          .dw XT_SPACE
00f8d0 f589          .dw XT_EMIT
00f8d1 f025          .dw XT_EXIT
                 
                 
                 ; ( c -- f ) 
                 ; System
                 ; is the character a line end character?
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_CRLFQ:
                 ;    .dw $ff02
                 ;    .db "crlf?"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_CRLFQ
                 XT_CRLFQ:
00f8d2 f000          .dw DO_COLON
                 .endif
00f8d3 f0c2          .dw XT_DUP
00f8d4 f045          .dw XT_DOLITERAL
00f8d5 000d          .dw 13
00f8d6 f3f0          .dw XT_EQUAL
00f8d7 f0d5          .dw XT_SWAP
00f8d8 f045          .dw XT_DOLITERAL
00f8d9 000a          .dw 10
00f8da f3f0          .dw XT_EQUAL
00f8db f22d          .dw XT_OR
00f8dc f025          .dw XT_EXIT
                 .include "words/refill.asm"
                 
                 ; System
                 ; refills the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILL:
00f8dd ff06          .dw $ff06
00f8de 6572
00f8df 6966
00f8e0 6c6c          .db "refill"
00f8e1 f884          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILL
                 XT_REFILL:
00f8e2 fc29          .dw PFA_DODEFER1
                 PFA_REFILL:
                 .endif
00f8e3 001a          .dw USER_REFILL
00f8e4 fbf2          .dw XT_UDEFERFETCH
00f8e5 fbfe          .dw XT_UDEFERSTORE
                 .include "words/char.asm"
                 
                 ; Tools
                 ; copy the first character of the next word onto the stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_CHAR:
00f8e6 ff04          .dw $ff04
00f8e7 6863
00f8e8 7261          .db "char"
00f8e9 f8dd          .dw VE_HEAD
                     .set VE_HEAD = VE_CHAR
                 XT_CHAR:
00f8ea f000          .dw DO_COLON
                 PFA_CHAR:
                 .endif
00f8eb f9b9          .dw XT_PARSENAME
00f8ec f129
00f8ed f03e          .dw XT_ZEROEQUAL,XT_DOCONDBRANCH 
00f8ee f8f2          DEST(CHAR_1)
00f8ef f045
00f8f0 fff0
00f8f1 f83c             .dw XT_DOLITERAL, -16, XT_THROW
                 CHAR_1:
                 
00f8f2 f0a9          .dw XT_CFETCH
00f8f3 f025          .dw XT_EXIT
                 .include "words/number.asm"
                 
                 ; Numeric IO
                 ; convert a string at addr to a number
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBER:
00f8f4 ff06          .dw $ff06
00f8f5 756e
00f8f6 626d
00f8f7 7265          .db "number"
00f8f8 f8e6          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMBER
                 XT_NUMBER:
00f8f9 f000          .dw DO_COLON
                 PFA_NUMBER:
                 .endif
00f8fa f54c          .dw XT_BASE
00f8fb f08a          .dw XT_FETCH
00f8fc f110          .dw XT_TO_R
00f8fd f93d          .dw XT_QSIGN
00f8fe f110          .dw XT_TO_R
00f8ff f950          .dw XT_SET_BASE
00f900 f93d          .dw XT_QSIGN
00f901 f107          .dw XT_R_FROM
00f902 f22d          .dw XT_OR
00f903 f110          .dw XT_TO_R
                     ; check whether something is left
00f904 f0c2          .dw XT_DUP
00f905 f129          .dw XT_ZEROEQUAL
00f906 f03e          .dw XT_DOCONDBRANCH
00f907 f910          DEST(PFA_NUMBER0)
                       ; nothing is left. It cannot be a number at all
00f908 f569            .dw XT_2DROP
00f909 f107            .dw XT_R_FROM
00f90a f0ea            .dw XT_DROP
00f90b f107            .dw XT_R_FROM
00f90c f54c            .dw XT_BASE
00f90d f092            .dw XT_STORE
00f90e f165            .dw XT_ZERO
00f90f f025            .dw XT_EXIT
                 PFA_NUMBER0:
00f910 f325          .dw XT_2TO_R
00f911 f165          .dw XT_ZERO       ; starting value
00f912 f165          .dw XT_ZERO
00f913 f334          .dw XT_2R_FROM
00f914 f96e          .dw XT_TO_NUMBER ; ( 0. addr len -- d addr' len'
                     ; check length of the remaining string.
                     ; if zero: a single cell number is entered
00f915 f0ca          .dw XT_QDUP
00f916 f03e          .dw XT_DOCONDBRANCH
00f917 f932          DEST(PFA_NUMBER1)
                     ; if equal 1: mayba a trailing dot? --> double cell number
00f918 f3f7          .dw XT_ONE
00f919 f3f0          .dw XT_EQUAL
00f91a f03e          .dw XT_DOCONDBRANCH
00f91b f929          DEST(PFA_NUMBER2)
                 	; excatly one character is left
00f91c f0a9      	.dw XT_CFETCH
00f91d f045      	.dw XT_DOLITERAL
00f91e 002e      	.dw 46 ; .
00f91f f3f0      	.dw XT_EQUAL
00f920 f03e      	.dw XT_DOCONDBRANCH
00f921 f92a      	DEST(PFA_NUMBER6)
                 	; its a double cell number
                         ; incorporate sign into number
00f922 f107      	.dw XT_R_FROM
00f923 f03e              .dw XT_DOCONDBRANCH
00f924 f926      	DEST(PFA_NUMBER3)
00f925 fd08              .dw XT_DNEGATE
                 PFA_NUMBER3:
00f926 f3fc      	.dw XT_TWO
00f927 f034      	.dw XT_DOBRANCH
00f928 f938      	DEST(PFA_NUMBER5)
                 PFA_NUMBER2:
00f929 f0ea      	.dw XT_DROP
                 PFA_NUMBER6:
00f92a f569      	.dw XT_2DROP
00f92b f107      	.dw XT_R_FROM
00f92c f0ea      	.dw XT_DROP
00f92d f107              .dw XT_R_FROM
00f92e f54c              .dw XT_BASE
00f92f f092              .dw XT_STORE
00f930 f165      	.dw XT_ZERO
00f931 f025      	.dw XT_EXIT
                 PFA_NUMBER1:
00f932 f569          .dw XT_2DROP ; remove the address
                     ; incorporate sign into number
00f933 f107          .dw XT_R_FROM
00f934 f03e          .dw XT_DOCONDBRANCH
00f935 f937          DEST(PFA_NUMBER4)
00f936 f63a          .dw XT_NEGATE
                 PFA_NUMBER4:
00f937 f3f7          .dw XT_ONE
                 PFA_NUMBER5:
00f938 f107          .dw XT_R_FROM
00f939 f54c          .dw XT_BASE
00f93a f092          .dw XT_STORE
00f93b f15c          .dw XT_TRUE
00f93c f025          .dw XT_EXIT
                 .include "words/q-sign.asm"
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_QSIGN:
00f93d f000          .dw DO_COLON 
                 PFA_QSIGN:        ; ( c -- ) 
                 .endif
00f93e f0e0          .dw XT_OVER    ; ( -- addr len addr )
00f93f f0a9          .dw XT_CFETCH
00f940 f045          .dw XT_DOLITERAL
00f941 002d          .dw '-'
00f942 f3f0          .dw XT_EQUAL  ; ( -- addr len flag )
00f943 f0c2          .dw XT_DUP
00f944 f110          .dw XT_TO_R
00f945 f03e          .dw XT_DOCONDBRANCH
00f946 f949          DEST(PFA_NUMBERSIGN_DONE)
00f947 f3f7          .dw XT_ONE    ; skip sign character
00f948 f9aa          .dw XT_SLASHSTRING
                 PFA_NUMBERSIGN_DONE:
00f949 f107          .dw XT_R_FROM
00f94a f025          .dw XT_EXIT
                 .include "words/set-base.asm"
                 
                 ; Numeric IO
                 ; skip a numeric prefix character
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_BASES:
00f94b f060          .dw PFA_DOCONSTANT
                 .endif
00f94c 000a
00f94d 0010
00f94e 0002
00f94f 000a          .dw 10,16,2,10 ; last one could a 8 instead.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_SET_BASE:
00f950 f000          .dw DO_COLON 
                 PFA_SET_BASE:        ; ( adr1 len1 -- adr2 len2 ) 
                 .endif
00f951 f0e0          .dw XT_OVER
00f952 f0a9          .dw XT_CFETCH
00f953 f045          .dw XT_DOLITERAL
00f954 0023          .dw 35
00f955 f1a4          .dw XT_MINUS
00f956 f0c2          .dw XT_DUP
00f957 f165          .dw XT_ZERO
00f958 f045          .dw XT_DOLITERAL
00f959 0004          .dw 4
00f95a f672          .dw XT_WITHIN
00f95b f03e          .dw XT_DOCONDBRANCH
00f95c f966          DEST(SET_BASE1)
                 	.if cpu_msp430==1
                 	.endif
00f95d f94b      	.dw XT_BASES
00f95e f1ae      	.dw XT_PLUS
00f95f f3d8      	.dw XT_FETCHI
00f960 f54c      	.dw XT_BASE
00f961 f092      	.dw XT_STORE
00f962 f3f7      	.dw XT_ONE
00f963 f9aa      	.dw XT_SLASHSTRING
00f964 f034      	.dw XT_DOBRANCH
00f965 f967      	DEST(SET_BASE2)
                 SET_BASE1:
00f966 f0ea      	.dw XT_DROP
                 SET_BASE2:
00f967 f025          .dw XT_EXIT 
                 
                 ; create bases 10 , 16 , 2 , 8 ,
                 ; : set-base 35 - dup 0 4 within if 
                 ;    bases + @i base ! 1 /string 
                 ;   else 
                 ;    drop
                 ;   then ;
                 .include "words/to-number.asm"
                 
                 ; Numeric IO
                 ; convert a string to a number  c-addr2/u2 is the unconverted string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO_NUMBER:
00f968 ff07          .dw $ff07
00f969 6e3e
00f96a 6d75
00f96b 6562
00f96c 0072          .db ">number",0
00f96d f8f4          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_NUMBER
                 XT_TO_NUMBER:
00f96e f000          .dw DO_COLON
                 
                 .endif
                 
00f96f f0c2
00f970 f03e      TONUM1: .DW XT_DUP,XT_DOCONDBRANCH
00f971 f986              DEST(TONUM3)
00f972 f0e0
00f973 f0a9
00f974 f74e              .DW XT_OVER,XT_CFETCH,XT_DIGITQ
00f975 f129
00f976 f03e              .DW XT_ZEROEQUAL,XT_DOCONDBRANCH
00f977 f97a              DEST(TONUM2)
00f978 f0ea
00f979 f025              .DW XT_DROP,XT_EXIT
00f97a f110
00f97b fd2c
00f97c f54c
00f97d f08a
00f97e 018b      TONUM2: .DW XT_TO_R,XT_2SWAP,XT_BASE,XT_FETCH,XT_UDSTAR
00f97f f107
00f980 0183
00f981 fd2c              .DW XT_R_FROM,XT_MPLUS,XT_2SWAP
00f982 f3f7
00f983 f9aa
00f984 f034              .DW XT_ONE,XT_SLASHSTRING,XT_DOBRANCH
00f985 f96f              DEST(TONUM1)
00f986 f025      TONUM3: .DW XT_EXIT
                 
                 ;C >NUMBER  ud adr u -- ud' adr' u'
                 ;C                      convert string to number
                 ;   BEGIN
                 ;   DUP WHILE
                 ;       OVER C@ DIGIT?
                 ;       0= IF DROP EXIT THEN
                 ;       >R 2SWAP BASE @ UD*
                 ;       R> M+ 2SWAP
                 ;       1 /STRING
                 ;   REPEAT ;
                 .include "words/parse.asm"
                 
                 ; String
                 ; in input buffer parse ccc delimited string by the delimiter char.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PARSE:
00f987 ff05          .dw $ff05
00f988 6170
00f989 7372
00f98a 0065          .db "parse",0
00f98b f968          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSE
                 XT_PARSE:
00f98c f000          .dw DO_COLON
                 PFA_PARSE:
                 .endif
00f98d f110          .dw XT_TO_R     ; ( -- )
00f98e f9a0          .dw XT_SOURCE   ; ( -- addr len)
00f98f f579          .dw XT_TO_IN     ; ( -- addr len >in)
00f990 f08a          .dw XT_FETCH
00f991 f9aa          .dw XT_SLASHSTRING ; ( -- addr' len' )
                 
00f992 f107          .dw XT_R_FROM      ; ( -- addr' len' c)
00f993 f869          .dw XT_CSCAN       ; ( -- addr' len'')
00f994 f0c2          .dw XT_DUP         ; ( -- addr' len'' len'')
00f995 f240          .dw XT_1PLUS
00f996 f579          .dw XT_TO_IN        ; ( -- addr' len'' len'' >in)
00f997 f276          .dw XT_PLUSSTORE   ; ( -- addr' len')
00f998 f3f7          .dw XT_ONE
00f999 f9aa          .dw XT_SLASHSTRING
00f99a f025          .dw XT_EXIT
                 .include "words/source.asm"
                 
                 ; System
                 ; address and current length of the input buffer
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCE:
00f99b ff06          .dw $FF06
00f99c 6f73
00f99d 7275
00f99e 6563          .db "source"
00f99f f987          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCE
                 XT_SOURCE:
00f9a0 fc29          .dw PFA_DODEFER1
                 PFA_SOURCE:
                 .endif
00f9a1 0016          .dw USER_SOURCE
00f9a2 fbf2          .dw XT_UDEFERFETCH
00f9a3 fbfe          .dw XT_UDEFERSTORE
                 
                 
                 .include "words/slash-string.asm"
                 
                 ; String
                 ; adjust string from addr1 to addr1+n, reduce length from u1 to u2 by n
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SLASHSTRING:
00f9a4 ff07          .dw $ff07
00f9a5 732f
00f9a6 7274
00f9a7 6e69
00f9a8 0067          .db "/string",0
00f9a9 f99b          .dw VE_HEAD
                     .set VE_HEAD = VE_SLASHSTRING
                 XT_SLASHSTRING:
00f9aa f000          .dw DO_COLON
                 PFA_SLASHSTRING:
                 .endif
00f9ab f0f2          .dw XT_ROT
00f9ac f0e0          .dw XT_OVER
00f9ad f1ae          .dw XT_PLUS
00f9ae f0f2          .dw XT_ROT
00f9af f0f2          .dw XT_ROT
00f9b0 f1a4          .dw XT_MINUS
00f9b1 f025          .dw XT_EXIT
                 
                 .include "words/parse-name.asm"
                 
                 ; String
                 ; In the SOURCE buffer parse whitespace delimited string. Returns string address within SOURCE.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_PARSENAME:
00f9b2 ff0a          .dw $FF0A 
00f9b3 6170
00f9b4 7372
00f9b5 2d65
00f9b6 616e
00f9b7 656d          .db "parse-name"
00f9b8 f9a4          .dw VE_HEAD
                     .set VE_HEAD = VE_PARSENAME
                 XT_PARSENAME:
00f9b9 f000          .dw DO_COLON 
                 PFA_PARSENAME:
                 .endif
00f9ba f5eb          .dw XT_BL
00f9bb f9bd          .dw XT_SKIPSCANCHAR
00f9bc f025          .dw XT_EXIT 
                 
                 ; ( c -- addr2 len2 ) 
                 ; String
                 ; skips char and scan what's left in source for char
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_SKIPSCANCHAR:
                 ;    .dw $FF0A 
                 ;    .db "skipscanchar"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_SKIPSCANCHAR
                 XT_SKIPSCANCHAR:
00f9bd f000          .dw DO_COLON
                 PFA_SKIPSCANCHAR:
                 .endif
00f9be f110          .dw XT_TO_R
00f9bf f9a0          .dw XT_SOURCE 
00f9c0 f579          .dw XT_TO_IN 
00f9c1 f08a          .dw XT_FETCH 
00f9c2 f9aa          .dw XT_SLASHSTRING 
                 
00f9c3 f117          .dw XT_R_FETCH
00f9c4 f852          .dw XT_CSKIP
00f9c5 f107          .dw XT_R_FROM
00f9c6 f869          .dw XT_CSCAN
                 
                     ; adjust >IN
00f9c7 f560          .dw XT_2DUP
00f9c8 f1ae          .dw XT_PLUS
00f9c9 f9a0          .dw XT_SOURCE 
00f9ca f0ea          .dw XT_DROP
00f9cb f1a4          .dw XT_MINUS
00f9cc f579          .dw XT_TO_IN
00f9cd f092          .dw XT_STORE
00f9ce f025          .dw XT_EXIT
                 .include "words/find-xt.asm"
                 
                 ; Tools
                 ; search wordlists for an entry with the xt from c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_FINDXT:
00f9cf ff07          .dw $ff07
00f9d0 6966
00f9d1 646e
00f9d2 782d
00f9d3 0074          .db "find-xt",0
00f9d4 f9b2          .dw VE_HEAD
                     .set VE_HEAD = VE_FINDXT
                 XT_FINDXT:
00f9d5 f000          .dw DO_COLON
                 PFA_FINDXT:
                 .endif
00f9d6 f045          .dw XT_DOLITERAL
00f9d7 f9e1          .dw XT_FINDXTA
00f9d8 f045          .dw XT_DOLITERAL
00f9d9 0088          .dw CFG_ORDERLISTLEN
00f9da 045e          .dw XT_MAPSTACK
00f9db f129          .dw XT_ZEROEQUAL
00f9dc f03e          .dw XT_DOCONDBRANCH
00f9dd f9e0          DEST(PFA_FINDXT1)
00f9de f569            .dw XT_2DROP
00f9df f165            .dw XT_ZERO
                 PFA_FINDXT1:
00f9e0 f025          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_FINDXTA:
00f9e1 f000          .dw DO_COLON
                 PFA_FINDXTA:
                 .endif
00f9e2 f110          .dw XT_TO_R
00f9e3 f560          .dw XT_2DUP
00f9e4 f107          .dw XT_R_FROM
00f9e5 fc3b          .dw XT_SEARCH_WORDLIST
00f9e6 f0c2          .dw XT_DUP
00f9e7 f03e          .dw XT_DOCONDBRANCH
00f9e8 f9ee          DEST(PFA_FINDXTA1)
00f9e9 f110            .dw XT_TO_R
00f9ea f101            .dw XT_NIP
00f9eb f101            .dw XT_NIP
00f9ec f107            .dw XT_R_FROM
00f9ed f15c            .dw XT_TRUE
                 PFA_FINDXTA1:
00f9ee f025          .dw XT_EXIT
                 
                 .include "words/prompt-ok.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_DEFAULT_PROMPTOK:
00f9ef f000          .dw DO_COLON
                 PFA_DEFAULT_PROMPTOK:
00f9f0 f768          .dw XT_DOSLITERAL
00f9f1 0003          .dw 3
00f9f2 6f20
00f9f3 006b          .db " ok",0
                 .endif
00f9f4 f79b          .dw XT_ITYPE
00f9f5 f025          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTOK:
00f9f6 ff03          .dw $FF03
00f9f7 6f2e
../../common\words/prompt-ok.asm(43): warning: .cseg .db misalignment - padding zero byte
00f9f8 006b          .db ".ok"
00f9f9 f9cf          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTOK
                 XT_PROMPTOK:
00f9fa fc29          .dw PFA_DODEFER1
                 PFA_PROMPTOK:
                 .endif
00f9fb 001c          .dw USER_P_OK
00f9fc fbf2          .dw XT_UDEFERFETCH
00f9fd fbfe          .dw XT_UDEFERSTORE
                 .include "words/prompt-ready.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTRDY:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTRDY
                 XT_DEFAULT_PROMPTREADY:
00f9fe f000          .dw DO_COLON
                 PFA_DEFAULT_PROMPTREADY:
00f9ff f768          .dw XT_DOSLITERAL
00fa00 0002          .dw 2
00fa01 203e          .db "> "
                 .endif
00fa02 f7d0          .dw XT_CR
00fa03 f79b          .dw XT_ITYPE
00fa04 f025          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTREADY:
00fa05 ff06          .dw $FF06
00fa06 722e
00fa07 6165
00fa08 7964          .db ".ready"
00fa09 f9f6          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTREADY
                 XT_PROMPTREADY:
00fa0a fc29          .dw PFA_DODEFER1
                 PFA_PROMPTREADY:
                 .endif
00fa0b 0020          .dw USER_P_RDY
00fa0c fbf2          .dw XT_UDEFERFETCH
00fa0d fbfe          .dw XT_UDEFERSTORE
                 .include "words/prompt-error.asm"
                 
                 ; System
                 ; process the error prompt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTERROR:
                 ;    .dw $ff04
                 ;    .db "p_er"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTERROR
                 XT_DEFAULT_PROMPTERROR:
00fa0e f000          .dw DO_COLON
                 PFA_DEFAULT_PROMPTERROR:
00fa0f f768      	.dw XT_DOSLITERAL
00fa10 0004          .dw 4
00fa11 3f20
00fa12 203f          .db " ?? "
                 .endif
00fa13 f79b          .dw XT_ITYPE
00fa14 f54c          .dw XT_BASE
00fa15 f08a          .dw XT_FETCH
00fa16 f110          .dw XT_TO_R
00fa17 f5d8          .dw XT_DECIMAL
00fa18 f71d          .dw XT_DOT
00fa19 f579          .dw XT_TO_IN
00fa1a f08a          .dw XT_FETCH
00fa1b f71d          .dw XT_DOT
00fa1c f107          .dw XT_R_FROM
00fa1d f54c          .dw XT_BASE
00fa1e f092          .dw XT_STORE
00fa1f f025          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTERROR:
00fa20 ff06          .dw $FF06
00fa21 652e
00fa22 7272
00fa23 726f          .db ".error"
00fa24 fa05          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTERROR
                 XT_PROMPTERROR:
00fa25 fc29          .dw PFA_DODEFER1
                 PFA_PROMPTERROR:
                 .endif
00fa26 001e          .dw USER_P_ERR
00fa27 fbf2          .dw XT_UDEFERFETCH
00fa28 fbfe          .dw XT_UDEFERSTORE
                 .include "words/prompt-input.asm"
                 
                 ; System
                 ; send the READY prompt to the command line
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ;VE_PROMPTOK:
                 ;    .dw $ff02
                 ;    .db "ok"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_PROMPTOK
                 XT_DEFAULT_PROMPTINPUT:
00fa29 f000          .dw DO_COLON
                 PFA_DEFAULT_PROMPTINPUT:
                 .endif
00fa2a f7d0          .dw XT_CR
00fa2b f025          .dw XT_EXIT
                 
                 ; ------------------------
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_PROMPTINPUT:
00fa2c ff06          .dw $FF06
00fa2d 692e
00fa2e 706e
00fa2f 7475          .db ".input"
00fa30 fa20          .dw VE_HEAD
                     .set VE_HEAD = VE_PROMPTINPUT
                 XT_PROMPTINPUT:
00fa31 fc29          .dw PFA_DODEFER1
                 PFA_PROMPTINPUT:
                 .endif
00fa32 0022          .dw USER_P_INPUT
00fa33 fbf2          .dw XT_UDEFERFETCH
00fa34 fbfe          .dw XT_UDEFERSTORE
                 .include "words/quit.asm"
                 
                 ; System
                 ; main loop of amforth. accept - interpret in an endless loop
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QUIT:
00fa35 ff04          .dw $ff04
00fa36 7571
00fa37 7469          .db "quit"
00fa38 fa2c          .dw VE_HEAD
                     .set VE_HEAD = VE_QUIT
                 XT_QUIT:
00fa39 f000          .dw DO_COLON
                 .endif
                 PFA_QUIT:
00fa3a 0313
00fa3b 031a
00fa3c f092          .dw XT_LP0,XT_LP,XT_STORE
00fa3d fa9b          .dw XT_SP0
00fa3e f2a7          .dw XT_SP_STORE
00fa3f faa3          .dw XT_RP0
00fa40 f291          .dw XT_RP_STORE
00fa41 03a8          .dw XT_LBRACKET
                 
                 PFA_QUIT2:
00fa42 f546          .dw XT_STATE
00fa43 f08a          .dw XT_FETCH
00fa44 f129          .dw XT_ZEROEQUAL
00fa45 f03e          .dw XT_DOCONDBRANCH
00fa46 fa48          DEST(PFA_QUIT4)
00fa47 fa0a          .dw XT_PROMPTREADY
                 PFA_QUIT4:
00fa48 f8e2          .dw XT_REFILL
00fa49 fa31          .dw XT_PROMPTINPUT
00fa4a f03e          .dw XT_DOCONDBRANCH
00fa4b fa5b          DEST(PFA_QUIT3)
00fa4c f045          .dw XT_DOLITERAL
00fa4d fabc          .dw XT_INTERPRET
00fa4e f826          .dw XT_CATCH
00fa4f f0ca          .dw XT_QDUP
00fa50 f03e          .dw XT_DOCONDBRANCH
00fa51 fa5b          DEST(PFA_QUIT3)
00fa52 f0c2      	.dw XT_DUP
00fa53 f045      	.dw XT_DOLITERAL
00fa54 fffe      	.dw -2
00fa55 f17f      	.dw XT_LESS
00fa56 f03e      	.dw XT_DOCONDBRANCH
00fa57 fa59      	DEST(PFA_QUIT5)
00fa58 fa25      	.dw XT_PROMPTERROR
                 PFA_QUIT5:
00fa59 f034      	.dw XT_DOBRANCH
00fa5a fa3a      	DEST(PFA_QUIT)
                 PFA_QUIT3:
00fa5b f9fa          .dw XT_PROMPTOK
00fa5c f034          .dw XT_DOBRANCH
00fa5d fa42          DEST(PFA_QUIT2)
                 ;    .dw XT_EXIT ; never reached
                 
                 .include "words/pause.asm"
                 
                 ; Multitasking
                 ; Fetch pause vector and execute it. may make a context/task switch
                 VE_PAUSE:
00fa5e ff05          .dw $ff05
00fa5f 6170
00fa60 7375
00fa61 0065          .db "pause",0
00fa62 fa35          .dw VE_HEAD
                     .set VE_HEAD = VE_PAUSE
                 XT_PAUSE:
00fa63 fc29          .dw PFA_DODEFER1
                 PFA_PAUSE:
00fa64 0257          .dw ram_pause
00fa65 fbde          .dw XT_RDEFERFETCH
00fa66 fbe8          .dw XT_RDEFERSTORE
                 
                 .dseg
000257           ram_pause: .byte 2
                 .cseg
                 .include "words/cold.asm"
                 
                 ; System
                 ; start up amforth.
                 VE_COLD:
00fa67 ff04          .dw $ff04
00fa68 6f63
00fa69 646c          .db "cold"
00fa6a fa5e          .dw VE_HEAD
                     .set VE_HEAD = VE_COLD
                 XT_COLD:
00fa6b fa6c          .dw PFA_COLD
                 PFA_COLD:
00fa6c b6a4          in_ mcu_boot, MCUSR
00fa6d 2422          clr zerol
00fa6e 2433          clr zeroh
00fa6f 24bb          clr isrflag
00fa70 be24          out_ MCUSR, zerol
                     ; clear RAM
00fa71 e0e0          ldi zl, low(ramstart)
00fa72 e0f2          ldi zh, high(ramstart)
                 clearloop:
00fa73 9221          st Z+, zerol
00fa74 30e0          cpi zl, low(sram_size+ramstart)
00fa75 f7e9          brne clearloop
00fa76 32f2          cpi zh, high(sram_size+ramstart)
00fa77 f7d9          brne clearloop
                     ; init first user data area
                     ; allocate space for User Area
                 .dseg
000259           ram_user1: .byte SYSUSERSIZE + APPUSERSIZE
                 .cseg
00fa78 e5e9          ldi zl, low(ram_user1)
00fa79 e0f2          ldi zh, high(ram_user1)
00fa7a 012f          movw upl, zl
                     ; init return stack pointer
00fa7b ef0f          ldi temp0,low(rstackstart)
00fa7c bf0d          out_ SPL,temp0
00fa7d 8304          std Z+4, temp0
00fa7e e211          ldi temp1,high(rstackstart)
00fa7f bf1e          out_ SPH,temp1
00fa80 8315          std Z+5, temp1
                 
                     ; init parameter stack pointer
00fa81 eacf          ldi yl,low(stackstart)
00fa82 83c6          std Z+6, yl
00fa83 e2d1          ldi yh,high(stackstart)
00fa84 83d7          std Z+7, yh
                 
                     ; load Forth IP with starting word
00fa85 e8ae          ldi XL, low(PFA_WARM)
00fa86 efba          ldi XH, high(PFA_WARM)
                     ; its a far jump...
00fa87 940c f004     jmp_ DO_NEXT
                 .include "words/warm.asm"
                 
                 ; System
                 ; initialize amforth further. executes turnkey operation and go to quit
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_WARM:
00fa89 ff04          .dw $ff04
00fa8a 6177
00fa8b 6d72          .db "warm"
00fa8c fa67          .dw VE_HEAD
                     .set VE_HEAD = VE_WARM
                 XT_WARM:
00fa8d f000          .dw DO_COLON
                 PFA_WARM:
                 .endif
00fa8e fd77          .dw XT_INIT_RAM
00fa8f f045          .dw XT_DOLITERAL
00fa90 fb95          .dw XT_NOOP
00fa91 f045          .dw XT_DOLITERAL
00fa92 fa63          .dw XT_PAUSE
00fa93 fc09          .dw XT_DEFERSTORE
00fa94 03a8          .dw XT_LBRACKET
00fa95 f5f3          .dw XT_TURNKEY
00fa96 fa39          .dw XT_QUIT     ; never returns
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/sp0.asm"
                 
                 ; Stack
                 ; start address of the data stack
                 VE_SP0:
00fa97 ff03          .dw $ff03
00fa98 7073
00fa99 0030          .db "sp0",0
00fa9a fa89          .dw VE_HEAD
                     .set VE_HEAD = VE_SP0
                 XT_SP0:
00fa9b f080          .dw PFA_DOVALUE1
                 PFA_SP0:
00fa9c 0006          .dw USER_SP0
00fa9d fbf2          .dw XT_UDEFERFETCH
00fa9e fbfe          .dw XT_UDEFERSTORE
                 .include "words/rp0.asm"
                 
                 ; Stack
                 ; start address of return stack
                 VE_RP0:
00fa9f ff03          .dw $ff03
00faa0 7072
00faa1 0030          .db "rp0",0
00faa2 fa97          .dw VE_HEAD
                     .set VE_HEAD = VE_RP0
                 XT_RP0:
00faa3 f000          .dw DO_COLON
                 PFA_RP0:
00faa4 faa7          .dw XT_DORP0
00faa5 f08a          .dw XT_FETCH
00faa6 f025          .dw XT_EXIT
                 
                 ; ( -- addr) 
                 ; Stack
                 ; user variable of the address of the initial return stack
                 ;VE_DORP0:
                 ;    .dw $ff05
                 ;    .db "(rp0)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DORP0
                 XT_DORP0:
00faa7 f066          .dw PFA_DOUSER
                 PFA_DORP0:
00faa8 0004          .dw USER_RP
                 .include "words/depth.asm"
                 
                 ; Stack
                 ; number of single-cell values contained in the data stack before n was placed on the stack.
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEPTH:
00faa9 ff05          .dw $ff05
00faaa 6564
00faab 7470
00faac 0068          .db "depth",0
00faad fa9f          .dw VE_HEAD
                     .set VE_HEAD = VE_DEPTH
                 XT_DEPTH:
00faae f000          .dw DO_COLON
                 PFA_DEPTH:
                 .endif
00faaf fa9b          .dw XT_SP0
00fab0 f29e          .dw XT_SP_FETCH
00fab1 f1a4          .dw XT_MINUS
00fab2 f215          .dw XT_2SLASH
00fab3 f246          .dw XT_1MINUS
00fab4 f025          .dw XT_EXIT
                 .include "words/interpret.asm"
                 
                 ; System
                 ; Interpret SOURCE word by word.
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_INTERPRET:
00fab5 ff09          .dw $ff09
00fab6 6e69
00fab7 6574
00fab8 7072
00fab9 6572
00faba 0074          .db "interpret",0
00fabb faa9          .dw VE_HEAD
                     .set VE_HEAD = VE_INTERPRET
                 XT_INTERPRET:
00fabc f000          .dw DO_COLON
                 .endif
                 PFA_INTERPRET:
00fabd f9b9          .dw XT_PARSENAME ; ( -- addr len )
00fabe f0c2          .dw XT_DUP   ; ( -- addr len flag)
00fabf f03e          .dw XT_DOCONDBRANCH
00fac0 facd          DEST(PFA_INTERPRET2)
00fac1 fad9            .dw XT_FORTHRECOGNIZER
00fac2 fae4            .dw XT_RECOGNIZE
00fac3 f546            .dw XT_STATE
00fac4 f08a            .dw XT_FETCH
00fac5 f03e            .dw XT_DOCONDBRANCH
00fac6 fac8          DEST(PFA_INTERPRET1)
00fac7 fbc1            .dw XT_ICELLPLUS   ; we need the compile action
                 PFA_INTERPRET1:
00fac8 f3d8            .dw XT_FETCHI
00fac9 f02f            .dw XT_EXECUTE
00faca fb6d            .dw XT_QSTACK
00facb f034          .dw XT_DOBRANCH
00facc fabd          DEST(PFA_INTERPRET)
                 PFA_INTERPRET2:
00facd f569          .dw XT_2DROP
00face f025          .dw XT_EXIT
                 .include "words/forth-recognizer.asm"
                 
                 ; System Value
                 ; address of the next free data space (RAM) cell
                 VE_FORTHRECOGNIZER:
00facf ff10          .dw $ff10
00fad0 6f66
00fad1 7472
00fad2 2d68
00fad3 6572
00fad4 6f63
00fad5 6e67
00fad6 7a69
00fad7 7265          .db "forth-recognizer"
00fad8 fab5          .dw VE_HEAD
                     .set VE_HEAD = VE_FORTHRECOGNIZER
                 XT_FORTHRECOGNIZER:
00fad9 f080          .dw PFA_DOVALUE1
                 PFA_FORTHRECOGNIZER:
00fada 007c          .dw CFG_FORTHRECOGNIZER
00fadb fbca          .dw XT_EDEFERFETCH
00fadc fbd4          .dw XT_EDEFERSTORE
                 .include "words/recognize.asm"
                 
                 ; System
                 ; walk the recognizer stack
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECOGNIZE:
00fadd ff09          .dw $ff09
00fade 6572
00fadf 6f63
00fae0 6e67
00fae1 7a69
00fae2 0065          .db "recognize",0
00fae3 facf          .dw VE_HEAD
                     .set VE_HEAD = VE_RECOGNIZE
                 XT_RECOGNIZE:
00fae4 f000          .dw DO_COLON
                 PFA_RECOGNIZE:
                 .endif
00fae5 f045          .dw XT_DOLITERAL
00fae6 faef          .dw XT_RECOGNIZE_A
00fae7 f0d5          .dw XT_SWAP
00fae8 045e          .dw XT_MAPSTACK
00fae9 f129          .dw XT_ZEROEQUAL
00faea f03e          .dw XT_DOCONDBRANCH
00faeb faee          DEST(PFA_RECOGNIZE1)
00faec f569            .dw XT_2DROP
00faed fb60            .dw XT_RECTYPE_NULL
                 PFA_RECOGNIZE1:
00faee f025          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 ; ( addr len XT -- addr len [ rectype-* -1 | 0 ] )
                 XT_RECOGNIZE_A:
00faef f000         .dw DO_COLON
                 PFA_RECOGNIZE_A:
                 .endif
00faf0 f0f2         .dw XT_ROT  ; -- len xt addr
00faf1 f0f2         .dw XT_ROT  ; -- xt addr len
00faf2 f560         .dw XT_2DUP 
00faf3 f325         .dw XT_2TO_R
00faf4 f0f2         .dw XT_ROT  ; -- addr len xt
00faf5 f02f         .dw XT_EXECUTE ; -- i*x rectype-* | rectype-null
00faf6 f334         .dw XT_2R_FROM
00faf7 f0f2         .dw XT_ROT
00faf8 f0c2         .dw XT_DUP
00faf9 fb60         .dw XT_RECTYPE_NULL
00fafa f3f0         .dw XT_EQUAL
00fafb f03e         .dw XT_DOCONDBRANCH
00fafc fb00         DEST(PFA_RECOGNIZE_A1)
00fafd f0ea           .dw XT_DROP
00fafe f165           .dw XT_ZERO
00faff f025           .dw XT_EXIT
                 PFA_RECOGNIZE_A1:
00fb00 f101         .dw XT_NIP 
00fb01 f101         .dw XT_NIP
00fb02 f15c         .dw XT_TRUE
00fb03 f025         .dw XT_EXIT
                 
                 ; : recognize ( addr len stack-id -- i*x rectype-* | rectype-null )
                 ;   [: ( addr len -- addr len 0 | i*x rectype-* -1 )
                 ;      rot rot 2dup 2>r rot execute 2r> rot 
                 ;      dup rectype-null = ( -- addr len rectype-* f )
                 ;      if drop 0 else nip nip -1 then
                 ;    ;] 
                 ;    map-stack ( -- i*x addr len rectype-* f )
                 ;    0= if \ a recognizer did the job, remove addr/len
                 ;     2drop rectype-null
                 ;    then ;
                 ;
                 .include "words/rec-intnum.asm"
                 
                 ; Interpreter
                 ; Method table for single cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_NUM:
00fb04 ff0b          .dw $ff0b
00fb05 6572
00fb06 7463
00fb07 7079
00fb08 2d65
00fb09 756e
00fb0a 006d          .db "rectype-num",0
00fb0b fadd          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_NUM
                 XT_RECTYPE_NUM:
00fb0c f060          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_NUM:
                 .endif
00fb0d fb95          .dw XT_NOOP    ; interpret
00fb0e 0234          .dw XT_LITERAL ; compile
00fb0f 0234          .dw XT_LITERAL ; postpone
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; Method table for double cell integers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_DNUM:
00fb10 ff0c          .dw $ff0c
00fb11 6572
00fb12 7463
00fb13 7079
00fb14 2d65
00fb15 6e64
00fb16 6d75          .db "rectype-dnum"
00fb17 fb04          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_DNUM
                 XT_RECTYPE_DNUM:
00fb18 f060          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_DNUM:
                 .endif
00fb19 fb95          .dw XT_NOOP     ; interpret
00fb1a f3e8          .dw XT_2LITERAL ; compile
00fb1b f3e8          .dw XT_2LITERAL ; postpone
                 
                 ; ( addr len -- f )
                 ; Interpreter
                 ; recognizer for integer numbers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 VE_REC_NUM:
00fb1c ff07          .dw $ff07
00fb1d 6572
00fb1e 2d63
00fb1f 756e
00fb20 006d          .db "rec-num",0
00fb21 fb10          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_NUM
                 XT_REC_NUM:
00fb22 f000          .dw DO_COLON
                 PFA_REC_NUM:
                 .endif
                     ; try converting to a number
00fb23 f8f9          .dw XT_NUMBER
00fb24 f03e          .dw XT_DOCONDBRANCH
00fb25 fb2e          DEST(PFA_REC_NONUMBER)
00fb26 f3f7          .dw XT_ONE
00fb27 f3f0          .dw XT_EQUAL
00fb28 f03e          .dw XT_DOCONDBRANCH
00fb29 fb2c          DEST(PFA_REC_INTNUM2)
00fb2a fb0c            .dw XT_RECTYPE_NUM
00fb2b f025            .dw XT_EXIT
                 PFA_REC_INTNUM2:
00fb2c fb18            .dw XT_RECTYPE_DNUM
00fb2d f025            .dw XT_EXIT
                 PFA_REC_NONUMBER:
00fb2e fb60          .dw XT_RECTYPE_NULL
00fb2f f025          .dw XT_EXIT
                 .include "words/rec-find.asm"
                 
                 ; Interpreter
                 ; search for a word
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 VE_REC_FIND:
00fb30 ff08          .dw $ff08
00fb31 6572
00fb32 2d63
00fb33 6966
00fb34 646e          .db "rec-find"
00fb35 fb1c          .dw VE_HEAD
                     .set VE_HEAD = VE_REC_FIND
                 XT_REC_FIND:
00fb36 f000          .dw DO_COLON
                 PFA_REC_FIND:
                 .endif
00fb37 f9d5          .DW XT_FINDXT
00fb38 f0c2          .dw XT_DUP
00fb39 f129          .dw XT_ZEROEQUAL
00fb3a f03e          .dw XT_DOCONDBRANCH
00fb3b fb3f          DEST(PFA_REC_WORD_FOUND)
00fb3c f0ea              .dw XT_DROP
00fb3d fb60      	.dw XT_RECTYPE_NULL
00fb3e f025      	.dw XT_EXIT
                 PFA_REC_WORD_FOUND:
00fb3f fb48          .dw XT_RECTYPE_XT
                 
00fb40 f025          .dw XT_EXIT
                 
                 ; ( -- addr )
                 ; Interpreter
                 ; actions to handle execution tokens and their flags
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_XT:
00fb41 ff0a          .dw $ff0a
00fb42 6572
00fb43 7463
00fb44 7079
00fb45 2d65
00fb46 7478          .db "rectype-xt"
00fb47 fb30          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_XT
                 XT_RECTYPE_XT:
00fb48 f060          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_XT:
                 .endif
00fb49 fb4c          .dw XT_R_WORD_INTERPRET
00fb4a fb50          .dw XT_R_WORD_COMPILE
00fb4b f3e8          .dw XT_2LITERAL
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; interpret method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_R_WORD_INTERPRET:
00fb4c f000          .dw DO_COLON
                 PFA_R_WORD_INTERPRET:
                 .endif
00fb4d f0ea          .dw XT_DROP ; the flags are in the way
00fb4e f02f          .dw XT_EXECUTE
00fb4f f025          .dw XT_EXIT
                 
                 ; ( XT flags -- )
                 ; Interpreter
                 ; Compile method for WORD recognizer
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 XT_R_WORD_COMPILE:
00fb50 f000          .dw DO_COLON
                 PFA_R_WORD_COMPILE:
                 .endif
00fb51 f130          .dw XT_ZEROLESS
00fb52 f03e          .dw XT_DOCONDBRANCH
00fb53 fb56          DEST(PFA_R_WORD_COMPILE1)
00fb54 021e      	.dw XT_COMMA
00fb55 f025              .dw XT_EXIT
                 PFA_R_WORD_COMPILE1:
00fb56 f02f              .dw XT_EXECUTE
00fb57 f025          .dw XT_EXIT
                 .include "words/rec-null.asm"
                 
                 ; Interpreter
                 ; there is no parser for this recognizer, this is the default and failsafe part
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RECTYPE_NULL:
00fb58 ff0c          .dw $ff0c
00fb59 6572
00fb5a 7463
00fb5b 7079
00fb5c 2d65
00fb5d 756e
00fb5e 6c6c          .db "rectype-null"
00fb5f fb41          .dw VE_HEAD
                     .set VE_HEAD = VE_RECTYPE_NULL
                 XT_RECTYPE_NULL:
00fb60 f060          .dw PFA_DOCONSTANT
                 PFA_RECTYPE_NULL:
                 .endif
00fb61 fb64          .dw XT_FAIL  ; interpret
00fb62 fb64          .dw XT_FAIL  ; compile
00fb63 fb64          .dw XT_FAIL  ; postpone
                 
                 ; ( addr len -- )
                 ; Interpreter
                 ; default failure action: throw exception -13.
                 .if cpu_msp430==1
                 .endif
                 .if cpu_avr8==1
                 ;VE_FAIL:
                 ;    .dw $ff04
                 ;    .db "fail"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_FAIL
                 XT_FAIL:
00fb64 f000          .dw DO_COLON
                 PFA_FAIL:
                 .endif
00fb65 f045          .dw XT_DOLITERAL
00fb66 fff3          .dw -13
00fb67 f83c          .dw XT_THROW
                 
                 .include "words/q-stack.asm"
                 
                 ; Tools
                 ; check data stack depth and exit to quit if underrun
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_QSTACK:
00fb68 ff06          .dw $ff06
00fb69 733f
00fb6a 6174
00fb6b 6b63          .db "?stack"
00fb6c fb58          .dw VE_HEAD
                     .set VE_HEAD = VE_QSTACK
                 XT_QSTACK:
00fb6d f000          .dw DO_COLON
                 PFA_QSTACK:
                 .endif
00fb6e faae          .dw XT_DEPTH
00fb6f f130          .dw XT_ZEROLESS
00fb70 f03e          .dw XT_DOCONDBRANCH
00fb71 fb75          DEST(PFA_QSTACK1)
00fb72 f045            .dw XT_DOLITERAL
00fb73 fffc            .dw -4
00fb74 f83c            .dw XT_THROW
                 PFA_QSTACK1:
00fb75 f025          .dw XT_EXIT
                 .include "words/ver.asm"
                 
                 ; Tools
                 ; print the version string
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DOT_VER:
00fb76 ff03          .dw $ff03
00fb77 6576
../../common\words/ver.asm(12): warning: .cseg .db misalignment - padding zero byte
00fb78 0072          .db "ver"
00fb79 fb68          .dw VE_HEAD
                     .set VE_HEAD = VE_DOT_VER
                 XT_DOT_VER:
00fb7a f000          .dw DO_COLON
                 PFA_DOT_VER:
                 .endif
00fb7b f508          .dw XT_ENV_FORTHNAME
00fb7c f79b          .dw XT_ITYPE
00fb7d f7dd          .dw XT_SPACE
00fb7e f54c          .dw XT_BASE
00fb7f f08a          .dw XT_FETCH
                 
00fb80 f516          .dw XT_ENV_FORTHVERSION
00fb81 f5d8          .dw XT_DECIMAL
00fb82 fd8e          .dw XT_S2D
00fb83 f6b9          .dw XT_L_SHARP
00fb84 f6c1          .dw XT_SHARP
00fb85 f045          .dw XT_DOLITERAL
00fb86 002e          .dw '.'
00fb87 f6aa          .dw XT_HOLD
00fb88 f6d7          .dw XT_SHARP_S
00fb89 f6e2          .dw XT_SHARP_G
00fb8a f7f6          .dw XT_TYPE
00fb8b f54c          .dw XT_BASE
00fb8c f092          .dw XT_STORE
00fb8d f7dd          .dw XT_SPACE
00fb8e f51e          .dw XT_ENV_CPU
00fb8f f79b          .dw XT_ITYPE
                 
00fb90 f025          .dw XT_EXIT
                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                 .include "words/noop.asm"
                 
                 ; Tools
                 ; do nothing
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NOOP:
00fb91 ff04          .dw $ff04
00fb92 6f6e
00fb93 706f          .db "noop"
00fb94 fb76          .dw VE_HEAD
                     .set VE_HEAD = VE_NOOP
                 XT_NOOP:
00fb95 f000          .dw DO_COLON
                 PFA_NOOP:
                 .endif
00fb96 f025         .DW XT_EXIT
                 .include "words/unused.asm"
                 
                 ; Tools
                 ; Amount of available RAM (incl. PAD)
                 VE_UNUSED:
00fb97 ff06          .dw $ff06
00fb98 6e75
00fb99 7375
00fb9a 6465          .db "unused"
00fb9b fb91          .dw VE_HEAD
                     .set VE_HEAD = VE_UNUSED
                 XT_UNUSED:
00fb9c f000          .dw DO_COLON
                 PFA_UNUSED:
00fb9d f29e          .dw XT_SP_FETCH
00fb9e f5ba          .dw XT_HERE
00fb9f f1a4          .dw XT_MINUS
00fba0 f025          .dw XT_EXIT
                 
                 .include "words/to.asm"
                 
                 ; Tools
                 ; store the TOS to the named value (eeprom cell)
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TO:
00fba1 0002          .dw $0002
00fba2 6f74          .db "to"
00fba3 fb97          .dw VE_HEAD
                     .set VE_HEAD = VE_TO
                 XT_TO:
00fba4 f000          .dw DO_COLON
                 PFA_TO:
                 .endif
00fba5 f805          .dw XT_TICK
00fba6 fd97          .dw XT_TO_BODY
00fba7 f546          .dw XT_STATE
00fba8 f08a          .dw XT_FETCH
00fba9 f03e          .dw XT_DOCONDBRANCH
00fbaa fbb5          DEST(PFA_TO1)
00fbab 0213          .dw XT_COMPILE
00fbac fbaf          .dw XT_DOTO
00fbad 021e          .dw XT_COMMA
00fbae f025          .dw XT_EXIT
                 
                 ; ( n -- ) (R: IP -- IP+1)
                 ; Tools
                 ; runtime portion of to
                 ;VE_DOTO:
                 ;    .dw $ff04
                 ;    .db "(to)"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_DOTO
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 
                 XT_DOTO:
00fbaf f000          .dw DO_COLON
                 PFA_DOTO:
                 .endif
00fbb0 f107          .dw XT_R_FROM
00fbb1 f0c2          .dw XT_DUP
00fbb2 fbc1          .dw XT_ICELLPLUS
00fbb3 f110          .dw XT_TO_R
00fbb4 f3d8          .dw XT_FETCHI
                 PFA_TO1:
00fbb5 f0c2          .dw XT_DUP
00fbb6 fbc1          .dw XT_ICELLPLUS
00fbb7 fbc1          .dw XT_ICELLPLUS
00fbb8 f3d8          .dw XT_FETCHI
00fbb9 f02f          .dw XT_EXECUTE
00fbba f025          .dw XT_EXIT
                 .include "words/i-cellplus.asm"
                 
                 ; Compiler
                 ; skip to the next cell in flash
                 VE_ICELLPLUS:
00fbbb ff07          .dw $FF07
00fbbc 2d69
00fbbd 6563
00fbbe 6c6c
00fbbf 002b          .db "i-cell+",0
00fbc0 fba1          .dw VE_HEAD
                     .set VE_HEAD = VE_ICELLPLUS
                 XT_ICELLPLUS:
00fbc1 f000          .dw DO_COLON
                 PFA_ICELLPLUS:
00fbc2 f240          .dw XT_1PLUS
00fbc3 f025          .dw XT_EXIT
                 
                 .include "words/edefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for eeprom defers
                 VE_EDEFERFETCH:
00fbc4 ff07          .dw $ff07
00fbc5 6445
00fbc6 6665
00fbc7 7265
00fbc8 0040          .db "Edefer@",0
00fbc9 fbbb          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERFETCH
                 XT_EDEFERFETCH:
00fbca f000          .dw DO_COLON
                 PFA_EDEFERFETCH:
00fbcb f3d8          .dw XT_FETCHI
00fbcc f366          .dw XT_FETCHE
00fbcd f025          .dw XT_EXIT
                 .include "words/edefer-store.asm"
                 
                 ; System
                 ; does the real defer! for eeprom defers
                 VE_EDEFERSTORE:
00fbce ff07          .dw $ff07
00fbcf 6445
00fbd0 6665
00fbd1 7265
00fbd2 0021          .db "Edefer!",0
00fbd3 fbc4          .dw VE_HEAD
                     .set VE_HEAD = VE_EDEFERSTORE
                 XT_EDEFERSTORE:
00fbd4 f000          .dw DO_COLON
                 PFA_EDEFERSTORE:
00fbd5 f3d8          .dw XT_FETCHI
00fbd6 f342          .dw XT_STOREE
00fbd7 f025          .dw XT_EXIT
                 .include "words/rdefer-fetch.asm"
                 
                 ; System
                 ; The defer@ for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERFETCH:
00fbd8 ff07          .dw $ff07
00fbd9 6452
00fbda 6665
00fbdb 7265
00fbdc 0040          .db "Rdefer@",0
00fbdd fbce          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERFETCH
                 XT_RDEFERFETCH:
00fbde f000          .dw DO_COLON
                 PFA_RDEFERFETCH:
                 .endif
00fbdf f3d8          .dw XT_FETCHI
00fbe0 f08a          .dw XT_FETCH
00fbe1 f025          .dw XT_EXIT
                 .include "words/rdefer-store.asm"
                 
                 ; System
                 ; The defer! for ram defers
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_RDEFERSTORE:
00fbe2 ff07          .dw $ff07
00fbe3 6452
00fbe4 6665
00fbe5 7265
00fbe6 0021          .db "Rdefer!",0
00fbe7 fbd8          .dw VE_HEAD
                     .set VE_HEAD = VE_RDEFERSTORE
                 XT_RDEFERSTORE:
00fbe8 f000          .dw DO_COLON
                 PFA_RDEFERSTORE:
                 .endif
00fbe9 f3d8          .dw XT_FETCHI
00fbea f092          .dw XT_STORE
00fbeb f025          .dw XT_EXIT
                 
                 .include "words/udefer-fetch.asm"
                 
                 ; System
                 ; does the real defer@ for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERFETCH:
00fbec ff07          .dw $ff07
00fbed 6455
00fbee 6665
00fbef 7265
00fbf0 0040          .db "Udefer@",0
00fbf1 fbe2          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERFETCH
                 XT_UDEFERFETCH:
00fbf2 f000          .dw DO_COLON
                 PFA_UDEFERFETCH:
                 .endif
00fbf3 f3d8          .dw XT_FETCHI
00fbf4 f313          .dw XT_UP_FETCH
00fbf5 f1ae          .dw XT_PLUS
00fbf6 f08a          .dw XT_FETCH
00fbf7 f025          .dw XT_EXIT
                 .include "words/udefer-store.asm"
                 
                 ; System
                 ; does the real defer! for user based defers
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_UDEFERSTORE:
00fbf8 ff07          .dw $ff07
00fbf9 6455
00fbfa 6665
00fbfb 7265
00fbfc 0021          .db "Udefer!",0
00fbfd fbec          .dw VE_HEAD
                     .set VE_HEAD = VE_UDEFERSTORE
                 XT_UDEFERSTORE:
00fbfe f000          .dw DO_COLON
                 PFA_UDEFERSTORE:
                 .endif
                 
00fbff f3d8          .dw XT_FETCHI
00fc00 f313          .dw XT_UP_FETCH
00fc01 f1ae          .dw XT_PLUS
00fc02 f092          .dw XT_STORE
00fc03 f025          .dw XT_EXIT
                 
                 .include "words/defer-store.asm"
                 
                 ; System
                 ; stores xt1 as the xt to be executed when xt2 is called
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERSTORE:
00fc04 ff06          .dw $ff06
00fc05 6564
00fc06 6566
00fc07 2172          .db "defer!"
00fc08 fbf8          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERSTORE
                 XT_DEFERSTORE:
00fc09 f000          .dw DO_COLON
                 PFA_DEFERSTORE:
                 .endif
00fc0a fd97          .dw XT_TO_BODY
00fc0b f0c2          .dw XT_DUP
00fc0c fbc1          .dw XT_ICELLPLUS
00fc0d fbc1          .dw XT_ICELLPLUS
00fc0e f3d8          .dw XT_FETCHI
00fc0f f02f          .dw XT_EXECUTE
00fc10 f025          .dw XT_EXIT
                 
                 .include "words/defer-fetch.asm"
                 
                 ; System
                 ; returns the XT associated with the given XT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_DEFERFETCH:
00fc11 ff06          .dw $ff06
00fc12 6564
00fc13 6566
00fc14 4072          .db "defer@"
00fc15 fc04          .dw VE_HEAD
                     .set VE_HEAD = VE_DEFERFETCH
                 XT_DEFERFETCH:
00fc16 f000          .dw DO_COLON
                 PFA_DEFERFETCH:
                 .endif
00fc17 fd97          .dw XT_TO_BODY 
00fc18 f0c2          .dw XT_DUP
00fc19 fbc1          .dw XT_ICELLPLUS
00fc1a f3d8          .dw XT_FETCHI
00fc1b f02f          .dw XT_EXECUTE
00fc1c f025          .dw XT_EXIT
                 .include "words/do-defer.asm"
                 
                 ; System
                 ; runtime of defer
                 VE_DODEFER:
00fc1d ff07          .dw $ff07
00fc1e 6428
00fc1f 6665
00fc20 7265
00fc21 0029          .db "(defer)", 0
00fc22 fc11          .dw VE_HEAD
                     .set VE_HEAD = VE_DODEFER
                 XT_DODEFER:
00fc23 f000          .dw DO_COLON
                 PFA_DODEFER:
00fc24 01e5          .dw XT_DOCREATE
00fc25 0350          .dw XT_REVEAL
00fc26 0213          .dw XT_COMPILE
00fc27 fc29          .dw PFA_DODEFER1
00fc28 f025          .dw XT_EXIT
                 PFA_DODEFER1:
00fc29 940e 0369     call_ DO_DODOES
00fc2b f0c2          .dw XT_DUP
00fc2c fbc1          .dw XT_ICELLPLUS
00fc2d f3d8          .dw XT_FETCHI
00fc2e f02f          .dw XT_EXECUTE 
00fc2f f02f          .dw XT_EXECUTE
00fc30 f025          .dw XT_EXIT
                 
                 ; : (defer) <builds does> dup i-cell+ @i execute execute ;
                 
                 
                 .include "words/search-wordlist.asm"
                 
                 ; Search Order
                 ; searches the word list wid for the word at c-addr/len
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SEARCH_WORDLIST:
00fc31 ff0f          .dw $ff0f
00fc32 6573
00fc33 7261
00fc34 6863
00fc35 772d
00fc36 726f
00fc37 6c64
00fc38 7369
00fc39 0074          .db "search-wordlist",0
00fc3a fc1d          .dw VE_HEAD
                     .set VE_HEAD = VE_SEARCH_WORDLIST
                 XT_SEARCH_WORDLIST:
00fc3b f000          .dw DO_COLON
                 PFA_SEARCH_WORDLIST:
                 .endif
00fc3c f110          .dw XT_TO_R
00fc3d f165          .dw XT_ZERO
00fc3e f045          .dw XT_DOLITERAL
00fc3f fc50          .dw XT_ISWORD
00fc40 f107          .dw XT_R_FROM
00fc41 fc6d          .dw XT_TRAVERSEWORDLIST
00fc42 f0c2          .dw XT_DUP
00fc43 f129          .dw XT_ZEROEQUAL
00fc44 f03e          .dw XT_DOCONDBRANCH
00fc45 fc4a          DEST(PFA_SEARCH_WORDLIST1)
00fc46 f569             .dw XT_2DROP
00fc47 f0ea             .dw XT_DROP
00fc48 f165             .dw XT_ZERO
00fc49 f025             .dw XT_EXIT
                 PFA_SEARCH_WORDLIST1:
                       ; ... get the XT ...
00fc4a f0c2            .dw XT_DUP
00fc4b fc94            .dw XT_NFA2CFA
                       ; .. and get the header flag
00fc4c f0d5            .dw XT_SWAP
00fc4d 01c0            .dw XT_NAME2FLAGS
00fc4e 01ae            .dw XT_IMMEDIATEQ
00fc4f f025          .dw XT_EXIT
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 XT_ISWORD:
00fc50 f000          .dw DO_COLON
                 PFA_ISWORD:
                 .endif
                     ; ( c-addr len 0 nt -- c-addr len 0 true| nt false )
00fc51 f110          .dw XT_TO_R
00fc52 f0ea          .dw XT_DROP
00fc53 f560          .dw XT_2DUP
00fc54 f117          .dw XT_R_FETCH  ; -- addr len addr len nt
00fc55 fc88          .dw XT_NAME2STRING
00fc56 fc9e          .dw XT_ICOMPARE      ; (-- addr len f )
00fc57 f03e          .dw XT_DOCONDBRANCH
00fc58 fc5e          DEST(PFA_ISWORD3)
                       ; not now
00fc59 f107            .dw XT_R_FROM
00fc5a f0ea            .dw XT_DROP
00fc5b f165            .dw XT_ZERO
00fc5c f15c            .dw XT_TRUE         ; maybe next word
00fc5d f025            .dw XT_EXIT
                 PFA_ISWORD3:
                       ; we found the word, now clean up iteration data ...
00fc5e f569            .dw XT_2DROP
00fc5f f107            .dw XT_R_FROM
00fc60 f165            .dw XT_ZERO       ; finish traverse-wordlist
00fc61 f025            .dw XT_EXIT
                 .include "words/traverse-wordlist.asm"
                 
                 ; Tools Ext (2012)
                 ; call the xt for every member of the wordlist wid until xt returns false
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TRAVERSEWORDLIST:
00fc62 ff11          .dw $ff11
00fc63 7274
00fc64 7661
00fc65 7265
00fc66 6573
00fc67 772d
00fc68 726f
00fc69 6c64
00fc6a 7369
00fc6b 0074          .db "traverse-wordlist",0
00fc6c fc31          .dw VE_HEAD
                     .set VE_HEAD = VE_TRAVERSEWORDLIST
                 XT_TRAVERSEWORDLIST:
00fc6d f000          .dw DO_COLON
                 PFA_TRAVERSEWORDLIST:
                 
                 .endif
00fc6e f366          .dw XT_FETCHE
                 PFA_TRAVERSEWORDLIST1:
00fc6f f0c2          .dw XT_DUP           ; ( -- xt nt nt )
00fc70 f03e          .dw XT_DOCONDBRANCH  ; ( -- nt ) is nfa = counted string
00fc71 fc7e          DEST(PFA_TRAVERSEWORDLIST2)
00fc72 f560          .dw XT_2DUP
00fc73 f325          .dw XT_2TO_R
00fc74 f0d5          .dw XT_SWAP
00fc75 f02f          .dw XT_EXECUTE
00fc76 f334          .dw XT_2R_FROM
00fc77 f0f2          .dw XT_ROT
00fc78 f03e          .dw XT_DOCONDBRANCH
00fc79 fc7e          DEST(PFA_TRAVERSEWORDLIST2)
00fc7a 04c9          .dw XT_NFA2LFA
00fc7b f3d8          .dw XT_FETCHI
00fc7c f034          .dw XT_DOBRANCH      ; ( -- addr )
00fc7d fc6f          DEST(PFA_TRAVERSEWORDLIST1)       ; ( -- addr )
                 PFA_TRAVERSEWORDLIST2:
00fc7e f569          .dw XT_2DROP
00fc7f f025          .dw XT_EXIT
                 
                 ; : traverse-wordlist ( i*x xt wid -- i*x' )
                 ;        begin @ dup
                 ;        while
                 ;          2dup 2>r
                 ;          swap execute ( i*x nt -- i*x' f )
                 ;          2r> rot
                 ;        while
                 ;          nfa>lfa @i
                 ;        repeat then 2drop ;
                 .include "words/name2string.asm"
                 
                 ; Tools Ext (2012)
                 ; get a (flash) string from a name token nt
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NAME2STRING:
00fc80 ff0b          .dw $ff0b
00fc81 616e
00fc82 656d
00fc83 733e
00fc84 7274
00fc85 6e69
00fc86 0067          .db "name>string",0
00fc87 fc62          .dw VE_HEAD
                     .set VE_HEAD = VE_NAME2STRING
                 XT_NAME2STRING:
00fc88 f000          .dw DO_COLON
                 PFA_NAME2STRING:
                 
                 .endif
00fc89 f7c7          .dw XT_ICOUNT   ; ( -- addr n )
00fc8a f045          .dw XT_DOLITERAL
00fc8b 00ff          .dw 255
00fc8c f224          .dw XT_AND      ; mask immediate bit
00fc8d f025          .dw XT_EXIT
                 .include "words/nfa2cfa.asm"
                 
                 ; Tools
                 ; get the XT from a name token
                 VE_NFA2CFA:
00fc8e ff07          .dw $ff07
00fc8f 666e
00fc90 3e61
00fc91 6663
../../avr8\words/nfa2cfa.asm(6): warning: .cseg .db misalignment - padding zero byte
00fc92 0061          .db "nfa>cfa"
00fc93 fc80          .dw VE_HEAD
                     .set VE_HEAD = VE_NFA2CFA
                 XT_NFA2CFA:
00fc94 f000          .dw DO_COLON
                 PFA_NFA2CFA:
00fc95 04c9          .dw XT_NFA2LFA ; skip to link field
00fc96 f240          .dw XT_1PLUS   ; next is the execution token
00fc97 f025          .dw XT_EXIT
                 .include "words/icompare.asm"
                 
                 ; Tools
                 ; compares string in RAM with string in flash. f is zero if equal like COMPARE
                 VE_ICOMPARE:
00fc98 ff08          .dw $ff08
00fc99 6369
00fc9a 6d6f
00fc9b 6170
00fc9c 6572          .db "icompare"
00fc9d fc8e          .dw VE_HEAD
                     .set VE_HEAD = VE_ICOMPARE
                 XT_ICOMPARE:
00fc9e f000          .dw DO_COLON
                 PFA_ICOMPARE:
00fc9f f110          .dw XT_TO_R    ; ( -- r-addr r-len f-addr)
00fca0 f0e0          .dw XT_OVER    ; ( -- r-addr r-len f-addr r-len)
00fca1 f107          .dw XT_R_FROM  ; ( -- r-addr r-len f-addr r-len f-len )
00fca2 f122          .dw XT_NOTEQUAL ; ( -- r-addr r-len f-addr flag )
00fca3 f03e          .dw XT_DOCONDBRANCH
00fca4 fca9          .dw PFA_ICOMPARE_SAMELEN
00fca5 f569            .dw XT_2DROP
00fca6 f0ea            .dw XT_DROP
00fca7 f15c            .dw XT_TRUE
00fca8 f025            .dw XT_EXIT
                 PFA_ICOMPARE_SAMELEN:
00fca9 f0d5          .dw XT_SWAP ; ( -- r-addr f-addr len )
00fcaa f165          .dw XT_ZERO
00fcab 02dd          .dw XT_QDOCHECK
00fcac f03e          .dw XT_DOCONDBRANCH
00fcad fcce          .dw PFA_ICOMPARE_DONE
00fcae f2ac          .dw XT_DODO
                 PFA_ICOMPARE_LOOP:
                     ; ( r-addr f-addr --)
00fcaf f0e0          .dw XT_OVER
00fcb0 f08a          .dw XT_FETCH
                 .if WANT_IGNORECASE == 1
00fcb1 fcd1          .dw XT_ICOMPARE_LC
                 .endif
00fcb2 f0e0          .dw XT_OVER
00fcb3 f3d8          .dw XT_FETCHI ; ( -- r-addr f-addr r-cc f- cc)
                 .if WANT_IGNORECASE == 1
00fcb4 fcd1          .dw XT_ICOMPARE_LC
                 .endif
                     ; flash strings are zero-padded at the last cell
                     ; that means: if the flash cell is less $0100, than mask the
                     ; high byte in the ram cell
00fcb5 f0c2          .dw XT_DUP
                     ;.dw XT_BYTESWAP
00fcb6 f045          .dw XT_DOLITERAL
00fcb7 0100          .dw $100
00fcb8 f16d          .dw XT_ULESS
00fcb9 f03e          .dw XT_DOCONDBRANCH
00fcba fcbf          .dw PFA_ICOMPARE_LASTCELL
00fcbb f0d5          .dw XT_SWAP
00fcbc f045          .dw XT_DOLITERAL
00fcbd 00ff          .dw $00FF
00fcbe f224          .dw XT_AND  ; the final swap can be omitted
                 PFA_ICOMPARE_LASTCELL:
00fcbf f122          .dw XT_NOTEQUAL
00fcc0 f03e          .dw XT_DOCONDBRANCH
00fcc1 fcc6          .dw PFA_ICOMPARE_NEXTLOOP
00fcc2 f569          .dw XT_2DROP
00fcc3 f15c          .dw XT_TRUE
00fcc4 f2e5          .dw XT_UNLOOP
00fcc5 f025          .dw XT_EXIT
                 PFA_ICOMPARE_NEXTLOOP:
00fcc6 f240          .dw XT_1PLUS
00fcc7 f0d5          .dw XT_SWAP
00fcc8 f559          .dw XT_CELLPLUS
00fcc9 f0d5          .dw XT_SWAP
00fcca f045          .dw XT_DOLITERAL
00fccb 0002          .dw 2
00fccc f2cb          .dw XT_DOPLUSLOOP
00fccd fcaf          .dw PFA_ICOMPARE_LOOP
                 PFA_ICOMPARE_DONE:
00fcce f569          .dw XT_2DROP
00fccf f165          .dw XT_ZERO
00fcd0 f025          .dw XT_EXIT
                 
                 .if WANT_IGNORECASE == 1
                 ; ( cc1 cc2 -- f) 
                 ; Tools
                 ; compares two packed characters 
                 ;VE_ICOMPARELC:
                 ;    .dw $ff08
                 ;    .db "icompare-lower"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ICOMPARELC
                 XT_ICOMPARE_LC:
00fcd1 f000          .dw DO_COLON
                 PFA_ICOMPARE_LC:
00fcd2 f0c2          .dw XT_DUP
00fcd3 f045          .dw XT_DOLITERAL
00fcd4 00ff          .dw $00ff
00fcd5 f224          .dw XT_AND
00fcd6 f693          .dw XT_TOLOWER
00fcd7 f0d5          .dw XT_SWAP
00fcd8 f30a          .dw XT_BYTESWAP
00fcd9 f045          .dw XT_DOLITERAL
00fcda 00ff          .dw $00ff
00fcdb f224          .dw XT_AND
00fcdc f693          .dw XT_TOLOWER
00fcdd f30a          .dw XT_BYTESWAP
00fcde f22d          .dw XT_OR
00fcdf f025          .dw XT_EXIT
                 .endif
                 
                 .include "words/star.asm"
                 
                 ; Arithmetics
                 ; multiply routine
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_STAR:
00fce0 ff01          .dw $ff01
00fce1 002a          .db "*",0
00fce2 fc98          .dw VE_HEAD
                     .set VE_HEAD = VE_STAR
                 XT_STAR:
00fce3 f000          .dw DO_COLON
                 PFA_STAR:
                 .endif
                 
00fce4 f1b7          .dw XT_MSTAR
00fce5 f0ea          .dw XT_DROP
00fce6 f025          .dw XT_EXIT
                 .include "words/j.asm"
                 
                 ; Compiler
                 ; loop counter of outer loop
                 VE_J:
00fce7 ff01          .dw $FF01
00fce8 006a          .db "j",0
00fce9 fce0          .dw VE_HEAD
                     .set VE_HEAD = VE_J
                 XT_J:
00fcea f000          .dw DO_COLON
                 PFA_J:
00fceb f287          .dw XT_RP_FETCH
00fcec f045          .dw XT_DOLITERAL
00fced 0007          .dw 7
00fcee f1ae          .dw XT_PLUS
00fcef f08a          .dw XT_FETCH
00fcf0 f287          .dw XT_RP_FETCH
00fcf1 f045          .dw XT_DOLITERAL
00fcf2 0009          .dw 9
00fcf3 f1ae          .dw XT_PLUS
00fcf4 f08a          .dw XT_FETCH
00fcf5 f1ae          .dw XT_PLUS
00fcf6 f025          .dw XT_EXIT
                 
                 .include "words/dabs.asm"
                 
                 ; Arithmetics
                 ; double cell absolute value
                 VE_DABS:
00fcf7 ff04          .dw $ff04
00fcf8 6164
00fcf9 7362          .db "dabs"
00fcfa fce7          .dw VE_HEAD
                     .set VE_HEAD = VE_DABS
                 XT_DABS:
00fcfb f000          .dw DO_COLON
                 PFA_DABS:
00fcfc f0c2          .dw XT_DUP
00fcfd f130          .dw XT_ZEROLESS
00fcfe f03e          .dw XT_DOCONDBRANCH
00fcff fd01          .dw PFA_DABS1
00fd00 fd08          .dw XT_DNEGATE
                 PFA_DABS1:
00fd01 f025          .dw XT_EXIT
                 ; : dabs      ( ud1 -- +d2 ) dup 0< if dnegate then ;
                 .include "words/dnegate.asm"
                 
                 ; Arithmetics
                 ; double cell negation
                 VE_DNEGATE:
00fd02 ff07          .dw $ff07
00fd03 6e64
00fd04 6765
00fd05 7461
00fd06 0065          .db "dnegate",0
00fd07 fcf7          .dw VE_HEAD
                     .set VE_HEAD = VE_DNEGATE
                 XT_DNEGATE:
00fd08 f000          .dw DO_COLON
                 PFA_DNEGATE:
00fd09 f46c          .dw XT_DINVERT
00fd0a f3f7          .dw XT_ONE
00fd0b f165          .dw XT_ZERO
00fd0c f446          .dw XT_DPLUS
00fd0d f025          .dw XT_EXIT
                 ; : dnegate   ( ud1 -- ud2 ) dinvert 1. d+ ;
                 .include "words/cmove.asm"
                 
                 ; Memory
                 ; copy data in RAM, from lower to higher addresses
                 VE_CMOVE:
00fd0e ff05          .dw $ff05
00fd0f 6d63
00fd10 766f
00fd11 0065          .db "cmove",0
00fd12 fd02          .dw VE_HEAD
                     .set VE_HEAD  = VE_CMOVE
                 XT_CMOVE:
00fd13 fd14          .dw PFA_CMOVE
                 PFA_CMOVE:
00fd14 93bf          push xh
00fd15 93af          push xl
00fd16 91e9          ld zl, Y+
00fd17 91f9          ld zh, Y+ ; addr-to
00fd18 91a9          ld xl, Y+
00fd19 91b9          ld xh, Y+ ; addr-from
00fd1a 2f09          mov temp0, tosh
00fd1b 2b08          or temp0, tosl
00fd1c f021          brbs 1, PFA_CMOVE1
                 PFA_CMOVE2:
00fd1d 911d          ld temp1, X+
00fd1e 9311          st Z+, temp1
00fd1f 9701          sbiw tosl, 1
00fd20 f7e1          brbc 1, PFA_CMOVE2
                 PFA_CMOVE1:
00fd21 91af          pop xl
00fd22 91bf          pop xh
00fd23 9189
00fd24 9199          loadtos
00fd25 940c f004     jmp_ DO_NEXT
                 .include "words/2swap.asm"
                 
                 ; Stack
                 ; Exchange the two top cell pairs
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_2SWAP:
00fd27 ff05          .dw $ff05
00fd28 7332
00fd29 6177
00fd2a 0070          .db "2swap",0
00fd2b fd0e          .dw VE_HEAD
                     .set VE_HEAD = VE_2SWAP
                 XT_2SWAP:
00fd2c f000          .dw DO_COLON
                 PFA_2SWAP:
                 
                 .endif
00fd2d f0f2          .dw XT_ROT
00fd2e f110          .dw XT_TO_R
00fd2f f0f2          .dw XT_ROT
00fd30 f107          .dw XT_R_FROM
00fd31 f025          .dw XT_EXIT
                 
                 .include "words/tib.asm"
                 
                 ; System
                 ; refills the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_REFILLTIB:
00fd32 ff0a          .dw $ff0a
00fd33 6572
00fd34 6966
00fd35 6c6c
00fd36 742d
00fd37 6269          .db "refill-tib"
00fd38 fd27          .dw VE_HEAD
                     .set VE_HEAD = VE_REFILLTIB
                 XT_REFILLTIB:
00fd39 f000          .dw DO_COLON
                 PFA_REFILLTIB:
                 .endif
00fd3a fd55          .dw XT_TIB
00fd3b f045          .dw XT_DOLITERAL
00fd3c 005a          .dw TIB_SIZE
00fd3d f889          .dw XT_ACCEPT
00fd3e fd5b          .dw XT_NUMBERTIB
00fd3f f092          .dw XT_STORE
00fd40 f165          .dw XT_ZERO
00fd41 f579          .dw XT_TO_IN
00fd42 f092          .dw XT_STORE
00fd43 f15c          .dw XT_TRUE ; -1
00fd44 f025          .dw XT_EXIT
                 
                 ; ( -- addr n ) 
                 ; System
                 ; address and current length of the input buffer
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_SOURCETIB:
00fd45 ff0a          .dw $FF0A
00fd46 6f73
00fd47 7275
00fd48 6563
00fd49 742d
00fd4a 6269          .db "source-tib"
00fd4b fd32          .dw VE_HEAD
                     .set VE_HEAD = VE_SOURCETIB
                 XT_SOURCETIB:
00fd4c f000          .dw DO_COLON
                 PFA_SOURCETIB:
                 .endif
00fd4d fd55          .dw XT_TIB
00fd4e fd5b          .dw XT_NUMBERTIB
00fd4f f08a          .dw XT_FETCH
00fd50 f025          .dw XT_EXIT
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; terminal input buffer address
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_TIB:
00fd51 ff03          .dw $ff03
00fd52 6974
00fd53 0062          .db "tib",0
00fd54 fd45          .dw VE_HEAD
                     .set VE_HEAD = VE_TIB
                 XT_TIB:
00fd55 f053          .dw PFA_DOVARIABLE
                 PFA_TIB:
00fd56 0287          .dw ram_tib
                 .dseg
000287           ram_tib: .byte TIB_SIZE
                 .cseg
                 .endif
                 
                 ; ( -- addr ) 
                 ; System Variable
                 ; variable holding the number of characters in TIB
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_NUMBERTIB:
00fd57 ff04          .dw $ff04
00fd58 7423
00fd59 6269          .db "#tib"
00fd5a fd51          .dw VE_HEAD
                     .set VE_HEAD  = VE_NUMBERTIB
                 XT_NUMBERTIB:
00fd5b f053          .dw PFA_DOVARIABLE
                 PFA_NUMBERTIB:
00fd5c 02e1          .dw ram_sharptib
                 .dseg
0002e1           ram_sharptib: .byte 2
                 .cseg
                 .endif
                 
                 .include "words/init-ram.asm"
                 
                 ; Tools
                 ; copy len cells from eeprom to ram
                 VE_EE2RAM:
00fd5d ff06        .dw $ff06
00fd5e 6565
00fd5f 723e
00fd60 6d61        .db "ee>ram"
00fd61 fd57        .dw VE_HEAD
                   .set VE_HEAD = VE_EE2RAM
                 XT_EE2RAM:
00fd62 f000        .dw DO_COLON
                 PFA_EE2RAM:          ; ( -- )
00fd63 f165          .dw XT_ZERO
00fd64 f2ac          .dw XT_DODO
                 PFA_EE2RAM_1:
                     ; ( -- e-addr r-addr )
00fd65 f0e0          .dw XT_OVER
00fd66 f366          .dw XT_FETCHE
00fd67 f0e0          .dw XT_OVER
00fd68 f092          .dw XT_STORE
00fd69 f559          .dw XT_CELLPLUS
00fd6a f0d5          .dw XT_SWAP
00fd6b f559          .dw XT_CELLPLUS
00fd6c f0d5          .dw XT_SWAP
00fd6d f2da          .dw XT_DOLOOP
00fd6e fd65          .dw PFA_EE2RAM_1
                 PFA_EE2RAM_2:
00fd6f f569          .dw XT_2DROP
00fd70 f025          .dw XT_EXIT
                 
                 ; ( -- )
                 ; Tools
                 ; setup the default user area from eeprom
                 VE_INIT_RAM:
00fd71 ff08        .dw $ff08
00fd72 6e69
00fd73 7469
00fd74 722d
00fd75 6d61        .db "init-ram"
00fd76 fd5d        .dw VE_HEAD
                   .set VE_HEAD = VE_INIT_RAM
                 XT_INIT_RAM:
00fd77 f000        .dw DO_COLON
                 PFA_INI_RAM:          ; ( -- )
00fd78 f045          .dw XT_DOLITERAL
00fd79 00a8          .dw EE_INITUSER
00fd7a f313          .dw XT_UP_FETCH
00fd7b f045          .dw XT_DOLITERAL
00fd7c 0024          .dw SYSUSERSIZE
00fd7d f215          .dw XT_2SLASH
00fd7e fd62          .dw XT_EE2RAM
00fd7f f025          .dw XT_EXIT
                 
                 .include "words/bounds.asm"
                 
                 ; Tools
                 ; convert a string to an address range
                 
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_BOUNDS:
00fd80 ff06          .dw $ff06
00fd81 6f62
00fd82 6e75
00fd83 7364          .db "bounds"
00fd84 fd71          .dw VE_HEAD
                     .set VE_HEAD = VE_BOUNDS
                 XT_BOUNDS:
00fd85 f000          .dw DO_COLON
                 PFA_BOUNDS:
                 .endif
00fd86 f0e0          .dw XT_OVER
00fd87 f1ae          .dw XT_PLUS
00fd88 f0d5          .dw XT_SWAP
00fd89 f025          .dw XT_EXIT
                 .include "words/s-to-d.asm"
                 
                 ; Conversion
                 ; extend (signed) single cell value to double cell
                 .if cpu_msp430==1
                 .endif
                 
                 .if cpu_avr8==1
                 VE_S2D:
00fd8a ff03          .dw $ff03
00fd8b 3e73
00fd8c 0064          .db "s>d",0
00fd8d fd80          .dw VE_HEAD
                     .set VE_HEAD = VE_S2D
                 XT_S2D:
00fd8e f000          .dw DO_COLON
                 PFA_S2D:
                 .endif
00fd8f f0c2          .dw XT_DUP
00fd90 f130          .dw XT_ZEROLESS
00fd91 f025          .dw XT_EXIT
                 .include "words/to-body.asm"
                 
                 ; Core
                 ; get body from XT
                 VE_TO_BODY:
00fd92 ff05          .dw $ff05
00fd93 623e
00fd94 646f
00fd95 0079          .db ">body",0
00fd96 fd8a          .dw VE_HEAD
                     .set VE_HEAD = VE_TO_BODY
                 XT_TO_BODY:
00fd97 f241          .dw PFA_1PLUS
                 
                 .include "dict/compiler2.inc"
                 
                 ; included almost independently from each other
                 ; on a include-per-use basis
                 ;
                 .if DICT_COMPILER2 == 0
                 .endif
                 .include "dict/interrupt.inc"
                 
                 .if WANT_INTERRUPTS == 1
                 
                 .if WANT_INTERRUPT_COUNTERS == 1
                   .include "words/irqcnt.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_IRQCNTADDR:
00fd98 ff06          .dw $ff06
00fd99 7269
00fd9a 5b71
00fd9b 235d          .db "irq[]#"
00fd9c fd92          .dw VE_HEAD
                     .set VE_HEAD = VE_IRQCNTADDR
                 XT_IRQCNTADDR:
00fd9d f000          .dw DO_COLON
                 PFA_IRQCNTADDR:
00fd9e f045          .dw XT_DOLITERAL
00fd9f 0212          .dw intcnt
00fda0 f1ae          .dw XT_PLUS
00fda1 f025          .dw XT_EXIT
                   .include "words/int-num.asm"
                 
                 ; Interrupt
                 ; number of interrupt vectors (0 based)
                 VE_NUMINT:
00fda2 ff04          .dw $ff04
00fda3 6923
00fda4 746e          .db "#int"
00fda5 fd98          .dw VE_HEAD
                     .set VE_HEAD = VE_NUMINT
                 XT_NUMINT:
00fda6 f053          .dw PFA_DOVARIABLE
                 PFA_NUMINT:
00fda7 0039          .dw INTVECTORS
                 .endif
                 
                 .include "words/int-on.asm"
                 
                 ; Interrupt
                 ; turns on all interrupts
                 VE_INTON:
00fda8 ff04          .dw $ff04
00fda9 692b
00fdaa 746e          .db "+int"
00fdab fda2          .dw VE_HEAD
                     .set VE_HEAD = VE_INTON
                 XT_INTON:
00fdac fdad          .dw PFA_INTON
                 PFA_INTON:
00fdad 9478          sei
00fdae 940c f004     jmp_ DO_NEXT
                 .include "words/int-off.asm"
                 
                 ; Interrupt
                 ; turns off all interrupts 
                 VE_INTOFF:
00fdb0 ff04          .dw $ff04
00fdb1 692d
00fdb2 746e          .db "-int"
00fdb3 fda8          .dw VE_HEAD
                     .set VE_HEAD = VE_INTOFF
                 XT_INTOFF:
00fdb4 fdb5          .dw PFA_INTOFF
                 PFA_INTOFF:
00fdb5 94f8          cli
00fdb6 940c f004     jmp_ DO_NEXT
                 .include "words/int-store.asm"
                 
                 ; Interrupt
                 ; stores XT as interrupt vector i
                 VE_INTSTORE:
00fdb8 ff04          .dw $ff04
00fdb9 6e69
00fdba 2174          .db "int!"
00fdbb fdb0          .dw VE_HEAD
                     .set VE_HEAD = VE_INTSTORE
                 XT_INTSTORE:
00fdbc f000          .dw DO_COLON
                 PFA_INTSTORE:
00fdbd f045          .dw XT_DOLITERAL
00fdbe 0000          .dw intvec
00fdbf f1ae          .dw XT_PLUS
00fdc0 f342          .dw XT_STOREE
00fdc1 f025          .dw XT_EXIT
                 .include "words/int-fetch.asm"
                 
                 ; Interrupt
                 ; fetches XT from interrupt vector i
                 VE_INTFETCH:
00fdc2 ff04          .dw $ff04
00fdc3 6e69
00fdc4 4074          .db "int@"
00fdc5 fdb8          .dw VE_HEAD
                     .set VE_HEAD = VE_INTFETCH
                 XT_INTFETCH:
00fdc6 f000          .dw DO_COLON
                 PFA_INTFETCH:
00fdc7 f045          .dw XT_DOLITERAL
00fdc8 0000          .dw intvec
00fdc9 f1ae          .dw XT_PLUS
00fdca f366          .dw XT_FETCHE
00fdcb f025          .dw XT_EXIT
                 .include "words/int-trap.asm"
                 
                 ; Interrupt
                 ; trigger an interrupt
                 VE_INTTRAP:
00fdcc ff08          .dw $ff08
00fdcd 6e69
00fdce 2d74
00fdcf 7274
00fdd0 7061          .db "int-trap"
00fdd1 fdc2          .dw VE_HEAD
                     .set VE_HEAD = VE_INTTRAP
                 XT_INTTRAP:
00fdd2 fdd3          .dw PFA_INTTRAP
                 PFA_INTTRAP:
00fdd3 2eb8          mov isrflag, tosl
00fdd4 9189
00fdd5 9199          loadtos
00fdd6 940c f004     jmp_ DO_NEXT
                 
                 .include "words/isr-exec.asm"
                 
                 ; Interrupt
                 ; executes an interrupt service routine
                 ;VE_ISREXEC:
                 ;    .dw $ff08
                 ;    .db "isr-exec"
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREXEC
                 XT_ISREXEC:
00fdd8 f000          .dw DO_COLON
                 PFA_ISREXEC:
00fdd9 fdc6          .dw XT_INTFETCH
00fdda f02f          .dw XT_EXECUTE
00fddb fddd          .dw XT_ISREND
00fddc f025          .dw XT_EXIT
                 .include "words/isr-end.asm"
                 
                 ; Interrupt
                 ; re-enables interrupts in an ISR
                 ;VE_ISREND:
                 ;    .dw $ff07
                 ;    .db "isr-end",0
                 ;    .dw VE_HEAD
                 ;    .set VE_HEAD = VE_ISREND
                 XT_ISREND:
00fddd fdde          .dw PFA_ISREND
                 PFA_ISREND:
00fdde d002          rcall PFA_ISREND1 ; clear the interrupt flag for the controller
00fddf 940c f004     jmp_ DO_NEXT
                 PFA_ISREND1:
00fde1 9518          reti
                 .endif
                 .elif AMFORTH_NRWW_SIZE>4000
                 .elif AMFORTH_NRWW_SIZE>2000
                 .else
                 .endif
                 .include "dict_appl_core.inc"
                 
                 ; do not delete it!
                 
                 .set flashlast = pc
                 .if (pc>FLASHEND)
                 .endif
                 
                 .dseg
                 ; define a label for the 1st free ram address
                 HERESTART:
                 .eseg
                 .include "amforth-eeprom.inc"
000072 ff ff     
                 ; some configs
000074 43 05     CFG_DP:      .dw DPSTART         ; Dictionary Pointer
000076 e3 02     EE_HERE:     .dw HERESTART       ; Memory Allocation
000078 ce 00     EE_EHERE:    .dw EHERESTART      ; EEProm Memory Allocation
00007a 85 04     CFG_WLSCOPE: .dw XT_GET_CURRENT  ; default wordlist scope
00007c 9a 00     CFG_FORTHRECOGNIZER: .dw CFG_RECOGNIZERLISTLEN ; Recognizer word set
                 ; LEAVE stack is between data stack and return stack.
00007e b0 21     CFG_LP0:     .dw stackstart+1
000080 35 05     CFG_TURNKEY: .dw XT_APPLTURNKEY    ; TURNKEY
000082 2d f5     CFG_ENVIRONMENT:.dw VE_ENVHEAD     ; environmental queries
000084 86 00     CFG_CURRENT: .dw CFG_FORTHWORDLIST ; forth-wordlist
000086 cc fd     CFG_FORTHWORDLIST:.dw VE_HEAD      ; pre-defined (compiled in) wordlist
                 CFG_ORDERLISTLEN:
000088 01 00         .dw 1
                 CFG_ORDERLIST: ; list of wordlist id, exactly numwordlist entries
00008a 86 00         .dw CFG_FORTHWORDLIST      ; get/set-order
00008c               .byte  (NUMWORDLISTS-1)*CELLSIZE ; one slot is already used
                 CFG_RECOGNIZERLISTLEN:
00009a 02 00         .dw 2
                 CFG_RECOGNIZERLIST:
00009c 36 fb         .dw XT_REC_FIND
00009e 22 fb         .dw XT_REC_NUM
0000a0               .byte  (NUMRECOGNIZERS-2)*CELLSIZE ; two slots are already used
                 
                 EE_STOREI:
0000a4 85 f3         .dw XT_DO_STOREI  ; Store a cell into flash
                 
                 ; MARKER saves everything up to here. Nothing beyond gets saved
                 EE_MARKER:
0000a6 a6 00         .dw EE_MARKER
                 
                 ; default user area
                 EE_INITUSER:
0000a8 00 00         .dw 0  ; USER_STATE
0000aa 00 00         .dw 0  ; USER_FOLLOWER
0000ac ff 21         .dw rstackstart  ; USER_RP
0000ae af 21         .dw stackstart   ; USER_SP0
0000b0 af 21         .dw stackstart   ; USER_SP
                     
0000b2 00 00         .dw 0  ; USER_HANDLER
0000b4 0a 00         .dw 10 ; USER_BASE
                     
0000b6 e1 00         .dw XT_TX  ; USER_EMIT
0000b8 ef 00         .dw XT_TXQ ; USER_EMITQ
0000ba b6 00         .dw XT_RX  ; USER_KEY
0000bc d1 00         .dw XT_RXQ ; USER_KEYQ
0000be 4c fd         .dw XT_SOURCETIB ; USER_SOURCE
0000c0 00 00         .dw 0            ; USER_G_IN
0000c2 39 fd         .dw XT_REFILLTIB ; USER_REFILL  
0000c4 ef f9         .dw XT_DEFAULT_PROMPTOK
0000c6 0e fa         .dw XT_DEFAULT_PROMPTERROR
0000c8 fe f9         .dw XT_DEFAULT_PROMPTREADY
0000ca 29 fa         .dw XT_DEFAULT_PROMPTINPUT
                 
                 ; calculate baud rate error
                 .equ UBRR_VAL   = ((F_CPU+BAUD*8)/(BAUD*16)-1)  ; smart round
                 .equ BAUD_REAL  = (F_CPU/(16*(UBRR_VAL+1)))     ; effective baud rate
                 .equ BAUD_ERROR = ((BAUD_REAL*1000)/BAUD-1000)  ; error in pro mille
                 
                 .if ((BAUD_ERROR>BAUD_MAXERROR) || (BAUD_ERROR<-BAUD_MAXERROR))       
                 .endif
                 EE_UBRRVAL:
0000cc 19 00         .dw UBRR_VAL     ; BAUDRATE
                 ; 1st free address in EEPROM.
                 EHERESTART:
                 .cseg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega1280" register use summary:
r0 :  25 r1 :   5 r2 :  10 r3 :  12 r4 :   4 r5 :   1 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   1 r11:   7 r12:   0 r13:   0 r14:  22 r15:  20 
r16:  80 r17:  61 r18:  52 r19:  37 r20:  13 r21:  38 r22:  11 r23:   3 
r24: 193 r25: 135 r26:  28 r27:  17 r28:   7 r29:   4 r30:  85 r31:  47 
x  :   4 y  : 203 z  :  48 
Registers used: 29 out of 35 (82.9%)

"ATmega1280" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  22 add   :  17 adiw  :  17 and   :   4 
andi  :   3 asr   :   2 bclr  :   0 bld   :   0 brbc  :   2 brbs  :   7 
brcc  :   3 brcs  :   1 break :   0 breq  :   7 brge  :   1 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   3 brmi  :   3 
brne  :  20 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   2 bset  :   0 bst   :   0 call  :   2 cbi   :   7 cbr   :   0 
clc   :   2 clh   :   0 cli   :   7 cln   :   0 clr   :  22 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  14 cp    :  11 cpc   :  10 
cpi   :   2 cpse  :   0 dec   :  10 elpm  :  16 eor   :   3 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :  18 inc   :   3 
jmp   :  15 ld    : 134 ldd   :   4 ldi   :  41 lds   :   1 lpm   :   0 
lsl   :  14 lsr   :   2 mov   :  16 movw  :  66 mul   :   5 muls  :   1 
mulsu :   2 neg   :   0 nop   :   0 or    :   9 ori   :   2 out   :  27 
pop   :  45 push  :  39 rcall :  69 ret   :   6 reti  :   1 rjmp  :  98 
rol   :  32 ror   :   6 sbc   :   9 sbci  :   3 sbi   :   8 sbic  :   3 
sbis  :   0 sbiw  :  14 sbr   :   0 sbrc  :   5 sbrs  :   4 sec   :   1 
seh   :   0 sei   :   1 sen   :   0 ser   :   4 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   2 st    :  76 std   :   8 
sts   :   1 sub   :   6 subi  :   3 swap  :   0 tst   :   1 wdr   :   0 

Instructions used: 72 out of 114 (63.2%)

"ATmega1280" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x01fbc4   2090  14710  16800  131072  12.8%
[.dseg] 0x000200 0x0002e3      0    227    227    8192   2.8%
[.eseg] 0x000000 0x0000ce      0    206    206    4096   5.0%

Assembly complete, 0 errors, 8 warnings
